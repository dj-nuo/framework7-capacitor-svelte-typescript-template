import {
  core_default
} from "./chunk-67RK4OXE.js";
import "./chunk-LESNZ6JR.js";
import "./chunk-6A2TAOKG.js";
import {
  HtmlTag,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_dev,
  assign,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  check_outros,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  setContext,
  set_attributes,
  set_data_dev,
  set_dynamic_element_data,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-3PEI35UK.js";
import "./chunk-JC4IRQUL.js";

// node_modules/framework7-svelte/shared/utils.js
function noUndefinedProps(obj) {
  const o = {};
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] !== "undefined")
      o[key] = obj[key];
  });
  return o;
}
function isStringProp(val) {
  return typeof val === "string" && val !== "";
}
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
}
function now() {
  return Date.now();
}
function extend() {
  let deep = true;
  let to;
  let from;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[0] === "boolean") {
    [deep, to] = args;
    args.splice(0, 2);
    from = args;
  } else {
    [to] = args;
    args.splice(0, 1);
    from = args;
  }
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function classNames() {
  const classes = [];
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  args.forEach((arg) => {
    if (typeof arg === "object" && arg.constructor === Object) {
      Object.keys(arg).forEach((key) => {
        if (arg[key])
          classes.push(key);
      });
    } else if (arg)
      classes.push(arg);
  });
  const uniqueClasses2 = [];
  classes.forEach((c) => {
    if (uniqueClasses2.indexOf(c) < 0)
      uniqueClasses2.push(c);
  });
  return uniqueClasses2.join(" ");
}
function createEmitter(createEventDispatcher2, props) {
  const dispatch = createEventDispatcher2();
  const emit = (events, argsArray) => {
    if (!events || !events.trim().length || typeof events !== "string")
      return;
    events.trim().split(" ").forEach((event) => {
      const eventName = (event || "").trim();
      if (!eventName)
        return;
      const propName = `on${eventName.charAt(0).toUpperCase() + eventName.slice(1)}`;
      dispatch(eventName, argsArray);
      if (typeof props[propName] === "function") {
        if (!Array.isArray(argsArray))
          props[propName](...[argsArray]);
        else
          props[propName](...argsArray || []);
      }
    });
  };
  return emit;
}
var routerIdCounter = 0;
var routerComponentIdCounter = 0;
function unsetRouterIds() {
  routerIdCounter = 0;
  routerComponentIdCounter = 0;
}
function getRouterId() {
  routerIdCounter += 1;
  return `${now()}_${routerIdCounter}`;
}
function getComponentId() {
  routerComponentIdCounter += 1;
  return `${now()}_${routerComponentIdCounter}`;
}
function plainText(text2) {
  if (typeof text2 === "undefined" || text2 === null)
    return "";
  return text2;
}

// node_modules/framework7-svelte/shared/f7.js
var f7;
var theme = {};
var app = typeof window !== "undefined" && window.Framework7ComponentsApp ? window.Framework7ComponentsApp : {
  Framework7: void 0,
  f7: void 0,
  f7events: void 0,
  theme: {},
  f7routers: {
    views: [],
    tabs: [],
    modals: null
  }
};
if (typeof window !== "undefined") {
  window.Framework7ComponentsApp = app;
}
app.setInstance = (instance87) => {
  f7 = instance87;
};
var setTheme = () => {
  if (!app.f7)
    return;
  app.theme.ios = app.f7.theme === "ios";
  theme.ios = app.f7.theme === "ios";
  app.theme.md = app.f7.theme === "md";
  theme.md = app.f7.theme === "md";
  app.theme.aurora = app.f7.theme === "aurora";
  theme.aurora = app.f7.theme === "aurora";
};
var cleanup = () => {
  unsetRouterIds();
  delete app.theme.ios;
  delete theme.ios;
  delete app.theme.md;
  delete theme.md;
  delete app.theme.aurora;
  delete theme.aurora;
  app.f7routers.views = [];
  app.f7routers.tabs = [];
  app.f7routers.modals = null;
};
var f7initEvents = () => {
  app.f7events = new app.Framework7.Events();
};
var f7init = function(rootEl, params, init2) {
  if (params === void 0) {
    params = {};
  }
  if (init2 === void 0) {
    init2 = true;
  }
  const f7Params = extend({}, params, {
    el: rootEl,
    init: init2
  });
  if (typeof params.store !== "undefined")
    f7Params.store = params.store;
  if (!f7Params.routes)
    f7Params.routes = [];
  if (f7Params.userAgent && (f7Params.theme === "auto" || !f7Params.theme)) {
    const device = app.Framework7.getDevice({
      userAgent: f7Params.userAgent
    }, true);
    app.theme.ios = !!device.ios;
    app.theme.aurora = device.desktop && device.electron;
    app.theme.md = !app.theme.ios && !app.theme.aurora;
  }
  if (app.f7 && typeof window !== "undefined")
    return;
  if (typeof window === "undefined")
    cleanup();
  const instance87 = new app.Framework7(f7Params);
  app.f7 = instance87;
  f7 = instance87;
  app.setInstance(instance87);
  setTheme();
  if (instance87.initialized) {
    app.f7 = instance87;
    f7 = instance87;
    app.setInstance(instance87);
    app.f7events.emit("ready", app.f7);
  } else {
    instance87.on("init", () => {
      app.f7 = instance87;
      f7 = instance87;
      app.setInstance(instance87);
      app.f7events.emit("ready", app.f7);
    });
  }
};
var f7ready = (callback) => {
  if (!callback)
    return;
  if (app.f7 && app.f7.initialized)
    callback(app.f7);
  else {
    app.f7events.once("ready", callback);
  }
};

// node_modules/framework7-svelte/shared/mixins.js
function colorClasses(props) {
  const {
    color,
    colorTheme,
    textColor,
    bgColor,
    borderColor,
    rippleColor,
    dark
  } = props;
  return {
    dark,
    [`color-${color}`]: color,
    [`color-theme-${colorTheme}`]: colorTheme,
    [`text-color-${textColor}`]: textColor,
    [`bg-color-${bgColor}`]: bgColor,
    [`border-color-${borderColor}`]: borderColor,
    [`ripple-color-${rippleColor}`]: rippleColor
  };
}
function routerAttrs(props) {
  const {
    force,
    reloadCurrent,
    reloadPrevious,
    reloadAll,
    reloadDetail,
    animate,
    ignoreCache,
    routeTabId,
    view,
    transition,
    openIn
  } = props;
  let dataAnimate;
  if ("animate" in props && typeof animate !== "undefined") {
    dataAnimate = animate.toString();
  }
  let dataReloadDetail;
  if ("reloadDetail" in props && typeof reloadDetail !== "undefined") {
    dataReloadDetail = reloadDetail.toString();
  }
  return {
    "data-force": force || void 0,
    "data-reload-current": reloadCurrent || void 0,
    "data-reload-all": reloadAll || void 0,
    "data-reload-previous": reloadPrevious || void 0,
    "data-reload-detail": dataReloadDetail,
    "data-animate": dataAnimate,
    "data-ignore-cache": ignoreCache || void 0,
    "data-route-tab-id": routeTabId || void 0,
    "data-view": isStringProp(view) ? view : void 0,
    "data-transition": isStringProp(transition) ? transition : void 0,
    "data-open-in": isStringProp(openIn) ? openIn : void 0
  };
}
function routerClasses(props) {
  const {
    back,
    linkBack,
    external,
    preventRouter
  } = props;
  return {
    back: back || linkBack,
    external,
    "prevent-router": preventRouter
  };
}
function actionsAttrs(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsOpen,
    actionsClose,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardClose
  } = props;
  return {
    "data-searchbar": isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || void 0,
    "data-panel": isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || void 0,
    "data-popup": isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || void 0,
    "data-actions": isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || void 0,
    "data-popover": isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || void 0,
    "data-sheet": isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || void 0,
    "data-login-screen": isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || void 0,
    "data-sortable": isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || void 0,
    "data-card": isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || void 0
  };
}
function actionsClasses(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsClose,
    actionsOpen,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardPreventOpen,
    cardClose,
    menuClose: menuClose2
  } = props;
  return {
    "searchbar-enable": searchbarEnable || searchbarEnable === "",
    "searchbar-disable": searchbarDisable || searchbarDisable === "",
    "searchbar-clear": searchbarClear || searchbarClear === "",
    "searchbar-toggle": searchbarToggle || searchbarToggle === "",
    "panel-close": panelClose || panelClose === "",
    "panel-open": panelOpen || panelOpen === "",
    "panel-toggle": panelToggle || panelToggle === "",
    "popup-close": popupClose || popupClose === "",
    "popup-open": popupOpen || popupOpen === "",
    "actions-close": actionsClose || actionsClose === "",
    "actions-open": actionsOpen || actionsOpen === "",
    "popover-close": popoverClose || popoverClose === "",
    "popover-open": popoverOpen || popoverOpen === "",
    "sheet-close": sheetClose || sheetClose === "",
    "sheet-open": sheetOpen || sheetOpen === "",
    "login-screen-close": loginScreenClose || loginScreenClose === "",
    "login-screen-open": loginScreenOpen || loginScreenOpen === "",
    "sortable-enable": sortableEnable || sortableEnable === "",
    "sortable-disable": sortableDisable || sortableDisable === "",
    "sortable-toggle": sortableToggle || sortableToggle === "",
    "card-close": cardClose || cardClose === "",
    "card-open": cardOpen || cardOpen === "",
    "card-prevent-open": cardPreventOpen || cardPreventOpen === "",
    "menu-close": menuClose2 || menuClose2 === ""
  };
}

// node_modules/framework7-svelte/shared/rest-props.js
var ignoreProps = ["color", "colorTheme", "textColor", "bgColor", "borderColor", "rippleColor", "dark", "force", "reloadCurrent", "reloadPrevious", "reloadAll", "reloadDetail", "animate", "ignoreCache", "routeTabId", "view", "transition", "openIn", "back", "linkBack", "external", "preventRouter", "searchbarEnable", "searchbarDisable", "searchbarClear", "searchbarToggle", "panelOpen", "panelClose", "panelToggle", "popupOpen", "popupClose", "actionsOpen", "actionsClose", "popoverOpen", "popoverClose", "loginScreenOpen", "loginScreenClose", "sheetOpen", "sheetClose", "sortableEnable", "sortableDisable", "sortableToggle", "cardOpen", "cardClose"];
function restProps(rest) {
  if (rest === void 0) {
    rest = {};
  }
  const props = {};
  Object.keys(rest).filter((prop) => !ignoreProps.includes(prop)).forEach((key) => {
    if (key.indexOf("on") !== 0) {
      props[key] = rest[key];
    }
  });
  return props;
}

// node_modules/framework7-svelte/shared/modal-state-classes.js
var modalStateClasses = function(_temp) {
  let {
    isOpened,
    isClosing
  } = _temp === void 0 ? {} : _temp;
  return {
    "modal-in": isOpened && !isClosing,
    "modal-out": isClosing
  };
};

// node_modules/framework7-svelte/components/popup.svelte
var file = "node_modules/framework7-svelte/components/popup.svelte";
var get_default_slot_changes = (dirty) => ({ popup: dirty[0] & /*f7Popup*/
4 });
var get_default_slot_context = (ctx) => ({ popup: (
  /*f7Popup*/
  ctx[2]
) });
function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 138, 0, 3662);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[20](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Popup*/
        262148)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "tabletFullscreen",
    "opened",
    "animate",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeOnEscape",
    "swipeToClose",
    "swipeHandler",
    "push",
    "containerEl",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popup", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { tabletFullscreen = void 0 } = $$props;
  let { opened = void 0 } = $$props;
  let { animate = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { swipeToClose = false } = $$props;
  let { swipeHandler = void 0 } = $$props;
  let { push = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let f7Popup;
  const state = { isOpened: opened, isClosing: false };
  function instance87() {
    return f7Popup;
  }
  function onSwipeStart(instance88) {
    emit("popupSwipeStart", [instance88]);
  }
  function onSwipeMove(instance88) {
    emit("popupSwipeMove", [instance88]);
  }
  function onSwipeEnd(instance88) {
    emit("popupSwipeEnd", [instance88]);
  }
  function onSwipeClose(instance88) {
    emit("popupSwipeClose", [instance88]);
  }
  function onOpen(instance88) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("popupOpen", [instance88]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance88) {
    emit("popupOpened", [instance88]);
  }
  function onClose(instance88) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("popupClose", [instance88]);
  }
  function onClosed(instance88) {
    Object.assign(state, { isClosing: false });
    emit("popupClosed", [instance88]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Popup)
      return;
    if (openedPassed)
      f7Popup.open();
    else
      f7Popup.close();
  }
  onMount(() => {
    const popupParams = {
      el,
      on: {
        swipeStart: onSwipeStart,
        swipeMove: onSwipeMove,
        swipeEnd: onSwipeEnd,
        swipeClose: onSwipeClose,
        open: onOpen,
        opened: onOpened,
        close: onClose,
        closed: onClosed
      }
    };
    if (typeof closeByBackdropClick !== "undefined")
      popupParams.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeOnEscape !== "undefined")
      popupParams.closeOnEscape = closeOnEscape;
    if (typeof animate !== "undefined")
      popupParams.animate = animate;
    if (typeof backdrop !== "undefined")
      popupParams.backdrop = backdrop;
    if (typeof backdropEl !== "undefined")
      popupParams.backdropEl = backdropEl;
    if (typeof swipeToClose !== "undefined")
      popupParams.swipeToClose = swipeToClose;
    if (typeof swipeHandler !== "undefined")
      popupParams.swipeHandler = swipeHandler;
    if (typeof containerEl !== "undefined")
      popupParams.containerEl = containerEl;
    f7ready(() => {
      $$invalidate(2, f7Popup = app.f7.popup.create(popupParams));
      if (opened) {
        f7Popup.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Popup)
      f7Popup.destroy();
    $$invalidate(2, f7Popup = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("tabletFullscreen" in $$new_props)
      $$invalidate(7, tabletFullscreen = $$new_props.tabletFullscreen);
    if ("opened" in $$new_props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props)
      $$invalidate(8, animate = $$new_props.animate);
    if ("backdrop" in $$new_props)
      $$invalidate(9, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(10, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(12, closeOnEscape = $$new_props.closeOnEscape);
    if ("swipeToClose" in $$new_props)
      $$invalidate(13, swipeToClose = $$new_props.swipeToClose);
    if ("swipeHandler" in $$new_props)
      $$invalidate(14, swipeHandler = $$new_props.swipeHandler);
    if ("push" in $$new_props)
      $$invalidate(15, push = $$new_props.push);
    if ("containerEl" in $$new_props)
      $$invalidate(16, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    modalStateClasses,
    emit,
    className,
    style,
    tabletFullscreen,
    opened,
    animate,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeOnEscape,
    swipeToClose,
    swipeHandler,
    push,
    containerEl,
    el,
    f7Popup,
    state,
    instance: instance87,
    onSwipeStart,
    onSwipeMove,
    onSwipeEnd,
    onSwipeClose,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    initialWatched,
    watchOpened,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("tabletFullscreen" in $$props)
      $$invalidate(7, tabletFullscreen = $$new_props.tabletFullscreen);
    if ("opened" in $$props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$props)
      $$invalidate(8, animate = $$new_props.animate);
    if ("backdrop" in $$props)
      $$invalidate(9, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(10, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeOnEscape" in $$props)
      $$invalidate(12, closeOnEscape = $$new_props.closeOnEscape);
    if ("swipeToClose" in $$props)
      $$invalidate(13, swipeToClose = $$new_props.swipeToClose);
    if ("swipeHandler" in $$props)
      $$invalidate(14, swipeHandler = $$new_props.swipeHandler);
    if ("push" in $$props)
      $$invalidate(15, push = $$new_props.push);
    if ("containerEl" in $$props)
      $$invalidate(16, containerEl = $$new_props.containerEl);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("f7Popup" in $$props)
      $$invalidate(2, f7Popup = $$new_props.f7Popup);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(
        className,
        "popup",
        {
          "popup-tablet-fullscreen": tabletFullscreen,
          "popup-push": push
        },
        modalStateClasses(state),
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*opened*/
    32) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7Popup,
    classes,
    $$restProps,
    opened,
    className,
    tabletFullscreen,
    animate,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeOnEscape,
    swipeToClose,
    swipeHandler,
    push,
    containerEl,
    instance87,
    $$scope,
    slots,
    div_binding
  ];
}
var Popup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        class: 6,
        style: 0,
        tabletFullscreen: 7,
        opened: 5,
        animate: 8,
        backdrop: 9,
        backdropEl: 10,
        closeByBackdropClick: 11,
        closeOnEscape: 12,
        swipeToClose: 13,
        swipeHandler: 14,
        push: 15,
        containerEl: 16,
        instance: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popup",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabletFullscreen() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabletFullscreen(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeToClose() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeToClose(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeHandler() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeHandler(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get push() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set push(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[17];
  }
  set instance(value) {
    throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var popup_default = Popup;

// node_modules/framework7-svelte/shared/get-router-initial-component.js
var getRouterInitialComponent = (router, initialComponent) => {
  let initialComponentData;
  const {
    initialUrl
  } = router.getInitialUrl();
  const initialRoute = router.findMatchingRoute(initialUrl);
  let routeProps = {};
  if (initialRoute && initialRoute.route && initialRoute.route.options) {
    routeProps = initialRoute.route.options.props;
  }
  const isMasterRoute = (route) => {
    if (route.master === true)
      return true;
    if (typeof route.master === "function")
      return route.master(router.app);
    return false;
  };
  if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
    initialComponentData = {
      component: initialRoute.route.component || initialRoute.route.asyncComponent,
      initialComponent,
      id: getComponentId(),
      isAsync: !!initialRoute.route.asyncComponent,
      props: {
        f7route: initialRoute,
        f7router: router,
        ...initialRoute.params,
        ...routeProps
      }
    };
  }
  return {
    initialPage: initialComponentData,
    initialRoute
  };
};

// node_modules/framework7-svelte/shared/use-tab.js
var useTab = (getEl, emit) => {
  const onTabShow = (el) => {
    if (getEl() !== el)
      return;
    emit("tabShow", [el]);
  };
  const onTabHide = (el) => {
    if (getEl() !== el)
      return;
    emit("tabHide", [el]);
  };
  const attachEvents = () => {
    if (!getEl())
      return;
    f7ready(() => {
      f7.on("tabShow", onTabShow);
      f7.on("tabHide", onTabHide);
    });
  };
  const detachEvents = () => {
    if (!f7)
      return;
    f7.off("tabShow", onTabShow);
    f7.off("tabHide", onTabHide);
  };
  onMount(() => {
    attachEvents();
  });
  onDestroy(() => {
    detachEvents();
  });
};

// node_modules/framework7-svelte/components/router-context-provider.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router_context_provider", slots, ["default"]);
  let { route = void 0 } = $$props;
  let { router = void 0 } = $$props;
  setContext("RouterContext", { route, router });
  const writable_props = ["route", "router"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router_context_provider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(0, route = $$props2.route);
    if ("router" in $$props2)
      $$invalidate(1, router = $$props2.router);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, route, router });
  $$self.$inject_state = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(0, route = $$props2.route);
    if ("router" in $$props2)
      $$invalidate(1, router = $$props2.router);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [route, router, $$scope, slots];
}
var Router_context_provider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, { route: 0, router: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_context_provider",
      options,
      id: create_fragment2.name
    });
  }
  get route() {
    throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set route(value) {
    throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get router() {
    throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var router_context_provider_default = Router_context_provider;

// node_modules/framework7-svelte/components/view.svelte
var file2 = "node_modules/framework7-svelte/components/view.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
var get_default_slot_changes2 = (dirty) => ({ view: dirty[0] & /*f7View*/
8 });
var get_default_slot_context2 = (ctx) => ({ view: (
  /*f7View*/
  ctx[3]
) });
function create_default_slot(ctx) {
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [
    /*page*/
    ctx[31].props
  ];
  var switch_value = (
    /*page*/
    ctx[31].component
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*pages*/
      16 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*page*/
        ctx2[31].props
      )]) : {};
      if (dirty[0] & /*pages*/
      16 && switch_value !== (switch_value = /*page*/
      ctx2[31].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(196:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let routercontextprovider;
  let current;
  routercontextprovider = new router_context_provider_default({
    props: {
      route: (
        /*page*/
        ctx[31].props.f7route
      ),
      router: (
        /*page*/
        ctx[31].props.f7router
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(routercontextprovider.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(routercontextprovider, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const routercontextprovider_changes = {};
      if (dirty[0] & /*pages*/
      16)
        routercontextprovider_changes.route = /*page*/
        ctx[31].props.f7route;
      if (dirty[0] & /*pages*/
      16)
        routercontextprovider_changes.router = /*page*/
        ctx[31].props.f7router;
      if (dirty[0] & /*$$scope, pages*/
      4112) {
        routercontextprovider_changes.$$scope = { dirty, ctx };
      }
      routercontextprovider.$set(routercontextprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(routercontextprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(routercontextprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(routercontextprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(195:2) {#each pages as page (page.id)}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context2
  );
  let each_value = (
    /*pages*/
    ctx[4]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*page*/
    ctx2[31].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[5]
      );
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[0]
      );
      add_location(div, file2, 192, 0, 5532);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[11](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/
        4104)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
      if (dirty[0] & /*pages*/
      16) {
        each_value = /*pages*/
        ctx2[4];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      32) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*style*/
      2) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[11](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_12($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, ["default"]);
  let { id = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { url = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  const { main, tab, tabActive, browserHistoryInitialMatch = true, initRouterOnTabShow } = $$props;
  const shouldInitRouter = !(initRouterOnTabShow && tab && !tabActive);
  let initialPage;
  let initialRoute;
  let el;
  let routerData;
  let f7View;
  function instance87() {
    return f7View;
  }
  function onViewInit(view) {
    emit("viewInit", [view]);
    if (!init2) {
      $$invalidate(3, f7View = view);
      routerData.instance = view;
    }
  }
  if (app.f7 && !f7View && init2) {
    const routerId = getRouterId();
    f7View = app.f7.views.create(el, {
      routerId,
      init: false,
      ...noUndefinedProps($$props),
      browserHistoryInitialMatch,
      on: { init: onViewInit }
    });
    routerData = { routerId, instance: f7View };
    app.f7routers.views.push(routerData);
    if (shouldInitRouter && f7View && f7View.router && (url || main)) {
      const initialData = getRouterInitialComponent(f7View.router);
      initialPage = initialData.initialPage;
      initialRoute = initialData.initialRoute;
      if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
        initialPage = void 0;
        initialRoute = void 0;
      }
    }
  }
  let pages = initialPage ? [initialPage] : [];
  function onResize(view, width) {
    emit("viewResize", [width]);
  }
  function onSwipeBackMove(data) {
    emit("swipeBackMove", [data]);
  }
  function onSwipeBackBeforeChange(data) {
    emit("swipeBackBeforeChange", [data]);
  }
  function onSwipeBackAfterChange(data) {
    emit("swipeBackAfterChange", [data]);
  }
  function onSwipeBackBeforeReset(data) {
    emit("swipeBackBeforeReset", [data]);
  }
  function onSwipeBackAfterReset(data) {
    emit("swipeBackAfterReset", [data]);
  }
  useTab(() => el, emit);
  onMount(() => {
    f7ready(() => {
      if (f7View) {
        routerData.el = el;
        routerData.pages = pages;
        routerData.setPages = (newPages) => {
          tick().then(() => {
            $$invalidate(4, pages = newPages);
          });
        };
        if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
          initialPage.component().then(() => {
            setTimeout(
              () => {
                f7View.init(el);
                if (initialPage) {
                  initialPage.el = f7View.router.currentPageEl;
                  if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
                    initialRoute.route.keepAliveData = { pageEl: initialPage.el };
                  }
                }
              },
              100
            );
          });
        } else {
          f7View.init(el);
          if (initialPage) {
            initialPage.el = f7View.router.currentPageEl;
            if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
              initialRoute.route.keepAliveData = { pageEl: initialPage.el };
            }
          }
        }
      } else {
        const routerId = getRouterId();
        routerData = {
          el,
          routerId,
          pages,
          instance: f7View,
          setPages(newPages) {
            tick().then(() => {
              $$invalidate(4, pages = newPages);
            });
          }
        };
        app.f7routers.views.push(routerData);
        routerData.instance = app.f7.views.create(el, {
          routerId,
          ...noUndefinedProps($$props),
          browserHistoryInitialMatch,
          on: { init: onViewInit }
        });
        $$invalidate(3, f7View = routerData.instance);
      }
      if (!init2)
        return;
      f7View.on("resize", onResize);
      f7View.on("swipebackMove", onSwipeBackMove);
      f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
      f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
      f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
      f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
    });
  });
  afterUpdate(() => {
    if (!routerData)
      return;
    app.f7events.emit("viewRouterDidUpdate", routerData);
  });
  onDestroy(() => {
    if (f7View) {
      f7View.off("resize", onResize);
      f7View.off("swipebackMove", onSwipeBackMove);
      f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
      f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
      f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
      f7View.off("swipebackAfterReset", onSwipeBackAfterReset);
      if (f7View.destroy)
        f7View.destroy();
      $$invalidate(3, f7View = null);
    }
    app.f7routers.views.splice(app.f7routers.views.indexOf(routerData), 1);
    routerData = null;
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("style" in $$new_props)
      $$invalidate(1, style = $$new_props.style);
    if ("init" in $$new_props)
      $$invalidate(6, init2 = $$new_props.init);
    if ("url" in $$new_props)
      $$invalidate(7, url = $$new_props.url);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    createEventDispatcher,
    tick,
    app,
    f7ready,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    getRouterId,
    getRouterInitialComponent,
    useTab,
    RouterContextProvider: router_context_provider_default,
    id,
    style,
    init: init2,
    url,
    className,
    emit,
    main,
    tab,
    tabActive,
    browserHistoryInitialMatch,
    initRouterOnTabShow,
    shouldInitRouter,
    initialPage,
    initialRoute,
    el,
    routerData,
    f7View,
    instance: instance87,
    onViewInit,
    pages,
    onResize,
    onSwipeBackMove,
    onSwipeBackBeforeChange,
    onSwipeBackAfterChange,
    onSwipeBackBeforeReset,
    onSwipeBackAfterReset,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("style" in $$props)
      $$invalidate(1, style = $$new_props.style);
    if ("init" in $$props)
      $$invalidate(6, init2 = $$new_props.init);
    if ("url" in $$props)
      $$invalidate(7, url = $$new_props.url);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("initialPage" in $$props)
      initialPage = $$new_props.initialPage;
    if ("initialRoute" in $$props)
      initialRoute = $$new_props.initialRoute;
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("routerData" in $$props)
      routerData = $$new_props.routerData;
    if ("f7View" in $$props)
      $$invalidate(3, f7View = $$new_props.f7View);
    if ("pages" in $$props)
      $$invalidate(4, pages = $$new_props.pages);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classes = classNames(
        className,
        "view",
        {
          "view-main": main,
          "tab-active": tabActive,
          tab
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    style,
    el,
    f7View,
    pages,
    classes,
    init2,
    url,
    className,
    instance87,
    slots,
    div_binding,
    $$scope
  ];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_12,
      create_fragment3,
      safe_not_equal,
      {
        id: 0,
        style: 1,
        init: 6,
        url: 7,
        class: 8,
        instance: 9
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment3.name
    });
  }
  get id() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[9];
  }
  set instance(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var view_default = View;

// node_modules/framework7-svelte/components/login-screen.svelte
var file3 = "node_modules/framework7-svelte/components/login-screen.svelte";
var get_default_slot_changes3 = (dirty) => ({ loginScreen: dirty & /*f7LoginScreen*/
4 });
var get_default_slot_context3 = (ctx) => ({ loginScreen: (
  /*f7LoginScreen*/
  ctx[2]
) });
function create_fragment4(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context3
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file3, 102, 0, 2427);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[12](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7LoginScreen*/
        1028)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_13($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "style", "opened", "animate", "containerEl", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Login_screen", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let f7LoginScreen;
  const state = { isOpened: opened, isClosing: false };
  function instance87() {
    return f7LoginScreen;
  }
  function onOpen(instance88) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("loginscreenOpen loginScreenOpen", [instance88]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance88) {
    emit("loginscreenOpened loginScreenOpened", [instance88]);
  }
  function onClose(instance88) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("loginscreenClose loginScreenClose", [instance88]);
  }
  function onClosed(instance88) {
    Object.assign(state, { isClosing: false });
    emit("loginscreenClosed loginScreenClosed", [instance88]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7LoginScreen)
      return;
    if (openedPassed)
      f7LoginScreen.open();
    else
      f7LoginScreen.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen,
        opened: onOpened,
        close: onClose,
        closed: onClosed
      }
    };
    if (typeof animate !== "undefined")
      params.animate = animate;
    if (typeof containerEl !== "undefined")
      params.containerEl = animate;
    f7ready(() => {
      $$invalidate(2, f7LoginScreen = app.f7.loginScreen.create(params));
      if (opened) {
        f7LoginScreen.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7LoginScreen)
      f7LoginScreen.destroy();
    $$invalidate(2, f7LoginScreen = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("containerEl" in $$new_props)
      $$invalidate(8, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    modalStateClasses,
    emit,
    className,
    style,
    opened,
    animate,
    containerEl,
    el,
    f7LoginScreen,
    state,
    instance: instance87,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    initialWatched,
    watchOpened,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("containerEl" in $$props)
      $$invalidate(8, containerEl = $$new_props.containerEl);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("f7LoginScreen" in $$props)
      $$invalidate(2, f7LoginScreen = $$new_props.f7LoginScreen);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "login-screen", modalStateClasses(state), colorClasses($$props)));
    if ($$self.$$.dirty & /*opened*/
    32) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7LoginScreen,
    classes,
    $$restProps,
    opened,
    className,
    animate,
    containerEl,
    instance87,
    $$scope,
    slots,
    div_binding
  ];
}
var Login_screen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment4, safe_not_equal, {
      class: 6,
      style: 0,
      opened: 5,
      animate: 7,
      containerEl: 8,
      instance: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Login_screen",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[9];
  }
  set instance(value) {
    throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var login_screen_default = Login_screen;

// node_modules/framework7-svelte/components/sheet.svelte
var file4 = "node_modules/framework7-svelte/components/sheet.svelte";
var get_static_slot_changes = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
var get_static_slot_context = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
var get_default_slot_changes4 = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
var get_default_slot_context4 = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
var get_fixed_slot_changes = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
var get_fixed_slot_context = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
function create_fragment5(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let current;
  const fixed_slot_template = (
    /*#slots*/
    ctx[26].fixed
  );
  const fixed_slot = create_slot(
    fixed_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_fixed_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_default_slot_context4
  );
  const static_slot_template = (
    /*#slots*/
    ctx[26].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_static_slot_context
  );
  let div1_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (fixed_slot)
        fixed_slot.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (static_slot)
        static_slot.c();
      attr_dev(div0, "class", "sheet-modal-inner");
      add_location(div0, file4, 165, 2, 4569);
      set_attributes(div1, div1_data);
      add_location(div1, file4, 163, 0, 4454);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (fixed_slot) {
        fixed_slot.m(div1, null);
      }
      append_dev(div1, t0);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_dev(div0, t1);
      if (static_slot) {
        static_slot.m(div0, null);
      }
      ctx[27](div0);
      ctx[28](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (fixed_slot) {
        if (fixed_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        33554440)) {
          update_slot_base(
            fixed_slot,
            fixed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              fixed_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_fixed_slot_changes
            ),
            get_fixed_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        33554440)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
      if (static_slot) {
        if (static_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        33554440)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_static_slot_changes
            ),
            get_static_slot_context
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fixed_slot, local);
      transition_in(default_slot, local);
      transition_in(static_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fixed_slot, local);
      transition_out(default_slot, local);
      transition_out(static_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (fixed_slot)
        fixed_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (static_slot)
        static_slot.d(detaching);
      ctx[27](null);
      ctx[28](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_14($$self, $$props, $$invalidate) {
  let positionComputed;
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "opened",
    "animate",
    "top",
    "bottom",
    "position",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeByOutsideClick",
    "closeOnEscape",
    "push",
    "swipeToClose",
    "swipeToStep",
    "swipeHandler",
    "containerEl",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sheet", slots, ["fixed", "default", "static"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate = void 0 } = $$props;
  let { top = void 0 } = $$props;
  let { bottom = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeByOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { push = void 0 } = $$props;
  let { swipeToClose = void 0 } = $$props;
  let { swipeToStep = void 0 } = $$props;
  let { swipeHandler = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let innerEl;
  let f7Sheet;
  const state = {
    isOpened: opened,
    isClosing: false,
    swipeStep: false
  };
  function instance87() {
    return f7Sheet;
  }
  function onOpen(instance88) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("sheetOpen", [instance88]);
    $$invalidate(6, opened = true);
  }
  function onOpened(instance88) {
    emit("sheetOpened", [instance88]);
  }
  function onClose(instance88) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("sheetClose", [instance88]);
  }
  function onClosed(instance88) {
    Object.assign(state, { isClosing: false });
    emit("sheetClosed", [instance88]);
    $$invalidate(6, opened = false);
  }
  function onStepProgress(instance88, progress) {
    emit("sheetStepProgress", [instance88, progress]);
  }
  function onStepOpen(instance88) {
    emit("sheetStepOpen", [instance88]);
  }
  function onStepClose(instance88) {
    emit("sheetStepClose", [instance88]);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Sheet)
      return;
    if (openedPassed)
      f7Sheet.open();
    else
      f7Sheet.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen,
        opened: onOpened,
        close: onClose,
        closed: onClosed,
        stepOpen: onStepOpen,
        stepClose: onStepClose,
        stepProgress: onStepProgress,
        // eslint-disable-next-line
        _swipeStep(isSwipeStep) {
          $$invalidate(23, state.swipeStep = isSwipeStep, state);
        }
      }
    };
    if (typeof backdrop !== "undefined")
      params.backdrop = backdrop;
    if (typeof animate !== "undefined")
      params.animate = animate;
    if (typeof backdropEl !== "undefined")
      params.backdropEl = backdropEl;
    if (typeof closeByBackdropClick !== "undefined")
      params.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeByOutsideClick !== "undefined")
      params.closeByOutsideClick = closeByOutsideClick;
    if (typeof closeOnEscape !== "undefined")
      params.closeOnEscape = closeOnEscape;
    if (typeof swipeToClose !== "undefined")
      params.swipeToClose = swipeToClose;
    if (typeof swipeToStep !== "undefined")
      params.swipeToStep = swipeToStep;
    if (typeof swipeHandler !== "undefined")
      params.swipeHandler = swipeHandler;
    if (typeof containerEl !== "undefined")
      params.containerEl = containerEl;
    f7ready(() => {
      if (el && innerEl) {
        const dom7 = app.f7.$;
        const fixedEls = dom7(innerEl).children(".navbar, .toolbar, .tabbar, .searchbar");
        if (fixedEls.length) {
          dom7(el).prepend(fixedEls);
        }
      }
      $$invalidate(3, f7Sheet = app.f7.sheet.create(params));
      if (opened) {
        f7Sheet.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Sheet)
      f7Sheet.destroy();
    $$invalidate(3, f7Sheet = null);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(2, innerEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props)
      $$invalidate(6, opened = $$new_props.opened);
    if ("animate" in $$new_props)
      $$invalidate(8, animate = $$new_props.animate);
    if ("top" in $$new_props)
      $$invalidate(9, top = $$new_props.top);
    if ("bottom" in $$new_props)
      $$invalidate(10, bottom = $$new_props.bottom);
    if ("position" in $$new_props)
      $$invalidate(11, position = $$new_props.position);
    if ("backdrop" in $$new_props)
      $$invalidate(12, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(13, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$new_props)
      $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("push" in $$new_props)
      $$invalidate(17, push = $$new_props.push);
    if ("swipeToClose" in $$new_props)
      $$invalidate(18, swipeToClose = $$new_props.swipeToClose);
    if ("swipeToStep" in $$new_props)
      $$invalidate(19, swipeToStep = $$new_props.swipeToStep);
    if ("swipeHandler" in $$new_props)
      $$invalidate(20, swipeHandler = $$new_props.swipeHandler);
    if ("containerEl" in $$new_props)
      $$invalidate(21, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    modalStateClasses,
    emit,
    className,
    style,
    opened,
    animate,
    top,
    bottom,
    position,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    push,
    swipeToClose,
    swipeToStep,
    swipeHandler,
    containerEl,
    el,
    innerEl,
    f7Sheet,
    state,
    instance: instance87,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    onStepProgress,
    onStepOpen,
    onStepClose,
    initialWatched,
    watchOpened,
    positionComputed,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$props)
      $$invalidate(6, opened = $$new_props.opened);
    if ("animate" in $$props)
      $$invalidate(8, animate = $$new_props.animate);
    if ("top" in $$props)
      $$invalidate(9, top = $$new_props.top);
    if ("bottom" in $$props)
      $$invalidate(10, bottom = $$new_props.bottom);
    if ("position" in $$props)
      $$invalidate(11, position = $$new_props.position);
    if ("backdrop" in $$props)
      $$invalidate(12, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(13, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$props)
      $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("push" in $$props)
      $$invalidate(17, push = $$new_props.push);
    if ("swipeToClose" in $$props)
      $$invalidate(18, swipeToClose = $$new_props.swipeToClose);
    if ("swipeToStep" in $$props)
      $$invalidate(19, swipeToStep = $$new_props.swipeToStep);
    if ("swipeHandler" in $$props)
      $$invalidate(20, swipeHandler = $$new_props.swipeHandler);
    if ("containerEl" in $$props)
      $$invalidate(21, containerEl = $$new_props.containerEl);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("innerEl" in $$props)
      $$invalidate(2, innerEl = $$new_props.innerEl);
    if ("f7Sheet" in $$props)
      $$invalidate(3, f7Sheet = $$new_props.f7Sheet);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("positionComputed" in $$props)
      $$invalidate(24, positionComputed = $$new_props.positionComputed);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*position, top, bottom*/
    3584) {
      $:
        $$invalidate(24, positionComputed = (() => {
          if (position)
            return position;
          if (top)
            return "top";
          if (bottom)
            return "bottom";
          return "bottom";
        })());
    }
    $:
      $$invalidate(4, classes = classNames(
        className,
        "sheet-modal",
        `sheet-modal-${positionComputed}`,
        {
          "sheet-modal-push": push,
          "modal-in-swipe-step": state.swipeStep
        },
        modalStateClasses(state),
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*opened*/
    64) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    innerEl,
    f7Sheet,
    classes,
    $$restProps,
    opened,
    className,
    animate,
    top,
    bottom,
    position,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    push,
    swipeToClose,
    swipeToStep,
    swipeHandler,
    containerEl,
    instance87,
    state,
    positionComputed,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
var Sheet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_14,
      create_fragment5,
      safe_not_equal,
      {
        class: 7,
        style: 0,
        opened: 6,
        animate: 8,
        top: 9,
        bottom: 10,
        position: 11,
        backdrop: 12,
        backdropEl: 13,
        closeByBackdropClick: 14,
        closeByOutsideClick: 15,
        closeOnEscape: 16,
        push: 17,
        swipeToClose: 18,
        swipeToStep: 19,
        swipeHandler: 20,
        containerEl: 21,
        instance: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sheet",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByOutsideClick() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByOutsideClick(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get push() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set push(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeToClose() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeToClose(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeToStep() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeToStep(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeHandler() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeHandler(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[22];
  }
  set instance(value) {
    throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var sheet_default = Sheet;

// node_modules/framework7-svelte/components/popover.svelte
var file5 = "node_modules/framework7-svelte/components/popover.svelte";
var get_default_slot_changes5 = (dirty) => ({ popover: dirty & /*f7Popover*/
4 });
var get_default_slot_context5 = (ctx) => ({ popover: (
  /*f7Popover*/
  ctx[2]
) });
function create_fragment6(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context5
  );
  let div2_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "popover-angle");
      add_location(div0, file5, 116, 2, 3232);
      attr_dev(div1, "class", "popover-inner");
      add_location(div1, file5, 117, 2, 3264);
      set_attributes(div2, div2_data);
      add_location(div2, file5, 115, 0, 3157);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[19](div2);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7Popover*/
        131076)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_15($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "opened",
    "animate",
    "targetEl",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeByOutsideClick",
    "closeOnEscape",
    "containerEl",
    "verticalPosition",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate = void 0 } = $$props;
  let { targetEl = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeByOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let { verticalPosition = void 0 } = $$props;
  let el;
  let f7Popover;
  const state = { isOpened: opened, isClosing: false };
  function instance87() {
    return f7Popover;
  }
  function onOpen(instance88) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("popoverOpen", [instance88]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance88) {
    emit("popoverOpened", [instance88]);
  }
  function onClose(instance88) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("popoverClose", [instance88]);
  }
  function onClosed(instance88) {
    Object.assign(state, { isClosing: false });
    emit("popoverClosed", [instance88]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Popover)
      return;
    if (openedPassed)
      f7Popover.open();
    else
      f7Popover.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen,
        opened: onOpened,
        close: onClose,
        closed: onClosed
      }
    };
    if (targetEl)
      params.targetEl = targetEl;
    if (typeof animate !== "undefined")
      params.animate = animate;
    if (typeof closeByBackdropClick !== "undefined")
      params.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeByOutsideClick !== "undefined")
      params.closeByOutsideClick = closeByOutsideClick;
    if (typeof closeOnEscape !== "undefined")
      params.closeOnEscape = closeOnEscape;
    if (typeof backdrop !== "undefined")
      params.backdrop = backdrop;
    if (typeof backdropEl !== "undefined")
      params.backdropEl = backdropEl;
    if (typeof containerEl !== "undefined")
      params.containerEl = containerEl;
    if (typeof verticalPosition !== "undefined")
      params.verticalPosition = verticalPosition;
    f7ready(() => {
      $$invalidate(2, f7Popover = app.f7.popover.create(params));
      if (opened) {
        f7Popover.open(targetEl, false);
      }
    });
  });
  onDestroy(() => {
    if (f7Popover)
      f7Popover.destroy();
    $$invalidate(2, f7Popover = null);
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("targetEl" in $$new_props)
      $$invalidate(8, targetEl = $$new_props.targetEl);
    if ("backdrop" in $$new_props)
      $$invalidate(9, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(10, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$new_props)
      $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
    if ("containerEl" in $$new_props)
      $$invalidate(14, containerEl = $$new_props.containerEl);
    if ("verticalPosition" in $$new_props)
      $$invalidate(15, verticalPosition = $$new_props.verticalPosition);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    modalStateClasses,
    emit,
    className,
    style,
    opened,
    animate,
    targetEl,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    containerEl,
    verticalPosition,
    el,
    f7Popover,
    state,
    instance: instance87,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    initialWatched,
    watchOpened,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("targetEl" in $$props)
      $$invalidate(8, targetEl = $$new_props.targetEl);
    if ("backdrop" in $$props)
      $$invalidate(9, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(10, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$props)
      $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$props)
      $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
    if ("containerEl" in $$props)
      $$invalidate(14, containerEl = $$new_props.containerEl);
    if ("verticalPosition" in $$props)
      $$invalidate(15, verticalPosition = $$new_props.verticalPosition);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("f7Popover" in $$props)
      $$invalidate(2, f7Popover = $$new_props.f7Popover);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "popover", modalStateClasses(state), colorClasses($$props)));
    if ($$self.$$.dirty & /*opened*/
    32) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7Popover,
    classes,
    $$restProps,
    opened,
    className,
    animate,
    targetEl,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    containerEl,
    verticalPosition,
    instance87,
    $$scope,
    slots,
    div2_binding
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_15, create_fragment6, safe_not_equal, {
      class: 6,
      style: 0,
      opened: 5,
      animate: 7,
      targetEl: 8,
      backdrop: 9,
      backdropEl: 10,
      closeByBackdropClick: 11,
      closeByOutsideClick: 12,
      closeOnEscape: 13,
      containerEl: 14,
      verticalPosition: 15,
      instance: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByOutsideClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByOutsideClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get verticalPosition() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set verticalPosition(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[16];
  }
  set instance(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var popover_default = Popover;

// node_modules/framework7-svelte/components/panel.svelte
var file6 = "node_modules/framework7-svelte/components/panel.svelte";
var get_default_slot_changes6 = (dirty) => ({ panel: dirty[0] & /*f7Panel*/
8 });
var get_default_slot_context6 = (ctx) => ({ panel: (
  /*f7Panel*/
  ctx[3]
) });
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "panel-resize-handler");
      add_location(div, file6, 205, 4, 5193);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(205:2) {#if resizable}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_default_slot_context6
  );
  let if_block = (
    /*resizable*/
    ctx[0] && create_if_block(ctx)
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file6, 202, 0, 5057);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[31](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Panel*/
        536870920)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
      if (
        /*resizable*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        2) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[31](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_16($$self, $$props, $$invalidate) {
  let sideComputed;
  let effectComputed;
  let classes;
  const omit_props_names = [
    "class",
    "side",
    "effect",
    "cover",
    "reveal",
    "push",
    "left",
    "right",
    "opened",
    "resizable",
    "backdrop",
    "backdropEl",
    "containerEl",
    "closeByBackdropClick",
    "visibleBreakpoint",
    "collapsedBreakpoint",
    "swipe",
    "swipeNoFollow",
    "swipeOnlyClose",
    "swipeActiveArea",
    "swipeThreshold",
    "f7Slot",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { side = void 0 } = $$props;
  let { effect = void 0 } = $$props;
  let { cover = false } = $$props;
  let { reveal = false } = $$props;
  let { push = false } = $$props;
  let { left = false } = $$props;
  let { right = false } = $$props;
  let { opened = false } = $$props;
  let { resizable = false } = $$props;
  let { backdrop = true } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { visibleBreakpoint = void 0 } = $$props;
  let { collapsedBreakpoint = void 0 } = $$props;
  let { swipe = false } = $$props;
  let { swipeNoFollow = false } = $$props;
  let { swipeOnlyClose = false } = $$props;
  let { swipeActiveArea = 0 } = $$props;
  let { swipeThreshold = 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let f7Panel;
  const state = {
    isOpened: false,
    isClosing: false,
    isCollapsed: false,
    isBreakpoint: false
  };
  function instance87() {
    return f7Panel;
  }
  let resizableOld = resizable;
  let initialWatchedResizable = false;
  function watchResizable(r) {
    if (!initialWatchedResizable) {
      initialWatchedResizable = true;
      return;
    }
    if (f7Panel && r && !resizableOld) {
      f7Panel.enableResizable();
    } else if (f7Panel && !r && resizableOld) {
      f7Panel.disableResizable();
    }
    resizableOld = r;
  }
  let openedOld = opened;
  let initialWatchedOpened = false;
  function watchOpened(o) {
    if (!initialWatchedOpened) {
      initialWatchedOpened = true;
      return;
    }
    if (f7Panel && o && !openedOld) {
      f7Panel.open();
    } else if (f7Panel && !o && openedOld) {
      f7Panel.close();
    }
    openedOld = o;
  }
  function onOpen(...args) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("panelOpen", args);
    $$invalidate(6, opened = true);
  }
  function onOpened(...args) {
    emit("panelOpened", args);
  }
  function onClose(...args) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("panelClose", args);
  }
  function onClosed(...args) {
    Object.assign(state, { isClosing: false });
    emit("panelClosed", args);
    $$invalidate(6, opened = false);
  }
  function onBackdropClick(...args) {
    emit("panelBackdropClick", args);
  }
  function onSwipe(...args) {
    emit("panelSwipe", args);
  }
  function onSwipeOpen(...args) {
    emit("panelSwipeOpen", args);
  }
  function onBreakpoint(...args) {
    Object.assign(state, { isBreakpoint: true, isCollapsed: false });
    emit("panelBreakpoint", args);
  }
  function onCollapsedBreakpoint(...args) {
    Object.assign(state, { isBreakpoint: false, isCollapsed: true });
    emit("panelCollapsedBreakpoint", args);
  }
  function onResize(...args) {
    emit("panelResize", args);
  }
  onMount(() => {
    f7ready(() => {
      const dom7 = app.f7.$;
      if (dom7(".panel-backdrop").length === 0) {
        dom7('<div class="panel-backdrop"></div>').insertBefore(el);
      }
      const params = noUndefinedProps({
        el,
        resizable,
        backdrop,
        backdropEl,
        containerEl,
        closeByBackdropClick,
        visibleBreakpoint,
        collapsedBreakpoint,
        swipe,
        swipeNoFollow,
        swipeOnlyClose,
        swipeActiveArea,
        swipeThreshold,
        on: {
          open: onOpen,
          opened: onOpened,
          close: onClose,
          closed: onClosed,
          backdropClick: onBackdropClick,
          swipe: onSwipe,
          swipeOpen: onSwipeOpen,
          collapsedBreakpoint: onCollapsedBreakpoint,
          breakpoint: onBreakpoint,
          resize: onResize
        }
      });
      $$invalidate(3, f7Panel = app.f7.panel.create(params));
      if (opened) {
        f7Panel.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Panel && f7Panel.destroy) {
      f7Panel.destroy();
    }
    $$invalidate(3, f7Panel = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(50, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("side" in $$new_props)
      $$invalidate(8, side = $$new_props.side);
    if ("effect" in $$new_props)
      $$invalidate(9, effect = $$new_props.effect);
    if ("cover" in $$new_props)
      $$invalidate(10, cover = $$new_props.cover);
    if ("reveal" in $$new_props)
      $$invalidate(11, reveal = $$new_props.reveal);
    if ("push" in $$new_props)
      $$invalidate(12, push = $$new_props.push);
    if ("left" in $$new_props)
      $$invalidate(13, left = $$new_props.left);
    if ("right" in $$new_props)
      $$invalidate(14, right = $$new_props.right);
    if ("opened" in $$new_props)
      $$invalidate(6, opened = $$new_props.opened);
    if ("resizable" in $$new_props)
      $$invalidate(0, resizable = $$new_props.resizable);
    if ("backdrop" in $$new_props)
      $$invalidate(15, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(16, backdropEl = $$new_props.backdropEl);
    if ("containerEl" in $$new_props)
      $$invalidate(17, containerEl = $$new_props.containerEl);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(18, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("visibleBreakpoint" in $$new_props)
      $$invalidate(19, visibleBreakpoint = $$new_props.visibleBreakpoint);
    if ("collapsedBreakpoint" in $$new_props)
      $$invalidate(20, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
    if ("swipe" in $$new_props)
      $$invalidate(21, swipe = $$new_props.swipe);
    if ("swipeNoFollow" in $$new_props)
      $$invalidate(22, swipeNoFollow = $$new_props.swipeNoFollow);
    if ("swipeOnlyClose" in $$new_props)
      $$invalidate(23, swipeOnlyClose = $$new_props.swipeOnlyClose);
    if ("swipeActiveArea" in $$new_props)
      $$invalidate(24, swipeActiveArea = $$new_props.swipeActiveArea);
    if ("swipeThreshold" in $$new_props)
      $$invalidate(25, swipeThreshold = $$new_props.swipeThreshold);
    if ("f7Slot" in $$new_props)
      $$invalidate(1, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    createEventDispatcher,
    restProps,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    app,
    f7ready,
    emit,
    className,
    side,
    effect,
    cover,
    reveal,
    push,
    left,
    right,
    opened,
    resizable,
    backdrop,
    backdropEl,
    containerEl,
    closeByBackdropClick,
    visibleBreakpoint,
    collapsedBreakpoint,
    swipe,
    swipeNoFollow,
    swipeOnlyClose,
    swipeActiveArea,
    swipeThreshold,
    f7Slot,
    el,
    f7Panel,
    state,
    instance: instance87,
    resizableOld,
    initialWatchedResizable,
    watchResizable,
    openedOld,
    initialWatchedOpened,
    watchOpened,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    onBackdropClick,
    onSwipe,
    onSwipeOpen,
    onBreakpoint,
    onCollapsedBreakpoint,
    onResize,
    effectComputed,
    sideComputed,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(50, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("side" in $$props)
      $$invalidate(8, side = $$new_props.side);
    if ("effect" in $$props)
      $$invalidate(9, effect = $$new_props.effect);
    if ("cover" in $$props)
      $$invalidate(10, cover = $$new_props.cover);
    if ("reveal" in $$props)
      $$invalidate(11, reveal = $$new_props.reveal);
    if ("push" in $$props)
      $$invalidate(12, push = $$new_props.push);
    if ("left" in $$props)
      $$invalidate(13, left = $$new_props.left);
    if ("right" in $$props)
      $$invalidate(14, right = $$new_props.right);
    if ("opened" in $$props)
      $$invalidate(6, opened = $$new_props.opened);
    if ("resizable" in $$props)
      $$invalidate(0, resizable = $$new_props.resizable);
    if ("backdrop" in $$props)
      $$invalidate(15, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(16, backdropEl = $$new_props.backdropEl);
    if ("containerEl" in $$props)
      $$invalidate(17, containerEl = $$new_props.containerEl);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(18, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("visibleBreakpoint" in $$props)
      $$invalidate(19, visibleBreakpoint = $$new_props.visibleBreakpoint);
    if ("collapsedBreakpoint" in $$props)
      $$invalidate(20, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
    if ("swipe" in $$props)
      $$invalidate(21, swipe = $$new_props.swipe);
    if ("swipeNoFollow" in $$props)
      $$invalidate(22, swipeNoFollow = $$new_props.swipeNoFollow);
    if ("swipeOnlyClose" in $$props)
      $$invalidate(23, swipeOnlyClose = $$new_props.swipeOnlyClose);
    if ("swipeActiveArea" in $$props)
      $$invalidate(24, swipeActiveArea = $$new_props.swipeActiveArea);
    if ("swipeThreshold" in $$props)
      $$invalidate(25, swipeThreshold = $$new_props.swipeThreshold);
    if ("f7Slot" in $$props)
      $$invalidate(1, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("f7Panel" in $$props)
      $$invalidate(3, f7Panel = $$new_props.f7Panel);
    if ("resizableOld" in $$props)
      resizableOld = $$new_props.resizableOld;
    if ("initialWatchedResizable" in $$props)
      initialWatchedResizable = $$new_props.initialWatchedResizable;
    if ("openedOld" in $$props)
      openedOld = $$new_props.openedOld;
    if ("initialWatchedOpened" in $$props)
      initialWatchedOpened = $$new_props.initialWatchedOpened;
    if ("effectComputed" in $$props)
      $$invalidate(27, effectComputed = $$new_props.effectComputed);
    if ("sideComputed" in $$props)
      $$invalidate(28, sideComputed = $$new_props.sideComputed);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*side, left, right*/
    24832) {
      $:
        $$invalidate(28, sideComputed = side || (left ? "left" : right ? "right" : "left"));
    }
    if ($$self.$$.dirty[0] & /*effect, reveal, push*/
    6656) {
      $:
        $$invalidate(27, effectComputed = effect || (reveal ? "reveal" : push ? "push" : "cover"));
    }
    $:
      $$invalidate(4, classes = classNames(
        className,
        "panel",
        {
          "panel-in": state.isOpened && !state.isClosing && !state.isBreakpoint,
          "panel-in-breakpoint": state.isBreakpoint,
          "panel-in-collapsed": state.isCollapsed,
          "panel-resizable": resizable,
          [`panel-${sideComputed}`]: sideComputed,
          [`panel-${effectComputed}`]: effectComputed
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*resizable*/
    1) {
      $:
        watchResizable(resizable);
    }
    if ($$self.$$.dirty[0] & /*opened*/
    64) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    resizable,
    f7Slot,
    el,
    f7Panel,
    classes,
    $$restProps,
    opened,
    className,
    side,
    effect,
    cover,
    reveal,
    push,
    left,
    right,
    backdrop,
    backdropEl,
    containerEl,
    closeByBackdropClick,
    visibleBreakpoint,
    collapsedBreakpoint,
    swipe,
    swipeNoFollow,
    swipeOnlyClose,
    swipeActiveArea,
    swipeThreshold,
    instance87,
    effectComputed,
    sideComputed,
    $$scope,
    slots,
    div_binding
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_16,
      create_fragment7,
      safe_not_equal,
      {
        class: 7,
        side: 8,
        effect: 9,
        cover: 10,
        reveal: 11,
        push: 12,
        left: 13,
        right: 14,
        opened: 6,
        resizable: 0,
        backdrop: 15,
        backdropEl: 16,
        containerEl: 17,
        closeByBackdropClick: 18,
        visibleBreakpoint: 19,
        collapsedBreakpoint: 20,
        swipe: 21,
        swipeNoFollow: 22,
        swipeOnlyClose: 23,
        swipeActiveArea: 24,
        swipeThreshold: 25,
        f7Slot: 1,
        instance: 26
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cover() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cover(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reveal() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reveal(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get push() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set push(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleBreakpoint() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleBreakpoint(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsedBreakpoint() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsedBreakpoint(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipe() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipe(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeNoFollow() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeNoFollow(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeOnlyClose() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeOnlyClose(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeActiveArea() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeActiveArea(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeThreshold() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeThreshold(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[26];
  }
  set instance(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var panel_default = Panel;

// node_modules/framework7-svelte/shared/router-open-in-component.svelte
function create_if_block_4(ctx) {
  let popup;
  let current;
  popup = new popup_default({
    props: {
      className: "popup-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(popup.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const popup_changes = {};
      if (dirty & /*url*/
      2)
        popup_changes["data-url"] = /*url*/
        ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popup, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(17:0) {#if openIn === 'popup'}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let view;
  let current;
  view = new view_default({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4)
        view_changes.linksView = /*viewSelector*/
        ctx2[2];
      if (dirty & /*url*/
      2)
        view_changes.url = /*url*/
        ctx2[1];
      view.$set(view_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(18:2) <Popup className=\\"popup-router-open-in\\" data-url={url}>',
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let loginscreen;
  let current;
  loginscreen = new login_screen_default({
    props: {
      className: "login-screen-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loginscreen.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(loginscreen, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loginscreen_changes = {};
      if (dirty & /*url*/
      2)
        loginscreen_changes["data-url"] = /*url*/
        ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        loginscreen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      loginscreen.$set(loginscreen_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loginscreen.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loginscreen.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loginscreen, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(22:0) {#if openIn === 'loginScreen'}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let view;
  let current;
  view = new view_default({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4)
        view_changes.linksView = /*viewSelector*/
        ctx2[2];
      if (dirty & /*url*/
      2)
        view_changes.url = /*url*/
        ctx2[1];
      view.$set(view_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(23:2) <LoginScreen className=\\"login-screen-router-open-in\\" data-url={url}>',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let sheet;
  let current;
  sheet = new sheet_default({
    props: {
      className: "sheet-modal-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sheet.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(sheet, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sheet_changes = {};
      if (dirty & /*url*/
      2)
        sheet_changes["data-url"] = /*url*/
        ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        sheet_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sheet.$set(sheet_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sheet.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sheet.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sheet, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(27:0) {#if openIn === 'sheet'}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let view;
  let current;
  view = new view_default({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4)
        view_changes.linksView = /*viewSelector*/
        ctx2[2];
      if (dirty & /*url*/
      2)
        view_changes.url = /*url*/
        ctx2[1];
      view.$set(view_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(28:2) <Sheet className=\\"sheet-modal-router-open-in\\" data-url={url}>',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let popover;
  let current;
  popover = new popover_default({
    props: {
      className: "popover-router-open-in",
      targetEl: (
        /*targetEl*/
        ctx[3]
      ),
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(popover.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const popover_changes = {};
      if (dirty & /*targetEl*/
      8)
        popover_changes.targetEl = /*targetEl*/
        ctx2[3];
      if (dirty & /*url*/
      2)
        popover_changes["data-url"] = /*url*/
        ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popover, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(32:0) {#if openIn === 'popover'}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let view;
  let current;
  view = new view_default({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4)
        view_changes.linksView = /*viewSelector*/
        ctx2[2];
      if (dirty & /*url*/
      2)
        view_changes.url = /*url*/
        ctx2[1];
      view.$set(view_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(33:2) <Popover className=\\"popover-router-open-in\\" {targetEl} data-url={url}>',
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let panel;
  let current;
  panel = new panel_default({
    props: {
      side: (
        /*side*/
        ctx[4]
      ),
      effect: (
        /*effect*/
        ctx[5]
      ),
      className: "panel-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(panel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*side*/
      16)
        panel_changes.side = /*side*/
        ctx2[4];
      if (dirty & /*effect*/
      32)
        panel_changes.effect = /*effect*/
        ctx2[5];
      if (dirty & /*url*/
      2)
        panel_changes["data-url"] = /*url*/
        ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(37:0) {#if openIn.indexOf('panel') === 0}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let view;
  let current;
  view = new view_default({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4)
        view_changes.linksView = /*viewSelector*/
        ctx2[2];
      if (dirty & /*url*/
      2)
        view_changes.url = /*url*/
        ctx2[1];
      view.$set(view_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(38:2) <Panel {side} {effect} className=\\"panel-router-open-in\\" data-url={url}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let show_if = (
    /*openIn*/
    ctx[0].indexOf("panel") === 0
  );
  let if_block4_anchor;
  let current;
  let if_block0 = (
    /*openIn*/
    ctx[0] === "popup" && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*openIn*/
    ctx[0] === "loginScreen" && create_if_block_3(ctx)
  );
  let if_block2 = (
    /*openIn*/
    ctx[0] === "sheet" && create_if_block_2(ctx)
  );
  let if_block3 = (
    /*openIn*/
    ctx[0] === "popover" && create_if_block_1(ctx)
  );
  let if_block4 = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, if_block4_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*openIn*/
        ctx2[0] === "popup"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "loginScreen"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "sheet"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "popover"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (dirty & /*openIn*/
      1)
        show_if = /*openIn*/
        ctx2[0].indexOf("panel") === 0;
      if (show_if) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(if_block4_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router_open_in_component", slots, []);
  let { openIn } = $$props;
  let { url } = $$props;
  let { viewSelector } = $$props;
  let { targetEl } = $$props;
  let { side } = $$props;
  let { effect } = $$props;
  $$self.$$.on_mount.push(function() {
    if (openIn === void 0 && !("openIn" in $$props || $$self.$$.bound[$$self.$$.props["openIn"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'openIn'");
    }
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'url'");
    }
    if (viewSelector === void 0 && !("viewSelector" in $$props || $$self.$$.bound[$$self.$$.props["viewSelector"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'viewSelector'");
    }
    if (targetEl === void 0 && !("targetEl" in $$props || $$self.$$.bound[$$self.$$.props["targetEl"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'targetEl'");
    }
    if (side === void 0 && !("side" in $$props || $$self.$$.bound[$$self.$$.props["side"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'side'");
    }
    if (effect === void 0 && !("effect" in $$props || $$self.$$.bound[$$self.$$.props["effect"]])) {
      console.warn("<Router_open_in_component> was created without expected prop 'effect'");
    }
  });
  const writable_props = ["openIn", "url", "viewSelector", "targetEl", "side", "effect"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router_open_in_component> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("openIn" in $$props2)
      $$invalidate(0, openIn = $$props2.openIn);
    if ("url" in $$props2)
      $$invalidate(1, url = $$props2.url);
    if ("viewSelector" in $$props2)
      $$invalidate(2, viewSelector = $$props2.viewSelector);
    if ("targetEl" in $$props2)
      $$invalidate(3, targetEl = $$props2.targetEl);
    if ("side" in $$props2)
      $$invalidate(4, side = $$props2.side);
    if ("effect" in $$props2)
      $$invalidate(5, effect = $$props2.effect);
  };
  $$self.$capture_state = () => ({
    Popup: popup_default,
    View: view_default,
    LoginScreen: login_screen_default,
    Sheet: sheet_default,
    Popover: popover_default,
    Panel: panel_default,
    openIn,
    url,
    viewSelector,
    targetEl,
    side,
    effect
  });
  $$self.$inject_state = ($$props2) => {
    if ("openIn" in $$props2)
      $$invalidate(0, openIn = $$props2.openIn);
    if ("url" in $$props2)
      $$invalidate(1, url = $$props2.url);
    if ("viewSelector" in $$props2)
      $$invalidate(2, viewSelector = $$props2.viewSelector);
    if ("targetEl" in $$props2)
      $$invalidate(3, targetEl = $$props2.targetEl);
    if ("side" in $$props2)
      $$invalidate(4, side = $$props2.side);
    if ("effect" in $$props2)
      $$invalidate(5, effect = $$props2.effect);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [openIn, url, viewSelector, targetEl, side, effect];
}
var Router_open_in_component = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment8, safe_not_equal, {
      openIn: 0,
      url: 1,
      viewSelector: 2,
      targetEl: 3,
      side: 4,
      effect: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_open_in_component",
      options,
      id: create_fragment8.name
    });
  }
  get openIn() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openIn(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewSelector() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewSelector(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<Router_open_in_component>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<Router_open_in_component>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var router_open_in_component_default = Router_open_in_component;

// node_modules/framework7-svelte/shared/router-open-in.js
var routerOpenIn = (router, url, options) => {
  const navigateOptions = {
    url,
    route: {
      path: url,
      options: {
        ...options,
        openIn: void 0,
        props: {
          ...options.props || {},
          url,
          openIn: options.openIn,
          viewSelector: router.view.selector
        }
      }
    }
  };
  const params = {
    ...options
  };
  params.component = router_open_in_component_default;
  if (options.openIn === "popup") {
    navigateOptions.route.popup = params;
  }
  if (options.openIn === "loginScreen") {
    navigateOptions.route.loginScreen = params;
  }
  if (options.openIn === "sheet") {
    navigateOptions.route.sheet = params;
  }
  if (options.openIn === "popover") {
    params.targetEl = options.clickedEl || options.targetEl;
    navigateOptions.route.popover = params;
    navigateOptions.route.options.props.targetEl = params.targetEl;
  }
  if (options.openIn.indexOf("panel") >= 0) {
    const parts = options.openIn.split(":");
    navigateOptions.route.options.props.side = parts[1] || "left";
    navigateOptions.route.options.props.effect = parts[2] || "cover";
    navigateOptions.route.panel = params;
  }
  return router.navigate(navigateOptions);
};

// node_modules/framework7-svelte/shared/components-router.js
var getChildrenArray = (el) => {
  const arr = [];
  for (let i = 0; i < el.children.length; i += 1) {
    arr.push(el.children[i]);
  }
  return arr;
};
var hasSameChildren = (childrenBefore, childrenAfter) => {
  if (childrenBefore.length !== childrenAfter.length)
    return false;
  const set = /* @__PURE__ */ new Set([...childrenBefore, ...childrenAfter]);
  if (set.size === childrenBefore.length)
    return true;
  return false;
};
var components_router_default = {
  proto: {
    openIn(router, navigateUrl, options) {
      return routerOpenIn(router, navigateUrl, options);
    },
    pageComponentLoader(_ref) {
      let {
        routerEl,
        component,
        options,
        resolve,
        reject
      } = _ref;
      const router = this;
      const routerId = router.id;
      const el = routerEl;
      let viewRouter;
      app.f7routers.views.forEach((data) => {
        if (data.el && data.el === routerEl || data.routerId && data.routerId === routerId) {
          viewRouter = data;
        }
      });
      if (!viewRouter) {
        reject();
        return;
      }
      const pageData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      const childrenBefore = getChildrenArray(el);
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved)
          return;
        const childrenAfter = getChildrenArray(el);
        if (hasSameChildren(childrenBefore, childrenAfter))
          return;
        app.f7events.off("viewRouterDidUpdate", onDidUpdate);
        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;
        resolve(pageEl);
        resolved = true;
      }
      app.f7events.on("viewRouterDidUpdate", onDidUpdate);
      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },
    removePage($pageEl) {
      if (!$pageEl)
        return;
      const router = this;
      let f7Page;
      if ("length" in $pageEl && $pageEl[0])
        f7Page = $pageEl[0].f7Page;
      else
        f7Page = $pageEl.f7Page;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }
      let viewRouter;
      app.f7routers.views.forEach((data) => {
        if (data.el && data.el === router.el) {
          viewRouter = data;
        }
      });
      let pageEl;
      if ("length" in $pageEl) {
        if ($pageEl.length === 0)
          return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl)
        return;
      let pageComponentFound;
      viewRouter.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });
      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(_temp) {
      let {
        tabEl,
        component,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      if (!tabEl)
        reject();
      let tabRouter;
      app.f7routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        reject();
        return;
      }
      const id = getComponentId();
      const tabContent = {
        id,
        component,
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved)
          return;
        app.f7events.off("tabRouterDidUpdate", onDidUpdate);
        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);
        resolved = true;
      }
      app.f7events.on("tabRouterDidUpdate", onDidUpdate);
      tabRouter.setTabContent(tabContent);
    },
    removeTabContent(tabEl) {
      if (!tabEl)
        return;
      let tabRouter;
      app.f7routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        tabEl.innerHTML = "";
        return;
      }
      tabRouter.setTabContent(null);
    },
    modalComponentLoader(_temp2) {
      let {
        component,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter) {
        reject();
        return;
      }
      const modalData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate() {
        if (resolved)
          return;
        app.f7events.off("modalsRouterDidUpdate", onDidUpdate);
        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;
        resolve(modalEl);
        resolved = true;
      }
      app.f7events.on("modalsRouterDidUpdate", onDidUpdate);
      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },
    removeModal(modalEl) {
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter)
        return;
      let modalDataToRemove;
      modalsRouter.modals.forEach((modalData) => {
        if (modalData.el === modalEl)
          modalDataToRemove = modalData;
      });
      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    }
  }
};

// node_modules/framework7-svelte/shared/plugin.js
var Framework7Svelte = {
  name: "sveltePlugin",
  installed: false,
  install(params) {
    if (params === void 0) {
      params = {};
    }
    const Framework7 = this;
    app.Framework7 = Framework7;
    if (Framework7Svelte.installed)
      return;
    Framework7Svelte.installed = true;
    f7initEvents();
    const {
      theme: paramsTheme,
      userAgent
    } = params;
    if (paramsTheme === "md") {
      app.theme.md = true;
      theme.md = true;
    }
    if (paramsTheme === "ios") {
      app.theme.md = true;
      theme.ios = true;
    }
    if (paramsTheme === "aurora") {
      app.theme.md = true;
      theme.aurora = true;
    }
    const needThemeCalc = typeof window === "undefined" ? !!userAgent : true;
    if (needThemeCalc && (!paramsTheme || paramsTheme === "auto")) {
      const device = Framework7.getDevice({
        userAgent
      }, true);
      app.theme.ios = !!device.ios;
      theme.ios = app.theme.ios;
      app.theme.aurora = device.desktop && device.electron;
      theme.aurora = app.theme.aurora;
      app.theme.md = !app.theme.ios && !app.theme.aurora;
      theme.md = app.theme.md;
    }
    f7ready(() => {
      setTheme();
    });
    Framework7.Router.use(components_router_default);
  }
};
var plugin_default = Framework7Svelte;

// node_modules/framework7-svelte/shared/use-store.js
var useStore = function() {
  let store = arguments.length <= 0 ? void 0 : arguments[0];
  let getter = arguments.length <= 1 ? void 0 : arguments[1];
  let callback = arguments.length <= 2 ? void 0 : arguments[2];
  if (arguments.length === 1) {
    store = f7.store;
    getter = arguments.length <= 0 ? void 0 : arguments[0];
  } else if (arguments.length === 2 && typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "string") {
    store = f7.store;
    getter = arguments.length <= 0 ? void 0 : arguments[0];
    callback = arguments.length <= 1 ? void 0 : arguments[1];
  }
  const obj = store._gettersPlain[getter];
  const value = obj.value;
  if (callback) {
    obj.onUpdated(callback);
  }
  onDestroy(() => {
    if (callback) {
      store.__removeCallback(callback);
    }
  });
  return value;
};

// node_modules/framework7-svelte/components/accordion-content.svelte
var file7 = "node_modules/framework7-svelte/components/accordion-content.svelte";
function create_fragment9(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file7, 11, 0, 331);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion_content", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "accordion-item-content", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Accordion_content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment9, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion_content",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var accordion_content_default = Accordion_content;

// node_modules/framework7-svelte/components/accordion-item.svelte
var file8 = "node_modules/framework7-svelte/components/accordion-item.svelte";
function create_fragment10(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[1]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file8, 72, 0, 1922);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "opened"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion_item", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { opened = void 0 } = $$props;
  let el;
  function onBeforeOpen(accEl, prevent) {
    if (accEl !== el)
      return;
    emit("accordionBeforeOpen", [prevent]);
  }
  function onOpen(accEl) {
    if (accEl !== el)
      return;
    emit("accordionOpen");
  }
  function onOpened(accEl) {
    if (accEl !== el)
      return;
    emit("accordionOpened");
  }
  function onBeforeClose(accEl, prevent) {
    if (accEl !== el)
      return;
    emit("accordionBeforeClose", [prevent]);
  }
  function onClose(accEl) {
    if (accEl !== el)
      return;
    emit("accordionClose");
  }
  function onClosed(accEl) {
    if (accEl !== el)
      return;
    emit("accordionClosed");
  }
  onMount(() => {
    f7ready(() => {
      app.f7.on("accordionBeforeOpen", onBeforeOpen);
      app.f7.on("accordionOpen", onOpen);
      app.f7.on("accordionOpened", onOpened);
      app.f7.on("accordionBeforeClose", onBeforeClose);
      app.f7.on("accordionClose", onClose);
      app.f7.on("accordionClosed", onClosed);
    });
  });
  onDestroy(() => {
    if (!app.f7 || !el)
      return;
    app.f7.off("accordionBeforeOpen", onBeforeOpen);
    app.f7.off("accordionOpen", onOpen);
    app.f7.off("accordionOpened", onOpened);
    app.f7.off("accordionBeforeClose", onBeforeClose);
    app.f7.off("accordionClose", onClose);
    app.f7.off("accordionClosed", onClosed);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("opened" in $$new_props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    opened,
    el,
    onBeforeOpen,
    onOpen,
    onOpened,
    onBeforeClose,
    onClose,
    onClosed,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("opened" in $$props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classes = classNames(className, "accordion-item", { "accordion-item-opened": opened }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [el, classes, $$restProps, className, opened, $$scope, slots, div_binding];
}
var Accordion_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment10, safe_not_equal, { class: 3, opened: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion_item",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var accordion_item_default = Accordion_item;

// node_modules/framework7-svelte/components/accordion-toggle.svelte
var file9 = "node_modules/framework7-svelte/components/accordion-toggle.svelte";
function create_fragment11(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file9, 11, 0, 330);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion_toggle", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "accordion-item-toggle", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Accordion_toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment11, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion_toggle",
      options,
      id: create_fragment11.name
    });
  }
  get class() {
    throw new Error("<Accordion_toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion_toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var accordion_toggle_default = Accordion_toggle;

// node_modules/framework7-svelte/components/accordion.svelte
var file10 = "node_modules/framework7-svelte/components/accordion.svelte";
function create_fragment12(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file10, 18, 0, 432);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "accordionOpposite"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { accordionOpposite = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("accordionOpposite" in $$new_props)
      $$invalidate(3, accordionOpposite = $$new_props.accordionOpposite);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    accordionOpposite,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("accordionOpposite" in $$props)
      $$invalidate(3, accordionOpposite = $$new_props.accordionOpposite);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "accordion-list", accordionOpposite && "accordion-opposite", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, accordionOpposite, $$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment12, safe_not_equal, { class: 2, accordionOpposite: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionOpposite() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionOpposite(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var accordion_default = Accordion;

// node_modules/framework7-svelte/components/actions-button.svelte
var file11 = "node_modules/framework7-svelte/components/actions-button.svelte";
var get_media_slot_changes = (dirty) => ({});
var get_media_slot_context = (ctx) => ({});
function create_if_block3(ctx) {
  let div;
  let current;
  const media_slot_template = (
    /*#slots*/
    ctx[9].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_media_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "actions-button-media");
      add_location(div, file11, 41, 4, 982);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_media_slot_changes
            ),
            get_media_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(41:2) {#if hasMediaSlots}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div1;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*hasMediaSlots*/
    ctx[2] && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div1_levels = [{ class: (
    /*classes*/
    ctx[1]
  ) }, restProps(
    /*$$restProps*/
    ctx[4]
  )];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "actions-button-text");
      add_location(div0, file11, 45, 2, 1066);
      set_attributes(div1, div1_data);
      add_location(div1, file11, 39, 0, 872);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[10](div1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "click",
          /*onClick*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*hasMediaSlots*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hasMediaSlots*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let hasMediaSlots;
  let classes;
  const omit_props_names = ["class", "bold", "close"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Actions_button", slots, ["media", "default"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { bold = false } = $$props;
  let { close = true } = $$props;
  let el;
  function onClick() {
    if (close && app.f7) {
      const dom7 = app.f7.$;
      app.f7.actions.close(dom7(el).parents(".actions-modal"));
    }
    emit("click");
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("bold" in $$new_props)
      $$invalidate(6, bold = $$new_props.bold);
    if ("close" in $$new_props)
      $$invalidate(7, close = $$new_props.close);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    emit,
    className,
    bold,
    close,
    el,
    onClick,
    classes,
    hasMediaSlots
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("bold" in $$props)
      $$invalidate(6, bold = $$new_props.bold);
    if ("close" in $$props)
      $$invalidate(7, close = $$new_props.close);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("hasMediaSlots" in $$props)
      $$invalidate(2, hasMediaSlots = $$new_props.hasMediaSlots);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classes = classNames(
        className,
        {
          "actions-button": true,
          "actions-button-bold": bold
        },
        colorClasses($$props)
      ));
  };
  $:
    $$invalidate(2, hasMediaSlots = $$slots.media);
  $$props = exclude_internal_props($$props);
  return [
    el,
    classes,
    hasMediaSlots,
    onClick,
    $$restProps,
    className,
    bold,
    close,
    $$scope,
    slots,
    div1_binding
  ];
}
var Actions_button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment13, safe_not_equal, { class: 5, bold: 6, close: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Actions_button",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bold() {
    throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bold(value) {
    throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set close(value) {
    throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var actions_button_default = Actions_button;

// node_modules/framework7-svelte/components/actions-group.svelte
var file12 = "node_modules/framework7-svelte/components/actions-group.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file12, 11, 0, 322);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Actions_group", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "actions-group", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Actions_group = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment14, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Actions_group",
      options,
      id: create_fragment14.name
    });
  }
  get class() {
    throw new Error("<Actions_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Actions_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var actions_group_default = Actions_group;

// node_modules/framework7-svelte/components/actions-label.svelte
var file13 = "node_modules/framework7-svelte/components/actions-label.svelte";
function create_fragment15(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file13, 28, 0, 591);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onClick*/
          ctx[1],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "bold"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Actions_label", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { bold = false } = $$props;
  function onClick() {
    emit("click");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("bold" in $$new_props)
      $$invalidate(4, bold = $$new_props.bold);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    emit,
    className,
    bold,
    onClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("bold" in $$props)
      $$invalidate(4, bold = $$new_props.bold);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "actions-label", { "actions-button-bold": bold }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, onClick, $$restProps, className, bold, $$scope, slots];
}
var Actions_label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment15, safe_not_equal, { class: 3, bold: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Actions_label",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<Actions_label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Actions_label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bold() {
    throw new Error("<Actions_label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bold(value) {
    throw new Error("<Actions_label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var actions_label_default = Actions_label;

// node_modules/framework7-svelte/components/actions.svelte
var file14 = "node_modules/framework7-svelte/components/actions.svelte";
var get_default_slot_changes7 = (dirty) => ({ actions: dirty & /*f7Actions*/
4 });
var get_default_slot_context7 = (ctx) => ({ actions: (
  /*f7Actions*/
  ctx[2]
) });
function create_fragment16(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context7
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file14, 126, 0, 3368);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[21](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7Actions*/
        524292)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_17($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "opened",
    "animate",
    "grid",
    "convertToPopover",
    "forceToPopover",
    "target",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeByOutsideClick",
    "closeOnEscape",
    "containerEl",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Actions", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate = void 0 } = $$props;
  let { grid = void 0 } = $$props;
  let { convertToPopover = void 0 } = $$props;
  let { forceToPopover = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeByOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let f7Actions;
  const state = { isOpened: opened, isClosing: false };
  function instance87() {
    return f7Actions;
  }
  function onOpen(instance88) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("actionsOpen", [instance88]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance88) {
    emit("actionsOpened", [instance88]);
  }
  function onClose(instance88) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("actionsClose", [instance88]);
  }
  function onClosed(instance88) {
    Object.assign(state, { isClosing: false });
    emit("actionsClosed", [instance88]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Actions)
      return;
    if (openedPassed)
      f7Actions.open();
    else
      f7Actions.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen,
        opened: onOpened,
        close: onClose,
        closed: onClosed
      }
    };
    if (target)
      params.targetEl = target;
    if (typeof convertToPopover !== "undefined")
      params.convertToPopover = convertToPopover;
    if (typeof forceToPopover !== "undefined")
      params.forceToPopover = forceToPopover;
    if (typeof backdrop !== "undefined")
      params.backdrop = backdrop;
    if (typeof backdropEl !== "undefined")
      params.backdropEl = backdropEl;
    if (typeof closeByBackdropClick !== "undefined")
      params.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeByOutsideClick !== "undefined")
      params.closeByOutsideClick = closeByOutsideClick;
    if (typeof closeOnEscape !== "undefined")
      params.closeOnEscape = closeOnEscape;
    if (typeof animate !== "undefined")
      params.animate = animate;
    if (typeof containerEl !== "undefined")
      params.containerEl = containerEl;
    f7ready(() => {
      $$invalidate(2, f7Actions = app.f7.actions.create(params));
      if (opened) {
        f7Actions.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Actions)
      f7Actions.destroy();
    $$invalidate(2, f7Actions = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("grid" in $$new_props)
      $$invalidate(8, grid = $$new_props.grid);
    if ("convertToPopover" in $$new_props)
      $$invalidate(9, convertToPopover = $$new_props.convertToPopover);
    if ("forceToPopover" in $$new_props)
      $$invalidate(10, forceToPopover = $$new_props.forceToPopover);
    if ("target" in $$new_props)
      $$invalidate(11, target = $$new_props.target);
    if ("backdrop" in $$new_props)
      $$invalidate(12, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(13, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$new_props)
      $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("containerEl" in $$new_props)
      $$invalidate(17, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    modalStateClasses,
    emit,
    className,
    style,
    opened,
    animate,
    grid,
    convertToPopover,
    forceToPopover,
    target,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    containerEl,
    el,
    f7Actions,
    state,
    instance: instance87,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    initialWatched,
    watchOpened,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$props)
      $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$props)
      $$invalidate(7, animate = $$new_props.animate);
    if ("grid" in $$props)
      $$invalidate(8, grid = $$new_props.grid);
    if ("convertToPopover" in $$props)
      $$invalidate(9, convertToPopover = $$new_props.convertToPopover);
    if ("forceToPopover" in $$props)
      $$invalidate(10, forceToPopover = $$new_props.forceToPopover);
    if ("target" in $$props)
      $$invalidate(11, target = $$new_props.target);
    if ("backdrop" in $$props)
      $$invalidate(12, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(13, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$props)
      $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("containerEl" in $$props)
      $$invalidate(17, containerEl = $$new_props.containerEl);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("f7Actions" in $$props)
      $$invalidate(2, f7Actions = $$new_props.f7Actions);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "actions-modal", { "actions-grid": grid }, modalStateClasses(state), colorClasses($$props)));
    if ($$self.$$.dirty & /*opened*/
    32) {
      $:
        watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7Actions,
    classes,
    $$restProps,
    opened,
    className,
    animate,
    grid,
    convertToPopover,
    forceToPopover,
    target,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    containerEl,
    instance87,
    $$scope,
    slots,
    div_binding
  ];
}
var Actions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_17, create_fragment16, safe_not_equal, {
      class: 6,
      style: 0,
      opened: 5,
      animate: 7,
      grid: 8,
      convertToPopover: 9,
      forceToPopover: 10,
      target: 11,
      backdrop: 12,
      backdropEl: 13,
      closeByBackdropClick: 14,
      closeByOutsideClick: 15,
      closeOnEscape: 16,
      containerEl: 17,
      instance: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Actions",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get grid() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set grid(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get convertToPopover() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set convertToPopover(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceToPopover() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceToPopover(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByOutsideClick() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByOutsideClick(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerEl() {
    throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerEl(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[18];
  }
  set instance(value) {
    throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var actions_default = Actions;

// node_modules/framework7-svelte/components/routable-modals.svelte
var file15 = "node_modules/framework7-svelte/components/routable-modals.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*modal*/
    ctx[5].props
  ];
  var switch_value = (
    /*modal*/
    ctx[5].component
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = dirty & /*modals*/
      1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*modal*/
        ctx[5].props
      )]) : {};
      if (dirty & /*modals*/
      1 && switch_value !== (switch_value = /*modal*/
      ctx[5].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(33:2) {#each modals as modal (modal.id)}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = (
    /*modals*/
    ctx[0]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*modal*/
    ctx2[5].id
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "framework7-modals");
      add_location(div, file15, 31, 0, 632);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[2](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*modals*/
      1) {
        each_value = /*modals*/
        ctx2[0];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[2](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Routable_modals", slots, []);
  let modals = [];
  let el;
  let routerData;
  onMount(() => {
    routerData = {
      el,
      modals,
      setModals(m) {
        tick().then(() => {
          $$invalidate(0, modals = m);
        });
      }
    };
    app.f7routers.modals = routerData;
  });
  afterUpdate(() => {
    if (!routerData)
      return;
    app.f7events.emit("modalsRouterDidUpdate", routerData);
  });
  onDestroy(() => {
    if (!routerData)
      return;
    app.f7routers.modals = null;
    routerData = null;
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    tick,
    app,
    modals,
    el,
    routerData
  });
  $$self.$inject_state = ($$props2) => {
    if ("modals" in $$props2)
      $$invalidate(0, modals = $$props2.modals);
    if ("el" in $$props2)
      $$invalidate(1, el = $$props2.el);
    if ("routerData" in $$props2)
      routerData = $$props2.routerData;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [modals, el, div_binding];
}
var Routable_modals = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment17, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Routable_modals",
      options,
      id: create_fragment17.name
    });
  }
};
var routable_modals_default = Routable_modals;

// node_modules/framework7-svelte/components/app.svelte
var file16 = "node_modules/framework7-svelte/components/app.svelte";
function create_fragment18(ctx) {
  let div;
  let t;
  let routablemodals;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  routablemodals = new routable_modals_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      create_component(routablemodals.$$.fragment);
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[1]
      );
      add_location(div, file16, 32, 0, 852);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      mount_component(routablemodals, div, null);
      ctx[5](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      2) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(routablemodals.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(routablemodals.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(routablemodals);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("App", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let el;
  if (!app.f7 || typeof window === "undefined") {
    f7init(el, noUndefinedProps($$props), false);
  }
  onMount(() => {
    const parentEl = el.parentNode;
    if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
      parentEl.style.height = "100%";
    }
    if (app.f7) {
      app.f7.init(el);
      return;
    }
    f7init(el, noUndefinedProps($$props), true);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    app,
    f7init,
    colorClasses,
    classNames,
    noUndefinedProps,
    RoutableModals: routable_modals_default,
    className,
    el,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classes = classNames(className, "framework7-root", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [el, classes, className, $$scope, slots, div_binding];
}
var App = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment18, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "App",
      options,
      id: create_fragment18.name
    });
  }
  get class() {
    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var app_default = App;

// node_modules/framework7-svelte/components/appbar.svelte
var file17 = "node_modules/framework7-svelte/components/appbar.svelte";
var get_after_inner_slot_changes = (dirty) => ({});
var get_after_inner_slot_context = (ctx) => ({});
var get_before_inner_slot_changes = (dirty) => ({});
var get_before_inner_slot_context = (ctx) => ({});
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(34:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "class",
        /*innerClasses*/
        ctx[1]
      );
      add_location(div, file17, 30, 4, 761);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*innerClasses*/
      2) {
        attr_dev(
          div,
          "class",
          /*innerClasses*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(30:2) {#if inner}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let current;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[10]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_before_inner_slot_context
  );
  const if_block_creators = [create_if_block4, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inner*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_inner_slot_template = (
    /*#slots*/
    ctx[10]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_after_inner_slot_context
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (before_inner_slot)
        before_inner_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      set_attributes(div, div_data);
      add_location(div, file17, 27, 0, 662);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (before_inner_slot) {
        before_inner_slot.m(div, null);
      }
      append_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t1);
      if (after_inner_slot) {
        after_inner_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_before_inner_slot_changes
            ),
            get_before_inner_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t1);
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_after_inner_slot_changes
            ),
            get_after_inner_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(if_block);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(if_block);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_inner_slot)
        after_inner_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let classes;
  let innerClasses;
  const omit_props_names = ["class", "noShadow", "noHairline", "inner", "innerClass", "innerClassName"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Appbar", slots, ["before-inner", "default", "after-inner"]);
  let { class: className = void 0 } = $$props;
  let { noShadow = void 0 } = $$props;
  let { noHairline = void 0 } = $$props;
  let { inner = true } = $$props;
  let { innerClass = void 0 } = $$props;
  let { innerClassName = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("noShadow" in $$new_props)
      $$invalidate(5, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$new_props)
      $$invalidate(6, noHairline = $$new_props.noHairline);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("innerClass" in $$new_props)
      $$invalidate(7, innerClass = $$new_props.innerClass);
    if ("innerClassName" in $$new_props)
      $$invalidate(8, innerClassName = $$new_props.innerClassName);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    noShadow,
    noHairline,
    inner,
    innerClass,
    innerClassName,
    innerClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("noShadow" in $$props)
      $$invalidate(5, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$props)
      $$invalidate(6, noHairline = $$new_props.noHairline);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("innerClass" in $$props)
      $$invalidate(7, innerClass = $$new_props.innerClass);
    if ("innerClassName" in $$props)
      $$invalidate(8, innerClassName = $$new_props.innerClassName);
    if ("innerClasses" in $$props)
      $$invalidate(1, innerClasses = $$new_props.innerClasses);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(
        className,
        "appbar",
        {
          "no-shadow": noShadow,
          "no-hairline": noHairline
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty & /*innerClass, innerClassName*/
    384) {
      $:
        $$invalidate(1, innerClasses = classNames("appbar-inner", innerClass, innerClassName));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    inner,
    innerClasses,
    classes,
    $$restProps,
    className,
    noShadow,
    noHairline,
    innerClass,
    innerClassName,
    $$scope,
    slots
  ];
}
var Appbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment19, safe_not_equal, {
      class: 4,
      noShadow: 5,
      noHairline: 6,
      inner: 0,
      innerClass: 7,
      innerClassName: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Appbar",
      options,
      id: create_fragment19.name
    });
  }
  get class() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noShadow() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noShadow(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairline() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairline(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClass() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClass(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClassName() {
    throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClassName(value) {
    throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var appbar_default = Appbar;

// node_modules/framework7-svelte/components/area-chart.svelte
var file18 = "node_modules/framework7-svelte/components/area-chart.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[54] = list[i];
  child_ctx[56] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i];
  child_ctx[56] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[59] = list[i];
  child_ctx[56] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[61] = list[i];
  child_ctx[56] = i;
  return child_ctx;
}
function create_else_block_1(ctx) {
  let polygon;
  let polygon_fill_value;
  let polygon_points_value;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      attr_dev(polygon, "fill", polygon_fill_value = /*data*/
      ctx[61].color);
      attr_dev(polygon, "fillrule", "evenodd");
      attr_dev(polygon, "points", polygon_points_value = /*data*/
      ctx[61].points);
      add_location(polygon, file18, 305, 8, 9023);
    },
    m: function mount(target, anchor) {
      insert_dev(target, polygon, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*chartData*/
      16384 && polygon_fill_value !== (polygon_fill_value = /*data*/
      ctx2[61].color)) {
        attr_dev(polygon, "fill", polygon_fill_value);
      }
      if (dirty[0] & /*chartData*/
      16384 && polygon_points_value !== (polygon_points_value = /*data*/
      ctx2[61].points)) {
        attr_dev(polygon, "points", polygon_points_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(305:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let path;
  let path_stroke_value;
  let path_d_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "stroke", path_stroke_value = /*data*/
      ctx[61].color);
      attr_dev(path, "fillrule", "evenodd");
      attr_dev(path, "d", path_d_value = /*data*/
      ctx[61].points);
      add_location(path, file18, 303, 8, 8937);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*chartData*/
      16384 && path_stroke_value !== (path_stroke_value = /*data*/
      ctx2[61].color)) {
        attr_dev(path, "stroke", path_stroke_value);
      }
      if (dirty[0] & /*chartData*/
      16384 && path_d_value !== (path_d_value = /*data*/
      ctx2[61].points)) {
        attr_dev(path, "d", path_d_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(303:6) {#if lineChart}",
    ctx
  });
  return block;
}
function create_each_block_3(key_1, ctx) {
  let first;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*lineChart*/
      ctx2[0]
    )
      return create_if_block_42;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(302:4) {#each chartData as data, index (index)}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let line;
  let line_data_index_value;
  let line_x__value;
  let line_y__value;
  let line_x__value_1;
  let line_class_value;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      line = svg_element("line");
      attr_dev(line, "data-index", line_data_index_value = /*index*/
      ctx[56]);
      attr_dev(line, "fill", "#000");
      attr_dev(line, "x1", line_x__value = /*line*/
      ctx[59]);
      attr_dev(line, "y1", line_y__value = 0);
      attr_dev(line, "x2", line_x__value_1 = /*line*/
      ctx[59]);
      attr_dev(
        line,
        "y2",
        /*height*/
        ctx[7]
      );
      attr_dev(line, "class", line_class_value = classNames({
        "area-chart-current-line": (
          /*currentIndex*/
          ctx[8] === /*index*/
          ctx[56]
        )
      }));
      add_location(line, file18, 310, 6, 9173);
      this.first = line;
    },
    m: function mount(target, anchor) {
      insert_dev(target, line, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*verticalLines*/
      8192 && line_data_index_value !== (line_data_index_value = /*index*/
      ctx[56])) {
        attr_dev(line, "data-index", line_data_index_value);
      }
      if (dirty[0] & /*verticalLines*/
      8192 && line_x__value !== (line_x__value = /*line*/
      ctx[59])) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty[0] & /*verticalLines*/
      8192 && line_x__value_1 !== (line_x__value_1 = /*line*/
      ctx[59])) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty[0] & /*height*/
      128) {
        attr_dev(
          line,
          "y2",
          /*height*/
          ctx[7]
        );
      }
      if (dirty[0] & /*currentIndex, verticalLines*/
      8448 && line_class_value !== (line_class_value = classNames({
        "area-chart-current-line": (
          /*currentIndex*/
          ctx[8] === /*index*/
          ctx[56]
        )
      }))) {
        attr_dev(line, "class", line_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(310:4) {#each verticalLines as line, index (index)}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value_1 = (
    /*axisLabels*/
    ctx[3]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => (
    /*index*/
    ctx2[56]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "area-chart-axis");
      add_location(div, file18, 322, 4, 9426);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*formatAxisLabel, axisLabels, visibleLegends*/
      135176) {
        each_value_1 = /*axisLabels*/
        ctx2[3];
        validate_each_argument(each_value_1);
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1, null, get_each_context_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(322:2) {#if axis}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let span;
  let t_value = (
    /*formatAxisLabel*/
    ctx[17](
      /*label*/
      ctx[57]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file18, 325, 46, 9566);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*axisLabels*/
      8 && t_value !== (t_value = /*formatAxisLabel*/
      ctx2[17](
        /*label*/
        ctx2[57]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(326:10) {#if visibleLegends.includes(label)}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let span;
  let show_if = (
    /*visibleLegends*/
    ctx[12].includes(
      /*label*/
      ctx[57]
    )
  );
  let t;
  let if_block = show_if && create_if_block_32(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      t = space();
      add_location(span, file18, 324, 8, 9513);
      this.first = span;
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      append_dev(span, t);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*visibleLegends, axisLabels*/
      4104)
        show_if = /*visibleLegends*/
        ctx[12].includes(
          /*label*/
          ctx[57]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_32(ctx);
          if_block.c();
          if_block.m(span, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(324:6) {#each axisLabels as label, index (index)}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let div;
  let each_value = (
    /*datasets*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "area-chart-legend");
      add_location(div, file18, 331, 4, 9677);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*hiddenDatasets, toggleDatasets, toggleDataset, formatLegendLabel, datasets*/
      328226) {
        each_value = /*datasets*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(331:2) {#if legend}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let span1;
  let span0;
  let span0_style_value;
  let t0;
  let t1_value = (
    /*formatLegendLabel*/
    ctx[18](
      /*dataset*/
      ctx[54].label
    ) + ""
  );
  let t1;
  let t2;
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr_dev(span0, "style", span0_style_value = `background-color: ${/*dataset*/
      ctx[54].color}`);
      add_location(span0, file18, 347, 12, 10305);
      attr_dev(span1, "class", "area-chart-legend-item");
      add_location(span1, file18, 346, 10, 10255);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, span0);
      append_dev(span1, t0);
      append_dev(span1, t1);
      append_dev(span1, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*datasets*/
      2 && span0_style_value !== (span0_style_value = `background-color: ${/*dataset*/
      ctx2[54].color}`)) {
        attr_dev(span0, "style", span0_style_value);
      }
      if (dirty[0] & /*datasets*/
      2 && t1_value !== (t1_value = /*formatLegendLabel*/
      ctx2[18](
        /*dataset*/
        ctx2[54].label
      ) + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(346:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let button;
  let span;
  let span_style_value;
  let t0;
  let t1_value = (
    /*formatLegendLabel*/
    ctx[18](
      /*dataset*/
      ctx[54].label
    ) + ""
  );
  let t1;
  let t2;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[32](
        /*index*/
        ctx[56]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr_dev(span, "style", span_style_value = `background-color: ${/*dataset*/
      ctx[54].color}`);
      add_location(span, file18, 342, 12, 10108);
      attr_dev(button, "class", button_class_value = classNames("area-chart-legend-item", {
        "area-chart-legend-item-hidden": (
          /*hiddenDatasets*/
          ctx[9].includes(
            /*index*/
            ctx[56]
          )
        ),
        "area-chart-legend-button": (
          /*toggleDatasets*/
          ctx[5]
        )
      }));
      attr_dev(button, "type", "button");
      add_location(button, file18, 334, 10, 9789);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, span);
      append_dev(button, t0);
      append_dev(button, t1);
      append_dev(button, t2);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*datasets*/
      2 && span_style_value !== (span_style_value = `background-color: ${/*dataset*/
      ctx[54].color}`)) {
        attr_dev(span, "style", span_style_value);
      }
      if (dirty[0] & /*datasets*/
      2 && t1_value !== (t1_value = /*formatLegendLabel*/
      ctx[18](
        /*dataset*/
        ctx[54].label
      ) + ""))
        set_data_dev(t1, t1_value);
      if (dirty[0] & /*hiddenDatasets, toggleDatasets*/
      544 && button_class_value !== (button_class_value = classNames("area-chart-legend-item", {
        "area-chart-legend-item-hidden": (
          /*hiddenDatasets*/
          ctx[9].includes(
            /*index*/
            ctx[56]
          )
        ),
        "area-chart-legend-button": (
          /*toggleDatasets*/
          ctx[5]
        )
      }))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(334:8) {#if toggleDatasets}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*toggleDatasets*/
      ctx2[5]
    )
      return create_if_block_12;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(333:6) {#each datasets as dataset, index}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div;
  let svg;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let each0_anchor;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let svg_viewBox_value;
  let t0;
  let t1;
  let t2;
  let current;
  let each_value_3 = (
    /*chartData*/
    ctx[14]
  );
  validate_each_argument(each_value_3);
  const get_key = (ctx2) => (
    /*index*/
    ctx2[56]
  );
  validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
  }
  let each_value_2 = (
    /*verticalLines*/
    ctx[13]
  );
  validate_each_argument(each_value_2);
  const get_key_1 = (ctx2) => (
    /*index*/
    ctx2[56]
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key_1);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  let if_block0 = (
    /*axis*/
    ctx[2] && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*legend*/
    ctx[4] && create_if_block5(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[15]
  ) }, restProps(
    /*$$restProps*/
    ctx[19]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*width*/
        ctx[6]
      );
      attr_dev(
        svg,
        "height",
        /*height*/
        ctx[7]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*width*/
      ctx[6]} ${/*height*/
      ctx[7]}`);
      attr_dev(svg, "preserveAspectRatio", "none");
      add_location(svg, file18, 293, 2, 8697);
      set_attributes(div, div_data);
      add_location(div, file18, 292, 0, 8630);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(svg, null);
        }
      }
      append_dev(svg, each0_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      ctx[31](svg);
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[33](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*chartData, lineChart*/
      16385) {
        each_value_3 = /*chartData*/
        ctx2[14];
        validate_each_argument(each_value_3);
        validate_each_keys(ctx2, each_value_3, get_each_context_3, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_3, each0_lookup, svg, destroy_block, create_each_block_3, each0_anchor, get_each_context_3);
      }
      if (dirty[0] & /*verticalLines, height, currentIndex*/
      8576) {
        each_value_2 = /*verticalLines*/
        ctx2[13];
        validate_each_argument(each_value_2);
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_2, each1_lookup, svg, destroy_block, create_each_block_2, null, get_each_context_2);
      }
      if (!current || dirty[0] & /*width*/
      64) {
        attr_dev(
          svg,
          "width",
          /*width*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*height*/
      128) {
        attr_dev(
          svg,
          "height",
          /*height*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*width, height*/
      192 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*width*/
      ctx2[6]} ${/*height*/
      ctx2[7]}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (
        /*axis*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*legend*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block5(ctx2);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        32768) && { class: (
          /*classes*/
          ctx2[15]
        ) },
        dirty[0] & /*$$restProps*/
        524288 && restProps(
          /*$$restProps*/
          ctx2[19]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[31](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[33](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classes;
  let chartData;
  let verticalLines;
  let visibleLegends;
  const omit_props_names = [
    "class",
    "lineChart",
    "datasets",
    "axis",
    "axisLabels",
    "tooltip",
    "legend",
    "toggleDatasets",
    "width",
    "height",
    "maxAxisLabels",
    "formatAxisLabel",
    "formatLegendLabel",
    "formatTooltip",
    "formatTooltipAxisLabel",
    "formatTooltipTotal",
    "formatTooltipDataset"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Area_chart", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { lineChart = false } = $$props;
  let { datasets = [] } = $$props;
  let { axis = false } = $$props;
  let { axisLabels = [] } = $$props;
  let { tooltip = false } = $$props;
  let { legend = false } = $$props;
  let { toggleDatasets = false } = $$props;
  let { width = 640 } = $$props;
  let { height = 320 } = $$props;
  let { maxAxisLabels = 8 } = $$props;
  let { formatAxisLabel: formatAxisLabelProp = void 0 } = $$props;
  let { formatLegendLabel: formatLegendLabelProp = void 0 } = $$props;
  let { formatTooltip: formatTooltipProp = void 0 } = $$props;
  let { formatTooltipAxisLabel = void 0 } = $$props;
  let { formatTooltipTotal = void 0 } = $$props;
  let { formatTooltipDataset = void 0 } = $$props;
  let el;
  let svgEl = null;
  let currentIndex = null;
  let previousIndex = null;
  let hiddenDatasets = [];
  let f7Tooltip = null;
  let linesOffsets = null;
  const setCurrentIndex = (value) => {
    previousIndex = currentIndex;
    $$invalidate(8, currentIndex = value);
  };
  const setHiddenDatasets = (value) => {
    $$invalidate(9, hiddenDatasets = value);
  };
  const getVisibleLegends = () => {
    if (!maxAxisLabels || axisLabels.length <= maxAxisLabels)
      return axisLabels;
    const skipStep = Math.ceil(axisLabels.length / maxAxisLabels);
    const filtered = axisLabels.filter((label, index) => index % skipStep === 0);
    return filtered;
  };
  const getSummValues = () => {
    const summValues = [];
    datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ values }) => {
      values.forEach((value, valueIndex) => {
        if (!summValues[valueIndex])
          summValues[valueIndex] = 0;
        summValues[valueIndex] += value;
      });
    });
    return summValues;
  };
  const getChartData = () => {
    const data = [];
    if (!datasets.length) {
      return data;
    }
    const lastValues = datasets[0].values.map(() => 0);
    let maxValue = 0;
    if (lineChart) {
      datasets.forEach(({ values }) => {
        const datasetMaxValue = Math.max(...values);
        if (datasetMaxValue > maxValue)
          maxValue = datasetMaxValue;
      });
    } else {
      maxValue = Math.max(...getSummValues());
    }
    datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ label, values, color }) => {
      const points = values.map((originalValue, valueIndex) => {
        lastValues[valueIndex] += originalValue;
        const value = lineChart ? originalValue : lastValues[valueIndex];
        const x = valueIndex / (values.length - 1) * width;
        const y = height - value / maxValue * height;
        if (lineChart) {
          return `${valueIndex === 0 ? "M" : "L"}${x},${y}`;
        }
        return `${x} ${y}`;
      });
      if (!lineChart) {
        points.push(`${width} ${height} 0 ${height}`);
      }
      data.push({ label, points: points.join(" "), color });
    });
    return data.reverse();
  };
  const getVerticalLines = () => {
    const lines = [];
    if (!datasets.length) {
      return lines;
    }
    const values = datasets[0].values;
    values.forEach((value, valueIndex) => {
      const x = valueIndex / (values.length - 1) * width;
      lines.push(x);
    });
    return lines;
  };
  const toggleDataset = (index) => {
    if (!toggleDatasets)
      return;
    if (hiddenDatasets.includes(index)) {
      hiddenDatasets.splice(hiddenDatasets.indexOf(index), 1);
    } else {
      hiddenDatasets.push(index);
    }
    setHiddenDatasets([...hiddenDatasets]);
  };
  const formatAxisLabel = (label) => {
    if (formatAxisLabelProp)
      return formatAxisLabelProp(label);
    return label;
  };
  const formatLegendLabel = (label) => {
    if (formatLegendLabelProp)
      return formatLegendLabelProp(label);
    return label;
  };
  const calcLinesOffsets = () => {
    const lines = svgEl.querySelectorAll("line");
    linesOffsets = [];
    for (let i = 0; i < lines.length; i += 1) {
      linesOffsets.push(lines[i].getBoundingClientRect().left);
    }
  };
  const formatTooltip = () => {
    if (currentIndex === null)
      return "";
    let total = 0;
    const currentValues = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).map((dataset) => ({
      color: dataset.color,
      label: dataset.label,
      value: dataset.values[currentIndex]
    }));
    currentValues.forEach((dataset) => {
      total += dataset.value;
    });
    if (formatTooltipProp) {
      return formatTooltipProp({
        index: currentIndex,
        total,
        datasets: currentValues
      });
    }
    let labelText = formatTooltipAxisLabel ? formatTooltipAxisLabel(axisLabels[currentIndex]) : formatAxisLabel(axisLabels[currentIndex]);
    if (!labelText)
      labelText = "";
    const totalText = formatTooltipTotal ? formatTooltipTotal(total) : total;
    const datasetsText = currentValues.length > 0 ? `
      <ul class="area-chart-tooltip-list">
        ${currentValues.map(({ label, color, value }) => {
      const valueText = formatTooltipDataset ? formatTooltipDataset(label, value, color) : `${label}: ${value}`;
      return `
              <li><span style="background-color: ${color};"></span>${valueText}</li>
            `;
    }).join("")}
      </ul>` : "";
    return `
      <div class="area-chart-tooltip-label">${labelText}</div>
      <div class="area-chart-tooltip-total">${totalText}</div>
      ${datasetsText}
    `;
  };
  const setTooltip = () => {
    if (!tooltip)
      return;
    if (currentIndex === null && !f7Tooltip)
      return;
    const hasVisibleDataSets = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).length > 0;
    if (!hasVisibleDataSets) {
      if (f7Tooltip && f7Tooltip.hide)
        f7Tooltip.hide();
      return;
    }
    if (currentIndex !== null && !f7Tooltip) {
      f7Tooltip = app.f7.tooltip.create({
        trigger: "manual",
        containerEl: el,
        targetEl: svgEl.querySelector(`line[data-index="${currentIndex}"]`),
        text: formatTooltip(),
        cssClass: "area-chart-tooltip"
      });
      if (f7Tooltip && f7Tooltip.show) {
        f7Tooltip.show();
      }
      return;
    }
    if (!f7Tooltip || !f7Tooltip.hide || !f7Tooltip.show) {
      return;
    }
    if (currentIndex !== null) {
      f7Tooltip.setText(formatTooltip());
      f7Tooltip.setTargetEl(svgEl.querySelector(`line[data-index="${currentIndex}"]`));
      f7Tooltip.show();
    } else {
      f7Tooltip.hide();
    }
  };
  const onMouseEnter = () => {
    calcLinesOffsets();
  };
  const onMouseMove = (e) => {
    if (!linesOffsets) {
      calcLinesOffsets();
    }
    let currentLeft = e.pageX;
    if (typeof currentLeft === "undefined")
      currentLeft = 0;
    const distances = linesOffsets.map((left) => Math.abs(currentLeft - left));
    const minDistance = Math.min(...distances);
    const closestIndex = distances.indexOf(minDistance);
    setCurrentIndex(closestIndex);
  };
  const onMouseLeave = () => {
    setCurrentIndex(null);
  };
  const attachEvents = () => {
    if (!svgEl)
      return;
    svgEl.addEventListener("mouseenter", onMouseEnter);
    svgEl.addEventListener("mousemove", onMouseMove);
    svgEl.addEventListener("mouseleave", onMouseLeave);
  };
  const detachEvents = () => {
    if (!svgEl)
      return;
    svgEl.removeEventListener("mouseenter", onMouseEnter);
    svgEl.removeEventListener("mousemove", onMouseMove);
    svgEl.removeEventListener("mouseleave", onMouseLeave);
  };
  onMount(() => {
    attachEvents();
  });
  onDestroy(() => {
    detachEvents();
    if (f7Tooltip && f7Tooltip.destroy) {
      f7Tooltip.destroy();
    }
    f7Tooltip = null;
  });
  const watchCurrentIndex = () => {
    if (currentIndex === previousIndex)
      return;
    emit("select", [currentIndex]);
    setTooltip();
  };
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      svgEl = $$value;
      $$invalidate(11, svgEl);
    });
  }
  const click_handler = (index) => toggleDataset(index);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(10, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(20, className = $$new_props.class);
    if ("lineChart" in $$new_props)
      $$invalidate(0, lineChart = $$new_props.lineChart);
    if ("datasets" in $$new_props)
      $$invalidate(1, datasets = $$new_props.datasets);
    if ("axis" in $$new_props)
      $$invalidate(2, axis = $$new_props.axis);
    if ("axisLabels" in $$new_props)
      $$invalidate(3, axisLabels = $$new_props.axisLabels);
    if ("tooltip" in $$new_props)
      $$invalidate(21, tooltip = $$new_props.tooltip);
    if ("legend" in $$new_props)
      $$invalidate(4, legend = $$new_props.legend);
    if ("toggleDatasets" in $$new_props)
      $$invalidate(5, toggleDatasets = $$new_props.toggleDatasets);
    if ("width" in $$new_props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(7, height = $$new_props.height);
    if ("maxAxisLabels" in $$new_props)
      $$invalidate(22, maxAxisLabels = $$new_props.maxAxisLabels);
    if ("formatAxisLabel" in $$new_props)
      $$invalidate(23, formatAxisLabelProp = $$new_props.formatAxisLabel);
    if ("formatLegendLabel" in $$new_props)
      $$invalidate(24, formatLegendLabelProp = $$new_props.formatLegendLabel);
    if ("formatTooltip" in $$new_props)
      $$invalidate(25, formatTooltipProp = $$new_props.formatTooltip);
    if ("formatTooltipAxisLabel" in $$new_props)
      $$invalidate(26, formatTooltipAxisLabel = $$new_props.formatTooltipAxisLabel);
    if ("formatTooltipTotal" in $$new_props)
      $$invalidate(27, formatTooltipTotal = $$new_props.formatTooltipTotal);
    if ("formatTooltipDataset" in $$new_props)
      $$invalidate(28, formatTooltipDataset = $$new_props.formatTooltipDataset);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    onMount,
    classNames,
    createEmitter,
    restProps,
    app,
    emit,
    className,
    lineChart,
    datasets,
    axis,
    axisLabels,
    tooltip,
    legend,
    toggleDatasets,
    width,
    height,
    maxAxisLabels,
    formatAxisLabelProp,
    formatLegendLabelProp,
    formatTooltipProp,
    formatTooltipAxisLabel,
    formatTooltipTotal,
    formatTooltipDataset,
    el,
    svgEl,
    currentIndex,
    previousIndex,
    hiddenDatasets,
    f7Tooltip,
    linesOffsets,
    setCurrentIndex,
    setHiddenDatasets,
    getVisibleLegends,
    getSummValues,
    getChartData,
    getVerticalLines,
    toggleDataset,
    formatAxisLabel,
    formatLegendLabel,
    calcLinesOffsets,
    formatTooltip,
    setTooltip,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    attachEvents,
    detachEvents,
    watchCurrentIndex,
    visibleLegends,
    verticalLines,
    chartData,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(53, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(20, className = $$new_props.className);
    if ("lineChart" in $$props)
      $$invalidate(0, lineChart = $$new_props.lineChart);
    if ("datasets" in $$props)
      $$invalidate(1, datasets = $$new_props.datasets);
    if ("axis" in $$props)
      $$invalidate(2, axis = $$new_props.axis);
    if ("axisLabels" in $$props)
      $$invalidate(3, axisLabels = $$new_props.axisLabels);
    if ("tooltip" in $$props)
      $$invalidate(21, tooltip = $$new_props.tooltip);
    if ("legend" in $$props)
      $$invalidate(4, legend = $$new_props.legend);
    if ("toggleDatasets" in $$props)
      $$invalidate(5, toggleDatasets = $$new_props.toggleDatasets);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(7, height = $$new_props.height);
    if ("maxAxisLabels" in $$props)
      $$invalidate(22, maxAxisLabels = $$new_props.maxAxisLabels);
    if ("formatAxisLabelProp" in $$props)
      $$invalidate(23, formatAxisLabelProp = $$new_props.formatAxisLabelProp);
    if ("formatLegendLabelProp" in $$props)
      $$invalidate(24, formatLegendLabelProp = $$new_props.formatLegendLabelProp);
    if ("formatTooltipProp" in $$props)
      $$invalidate(25, formatTooltipProp = $$new_props.formatTooltipProp);
    if ("formatTooltipAxisLabel" in $$props)
      $$invalidate(26, formatTooltipAxisLabel = $$new_props.formatTooltipAxisLabel);
    if ("formatTooltipTotal" in $$props)
      $$invalidate(27, formatTooltipTotal = $$new_props.formatTooltipTotal);
    if ("formatTooltipDataset" in $$props)
      $$invalidate(28, formatTooltipDataset = $$new_props.formatTooltipDataset);
    if ("el" in $$props)
      $$invalidate(10, el = $$new_props.el);
    if ("svgEl" in $$props)
      $$invalidate(11, svgEl = $$new_props.svgEl);
    if ("currentIndex" in $$props)
      $$invalidate(8, currentIndex = $$new_props.currentIndex);
    if ("previousIndex" in $$props)
      previousIndex = $$new_props.previousIndex;
    if ("hiddenDatasets" in $$props)
      $$invalidate(9, hiddenDatasets = $$new_props.hiddenDatasets);
    if ("f7Tooltip" in $$props)
      f7Tooltip = $$new_props.f7Tooltip;
    if ("linesOffsets" in $$props)
      linesOffsets = $$new_props.linesOffsets;
    if ("visibleLegends" in $$props)
      $$invalidate(12, visibleLegends = $$new_props.visibleLegends);
    if ("verticalLines" in $$props)
      $$invalidate(13, verticalLines = $$new_props.verticalLines);
    if ("chartData" in $$props)
      $$invalidate(14, chartData = $$new_props.chartData);
    if ("classes" in $$props)
      $$invalidate(15, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*currentIndex*/
    256) {
      $:
        watchCurrentIndex(currentIndex);
    }
    if ($$self.$$.dirty[0] & /*className*/
    1048576) {
      $:
        $$invalidate(15, classes = classNames("area-chart", className));
    }
    if ($$self.$$.dirty[0] & /*datasets, hiddenDatasets*/
    514) {
      $:
        $$invalidate(14, chartData = getChartData(datasets, hiddenDatasets));
    }
    if ($$self.$$.dirty[0] & /*datasets*/
    2) {
      $:
        $$invalidate(13, verticalLines = getVerticalLines(datasets));
    }
    if ($$self.$$.dirty[0] & /*maxAxisLabels, axisLabels*/
    4194312) {
      $:
        $$invalidate(12, visibleLegends = getVisibleLegends(maxAxisLabels, axisLabels));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    lineChart,
    datasets,
    axis,
    axisLabels,
    legend,
    toggleDatasets,
    width,
    height,
    currentIndex,
    hiddenDatasets,
    el,
    svgEl,
    visibleLegends,
    verticalLines,
    chartData,
    classes,
    toggleDataset,
    formatAxisLabel,
    formatLegendLabel,
    $$restProps,
    className,
    tooltip,
    maxAxisLabels,
    formatAxisLabelProp,
    formatLegendLabelProp,
    formatTooltipProp,
    formatTooltipAxisLabel,
    formatTooltipTotal,
    formatTooltipDataset,
    $$scope,
    slots,
    svg_binding,
    click_handler,
    div_binding
  ];
}
var Area_chart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment20,
      safe_not_equal,
      {
        class: 20,
        lineChart: 0,
        datasets: 1,
        axis: 2,
        axisLabels: 3,
        tooltip: 21,
        legend: 4,
        toggleDatasets: 5,
        width: 6,
        height: 7,
        maxAxisLabels: 22,
        formatAxisLabel: 23,
        formatLegendLabel: 24,
        formatTooltip: 25,
        formatTooltipAxisLabel: 26,
        formatTooltipTotal: 27,
        formatTooltipDataset: 28
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Area_chart",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineChart() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineChart(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get datasets() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set datasets(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axis() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axis(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axisLabels() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axisLabels(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggleDatasets() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggleDatasets(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxAxisLabels() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxAxisLabels(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatAxisLabel() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatAxisLabel(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatLegendLabel() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatLegendLabel(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatTooltip() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTooltip(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatTooltipAxisLabel() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTooltipAxisLabel(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatTooltipTotal() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTooltipTotal(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatTooltipDataset() {
    throw new Error("<Area_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTooltipDataset(value) {
    throw new Error("<Area_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var area_chart_default = Area_chart;

// node_modules/framework7-svelte/shared/use-tooltip.js
var useTooltip = (el, props) => {
  let f7Tooltip = null;
  const {
    tooltip,
    tooltipTrigger
  } = props;
  if (el && tooltip) {
    f7ready(() => {
      f7Tooltip = app.f7.tooltip.create({
        targetEl: el,
        text: tooltip,
        trigger: tooltipTrigger
      });
    });
  }
  return {
    update(_temp) {
      let {
        tooltip: value
      } = _temp === void 0 ? {} : _temp;
      if (!value && f7Tooltip) {
        f7Tooltip.destroy();
        f7Tooltip = null;
        return;
      }
      if (value && !f7Tooltip && app.f7) {
        f7Tooltip = app.f7.tooltip.create({
          targetEl: el,
          text: value,
          trigger: tooltipTrigger
        });
        return;
      }
      if (!value || !f7Tooltip)
        return;
      f7Tooltip.setText(value);
    },
    destroy() {
      if (f7Tooltip && f7Tooltip.destroy) {
        f7Tooltip.destroy();
        f7Tooltip = null;
      }
    }
  };
};

// node_modules/framework7-svelte/components/badge.svelte
var file19 = "node_modules/framework7-svelte/components/badge.svelte";
function create_fragment21(ctx) {
  let span;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file19, 15, 0, 447);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, span, {
          tooltip: (
            /*tooltip*/
            ctx[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[1]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      3)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[1]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tooltip", "tooltipTrigger"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("tooltip" in $$new_props)
      $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    useTooltip,
    className,
    tooltip,
    tooltipTrigger,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("tooltip" in $$props)
      $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "badge", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [tooltip, tooltipTrigger, classes, $$restProps, className, $$scope, slots];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment21, safe_not_equal, { class: 4, tooltip: 0, tooltipTrigger: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment21.name
    });
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var badge_default = Badge;

// node_modules/framework7-svelte/components/block-footer.svelte
var file20 = "node_modules/framework7-svelte/components/block-footer.svelte";
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file20, 11, 0, 321);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block_footer", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "block-footer", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Block_footer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment22, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block_footer",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<Block_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Block_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var block_footer_default = Block_footer;

// node_modules/framework7-svelte/components/block-header.svelte
var file21 = "node_modules/framework7-svelte/components/block-header.svelte";
function create_fragment23(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file21, 11, 0, 321);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block_header", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    restProps,
    colorClasses,
    classNames,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "block-header", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Block_header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment23, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block_header",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    throw new Error("<Block_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Block_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var block_header_default = Block_header;

// node_modules/framework7-svelte/components/block-title.svelte
var file22 = "node_modules/framework7-svelte/components/block-title.svelte";
function create_fragment24(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file22, 22, 0, 478);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["large", "medium", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block_title", slots, ["default"]);
  let { large = false } = $$props;
  let { medium = false } = $$props;
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("large" in $$new_props)
      $$invalidate(2, large = $$new_props.large);
    if ("medium" in $$new_props)
      $$invalidate(3, medium = $$new_props.medium);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    large,
    medium,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("large" in $$props)
      $$invalidate(2, large = $$new_props.large);
    if ("medium" in $$props)
      $$invalidate(3, medium = $$new_props.medium);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(
        className,
        "block-title",
        {
          "block-title-large": large,
          "block-title-medium": medium
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, large, medium, className, $$scope, slots];
}
var Block_title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment24, safe_not_equal, { large: 2, medium: 3, class: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block_title",
      options,
      id: create_fragment24.name
    });
  }
  get large() {
    throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get medium() {
    throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set medium(value) {
    throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var block_title_default = Block_title;

// node_modules/framework7-svelte/components/block.svelte
var file23 = "node_modules/framework7-svelte/components/block.svelte";
function create_fragment25(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[1]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file23, 58, 0, 1612);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "inset",
    "xsmallInset",
    "smallInset",
    "mediumInset",
    "largeInset",
    "xlargeInset",
    "strong",
    "tabs",
    "tab",
    "tabActive",
    "accordionList",
    "accordionOpposite",
    "noHairlines",
    "noHairlinesMd",
    "noHairlinesIos",
    "noHairlinesAurora",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Block", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { inset = false } = $$props;
  let { xsmallInset = false } = $$props;
  let { smallInset = false } = $$props;
  let { mediumInset = false } = $$props;
  let { largeInset = false } = $$props;
  let { xlargeInset = false } = $$props;
  let { strong = false } = $$props;
  let { tabs = false } = $$props;
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { accordionList = false } = $$props;
  let { accordionOpposite = false } = $$props;
  let { noHairlines = false } = $$props;
  let { noHairlinesMd = false } = $$props;
  let { noHairlinesIos = false } = $$props;
  let { noHairlinesAurora = false } = $$props;
  let { class: className = void 0 } = $$props;
  let el;
  useTab(() => el, emit);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inset" in $$new_props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("xsmallInset" in $$new_props)
      $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    if ("smallInset" in $$new_props)
      $$invalidate(5, smallInset = $$new_props.smallInset);
    if ("mediumInset" in $$new_props)
      $$invalidate(6, mediumInset = $$new_props.mediumInset);
    if ("largeInset" in $$new_props)
      $$invalidate(7, largeInset = $$new_props.largeInset);
    if ("xlargeInset" in $$new_props)
      $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    if ("strong" in $$new_props)
      $$invalidate(9, strong = $$new_props.strong);
    if ("tabs" in $$new_props)
      $$invalidate(10, tabs = $$new_props.tabs);
    if ("tab" in $$new_props)
      $$invalidate(11, tab = $$new_props.tab);
    if ("tabActive" in $$new_props)
      $$invalidate(12, tabActive = $$new_props.tabActive);
    if ("accordionList" in $$new_props)
      $$invalidate(13, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$new_props)
      $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    if ("noHairlines" in $$new_props)
      $$invalidate(15, noHairlines = $$new_props.noHairlines);
    if ("noHairlinesMd" in $$new_props)
      $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    if ("noHairlinesIos" in $$new_props)
      $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    if ("noHairlinesAurora" in $$new_props)
      $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    if ("class" in $$new_props)
      $$invalidate(19, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    useTab,
    emit,
    inset,
    xsmallInset,
    smallInset,
    mediumInset,
    largeInset,
    xlargeInset,
    strong,
    tabs,
    tab,
    tabActive,
    accordionList,
    accordionOpposite,
    noHairlines,
    noHairlinesMd,
    noHairlinesIos,
    noHairlinesAurora,
    className,
    el,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("inset" in $$props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("xsmallInset" in $$props)
      $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    if ("smallInset" in $$props)
      $$invalidate(5, smallInset = $$new_props.smallInset);
    if ("mediumInset" in $$props)
      $$invalidate(6, mediumInset = $$new_props.mediumInset);
    if ("largeInset" in $$props)
      $$invalidate(7, largeInset = $$new_props.largeInset);
    if ("xlargeInset" in $$props)
      $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    if ("strong" in $$props)
      $$invalidate(9, strong = $$new_props.strong);
    if ("tabs" in $$props)
      $$invalidate(10, tabs = $$new_props.tabs);
    if ("tab" in $$props)
      $$invalidate(11, tab = $$new_props.tab);
    if ("tabActive" in $$props)
      $$invalidate(12, tabActive = $$new_props.tabActive);
    if ("accordionList" in $$props)
      $$invalidate(13, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$props)
      $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    if ("noHairlines" in $$props)
      $$invalidate(15, noHairlines = $$new_props.noHairlines);
    if ("noHairlinesMd" in $$props)
      $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    if ("noHairlinesIos" in $$props)
      $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    if ("noHairlinesAurora" in $$props)
      $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    if ("className" in $$props)
      $$invalidate(19, className = $$new_props.className);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classes = classNames(
        className,
        "block",
        {
          inset,
          "xsmall-inset": xsmallInset,
          "small-inset": smallInset,
          "medium-inset": mediumInset,
          "large-inset": largeInset,
          "xlarge-inset": xlargeInset,
          "block-strong": strong,
          "accordion-list": accordionList,
          "accordion-opposite": accordionOpposite,
          tabs,
          tab,
          "tab-active": tabActive,
          "no-hairlines": noHairlines,
          "no-hairlines-md": noHairlinesMd,
          "no-hairlines-ios": noHairlinesIos,
          "no-hairlines-aurora": noHairlinesAurora
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    el,
    classes,
    $$restProps,
    inset,
    xsmallInset,
    smallInset,
    mediumInset,
    largeInset,
    xlargeInset,
    strong,
    tabs,
    tab,
    tabActive,
    accordionList,
    accordionOpposite,
    noHairlines,
    noHairlinesMd,
    noHairlinesIos,
    noHairlinesAurora,
    className,
    $$scope,
    slots,
    div_binding
  ];
}
var Block = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment25, safe_not_equal, {
      inset: 3,
      xsmallInset: 4,
      smallInset: 5,
      mediumInset: 6,
      largeInset: 7,
      xlargeInset: 8,
      strong: 9,
      tabs: 10,
      tab: 11,
      tabActive: 12,
      accordionList: 13,
      accordionOpposite: 14,
      noHairlines: 15,
      noHairlinesMd: 16,
      noHairlinesIos: 17,
      noHairlinesAurora: 18,
      class: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Block",
      options,
      id: create_fragment25.name
    });
  }
  get inset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xsmallInset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xsmallInset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallInset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallInset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediumInset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediumInset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeInset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeInset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xlargeInset() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xlargeInset(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabActive() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabActive(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionList() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionList(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionOpposite() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionOpposite(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlines() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlines(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesMd() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesMd(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesIos() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesIos(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesAurora() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesAurora(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var block_default = Block;

// node_modules/framework7-svelte/components/breadcrumbs-collapsed.svelte
var file24 = "node_modules/framework7-svelte/components/breadcrumbs-collapsed.svelte";
function create_fragment26(ctx) {
  let div;
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t = space();
      if (default_slot)
        default_slot.c();
      add_location(span, file24, 18, 2, 499);
      set_attributes(div, div_data);
      add_location(div, file24, 17, 0, 428);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onClick*/
          ctx[1],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs_collapsed", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  function onClick() {
    emit("click");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    classNames,
    createEmitter,
    restProps,
    className,
    emit,
    onClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(0, classes = classNames(className, "breadcrumbs-collapsed"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [classes, onClick, $$restProps, className, $$scope, slots];
}
var Breadcrumbs_collapsed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment26, safe_not_equal, { class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs_collapsed",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<Breadcrumbs_collapsed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs_collapsed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var breadcrumbs_collapsed_default = Breadcrumbs_collapsed;

// node_modules/framework7-svelte/components/breadcrumbs-item.svelte
var file25 = "node_modules/framework7-svelte/components/breadcrumbs-item.svelte";
function create_fragment27(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file25, 12, 0, 315);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["active", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs_item", slots, ["default"]);
  let { active = false } = $$props;
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("active" in $$new_props)
      $$invalidate(2, active = $$new_props.active);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classNames,
    restProps,
    active,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("active" in $$props)
      $$invalidate(2, active = $$new_props.active);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active*/
    12) {
      $:
        $$invalidate(0, classes = classNames(className, "breadcrumbs-item", active && "breadcrumbs-item-active"));
    }
  };
  return [classes, $$restProps, active, className, $$scope, slots];
}
var Breadcrumbs_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment27, safe_not_equal, { active: 2, class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs_item",
      options,
      id: create_fragment27.name
    });
  }
  get active() {
    throw new Error("<Breadcrumbs_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Breadcrumbs_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Breadcrumbs_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var breadcrumbs_item_default = Breadcrumbs_item;

// node_modules/framework7-svelte/components/breadcrumbs-separator.svelte
var file26 = "node_modules/framework7-svelte/components/breadcrumbs-separator.svelte";
function create_fragment28(ctx) {
  let div;
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      add_location(div, file26, 10, 0, 253);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*classes*/
        1 && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs_separator", slots, []);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
  };
  $$self.$capture_state = () => ({
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classNames(className, "breadcrumbs-separator"));
    }
  };
  return [classes, $$restProps, className];
}
var Breadcrumbs_separator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment28, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs_separator",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<Breadcrumbs_separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs_separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var breadcrumbs_separator_default = Breadcrumbs_separator;

// node_modules/framework7-svelte/components/breadcrumbs.svelte
var file27 = "node_modules/framework7-svelte/components/breadcrumbs.svelte";
function create_fragment29(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file27, 10, 0, 243);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classNames(className, "breadcrumbs"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var Breadcrumbs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment29, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs",
      options,
      id: create_fragment29.name
    });
  }
  get class() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var breadcrumbs_default = Breadcrumbs;

// node_modules/framework7-svelte/shared/use-route-props.js
var useRouteProps = (el, routeProps) => {
  if (el && routeProps) {
    el.f7RouteProps = routeProps;
  }
  return {
    update(newValue) {
      if (el && el.f7RouteProps && !newValue)
        delete el.f7RouteProps;
      else if (el && newValue)
        el.f7RouteProps = newValue;
    },
    destroy() {
      if (el && routeProps) {
        delete el.f7RouteProps;
      }
    }
  };
};

// node_modules/framework7-svelte/shared/use-icon.js
var useIcon = function(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    icon,
    iconMaterial,
    iconF7,
    iconMd,
    iconIos,
    iconAurora,
    iconColor,
    iconSize,
    iconBadge,
    badgeColor,
    iconBadgeColor
  } = props;
  if (icon || iconMaterial || iconF7 || iconMd || iconIos || iconAurora) {
    return {
      props: {
        material: iconMaterial,
        f7: iconF7,
        icon,
        md: iconMd,
        ios: iconIos,
        aurora: iconAurora,
        color: iconColor,
        size: iconSize
      },
      badge: iconBadge || iconBadge === 0 ? {
        props: {
          color: badgeColor || iconBadgeColor
        },
        content: iconBadge
      } : null
    };
  }
  return null;
};

// node_modules/framework7-svelte/shared/use-theme.js
var useTheme = (set) => {
  const t = app.f7 ? app.theme : null;
  if (!app.f7) {
    f7ready(() => {
      set(app.theme);
    });
  }
  return t;
};

// node_modules/framework7-svelte/components/icon.svelte
var file28 = "node_modules/framework7-svelte/components/icon.svelte";
function create_fragment30(ctx) {
  let i;
  let t0_value = (
    /*iconText*/
    (ctx[4] || "") + ""
  );
  let t0;
  let t1;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let i_levels = [
    { style: (
      /*iconStyle*/
      ctx[3]
    ) },
    { class: (
      /*iconClasses*/
      ctx[5]
    ) },
    restProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file28, 99, 0, 2603);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      append_dev(i, t0);
      append_dev(i, t1);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[22](i);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, i, {
          tooltip: (
            /*tooltip*/
            ctx[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[1]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if ((!current || dirty & /*iconText*/
      16) && t0_value !== (t0_value = /*iconText*/
      (ctx2[4] || "") + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*iconStyle*/
        8) && { style: (
          /*iconStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*iconClasses*/
        32) && { class: (
          /*iconClasses*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      3)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[1]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let iconClasses;
  let iconText;
  let iconSize;
  let iconStyle;
  const omit_props_names = [
    "style",
    "class",
    "material",
    "f7",
    "icon",
    "ios",
    "aurora",
    "md",
    "tooltip",
    "tooltipTrigger",
    "size"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, ["default"]);
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { f7: f72 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { aurora = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let el;
  let theme2 = useTheme((t) => {
    $$invalidate(16, theme2 = t);
  });
  let classes = { icon: true };
  let themeIcon;
  function iconTextComputed(t) {
    let textComputed = material || f72;
    if (md && t && t.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
      textComputed = md.split(":")[1];
    } else if (ios && t && t.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
      textComputed = ios.split(":")[1];
    } else if (aurora && t && t.aurora && (aurora.indexOf("material:") >= 0 || aurora.indexOf("f7:") >= 0)) {
      textComputed = aurora.split(":")[1];
    }
    return textComputed;
  }
  function i_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(7, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("material" in $$new_props)
      $$invalidate(9, material = $$new_props.material);
    if ("f7" in $$new_props)
      $$invalidate(10, f72 = $$new_props.f7);
    if ("icon" in $$new_props)
      $$invalidate(11, icon = $$new_props.icon);
    if ("ios" in $$new_props)
      $$invalidate(12, ios = $$new_props.ios);
    if ("aurora" in $$new_props)
      $$invalidate(13, aurora = $$new_props.aurora);
    if ("md" in $$new_props)
      $$invalidate(14, md = $$new_props.md);
    if ("tooltip" in $$new_props)
      $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("size" in $$new_props)
      $$invalidate(15, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    useTooltip,
    useTheme,
    style,
    className,
    material,
    f7: f72,
    icon,
    ios,
    aurora,
    md,
    tooltip,
    tooltipTrigger,
    size,
    el,
    theme: theme2,
    classes,
    themeIcon,
    iconTextComputed,
    iconSize,
    iconStyle,
    iconText,
    iconClasses
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("style" in $$props)
      $$invalidate(7, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("material" in $$props)
      $$invalidate(9, material = $$new_props.material);
    if ("f7" in $$props)
      $$invalidate(10, f72 = $$new_props.f7);
    if ("icon" in $$props)
      $$invalidate(11, icon = $$new_props.icon);
    if ("ios" in $$props)
      $$invalidate(12, ios = $$new_props.ios);
    if ("aurora" in $$props)
      $$invalidate(13, aurora = $$new_props.aurora);
    if ("md" in $$props)
      $$invalidate(14, md = $$new_props.md);
    if ("tooltip" in $$props)
      $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("size" in $$props)
      $$invalidate(15, size = $$new_props.size);
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("theme" in $$props)
      $$invalidate(16, theme2 = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(17, classes = $$new_props.classes);
    if ("themeIcon" in $$props)
      $$invalidate(18, themeIcon = $$new_props.themeIcon);
    if ("iconSize" in $$props)
      $$invalidate(19, iconSize = $$new_props.iconSize);
    if ("iconStyle" in $$props)
      $$invalidate(3, iconStyle = $$new_props.iconStyle);
    if ("iconText" in $$props)
      $$invalidate(4, iconText = $$new_props.iconText);
    if ("iconClasses" in $$props)
      $$invalidate(5, iconClasses = $$new_props.iconClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme, ios, md, aurora*/
    94208) {
      $:
        if (theme2) {
          if (theme2.ios)
            $$invalidate(18, themeIcon = ios);
          if (theme2.md)
            $$invalidate(18, themeIcon = md);
          if (theme2.aurora)
            $$invalidate(18, themeIcon = aurora);
        }
    }
    if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/
    265728) {
      $:
        if (themeIcon) {
          $$invalidate(17, classes = { icon: true });
          const parts = themeIcon.split(":");
          const prop = parts[0];
          const value = parts[1];
          if (prop === "material" || prop === "f7") {
            $$invalidate(17, classes["material-icons"] = prop === "material", classes);
            $$invalidate(17, classes["f7-icons"] = prop === "f7", classes);
            if (prop === "icon") {
              $$invalidate(17, classes[value] = true, classes);
            }
          } else {
            if (themeIcon.includes(":")) {
              $$invalidate(18, themeIcon = themeIcon.split(" ").map((el2) => el2.replace("icon:", "")).join(" "));
            }
            $$invalidate(17, classes[themeIcon] = true, classes);
          }
        } else {
          $$invalidate(17, classes = {
            icon: true,
            "material-icons": material,
            "f7-icons": f72
          });
          if (icon)
            $$invalidate(17, classes[icon] = true, classes);
        }
    }
    $:
      $$invalidate(5, iconClasses = classNames(className, classes, colorClasses($$props)));
    if ($$self.$$.dirty & /*theme*/
    65536) {
      $:
        $$invalidate(4, iconText = iconTextComputed(theme2));
    }
    if ($$self.$$.dirty & /*size*/
    32768) {
      $:
        $$invalidate(19, iconSize = typeof size === "number" || parseFloat(size) === size * 1 ? `${size}px` : size);
    }
    if ($$self.$$.dirty & /*style, iconSize*/
    524416) {
      $:
        $$invalidate(3, iconStyle = (style || "") + (iconSize ? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(";;", "") : ""));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    tooltip,
    tooltipTrigger,
    el,
    iconStyle,
    iconText,
    iconClasses,
    $$restProps,
    style,
    className,
    material,
    f72,
    icon,
    ios,
    aurora,
    md,
    size,
    theme2,
    classes,
    themeIcon,
    iconSize,
    $$scope,
    slots,
    i_binding
  ];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment30, safe_not_equal, {
      style: 7,
      class: 8,
      material: 9,
      f7: 10,
      icon: 11,
      ios: 12,
      aurora: 13,
      md: 14,
      tooltip: 0,
      tooltipTrigger: 1,
      size: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment30.name
    });
  }
  get style() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ios() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ios(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aurora() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aurora(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var icon_default = Icon;

// node_modules/framework7-svelte/components/use-icon.svelte
function create_if_block6(ctx) {
  let badge;
  let current;
  const badge_spread_levels = [
    /*icon*/
    ctx[0].badge.props
  ];
  let badge_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < badge_spread_levels.length; i += 1) {
    badge_props = assign(badge_props, badge_spread_levels[i]);
  }
  badge = new badge_default({ props: badge_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(badge.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_changes = dirty & /*icon*/
      1 ? get_spread_update(badge_spread_levels, [get_spread_object(
        /*icon*/
        ctx2[0].badge.props
      )]) : {};
      if (dirty & /*$$scope, icon*/
      3) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(9:2) {#if icon.badge}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t_value = (
    /*icon*/
    ctx[0].badge.content + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      1 && t_value !== (t_value = /*icon*/
      ctx2[0].badge.content + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(10:4) <Badge {...icon.badge.props}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx[0].badge && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[0].badge
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(8:0) <Icon {...icon.props}>",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let icon_1;
  let current;
  const icon_1_spread_levels = [
    /*icon*/
    ctx[0].props
  ];
  let icon_1_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_1_spread_levels.length; i += 1) {
    icon_1_props = assign(icon_1_props, icon_1_spread_levels[i]);
  }
  icon_1 = new icon_default({ props: icon_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const icon_1_changes = dirty & /*icon*/
      1 ? get_spread_update(icon_1_spread_levels, [get_spread_object(
        /*icon*/
        ctx2[0].props
      )]) : {};
      if (dirty & /*$$scope, icon*/
      3) {
        icon_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Use_icon", slots, []);
  let { icon = void 0 } = $$props;
  const writable_props = ["icon"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Use_icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
  };
  $$self.$capture_state = () => ({ Icon: icon_default, Badge: badge_default, icon });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon];
}
var Use_icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment31, safe_not_equal, { icon: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Use_icon",
      options,
      id: create_fragment31.name
    });
  }
  get icon() {
    throw new Error("<Use_icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Use_icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var use_icon_default = Use_icon;

// node_modules/framework7-svelte/components/preloader.svelte
var file29 = "node_modules/framework7-svelte/components/preloader.svelte";
function create_else_block3(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "preloader-inner");
      add_location(span, file29, 49, 9, 1601);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(50:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let span1;
  let span0;
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      attr_dev(span0, "class", "preloader-inner-circle");
      add_location(span0, file29, 48, 35, 1544);
      attr_dev(span1, "class", "preloader-inner");
      add_location(span1, file29, 48, 4, 1513);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, span0);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(48:34) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let span8;
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  let t2;
  let span3;
  let t3;
  let span4;
  let t4;
  let span5;
  let t5;
  let span6;
  let t6;
  let span7;
  const block = {
    c: function create() {
      span8 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      t2 = space();
      span3 = element("span");
      t3 = space();
      span4 = element("span");
      t4 = space();
      span5 = element("span");
      t5 = space();
      span6 = element("span");
      t6 = space();
      span7 = element("span");
      attr_dev(span0, "class", "preloader-inner-line");
      add_location(span0, file29, 38, 6, 1116);
      attr_dev(span1, "class", "preloader-inner-line");
      add_location(span1, file29, 39, 6, 1160);
      attr_dev(span2, "class", "preloader-inner-line");
      add_location(span2, file29, 40, 6, 1204);
      attr_dev(span3, "class", "preloader-inner-line");
      add_location(span3, file29, 41, 6, 1248);
      attr_dev(span4, "class", "preloader-inner-line");
      add_location(span4, file29, 42, 6, 1292);
      attr_dev(span5, "class", "preloader-inner-line");
      add_location(span5, file29, 43, 6, 1336);
      attr_dev(span6, "class", "preloader-inner-line");
      add_location(span6, file29, 44, 6, 1380);
      attr_dev(span7, "class", "preloader-inner-line");
      add_location(span7, file29, 45, 6, 1424);
      attr_dev(span8, "class", "preloader-inner");
      add_location(span8, file29, 37, 4, 1079);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span8, anchor);
      append_dev(span8, span0);
      append_dev(span8, t0);
      append_dev(span8, span1);
      append_dev(span8, t1);
      append_dev(span8, span2);
      append_dev(span8, t2);
      append_dev(span8, span3);
      append_dev(span8, t3);
      append_dev(span8, span4);
      append_dev(span8, t4);
      append_dev(span8, span5);
      append_dev(span8, t5);
      append_dev(span8, span6);
      append_dev(span8, t6);
      append_dev(span8, span7);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span8);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(37:31) ",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let span;
  let svg;
  let circle;
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      circle = svg_element("circle");
      attr_dev(circle, "cx", "18");
      attr_dev(circle, "cy", "18");
      attr_dev(circle, "r", "16");
      add_location(circle, file29, 33, 8, 984);
      attr_dev(svg, "viewBox", "0 0 36 36");
      add_location(svg, file29, 32, 6, 950);
      attr_dev(span, "class", "preloader-inner");
      add_location(span, file29, 31, 4, 913);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, svg);
      append_dev(svg, circle);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(31:2) {#if theme && theme.md}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[0] && /*theme*/
      ctx2[0].md
    )
      return create_if_block7;
    if (
      /*theme*/
      ctx2[0] && /*theme*/
      ctx2[0].ios
    )
      return create_if_block_13;
    if (
      /*theme*/
      ctx2[0] && /*theme*/
      ctx2[0].aurora
    )
      return create_if_block_23;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let span_levels = [
    { style: (
      /*preloaderStyle*/
      ctx[2]
    ) },
    { class: (
      /*classes*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      set_attributes(span, span_data);
      add_location(span, file29, 29, 0, 809);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if_block.m(span, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*preloaderStyle*/
        4 && { style: (
          /*preloaderStyle*/
          ctx2[2]
        ) },
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let sizeComputed;
  let preloaderStyle;
  let classes;
  const omit_props_names = ["style", "class", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Preloader", slots, []);
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let theme2 = useTheme((t) => {
    $$invalidate(0, theme2 = t);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({
    restProps,
    colorClasses,
    classNames,
    useTheme,
    style,
    className,
    size,
    theme: theme2,
    classes,
    sizeComputed,
    preloaderStyle
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(0, theme2 = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("sizeComputed" in $$props)
      $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
    if ("preloaderStyle" in $$props)
      $$invalidate(2, preloaderStyle = $$new_props.preloaderStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    64) {
      $:
        $$invalidate(7, sizeComputed = size && typeof size === "string" && size.indexOf("px") >= 0 ? size.replace("px", "") : size);
    }
    if ($$self.$$.dirty & /*style, sizeComputed*/
    144) {
      $:
        $$invalidate(2, preloaderStyle = ((style || "") + (sizeComputed ? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px` : "")).replace(";;", ";"));
    }
    $:
      $$invalidate(1, classes = classNames(className, "preloader", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    theme2,
    classes,
    preloaderStyle,
    $$restProps,
    style,
    className,
    size,
    sizeComputed
  ];
}
var Preloader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment32, safe_not_equal, { style: 4, class: 5, size: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Preloader",
      options,
      id: create_fragment32.name
    });
  }
  get style() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var preloader_default = Preloader;

// node_modules/framework7-svelte/components/button.svelte
var file30 = "node_modules/framework7-svelte/components/button.svelte";
function create_else_block_12(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let useRouteProps_action;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_6, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*preloader*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    { class: (
      /*classes*/
      ctx[10]
    ) },
    /*attrs*/
    ctx[11]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      add_location(a, file30, 162, 2, 4454);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      ctx[50](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[3]
          )),
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[0] & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        dirty[0] & /*attrs*/
        2048 && /*attrs*/
        ctx2[11]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      8)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[3]
        );
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      6)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[1]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[2]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
      ctx[50](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(162:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let useRouteProps_action;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_14, create_else_block4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*preloader*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let button_levels = [
    { class: (
      /*classes*/
      ctx[10]
    ) },
    /*attrs*/
    ctx[11]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if_block.c();
      set_attributes(button, button_data);
      add_location(button, file30, 132, 2, 3788);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      if (button.autofocus)
        button.focus();
      ctx[49](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            button,
            /*routeProps*/
            ctx[3]
          )),
          listen_dev(
            button,
            "click",
            /*onClick*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, button, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty[0] & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        dirty[0] & /*attrs*/
        2048 && /*attrs*/
        ctx2[11]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      8)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[3]
        );
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      6)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[1]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[2]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if_blocks[current_block_type_index].d();
      ctx[49](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(132:0) {#if tagName === 'button'}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_10(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_9(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    null
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(182:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let preloader_1;
  let t0;
  let span;
  let t1;
  let t2;
  let current;
  preloader_1 = new preloader_default({
    props: {
      size: (
        /*preloaderSize*/
        ctx[5]
      ),
      color: (
        /*preloaderColor*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_8(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_7(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    null
  );
  const block = {
    c: function create() {
      create_component(preloader_1.$$.fragment);
      t0 = space();
      span = element("span");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      add_location(span, file30, 172, 6, 4712);
    },
    m: function mount(target, anchor) {
      mount_component(preloader_1, target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t1);
      if (if_block1)
        if_block1.m(span, null);
      append_dev(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const preloader_1_changes = {};
      if (dirty[0] & /*preloaderSize*/
      32)
        preloader_1_changes.size = /*preloaderSize*/
        ctx2[5];
      if (dirty[0] & /*preloaderColor*/
      64)
        preloader_1_changes.color = /*preloaderColor*/
        ctx2[6];
      preloader_1.$set(preloader_1_changes);
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloader_1, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(171:4) {#if preloader}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256)
        useicon_changes.icon = /*icon*/
        ctx2[8];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(183:6) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file30, 186, 8, 5025);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(186:6) {#if typeof text !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256)
        useicon_changes.icon = /*icon*/
        ctx2[8];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(174:8) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file30, 177, 10, 4833);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(177:8) {#if typeof text !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_5(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_43(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    null
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_43(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(152:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let preloader_1;
  let t0;
  let span;
  let t1;
  let t2;
  let current;
  preloader_1 = new preloader_default({
    props: {
      size: (
        /*preloaderSize*/
        ctx[5]
      ),
      color: (
        /*preloaderColor*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_33(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_24(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    null
  );
  const block = {
    c: function create() {
      create_component(preloader_1.$$.fragment);
      t0 = space();
      span = element("span");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      add_location(span, file30, 142, 6, 4051);
    },
    m: function mount(target, anchor) {
      mount_component(preloader_1, target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t1);
      if (if_block1)
        if_block1.m(span, null);
      append_dev(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const preloader_1_changes = {};
      if (dirty[0] & /*preloaderSize*/
      32)
        preloader_1_changes.size = /*preloaderSize*/
        ctx2[5];
      if (dirty[0] & /*preloaderColor*/
      64)
        preloader_1_changes.color = /*preloaderColor*/
        ctx2[6];
      preloader_1.$set(preloader_1_changes);
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_24(ctx2);
          if_block1.c();
          if_block1.m(span, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloader_1, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(141:4) {#if preloader}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256)
        useicon_changes.icon = /*icon*/
        ctx2[8];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(153:6) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file30, 156, 8, 4364);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(156:6) {#if typeof text !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256)
        useicon_changes.icon = /*icon*/
        ctx2[8];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(144:8) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file30, 147, 10, 4172);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(147:8) {#if typeof text !== 'undefined'}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tagName*/
      ctx2[9] === "button"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let hrefComputed;
  let attrs;
  let classes;
  let tagName;
  let icon;
  const omit_props_names = [
    "class",
    "text",
    "tabLink",
    "tabLinkActive",
    "type",
    "href",
    "target",
    "round",
    "roundMd",
    "roundIos",
    "roundAurora",
    "fill",
    "fillMd",
    "fillIos",
    "fillAurora",
    "large",
    "largeMd",
    "largeIos",
    "largeAurora",
    "small",
    "smallMd",
    "smallIos",
    "smallAurora",
    "raised",
    "raisedMd",
    "raisedIos",
    "raisedAurora",
    "outline",
    "outlineMd",
    "outlineIos",
    "outlineAurora",
    "active",
    "disabled",
    "tooltip",
    "tooltipTrigger",
    "routeProps",
    "preloader",
    "preloaderSize",
    "preloaderColor",
    "loading"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { type = void 0 } = $$props;
  let { href = "#" } = $$props;
  let { target = void 0 } = $$props;
  let { round = false } = $$props;
  let { roundMd = false } = $$props;
  let { roundIos = false } = $$props;
  let { roundAurora = false } = $$props;
  let { fill = false } = $$props;
  let { fillMd = false } = $$props;
  let { fillIos = false } = $$props;
  let { fillAurora = false } = $$props;
  let { large = false } = $$props;
  let { largeMd = false } = $$props;
  let { largeIos = false } = $$props;
  let { largeAurora = false } = $$props;
  let { small = false } = $$props;
  let { smallMd = false } = $$props;
  let { smallIos = false } = $$props;
  let { smallAurora = false } = $$props;
  let { raised = false } = $$props;
  let { raisedMd = false } = $$props;
  let { raisedIos = false } = $$props;
  let { raisedAurora = false } = $$props;
  let { outline = false } = $$props;
  let { outlineMd = false } = $$props;
  let { outlineIos = false } = $$props;
  let { outlineAurora = false } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let { preloader = false } = $$props;
  let { preloaderSize = void 0 } = $$props;
  let { preloaderColor = void 0 } = $$props;
  let { loading = false } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(13, className = $$new_props.class);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$new_props)
      $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props)
      $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("type" in $$new_props)
      $$invalidate(16, type = $$new_props.type);
    if ("href" in $$new_props)
      $$invalidate(17, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(18, target = $$new_props.target);
    if ("round" in $$new_props)
      $$invalidate(19, round = $$new_props.round);
    if ("roundMd" in $$new_props)
      $$invalidate(20, roundMd = $$new_props.roundMd);
    if ("roundIos" in $$new_props)
      $$invalidate(21, roundIos = $$new_props.roundIos);
    if ("roundAurora" in $$new_props)
      $$invalidate(22, roundAurora = $$new_props.roundAurora);
    if ("fill" in $$new_props)
      $$invalidate(23, fill = $$new_props.fill);
    if ("fillMd" in $$new_props)
      $$invalidate(24, fillMd = $$new_props.fillMd);
    if ("fillIos" in $$new_props)
      $$invalidate(25, fillIos = $$new_props.fillIos);
    if ("fillAurora" in $$new_props)
      $$invalidate(26, fillAurora = $$new_props.fillAurora);
    if ("large" in $$new_props)
      $$invalidate(27, large = $$new_props.large);
    if ("largeMd" in $$new_props)
      $$invalidate(28, largeMd = $$new_props.largeMd);
    if ("largeIos" in $$new_props)
      $$invalidate(29, largeIos = $$new_props.largeIos);
    if ("largeAurora" in $$new_props)
      $$invalidate(30, largeAurora = $$new_props.largeAurora);
    if ("small" in $$new_props)
      $$invalidate(31, small = $$new_props.small);
    if ("smallMd" in $$new_props)
      $$invalidate(32, smallMd = $$new_props.smallMd);
    if ("smallIos" in $$new_props)
      $$invalidate(33, smallIos = $$new_props.smallIos);
    if ("smallAurora" in $$new_props)
      $$invalidate(34, smallAurora = $$new_props.smallAurora);
    if ("raised" in $$new_props)
      $$invalidate(35, raised = $$new_props.raised);
    if ("raisedMd" in $$new_props)
      $$invalidate(36, raisedMd = $$new_props.raisedMd);
    if ("raisedIos" in $$new_props)
      $$invalidate(37, raisedIos = $$new_props.raisedIos);
    if ("raisedAurora" in $$new_props)
      $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    if ("outline" in $$new_props)
      $$invalidate(39, outline = $$new_props.outline);
    if ("outlineMd" in $$new_props)
      $$invalidate(40, outlineMd = $$new_props.outlineMd);
    if ("outlineIos" in $$new_props)
      $$invalidate(41, outlineIos = $$new_props.outlineIos);
    if ("outlineAurora" in $$new_props)
      $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    if ("active" in $$new_props)
      $$invalidate(43, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(44, disabled = $$new_props.disabled);
    if ("tooltip" in $$new_props)
      $$invalidate(1, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props)
      $$invalidate(3, routeProps = $$new_props.routeProps);
    if ("preloader" in $$new_props)
      $$invalidate(4, preloader = $$new_props.preloader);
    if ("preloaderSize" in $$new_props)
      $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    if ("preloaderColor" in $$new_props)
      $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    if ("loading" in $$new_props)
      $$invalidate(45, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(47, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsAttrs,
    actionsClasses,
    classNames,
    extend,
    isStringProp,
    plainText,
    createEmitter,
    restProps,
    useTooltip,
    useRouteProps,
    useIcon,
    UseIcon: use_icon_default,
    Preloader: preloader_default,
    emit,
    className,
    text: text2,
    tabLink,
    tabLinkActive,
    type,
    href,
    target,
    round,
    roundMd,
    roundIos,
    roundAurora,
    fill,
    fillMd,
    fillIos,
    fillAurora,
    large,
    largeMd,
    largeIos,
    largeAurora,
    small,
    smallMd,
    smallIos,
    smallAurora,
    raised,
    raisedMd,
    raisedIos,
    raisedAurora,
    outline,
    outlineMd,
    outlineIos,
    outlineAurora,
    active,
    disabled,
    tooltip,
    tooltipTrigger,
    routeProps,
    preloader,
    preloaderSize,
    preloaderColor,
    loading,
    el,
    onClick,
    icon,
    tagName,
    classes,
    hrefComputed,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(13, className = $$new_props.className);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$props)
      $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$props)
      $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("type" in $$props)
      $$invalidate(16, type = $$new_props.type);
    if ("href" in $$props)
      $$invalidate(17, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(18, target = $$new_props.target);
    if ("round" in $$props)
      $$invalidate(19, round = $$new_props.round);
    if ("roundMd" in $$props)
      $$invalidate(20, roundMd = $$new_props.roundMd);
    if ("roundIos" in $$props)
      $$invalidate(21, roundIos = $$new_props.roundIos);
    if ("roundAurora" in $$props)
      $$invalidate(22, roundAurora = $$new_props.roundAurora);
    if ("fill" in $$props)
      $$invalidate(23, fill = $$new_props.fill);
    if ("fillMd" in $$props)
      $$invalidate(24, fillMd = $$new_props.fillMd);
    if ("fillIos" in $$props)
      $$invalidate(25, fillIos = $$new_props.fillIos);
    if ("fillAurora" in $$props)
      $$invalidate(26, fillAurora = $$new_props.fillAurora);
    if ("large" in $$props)
      $$invalidate(27, large = $$new_props.large);
    if ("largeMd" in $$props)
      $$invalidate(28, largeMd = $$new_props.largeMd);
    if ("largeIos" in $$props)
      $$invalidate(29, largeIos = $$new_props.largeIos);
    if ("largeAurora" in $$props)
      $$invalidate(30, largeAurora = $$new_props.largeAurora);
    if ("small" in $$props)
      $$invalidate(31, small = $$new_props.small);
    if ("smallMd" in $$props)
      $$invalidate(32, smallMd = $$new_props.smallMd);
    if ("smallIos" in $$props)
      $$invalidate(33, smallIos = $$new_props.smallIos);
    if ("smallAurora" in $$props)
      $$invalidate(34, smallAurora = $$new_props.smallAurora);
    if ("raised" in $$props)
      $$invalidate(35, raised = $$new_props.raised);
    if ("raisedMd" in $$props)
      $$invalidate(36, raisedMd = $$new_props.raisedMd);
    if ("raisedIos" in $$props)
      $$invalidate(37, raisedIos = $$new_props.raisedIos);
    if ("raisedAurora" in $$props)
      $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    if ("outline" in $$props)
      $$invalidate(39, outline = $$new_props.outline);
    if ("outlineMd" in $$props)
      $$invalidate(40, outlineMd = $$new_props.outlineMd);
    if ("outlineIos" in $$props)
      $$invalidate(41, outlineIos = $$new_props.outlineIos);
    if ("outlineAurora" in $$props)
      $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    if ("active" in $$props)
      $$invalidate(43, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(44, disabled = $$new_props.disabled);
    if ("tooltip" in $$props)
      $$invalidate(1, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$props)
      $$invalidate(3, routeProps = $$new_props.routeProps);
    if ("preloader" in $$props)
      $$invalidate(4, preloader = $$new_props.preloader);
    if ("preloaderSize" in $$props)
      $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    if ("preloaderColor" in $$props)
      $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    if ("loading" in $$props)
      $$invalidate(45, loading = $$new_props.loading);
    if ("el" in $$props)
      $$invalidate(7, el = $$new_props.el);
    if ("icon" in $$props)
      $$invalidate(8, icon = $$new_props.icon);
    if ("tagName" in $$props)
      $$invalidate(9, tagName = $$new_props.tagName);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("hrefComputed" in $$props)
      $$invalidate(46, hrefComputed = $$new_props.hrefComputed);
    if ("attrs" in $$props)
      $$invalidate(11, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*href*/
    131072) {
      $:
        $$invalidate(46, hrefComputed = href === true ? "#" : href || void 0);
    }
    $:
      $$invalidate(11, attrs = extend(
        {
          href: hrefComputed,
          target,
          type,
          "data-tab": isStringProp(tabLink) && tabLink || void 0,
          ...restProps($$restProps)
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    $:
      $$invalidate(10, classes = classNames(
        className,
        "button",
        {
          "tab-link": tabLink || tabLink === "",
          "tab-link-active": tabLinkActive,
          "button-round": round,
          "button-round-ios": roundIos,
          "button-round-aurora": roundAurora,
          "button-round-md": roundMd,
          "button-fill": fill,
          "button-fill-ios": fillIos,
          "button-fill-aurora": fillAurora,
          "button-fill-md": fillMd,
          "button-large": large,
          "button-large-ios": largeIos,
          "button-large-aurora": largeAurora,
          "button-large-md": largeMd,
          "button-small": small,
          "button-small-ios": smallIos,
          "button-small-aurora": smallAurora,
          "button-small-md": smallMd,
          "button-raised": raised,
          "button-raised-ios": raisedIos,
          "button-raised-aurora": raisedAurora,
          "button-raised-md": raisedMd,
          "button-active": active,
          "button-outline": outline,
          "button-outline-ios": outlineIos,
          "button-outline-aurora": outlineAurora,
          "button-outline-md": outlineMd,
          "button-preloader": preloader,
          "button-loading": loading,
          disabled
        },
        colorClasses($$props),
        routerClasses($$props),
        actionsClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*type*/
    65536) {
      $:
        $$invalidate(9, tagName = type === "submit" || type === "reset" || type === "button" ? "button" : "a");
    }
    $:
      $$invalidate(8, icon = useIcon($$props));
  };
  $$props = exclude_internal_props($$props);
  return [
    text2,
    tooltip,
    tooltipTrigger,
    routeProps,
    preloader,
    preloaderSize,
    preloaderColor,
    el,
    icon,
    tagName,
    classes,
    attrs,
    onClick,
    className,
    tabLink,
    tabLinkActive,
    type,
    href,
    target,
    round,
    roundMd,
    roundIos,
    roundAurora,
    fill,
    fillMd,
    fillIos,
    fillAurora,
    large,
    largeMd,
    largeIos,
    largeAurora,
    small,
    smallMd,
    smallIos,
    smallAurora,
    raised,
    raisedMd,
    raisedIos,
    raisedAurora,
    outline,
    outlineMd,
    outlineIos,
    outlineAurora,
    active,
    disabled,
    loading,
    hrefComputed,
    $$scope,
    slots,
    button_binding,
    a_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance26,
      create_fragment33,
      safe_not_equal,
      {
        class: 13,
        text: 0,
        tabLink: 14,
        tabLinkActive: 15,
        type: 16,
        href: 17,
        target: 18,
        round: 19,
        roundMd: 20,
        roundIos: 21,
        roundAurora: 22,
        fill: 23,
        fillMd: 24,
        fillIos: 25,
        fillAurora: 26,
        large: 27,
        largeMd: 28,
        largeIos: 29,
        largeAurora: 30,
        small: 31,
        smallMd: 32,
        smallIos: 33,
        smallAurora: 34,
        raised: 35,
        raisedMd: 36,
        raisedIos: 37,
        raisedAurora: 38,
        outline: 39,
        outlineMd: 40,
        outlineIos: 41,
        outlineAurora: 42,
        active: 43,
        disabled: 44,
        tooltip: 1,
        tooltipTrigger: 2,
        routeProps: 3,
        preloader: 4,
        preloaderSize: 5,
        preloaderColor: 6,
        loading: 45
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment33.name
    });
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLink() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLink(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLinkActive() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLinkActive(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineMd() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineMd(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineIos() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineIos(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineAurora() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineAurora(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preloader() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preloader(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preloaderSize() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preloaderSize(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preloaderColor() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preloaderColor(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var button_default = Button;

// node_modules/framework7-svelte/components/card-content.svelte
var file31 = "node_modules/framework7-svelte/components/card-content.svelte";
function create_fragment34(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file31, 20, 0, 420);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card_content", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { padding = true } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("padding" in $$new_props)
      $$invalidate(3, padding = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    padding,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("padding" in $$props)
      $$invalidate(3, padding = $$new_props.padding);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "card-content", { "card-content-padding": padding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, padding, $$scope, slots];
}
var Card_content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment34, safe_not_equal, { class: 2, padding: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card_content",
      options,
      id: create_fragment34.name
    });
  }
  get class() {
    throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var card_content_default = Card_content;

// node_modules/framework7-svelte/components/card-footer.svelte
var file32 = "node_modules/framework7-svelte/components/card-footer.svelte";
function create_fragment35(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file32, 11, 0, 320);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card_footer", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "card-footer", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Card_footer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment35, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card_footer",
      options,
      id: create_fragment35.name
    });
  }
  get class() {
    throw new Error("<Card_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var card_footer_default = Card_footer;

// node_modules/framework7-svelte/components/card-header.svelte
var file33 = "node_modules/framework7-svelte/components/card-header.svelte";
function create_fragment36(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file33, 11, 0, 320);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card_header", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "card-header", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Card_header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment36, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card_header",
      options,
      id: create_fragment36.name
    });
  }
  get class() {
    throw new Error("<Card_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var card_header_default = Card_header;

// node_modules/framework7-svelte/components/card.svelte
var file34 = "node_modules/framework7-svelte/components/card.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_25(ctx) {
  let cardheader;
  let current;
  cardheader = new card_header_default({
    props: {
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(cardheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(cardheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const cardheader_changes = {};
      if (dirty[0] & /*$$scope, title*/
      268435457) {
        cardheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardheader.$set(cardheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cardheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(cardheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(151:2) {#if typeof title !== 'undefined' || hasHeaderSlots}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t0_value = plainText(
    /*title*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[26].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      1) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(152:4) <CardHeader>",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let cardcontent;
  let current;
  cardcontent = new card_content_default({
    props: {
      padding: (
        /*padding*/
        ctx[12]
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(cardcontent.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(cardcontent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const cardcontent_changes = {};
      if (dirty[0] & /*padding*/
      4096)
        cardcontent_changes.padding = /*padding*/
        ctx2[12];
      if (dirty[0] & /*$$scope, content*/
      268435458) {
        cardcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardcontent.$set(cardcontent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cardcontent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardcontent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(cardcontent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(157:2) {#if typeof content !== 'undefined' || hasContentSlots}",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let t0_value = plainText(
    /*content*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const content_slot_template = (
    /*#slots*/
    ctx[26].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_content_slot_context
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (content_slot)
        content_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*content*/
      2) && t0_value !== (t0_value = plainText(
        /*content*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (content_slot) {
        if (content_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (content_slot)
        content_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(158:4) <CardContent {padding}>",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let cardfooter;
  let current;
  cardfooter = new card_footer_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(cardfooter.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(cardfooter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const cardfooter_changes = {};
      if (dirty[0] & /*$$scope, footer*/
      268435460) {
        cardfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardfooter.$set(cardfooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cardfooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardfooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(cardfooter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(163:2) {#if typeof footer !== 'undefined' || hasFooterSlots}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let t0_value = plainText(
    /*footer*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[26].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      if (footer_slot) {
        footer_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      4) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(164:4) <CardFooter>",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let div_data_animate_value;
  let div_data_hide_navbar_on_open_value;
  let div_data_hide_toolbar_on_open_value;
  let div_data_hide_statusbar_on_open_value;
  let div_data_swipe_to_close_value;
  let div_data_close_by_backdrop_click_value;
  let div_data_backdrop_value;
  let current;
  let if_block0 = (typeof /*title*/
  ctx[0] !== "undefined" || /*hasHeaderSlots*/
  ctx[16]) && create_if_block_25(ctx);
  let if_block1 = (typeof /*content*/
  ctx[1] !== "undefined" || /*hasContentSlots*/
  ctx[15]) && create_if_block_15(ctx);
  let if_block2 = (typeof /*footer*/
  ctx[2] !== "undefined" || /*hasFooterSlots*/
  ctx[14]) && create_if_block9(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[17]
    ) },
    {
      "data-animate": div_data_animate_value = typeof /*animate*/
      ctx[3] === "undefined" ? (
        /*animate*/
        ctx[3]
      ) : (
        /*animate*/
        ctx[3].toString()
      )
    },
    {
      "data-hide-navbar-on-open": div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/
      ctx[4] === "undefined" ? (
        /*hideNavbarOnOpen*/
        ctx[4]
      ) : (
        /*hideNavbarOnOpen*/
        ctx[4].toString()
      )
    },
    {
      "data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/
      ctx[5] === "undefined" ? (
        /*hideToolbarOnOpen*/
        ctx[5]
      ) : (
        /*hideToolbarOnOpen*/
        ctx[5].toString()
      )
    },
    {
      "data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/
      ctx[6] === "undefined" ? (
        /*hideStatusbarOnOpen*/
        ctx[6]
      ) : (
        /*hideStatusbarOnOpen*/
        ctx[6].toString()
      )
    },
    {
      "data-scrollable-el": (
        /*scrollableEl*/
        ctx[7]
      )
    },
    {
      "data-swipe-to-close": div_data_swipe_to_close_value = typeof /*swipeToClose*/
      ctx[8] === "undefined" ? (
        /*swipeToClose*/
        ctx[8]
      ) : (
        /*swipeToClose*/
        ctx[8].toString()
      )
    },
    {
      "data-close-by-backdrop-click": div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/
      ctx[9] === "undefined" ? (
        /*closeByBackdropClick*/
        ctx[9]
      ) : (
        /*closeByBackdropClick*/
        ctx[9].toString()
      )
    },
    {
      "data-backdrop": div_data_backdrop_value = typeof /*backdrop*/
      ctx[10] === "undefined" ? (
        /*backdrop*/
        ctx[10]
      ) : (
        /*backdrop*/
        ctx[10].toString()
      )
    },
    {
      "data-backdrop-el": (
        /*backdropEl*/
        ctx[11]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[18]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file34, 128, 0, 3408);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_dev(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[27](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*title*/
      ctx2[0] !== "undefined" || /*hasHeaderSlots*/
      ctx2[16]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*title, hasHeaderSlots*/
          65537) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_25(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*content*/
      ctx2[1] !== "undefined" || /*hasContentSlots*/
      ctx2[15]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*content, hasContentSlots*/
          32770) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (typeof /*footer*/
      ctx2[2] !== "undefined" || /*hasFooterSlots*/
      ctx2[14]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*footer, hasFooterSlots*/
          16388) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        131072) && { class: (
          /*classes*/
          ctx2[17]
        ) },
        (!current || dirty[0] & /*animate*/
        8 && div_data_animate_value !== (div_data_animate_value = typeof /*animate*/
        ctx2[3] === "undefined" ? (
          /*animate*/
          ctx2[3]
        ) : (
          /*animate*/
          ctx2[3].toString()
        ))) && { "data-animate": div_data_animate_value },
        (!current || dirty[0] & /*hideNavbarOnOpen*/
        16 && div_data_hide_navbar_on_open_value !== (div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/
        ctx2[4] === "undefined" ? (
          /*hideNavbarOnOpen*/
          ctx2[4]
        ) : (
          /*hideNavbarOnOpen*/
          ctx2[4].toString()
        ))) && {
          "data-hide-navbar-on-open": div_data_hide_navbar_on_open_value
        },
        (!current || dirty[0] & /*hideToolbarOnOpen*/
        32 && div_data_hide_toolbar_on_open_value !== (div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/
        ctx2[5] === "undefined" ? (
          /*hideToolbarOnOpen*/
          ctx2[5]
        ) : (
          /*hideToolbarOnOpen*/
          ctx2[5].toString()
        ))) && {
          "data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value
        },
        (!current || dirty[0] & /*hideStatusbarOnOpen*/
        64 && div_data_hide_statusbar_on_open_value !== (div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/
        ctx2[6] === "undefined" ? (
          /*hideStatusbarOnOpen*/
          ctx2[6]
        ) : (
          /*hideStatusbarOnOpen*/
          ctx2[6].toString()
        ))) && {
          "data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value
        },
        (!current || dirty[0] & /*scrollableEl*/
        128) && {
          "data-scrollable-el": (
            /*scrollableEl*/
            ctx2[7]
          )
        },
        (!current || dirty[0] & /*swipeToClose*/
        256 && div_data_swipe_to_close_value !== (div_data_swipe_to_close_value = typeof /*swipeToClose*/
        ctx2[8] === "undefined" ? (
          /*swipeToClose*/
          ctx2[8]
        ) : (
          /*swipeToClose*/
          ctx2[8].toString()
        ))) && {
          "data-swipe-to-close": div_data_swipe_to_close_value
        },
        (!current || dirty[0] & /*closeByBackdropClick*/
        512 && div_data_close_by_backdrop_click_value !== (div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/
        ctx2[9] === "undefined" ? (
          /*closeByBackdropClick*/
          ctx2[9]
        ) : (
          /*closeByBackdropClick*/
          ctx2[9].toString()
        ))) && {
          "data-close-by-backdrop-click": div_data_close_by_backdrop_click_value
        },
        (!current || dirty[0] & /*backdrop*/
        1024 && div_data_backdrop_value !== (div_data_backdrop_value = typeof /*backdrop*/
        ctx2[10] === "undefined" ? (
          /*backdrop*/
          ctx2[10]
        ) : (
          /*backdrop*/
          ctx2[10].toString()
        ))) && { "data-backdrop": div_data_backdrop_value },
        (!current || dirty[0] & /*backdropEl*/
        2048) && {
          "data-backdrop-el": (
            /*backdropEl*/
            ctx2[11]
          )
        },
        dirty[0] & /*$$restProps*/
        262144 && restProps(
          /*$$restProps*/
          ctx2[18]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[27](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let classes;
  let hasHeaderSlots;
  let hasContentSlots;
  let hasFooterSlots;
  const omit_props_names = [
    "class",
    "title",
    "content",
    "footer",
    "outline",
    "expandable",
    "expandableAnimateWidth",
    "expandableOpened",
    "animate",
    "hideNavbarOnOpen",
    "hideToolbarOnOpen",
    "hideStatusbarOnOpen",
    "scrollableEl",
    "swipeToClose",
    "closeByBackdropClick",
    "backdrop",
    "backdropEl",
    "noShadow",
    "noBorder",
    "padding"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["header", "content", "footer", "default"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { content = void 0 } = $$props;
  let { footer = void 0 } = $$props;
  let { outline = false } = $$props;
  let { expandable = false } = $$props;
  let { expandableAnimateWidth = false } = $$props;
  let { expandableOpened = false } = $$props;
  let { animate = void 0 } = $$props;
  let { hideNavbarOnOpen = void 0 } = $$props;
  let { hideToolbarOnOpen = void 0 } = $$props;
  let { hideStatusbarOnOpen = void 0 } = $$props;
  let { scrollableEl = void 0 } = $$props;
  let { swipeToClose = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { noShadow = false } = $$props;
  let { noBorder = false } = $$props;
  let { padding = true } = $$props;
  let el;
  function open() {
    app.f7.card.open(el);
  }
  function close() {
    app.f7.card.close(el);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (openedPassed) {
      open();
    } else {
      close();
    }
  }
  function onBeforeOpen(cardEl, prevent) {
    if (cardEl !== el)
      return;
    emit("cardBeforeOpen", [el, prevent]);
  }
  function onOpen(cardEl) {
    if (cardEl !== el)
      return;
    emit("cardOpen", [el]);
    $$invalidate(19, expandableOpened = true);
  }
  function onOpened(cardEl, pageEl) {
    if (cardEl !== el)
      return;
    emit("cardOpened", [el, pageEl]);
  }
  function onClose(cardEl) {
    if (cardEl !== el)
      return;
    emit("cardClose", [el]);
  }
  function onClosed(cardEl, pageEl) {
    if (cardEl !== el)
      return;
    emit("cardClosed", [el, pageEl]);
    $$invalidate(19, expandableOpened = false);
  }
  onMount(() => {
    if (!expandable)
      return;
    f7ready(() => {
      app.f7.on("cardBeforeOpen", onBeforeOpen);
      app.f7.on("cardOpen", onOpen);
      app.f7.on("cardOpened", onOpened);
      app.f7.on("cardClose", onClose);
      app.f7.on("cardClosed", onClosed);
      if (expandable && expandableOpened && el) {
        app.f7.card.open(el, false);
      }
    });
  });
  onDestroy(() => {
    if (!expandable)
      return;
    if (!app.f7 || !el)
      return;
    app.f7.off("cardBeforeOpen", onBeforeOpen);
    app.f7.off("cardOpen", onOpen);
    app.f7.off("cardOpened", onOpened);
    app.f7.off("cardClose", onClose);
    app.f7.off("cardClosed", onClosed);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(13, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(20, className = $$new_props.class);
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("content" in $$new_props)
      $$invalidate(1, content = $$new_props.content);
    if ("footer" in $$new_props)
      $$invalidate(2, footer = $$new_props.footer);
    if ("outline" in $$new_props)
      $$invalidate(21, outline = $$new_props.outline);
    if ("expandable" in $$new_props)
      $$invalidate(22, expandable = $$new_props.expandable);
    if ("expandableAnimateWidth" in $$new_props)
      $$invalidate(23, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
    if ("expandableOpened" in $$new_props)
      $$invalidate(19, expandableOpened = $$new_props.expandableOpened);
    if ("animate" in $$new_props)
      $$invalidate(3, animate = $$new_props.animate);
    if ("hideNavbarOnOpen" in $$new_props)
      $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
    if ("hideToolbarOnOpen" in $$new_props)
      $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
    if ("hideStatusbarOnOpen" in $$new_props)
      $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
    if ("scrollableEl" in $$new_props)
      $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
    if ("swipeToClose" in $$new_props)
      $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
    if ("closeByBackdropClick" in $$new_props)
      $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("backdrop" in $$new_props)
      $$invalidate(10, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(11, backdropEl = $$new_props.backdropEl);
    if ("noShadow" in $$new_props)
      $$invalidate(24, noShadow = $$new_props.noShadow);
    if ("noBorder" in $$new_props)
      $$invalidate(25, noBorder = $$new_props.noBorder);
    if ("padding" in $$new_props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    CardHeader: card_header_default,
    CardContent: card_content_default,
    CardFooter: card_footer_default,
    emit,
    className,
    title,
    content,
    footer,
    outline,
    expandable,
    expandableAnimateWidth,
    expandableOpened,
    animate,
    hideNavbarOnOpen,
    hideToolbarOnOpen,
    hideStatusbarOnOpen,
    scrollableEl,
    swipeToClose,
    closeByBackdropClick,
    backdrop,
    backdropEl,
    noShadow,
    noBorder,
    padding,
    el,
    open,
    close,
    initialWatched,
    watchOpened,
    onBeforeOpen,
    onOpen,
    onOpened,
    onClose,
    onClosed,
    hasFooterSlots,
    hasContentSlots,
    hasHeaderSlots,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(20, className = $$new_props.className);
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("content" in $$props)
      $$invalidate(1, content = $$new_props.content);
    if ("footer" in $$props)
      $$invalidate(2, footer = $$new_props.footer);
    if ("outline" in $$props)
      $$invalidate(21, outline = $$new_props.outline);
    if ("expandable" in $$props)
      $$invalidate(22, expandable = $$new_props.expandable);
    if ("expandableAnimateWidth" in $$props)
      $$invalidate(23, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
    if ("expandableOpened" in $$props)
      $$invalidate(19, expandableOpened = $$new_props.expandableOpened);
    if ("animate" in $$props)
      $$invalidate(3, animate = $$new_props.animate);
    if ("hideNavbarOnOpen" in $$props)
      $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
    if ("hideToolbarOnOpen" in $$props)
      $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
    if ("hideStatusbarOnOpen" in $$props)
      $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
    if ("scrollableEl" in $$props)
      $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
    if ("swipeToClose" in $$props)
      $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
    if ("closeByBackdropClick" in $$props)
      $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("backdrop" in $$props)
      $$invalidate(10, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(11, backdropEl = $$new_props.backdropEl);
    if ("noShadow" in $$props)
      $$invalidate(24, noShadow = $$new_props.noShadow);
    if ("noBorder" in $$props)
      $$invalidate(25, noBorder = $$new_props.noBorder);
    if ("padding" in $$props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("el" in $$props)
      $$invalidate(13, el = $$new_props.el);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("hasFooterSlots" in $$props)
      $$invalidate(14, hasFooterSlots = $$new_props.hasFooterSlots);
    if ("hasContentSlots" in $$props)
      $$invalidate(15, hasContentSlots = $$new_props.hasContentSlots);
    if ("hasHeaderSlots" in $$props)
      $$invalidate(16, hasHeaderSlots = $$new_props.hasHeaderSlots);
    if ("classes" in $$props)
      $$invalidate(17, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(17, classes = classNames(
        className,
        "card",
        {
          "card-outline": outline,
          "card-expandable": expandable,
          "card-expandable-animate-width": expandableAnimateWidth,
          "no-shadow": noShadow,
          "no-border": noBorder
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*expandableOpened*/
    524288) {
      $:
        watchOpened(expandableOpened);
    }
  };
  $:
    $$invalidate(16, hasHeaderSlots = $$slots.header);
  $:
    $$invalidate(15, hasContentSlots = $$slots.content);
  $:
    $$invalidate(14, hasFooterSlots = $$slots.footer);
  $$props = exclude_internal_props($$props);
  return [
    title,
    content,
    footer,
    animate,
    hideNavbarOnOpen,
    hideToolbarOnOpen,
    hideStatusbarOnOpen,
    scrollableEl,
    swipeToClose,
    closeByBackdropClick,
    backdrop,
    backdropEl,
    padding,
    el,
    hasFooterSlots,
    hasContentSlots,
    hasHeaderSlots,
    classes,
    $$restProps,
    expandableOpened,
    className,
    outline,
    expandable,
    expandableAnimateWidth,
    noShadow,
    noBorder,
    slots,
    div_binding,
    $$scope
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance30,
      create_fragment37,
      safe_not_equal,
      {
        class: 20,
        title: 0,
        content: 1,
        footer: 2,
        outline: 21,
        expandable: 22,
        expandableAnimateWidth: 23,
        expandableOpened: 19,
        animate: 3,
        hideNavbarOnOpen: 4,
        hideToolbarOnOpen: 5,
        hideStatusbarOnOpen: 6,
        scrollableEl: 7,
        swipeToClose: 8,
        closeByBackdropClick: 9,
        backdrop: 10,
        backdropEl: 11,
        noShadow: 24,
        noBorder: 25,
        padding: 12
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get content() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandableAnimateWidth() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandableAnimateWidth(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandableOpened() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandableOpened(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideNavbarOnOpen() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideNavbarOnOpen(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideToolbarOnOpen() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideToolbarOnOpen(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideStatusbarOnOpen() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideStatusbarOnOpen(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollableEl() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollableEl(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeToClose() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeToClose(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeByBackdropClick() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeByBackdropClick(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noShadow() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noShadow(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noBorder() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noBorder(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var card_default = Card;

// node_modules/framework7-svelte/components/checkbox.svelte
var file35 = "node_modules/framework7-svelte/components/checkbox.svelte";
function create_fragment38(ctx) {
  let label;
  let input;
  let input_value_value;
  let t0;
  let i;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let label_levels = [{ class: (
    /*classes*/
    ctx[6]
  ) }, restProps(
    /*$$restProps*/
    ctx[8]
  )];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign(label_data, label_levels[i2]);
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t0 = space();
      i = element("i");
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.value = input_value_value = typeof /*value*/
      ctx[2] === "undefined" ? "" : (
        /*value*/
        ctx[2]
      );
      input.disabled = /*disabled*/
      ctx[3];
      input.readOnly = /*readonly*/
      ctx[4];
      input.checked = /*checked*/
      ctx[0];
      add_location(input, file35, 48, 2, 1098);
      attr_dev(i, "class", "icon-checkbox");
      add_location(i, file35, 58, 2, 1290);
      set_attributes(label, label_data);
      add_location(label, file35, 47, 0, 1044);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, input);
      ctx[13](input);
      append_dev(label, t0);
      append_dev(label, i);
      append_dev(label, t1);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*onChange*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*value*/
      4 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[2] === "undefined" ? "" : (
        /*value*/
        ctx2[2]
      ))) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*readonly*/
      16) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        256 && restProps(
          /*$$restProps*/
          ctx2[8]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[13](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "checked", "indeterminate", "name", "value", "disabled", "readonly"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { checked = void 0 } = $$props;
  let { indeterminate = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let inputEl;
  function onChange(event) {
    emit("change", [event]);
    $$invalidate(0, checked = event.target.checked);
  }
  onMount(() => {
    if (indeterminate && inputEl) {
      $$invalidate(5, inputEl.indeterminate = true, inputEl);
    }
  });
  afterUpdate(() => {
    if (inputEl) {
      $$invalidate(5, inputEl.indeterminate = indeterminate, inputEl);
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(10, indeterminate = $$new_props.indeterminate);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    afterUpdate,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    emit,
    className,
    checked,
    indeterminate,
    name,
    value,
    disabled,
    readonly,
    inputEl,
    onChange,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(10, indeterminate = $$new_props.indeterminate);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("inputEl" in $$props)
      $$invalidate(5, inputEl = $$new_props.inputEl);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classes = classNames(className, { checkbox: true, disabled }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    name,
    value,
    disabled,
    readonly,
    inputEl,
    classes,
    onChange,
    $$restProps,
    className,
    indeterminate,
    $$scope,
    slots,
    input_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment38, safe_not_equal, {
      class: 9,
      checked: 0,
      indeterminate: 10,
      name: 1,
      value: 2,
      disabled: 3,
      readonly: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment38.name
    });
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var checkbox_default = Checkbox;

// node_modules/framework7-svelte/components/chip.svelte
var file36 = "node_modules/framework7-svelte/components/chip.svelte";
var get_text_slot_changes = (dirty) => ({});
var get_text_slot_context = (ctx) => ({});
var get_media_slot_changes2 = (dirty) => ({});
var get_media_slot_context2 = (ctx) => ({});
function create_if_block_26(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*media*/
    ctx[0]
  ) + "";
  let t1;
  let t2;
  let current;
  let if_block = (
    /*icon*/
    ctx[6] && create_if_block_34(ctx)
  );
  const media_slot_template = (
    /*#slots*/
    ctx[20].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_media_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (media_slot)
        media_slot.c();
      attr_dev(
        div,
        "class",
        /*mediaClasses*/
        ctx[10]
      );
      add_location(div, file36, 70, 4, 1743);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_34(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*media*/
      1) && t1_value !== (t1_value = plainText(
        /*media*/
        ctx2[0]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_media_slot_changes2
            ),
            get_media_slot_context2
          );
        }
      }
      if (!current || dirty & /*mediaClasses*/
      1024) {
        attr_dev(
          div,
          "class",
          /*mediaClasses*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(70:2) {#if media || hasMediaSlots || icon}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[6]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty & /*icon*/
      64)
        useicon_changes.icon = /*icon*/
        ctx2[6];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(72:6) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let t2;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[20].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_text_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "chip-label");
      add_location(div, file36, 79, 4, 1950);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      append_dev(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      2) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_text_slot_changes
            ),
            get_text_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(79:2) {#if text || hasTextSlots || hasDefaultSlots}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let a;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      attr_dev(a, "class", "chip-delete");
      add_location(a, file36, 85, 18, 2078);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*onDeleteClick*/
          ctx[13],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(86:2) {#if deleteable}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let div;
  let t0;
  let t1;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*media*/
    (ctx[0] || /*hasMediaSlots*/
    ctx[9] || /*icon*/
    ctx[6]) && create_if_block_26(ctx)
  );
  let if_block1 = (
    /*text*/
    (ctx[1] || /*hasTextSlots*/
    ctx[8] || /*hasDefaultSlots*/
    ctx[7]) && create_if_block_16(ctx)
  );
  let if_block2 = (
    /*deleteable*/
    ctx[2] && create_if_block10(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[11]
  ) }, restProps(
    /*$$restProps*/
    ctx[14]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      set_attributes(div, div_data);
      add_location(div, file36, 62, 0, 1560);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      ctx[21](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, div, {
            tooltip: (
              /*tooltip*/
              ctx[3]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[4]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*media*/
        ctx2[0] || /*hasMediaSlots*/
        ctx2[9] || /*icon*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*media, hasMediaSlots, icon*/
          577) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_26(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*text*/
        ctx2[1] || /*hasTextSlots*/
        ctx2[8] || /*hasDefaultSlots*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*text, hasTextSlots, hasDefaultSlots*/
          386) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*deleteable*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block10(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2048) && { class: (
          /*classes*/
          ctx2[11]
        ) },
        dirty & /*$$restProps*/
        16384 && restProps(
          /*$$restProps*/
          ctx2[14]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      24)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[3]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[4]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let classes;
  let mediaClasses;
  let hasMediaSlots;
  let hasTextSlots;
  let hasDefaultSlots;
  let icon;
  const omit_props_names = [
    "class",
    "media",
    "text",
    "deleteable",
    "mediaBgColor",
    "mediaTextColor",
    "outline",
    "tooltip",
    "tooltipTrigger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chip", slots, ["media", "text", "default"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { media = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { deleteable = void 0 } = $$props;
  let { mediaBgColor = void 0 } = $$props;
  let { mediaTextColor = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let el;
  function onClick(e) {
    emit("click", [e]);
  }
  function onDeleteClick(e) {
    emit("delete", [e]);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(5, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(15, className = $$new_props.class);
    if ("media" in $$new_props)
      $$invalidate(0, media = $$new_props.media);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("deleteable" in $$new_props)
      $$invalidate(2, deleteable = $$new_props.deleteable);
    if ("mediaBgColor" in $$new_props)
      $$invalidate(16, mediaBgColor = $$new_props.mediaBgColor);
    if ("mediaTextColor" in $$new_props)
      $$invalidate(17, mediaTextColor = $$new_props.mediaTextColor);
    if ("outline" in $$new_props)
      $$invalidate(18, outline = $$new_props.outline);
    if ("tooltip" in $$new_props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    useTooltip,
    useIcon,
    UseIcon: use_icon_default,
    emit,
    className,
    media,
    text: text2,
    deleteable,
    mediaBgColor,
    mediaTextColor,
    outline,
    tooltip,
    tooltipTrigger,
    el,
    onClick,
    onDeleteClick,
    icon,
    hasDefaultSlots,
    hasTextSlots,
    hasMediaSlots,
    mediaClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(15, className = $$new_props.className);
    if ("media" in $$props)
      $$invalidate(0, media = $$new_props.media);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("deleteable" in $$props)
      $$invalidate(2, deleteable = $$new_props.deleteable);
    if ("mediaBgColor" in $$props)
      $$invalidate(16, mediaBgColor = $$new_props.mediaBgColor);
    if ("mediaTextColor" in $$props)
      $$invalidate(17, mediaTextColor = $$new_props.mediaTextColor);
    if ("outline" in $$props)
      $$invalidate(18, outline = $$new_props.outline);
    if ("tooltip" in $$props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("el" in $$props)
      $$invalidate(5, el = $$new_props.el);
    if ("icon" in $$props)
      $$invalidate(6, icon = $$new_props.icon);
    if ("hasDefaultSlots" in $$props)
      $$invalidate(7, hasDefaultSlots = $$new_props.hasDefaultSlots);
    if ("hasTextSlots" in $$props)
      $$invalidate(8, hasTextSlots = $$new_props.hasTextSlots);
    if ("hasMediaSlots" in $$props)
      $$invalidate(9, hasMediaSlots = $$new_props.hasMediaSlots);
    if ("mediaClasses" in $$props)
      $$invalidate(10, mediaClasses = $$new_props.mediaClasses);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(11, classes = classNames(className, "chip", { "chip-outline": outline }, colorClasses($$props)));
    if ($$self.$$.dirty & /*mediaTextColor, mediaBgColor*/
    196608) {
      $:
        $$invalidate(10, mediaClasses = classNames("chip-media", mediaTextColor && `text-color-${mediaTextColor}`, mediaBgColor && `bg-color-${mediaBgColor}`));
    }
    $:
      $$invalidate(6, icon = useIcon($$props));
  };
  $:
    $$invalidate(9, hasMediaSlots = $$slots.media);
  $:
    $$invalidate(8, hasTextSlots = $$slots.text);
  $:
    $$invalidate(7, hasDefaultSlots = $$slots.default);
  $$props = exclude_internal_props($$props);
  return [
    media,
    text2,
    deleteable,
    tooltip,
    tooltipTrigger,
    el,
    icon,
    hasDefaultSlots,
    hasTextSlots,
    hasMediaSlots,
    mediaClasses,
    classes,
    onClick,
    onDeleteClick,
    $$restProps,
    className,
    mediaBgColor,
    mediaTextColor,
    outline,
    $$scope,
    slots,
    div_binding
  ];
}
var Chip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment39, safe_not_equal, {
      class: 15,
      media: 0,
      text: 1,
      deleteable: 2,
      mediaBgColor: 16,
      mediaTextColor: 17,
      outline: 18,
      tooltip: 3,
      tooltipTrigger: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chip",
      options,
      id: create_fragment39.name
    });
  }
  get class() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get media() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set media(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteable() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteable(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaBgColor() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaBgColor(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaTextColor() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaTextColor(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var chip_default = Chip;

// node_modules/framework7-svelte/components/col.svelte
var file37 = "node_modules/framework7-svelte/components/col.svelte";
function create_if_block_27(ctx) {
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*resizable*/
    ctx[1] && /*resizableHandler*/
    ctx[2] && create_if_block_35(ctx)
  );
  let span_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(span, span_data);
      add_location(span, file37, 68, 2, 1813);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_dev(span, t);
      if (if_block)
        if_block.m(span, null);
      ctx[19](span);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*resizable*/
        ctx2[1] && /*resizableHandler*/
        ctx2[2]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[19](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(68:25) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let div;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*resizable*/
    ctx[1] && /*resizableHandler*/
    ctx[2] && create_if_block_17(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file37, 63, 2, 1603);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[18](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*resizable*/
        ctx2[1] && /*resizableHandler*/
        ctx2[2]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[18](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(63:0) {#if tag === 'div'}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "resize-handler");
      add_location(span, file37, 70, 39, 1950);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(71:4) {#if resizable && resizableHandler}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "resize-handler");
      add_location(span, file37, 65, 39, 1739);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(66:4) {#if resizable && resizableHandler}",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block11, create_if_block_27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "div"
    )
      return 0;
    if (
      /*tag*/
      ctx2[0] === "span"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "tag",
    "width",
    "xsmall",
    "small",
    "medium",
    "large",
    "xlarge",
    "resizable",
    "resizableFixed",
    "resizableAbsolute",
    "resizableHandler"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Col", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { tag = "div" } = $$props;
  let { width = "auto" } = $$props;
  let { xsmall = void 0 } = $$props;
  let { small = void 0 } = $$props;
  let { medium = void 0 } = $$props;
  let { large = void 0 } = $$props;
  let { xlarge = void 0 } = $$props;
  let { resizable = false } = $$props;
  let { resizableFixed = false } = $$props;
  let { resizableAbsolute = false } = $$props;
  let { resizableHandler = true } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function onResize(targetEl) {
    if (el !== targetEl)
      return;
    emit("gridResize");
  }
  onMount(() => {
    f7ready(() => {
      app.f7.on("gridResize", onResize);
    });
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    app.f7.off("gridResize", onResize);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("width" in $$new_props)
      $$invalidate(8, width = $$new_props.width);
    if ("xsmall" in $$new_props)
      $$invalidate(9, xsmall = $$new_props.xsmall);
    if ("small" in $$new_props)
      $$invalidate(10, small = $$new_props.small);
    if ("medium" in $$new_props)
      $$invalidate(11, medium = $$new_props.medium);
    if ("large" in $$new_props)
      $$invalidate(12, large = $$new_props.large);
    if ("xlarge" in $$new_props)
      $$invalidate(13, xlarge = $$new_props.xlarge);
    if ("resizable" in $$new_props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("resizableFixed" in $$new_props)
      $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
    if ("resizableAbsolute" in $$new_props)
      $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
    if ("resizableHandler" in $$new_props)
      $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    tag,
    width,
    xsmall,
    small,
    medium,
    large,
    xlarge,
    resizable,
    resizableFixed,
    resizableAbsolute,
    resizableHandler,
    el,
    onClick,
    onResize,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("width" in $$props)
      $$invalidate(8, width = $$new_props.width);
    if ("xsmall" in $$props)
      $$invalidate(9, xsmall = $$new_props.xsmall);
    if ("small" in $$props)
      $$invalidate(10, small = $$new_props.small);
    if ("medium" in $$props)
      $$invalidate(11, medium = $$new_props.medium);
    if ("large" in $$props)
      $$invalidate(12, large = $$new_props.large);
    if ("xlarge" in $$props)
      $$invalidate(13, xlarge = $$new_props.xlarge);
    if ("resizable" in $$props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("resizableFixed" in $$props)
      $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
    if ("resizableAbsolute" in $$props)
      $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
    if ("resizableHandler" in $$props)
      $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classes = classNames(
        className,
        {
          col: width === "auto",
          [`col-${width}`]: width !== "auto",
          [`xsmall-${xsmall}`]: xsmall,
          [`small-${small}`]: small,
          [`medium-${medium}`]: medium,
          [`large-${large}`]: large,
          [`xlarge-${xlarge}`]: xlarge,
          resizable,
          "resizable-fixed": resizableFixed,
          "resizable-absolute": resizableAbsolute
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    tag,
    resizable,
    resizableHandler,
    el,
    classes,
    onClick,
    $$restProps,
    className,
    width,
    xsmall,
    small,
    medium,
    large,
    xlarge,
    resizableFixed,
    resizableAbsolute,
    $$scope,
    slots,
    div_binding,
    span_binding
  ];
}
var Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment40, safe_not_equal, {
      class: 7,
      tag: 0,
      width: 8,
      xsmall: 9,
      small: 10,
      medium: 11,
      large: 12,
      xlarge: 13,
      resizable: 1,
      resizableFixed: 14,
      resizableAbsolute: 15,
      resizableHandler: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Col",
      options,
      id: create_fragment40.name
    });
  }
  get class() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xsmall() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xsmall(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get medium() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set medium(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xlarge() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xlarge(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableFixed() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableFixed(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableAbsolute() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableAbsolute(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableHandler() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableHandler(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var col_default = Col;

// node_modules/framework7-svelte/components/fab-backdrop.svelte
var file38 = "node_modules/framework7-svelte/components/fab-backdrop.svelte";
function create_fragment41(ctx) {
  let div;
  let div_levels = [
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      add_location(div, file38, 12, 0, 276);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*f7Slot*/
        1 && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "f7Slot"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fab_backdrop", slots, []);
  let { class: className = void 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("f7Slot" in $$new_props)
      $$invalidate(0, f7Slot = $$new_props.f7Slot);
  };
  $$self.$capture_state = () => ({
    classNames,
    restProps,
    className,
    f7Slot,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("f7Slot" in $$props)
      $$invalidate(0, f7Slot = $$new_props.f7Slot);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classNames(className, "fab-backdrop"));
    }
  };
  return [f7Slot, classes, $$restProps, className];
}
var Fab_backdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment41, safe_not_equal, { class: 3, f7Slot: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fab_backdrop",
      options,
      id: create_fragment41.name
    });
  }
  get class() {
    throw new Error("<Fab_backdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fab_backdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Fab_backdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Fab_backdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fab_backdrop_default = Fab_backdrop;

// node_modules/framework7-svelte/components/fab-button.svelte
var file39 = "node_modules/framework7-svelte/components/fab-button.svelte";
function create_if_block12(ctx) {
  let span;
  let t_value = plainText(
    /*label*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      attr_dev(span, "class", "fab-label");
      add_location(span, file39, 45, 4, 1066);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      1 && t_value !== (t_value = plainText(
        /*label*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(45:2) {#if typeof label !== 'undefined'}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let a;
  let t;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let if_block = typeof /*label*/
  ctx[0] !== "undefined" && create_if_block12(ctx);
  let a_levels = [
    { target: (
      /*target*/
      ctx[1]
    ) },
    { class: (
      /*classes*/
      ctx[5]
    ) },
    restProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(a, a_data);
      add_location(a, file39, 35, 0, 865);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_dev(a, t);
      if (if_block)
        if_block.m(a, null);
      ctx[12](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[2]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[3]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (typeof /*label*/
      ctx2[0] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*target*/
        2) && { target: (
          /*target*/
          ctx2[1]
        ) },
        (!current || dirty & /*classes*/
        32) && { class: (
          /*classes*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        128 && restProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      12)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[2]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[3]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "fabClose", "label", "target", "tooltip", "tooltipTrigger"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fab_button", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { fabClose = false } = $$props;
  let { label = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(4, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("fabClose" in $$new_props)
      $$invalidate(9, fabClose = $$new_props.fabClose);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("target" in $$new_props)
      $$invalidate(1, target = $$new_props.target);
    if ("tooltip" in $$new_props)
      $$invalidate(2, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(3, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    useTooltip,
    emit,
    className,
    fabClose,
    label,
    target,
    tooltip,
    tooltipTrigger,
    el,
    onClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("fabClose" in $$props)
      $$invalidate(9, fabClose = $$new_props.fabClose);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("target" in $$props)
      $$invalidate(1, target = $$new_props.target);
    if ("tooltip" in $$props)
      $$invalidate(2, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(3, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("el" in $$props)
      $$invalidate(4, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classes = classNames(
        className,
        {
          "fab-close": fabClose,
          "fab-label-button": label
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    target,
    tooltip,
    tooltipTrigger,
    el,
    classes,
    onClick,
    $$restProps,
    className,
    fabClose,
    $$scope,
    slots,
    a_binding
  ];
}
var Fab_button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment42, safe_not_equal, {
      class: 8,
      fabClose: 9,
      label: 0,
      target: 1,
      tooltip: 2,
      tooltipTrigger: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fab_button",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fabClose() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fabClose(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fab_button_default = Fab_button;

// node_modules/framework7-svelte/components/fab-buttons.svelte
var file40 = "node_modules/framework7-svelte/components/fab-buttons.svelte";
function create_fragment43(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file40, 18, 0, 400);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "position"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fab_buttons", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { position = "top" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("position" in $$new_props)
      $$invalidate(3, position = $$new_props.position);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    position,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("position" in $$props)
      $$invalidate(3, position = $$new_props.position);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "fab-buttons", `fab-buttons-${position}`, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, position, $$scope, slots];
}
var Fab_buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment43, safe_not_equal, { class: 2, position: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fab_buttons",
      options,
      id: create_fragment43.name
    });
  }
  get class() {
    throw new Error("<Fab_buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fab_buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Fab_buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Fab_buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fab_buttons_default = Fab_buttons;

// node_modules/framework7-svelte/components/fab.svelte
var file41 = "node_modules/framework7-svelte/components/fab.svelte";
var get_root_slot_changes = (dirty) => ({});
var get_root_slot_context = (ctx) => ({});
var get_link_slot_changes = (dirty) => ({});
var get_link_slot_context = (ctx) => ({});
var get_text_slot_changes2 = (dirty) => ({});
var get_text_slot_context2 = (ctx) => ({});
function create_if_block13(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[18].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_text_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "fab-text");
      add_location(div, file41, 81, 6, 1979);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      ctx[19](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_text_slot_changes2
            ),
            get_text_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(81:4) {#if typeof text !== 'undefined' || hasTextSlots}",
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let div;
  let a;
  let t0;
  let t1;
  let useTooltip_action;
  let t2;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let if_block = (typeof /*text*/
  ctx[2] !== "undefined" || /*hasTextSlots*/
  ctx[7]) && create_if_block13(ctx);
  const link_slot_template = (
    /*#slots*/
    ctx[18].link
  );
  const link_slot = create_slot(
    link_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_link_slot_context
  );
  const root_slot_template = (
    /*#slots*/
    ctx[18].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_root_slot_context
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[10]
    ) },
    { "data-morph-to": (
      /*morphTo*/
      ctx[0]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[5]
    ) },
    restProps(
      /*$$restProps*/
      ctx[13]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (link_slot)
        link_slot.c();
      t2 = space();
      if (root_slot)
        root_slot.c();
      attr_dev(
        a,
        "target",
        /*target*/
        ctx[1]
      );
      attr_dev(
        a,
        "href",
        /*hrefComputed*/
        ctx[11]
      );
      add_location(a, file41, 72, 2, 1767);
      set_attributes(div, div_data);
      add_location(div, file41, 65, 0, 1643);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_dev(a, t0);
      if (if_block)
        if_block.m(a, null);
      append_dev(a, t1);
      if (link_slot) {
        link_slot.m(a, null);
      }
      ctx[20](a);
      append_dev(div, t2);
      if (root_slot) {
        root_slot.m(div, null);
      }
      ctx[21](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[3]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[4]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (typeof /*text*/
      ctx2[2] !== "undefined" || /*hasTextSlots*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*text, hasTextSlots*/
          132) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (link_slot) {
        if (link_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            link_slot,
            link_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              link_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_link_slot_changes
            ),
            get_link_slot_context
          );
        }
      }
      if (!current || dirty & /*target*/
      2) {
        attr_dev(
          a,
          "target",
          /*target*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*hrefComputed*/
      2048) {
        attr_dev(
          a,
          "href",
          /*hrefComputed*/
          ctx2[11]
        );
      }
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      24)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[3]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[4]
          )
        });
      if (root_slot) {
        if (root_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_root_slot_changes
            ),
            get_root_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        (!current || dirty & /*morphTo*/
        1) && { "data-morph-to": (
          /*morphTo*/
          ctx2[0]
        ) },
        (!current || dirty & /*f7Slot*/
        32) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        8192 && restProps(
          /*$$restProps*/
          ctx2[13]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      transition_in(link_slot, local);
      transition_in(root_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      transition_out(link_slot, local);
      transition_out(root_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (link_slot)
        link_slot.d(detaching);
      ctx[20](null);
      if (root_slot)
        root_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let hrefComputed;
  let hasTextSlots;
  let classes;
  const omit_props_names = [
    "class",
    "morphTo",
    "href",
    "target",
    "text",
    "position",
    "tooltip",
    "tooltipTrigger",
    "f7Slot"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fab", slots, ["default", "text", "link", "root"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { morphTo = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { position = "right-bottom" } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let linkEl;
  let textEl;
  function onClick() {
    emit("click");
  }
  onMount(() => {
    f7ready(() => {
      const dom7 = app.f7.$;
      const rootEls = dom7(linkEl).children(".fab-buttons");
      if (rootEls.length) {
        dom7(el).append(rootEls);
      }
    });
  });
  afterUpdate(() => {
    if (!app.f7)
      return;
    const dom7 = app.f7.$;
    const rootEls = dom7(linkEl).children(".fab-buttons");
    if (rootEls.length) {
      dom7(el).append(rootEls);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textEl = $$value;
      $$invalidate(6, textEl);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      linkEl = $$value;
      $$invalidate(9, linkEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(8, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(14, className = $$new_props.class);
    if ("morphTo" in $$new_props)
      $$invalidate(0, morphTo = $$new_props.morphTo);
    if ("href" in $$new_props)
      $$invalidate(15, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(1, target = $$new_props.target);
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("position" in $$new_props)
      $$invalidate(16, position = $$new_props.position);
    if ("tooltip" in $$new_props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("f7Slot" in $$new_props)
      $$invalidate(5, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    afterUpdate,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTooltip,
    emit,
    className,
    morphTo,
    href,
    target,
    text: text2,
    position,
    tooltip,
    tooltipTrigger,
    f7Slot,
    el,
    linkEl,
    textEl,
    onClick,
    hasTextSlots,
    classes,
    hrefComputed
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(14, className = $$new_props.className);
    if ("morphTo" in $$props)
      $$invalidate(0, morphTo = $$new_props.morphTo);
    if ("href" in $$props)
      $$invalidate(15, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(1, target = $$new_props.target);
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("position" in $$props)
      $$invalidate(16, position = $$new_props.position);
    if ("tooltip" in $$props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("f7Slot" in $$props)
      $$invalidate(5, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(8, el = $$new_props.el);
    if ("linkEl" in $$props)
      $$invalidate(9, linkEl = $$new_props.linkEl);
    if ("textEl" in $$props)
      $$invalidate(6, textEl = $$new_props.textEl);
    if ("hasTextSlots" in $$props)
      $$invalidate(7, hasTextSlots = $$new_props.hasTextSlots);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("hrefComputed" in $$props)
      $$invalidate(11, hrefComputed = $$new_props.hrefComputed);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href*/
    32768) {
      $:
        $$invalidate(11, hrefComputed = href === true ? "#" : href || void 0);
    }
    $:
      $$invalidate(10, classes = classNames(
        className,
        "fab",
        `fab-${position}`,
        {
          "fab-morph": morphTo,
          "fab-extended": text2 || hasTextSlots || typeof textEl !== "undefined"
        },
        colorClasses($$props)
      ));
  };
  $:
    $$invalidate(7, hasTextSlots = $$slots.text);
  $$props = exclude_internal_props($$props);
  return [
    morphTo,
    target,
    text2,
    tooltip,
    tooltipTrigger,
    f7Slot,
    textEl,
    hasTextSlots,
    el,
    linkEl,
    classes,
    hrefComputed,
    onClick,
    $$restProps,
    className,
    href,
    position,
    $$scope,
    slots,
    div_binding,
    a_binding,
    div_binding_1
  ];
}
var Fab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment44, safe_not_equal, {
      class: 14,
      morphTo: 0,
      href: 15,
      target: 1,
      text: 2,
      position: 16,
      tooltip: 3,
      tooltipTrigger: 4,
      f7Slot: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fab",
      options,
      id: create_fragment44.name
    });
  }
  get class() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get morphTo() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set morphTo(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fab_default = Fab;

// node_modules/framework7-svelte/components/gauge.svelte
var file42 = "node_modules/framework7-svelte/components/gauge.svelte";
function create_if_block_44(ctx) {
  let path0;
  let path0_d_value;
  let path0_fill_value;
  let path1;
  let path1_d_value;
  let path1_stroke_dasharray_value;
  let path1_stroke_dashoffset_value;
  let path1_fill_value;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "class", "gauge-back-semi");
      attr_dev(path0, "d", path0_d_value = `M${/*size*/
      ctx[0] - /*borderWidth*/
      ctx[4] / 2},${/*size*/
      ctx[0] / 2} a1,1 0 0,0 -${/*size*/
      ctx[0] - /*borderWidth*/
      ctx[4]},0`);
      attr_dev(
        path0,
        "stroke",
        /*borderBgColor*/
        ctx[2]
      );
      attr_dev(
        path0,
        "stroke-width",
        /*borderWidth*/
        ctx[4]
      );
      attr_dev(path0, "fill", path0_fill_value = /*bgColor*/
      ctx[1] || "none");
      add_location(path0, file42, 39, 6, 1168);
      attr_dev(path1, "class", "gauge-front-semi");
      attr_dev(path1, "d", path1_d_value = `M${/*size*/
      ctx[0] - /*borderWidth*/
      ctx[4] / 2},${/*size*/
      ctx[0] / 2} a1,1 0 0,0 -${/*size*/
      ctx[0] - /*borderWidth*/
      ctx[4]},0`);
      attr_dev(
        path1,
        "stroke",
        /*borderColor*/
        ctx[3]
      );
      attr_dev(
        path1,
        "stroke-width",
        /*borderWidth*/
        ctx[4]
      );
      attr_dev(path1, "stroke-dasharray", path1_stroke_dasharray_value = /*length*/
      ctx[15] / 2);
      attr_dev(path1, "stroke-dashoffset", path1_stroke_dashoffset_value = /*length*/
      ctx[15] / 2 * (1 + /*progress*/
      ctx[14]));
      attr_dev(path1, "fill", path1_fill_value = /*borderBgColor*/
      ctx[2] ? "none" : (
        /*bgColor*/
        ctx[1] || "none"
      ));
      add_location(path1, file42, 46, 6, 1409);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path0, anchor);
      insert_dev(target, path1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*size, borderWidth*/
      17 && path0_d_value !== (path0_d_value = `M${/*size*/
      ctx2[0] - /*borderWidth*/
      ctx2[4] / 2},${/*size*/
      ctx2[0] / 2} a1,1 0 0,0 -${/*size*/
      ctx2[0] - /*borderWidth*/
      ctx2[4]},0`)) {
        attr_dev(path0, "d", path0_d_value);
      }
      if (dirty & /*borderBgColor*/
      4) {
        attr_dev(
          path0,
          "stroke",
          /*borderBgColor*/
          ctx2[2]
        );
      }
      if (dirty & /*borderWidth*/
      16) {
        attr_dev(
          path0,
          "stroke-width",
          /*borderWidth*/
          ctx2[4]
        );
      }
      if (dirty & /*bgColor*/
      2 && path0_fill_value !== (path0_fill_value = /*bgColor*/
      ctx2[1] || "none")) {
        attr_dev(path0, "fill", path0_fill_value);
      }
      if (dirty & /*size, borderWidth*/
      17 && path1_d_value !== (path1_d_value = `M${/*size*/
      ctx2[0] - /*borderWidth*/
      ctx2[4] / 2},${/*size*/
      ctx2[0] / 2} a1,1 0 0,0 -${/*size*/
      ctx2[0] - /*borderWidth*/
      ctx2[4]},0`)) {
        attr_dev(path1, "d", path1_d_value);
      }
      if (dirty & /*borderColor*/
      8) {
        attr_dev(
          path1,
          "stroke",
          /*borderColor*/
          ctx2[3]
        );
      }
      if (dirty & /*borderWidth*/
      16) {
        attr_dev(
          path1,
          "stroke-width",
          /*borderWidth*/
          ctx2[4]
        );
      }
      if (dirty & /*length*/
      32768 && path1_stroke_dasharray_value !== (path1_stroke_dasharray_value = /*length*/
      ctx2[15] / 2)) {
        attr_dev(path1, "stroke-dasharray", path1_stroke_dasharray_value);
      }
      if (dirty & /*length, progress*/
      49152 && path1_stroke_dashoffset_value !== (path1_stroke_dashoffset_value = /*length*/
      ctx2[15] / 2 * (1 + /*progress*/
      ctx2[14]))) {
        attr_dev(path1, "stroke-dashoffset", path1_stroke_dashoffset_value);
      }
      if (dirty & /*borderBgColor, bgColor*/
      6 && path1_fill_value !== (path1_fill_value = /*borderBgColor*/
      ctx2[2] ? "none" : (
        /*bgColor*/
        ctx2[1] || "none"
      ))) {
        attr_dev(path1, "fill", path1_fill_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path0);
      if (detaching)
        detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(39:4) {#if semiCircle}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let circle;
  let circle_transform_value;
  let circle_stroke_dashoffset_value;
  let circle_fill_value;
  let circle_cx_value;
  let circle_cy_value;
  let if_block = (
    /*borderBgColor*/
    ctx[2] && create_if_block_36(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      circle = svg_element("circle");
      attr_dev(circle, "class", "gauge-front-circle");
      attr_dev(circle, "transform", circle_transform_value = `rotate(-90 ${/*size*/
      ctx[0] / 2} ${/*size*/
      ctx[0] / 2})`);
      attr_dev(
        circle,
        "stroke",
        /*borderColor*/
        ctx[3]
      );
      attr_dev(
        circle,
        "stroke-width",
        /*borderWidth*/
        ctx[4]
      );
      attr_dev(
        circle,
        "stroke-dasharray",
        /*length*/
        ctx[15]
      );
      attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value = /*length*/
      ctx[15] * (1 - /*progress*/
      ctx[14]));
      attr_dev(circle, "fill", circle_fill_value = /*borderBgColor*/
      ctx[2] ? "none" : (
        /*bgColor*/
        ctx[1] || "none"
      ));
      attr_dev(circle, "cx", circle_cx_value = /*size*/
      ctx[0] / 2);
      attr_dev(circle, "cy", circle_cy_value = /*size*/
      ctx[0] / 2);
      attr_dev(
        circle,
        "r",
        /*radius*/
        ctx[13]
      );
      add_location(circle, file42, 68, 6, 2077);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*borderBgColor*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_36(ctx2);
          if_block.c();
          if_block.m(circle.parentNode, circle);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*size*/
      1 && circle_transform_value !== (circle_transform_value = `rotate(-90 ${/*size*/
      ctx2[0] / 2} ${/*size*/
      ctx2[0] / 2})`)) {
        attr_dev(circle, "transform", circle_transform_value);
      }
      if (dirty & /*borderColor*/
      8) {
        attr_dev(
          circle,
          "stroke",
          /*borderColor*/
          ctx2[3]
        );
      }
      if (dirty & /*borderWidth*/
      16) {
        attr_dev(
          circle,
          "stroke-width",
          /*borderWidth*/
          ctx2[4]
        );
      }
      if (dirty & /*length*/
      32768) {
        attr_dev(
          circle,
          "stroke-dasharray",
          /*length*/
          ctx2[15]
        );
      }
      if (dirty & /*length, progress*/
      49152 && circle_stroke_dashoffset_value !== (circle_stroke_dashoffset_value = /*length*/
      ctx2[15] * (1 - /*progress*/
      ctx2[14]))) {
        attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value);
      }
      if (dirty & /*borderBgColor, bgColor*/
      6 && circle_fill_value !== (circle_fill_value = /*borderBgColor*/
      ctx2[2] ? "none" : (
        /*bgColor*/
        ctx2[1] || "none"
      ))) {
        attr_dev(circle, "fill", circle_fill_value);
      }
      if (dirty & /*size*/
      1 && circle_cx_value !== (circle_cx_value = /*size*/
      ctx2[0] / 2)) {
        attr_dev(circle, "cx", circle_cx_value);
      }
      if (dirty & /*size*/
      1 && circle_cy_value !== (circle_cy_value = /*size*/
      ctx2[0] / 2)) {
        attr_dev(circle, "cy", circle_cy_value);
      }
      if (dirty & /*radius*/
      8192) {
        attr_dev(
          circle,
          "r",
          /*radius*/
          ctx2[13]
        );
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(57:4) {#if !semiCircle}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let circle;
  let circle_fill_value;
  let circle_cx_value;
  let circle_cy_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      attr_dev(circle, "class", "gauge-back-circle");
      attr_dev(
        circle,
        "stroke",
        /*borderBgColor*/
        ctx[2]
      );
      attr_dev(
        circle,
        "stroke-width",
        /*borderWidth*/
        ctx[4]
      );
      attr_dev(circle, "fill", circle_fill_value = /*bgColor*/
      ctx[1] || "none");
      attr_dev(circle, "cx", circle_cx_value = /*size*/
      ctx[0] / 2);
      attr_dev(circle, "cy", circle_cy_value = /*size*/
      ctx[0] / 2);
      attr_dev(
        circle,
        "r",
        /*radius*/
        ctx[13]
      );
      add_location(circle, file42, 58, 8, 1830);
    },
    m: function mount(target, anchor) {
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*borderBgColor*/
      4) {
        attr_dev(
          circle,
          "stroke",
          /*borderBgColor*/
          ctx2[2]
        );
      }
      if (dirty & /*borderWidth*/
      16) {
        attr_dev(
          circle,
          "stroke-width",
          /*borderWidth*/
          ctx2[4]
        );
      }
      if (dirty & /*bgColor*/
      2 && circle_fill_value !== (circle_fill_value = /*bgColor*/
      ctx2[1] || "none")) {
        attr_dev(circle, "fill", circle_fill_value);
      }
      if (dirty & /*size*/
      1 && circle_cx_value !== (circle_cx_value = /*size*/
      ctx2[0] / 2)) {
        attr_dev(circle, "cx", circle_cx_value);
      }
      if (dirty & /*size*/
      1 && circle_cy_value !== (circle_cy_value = /*size*/
      ctx2[0] / 2)) {
        attr_dev(circle, "cy", circle_cy_value);
      }
      if (dirty & /*radius*/
      8192) {
        attr_dev(
          circle,
          "r",
          /*radius*/
          ctx2[13]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(58:6) {#if borderBgColor}",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let text_1;
  let t;
  let text_1_y_value;
  let text_1_dy_value;
  let text_1_dominant_baseline_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t = text(
        /*valueText*/
        ctx[5]
      );
      attr_dev(text_1, "class", "gauge-value-text");
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", text_1_y_value = /*semiCircle*/
      ctx[16] ? "100%" : "50%");
      attr_dev(
        text_1,
        "font-weight",
        /*valueFontWeight*/
        ctx[8]
      );
      attr_dev(
        text_1,
        "font-size",
        /*valueFontSize*/
        ctx[7]
      );
      attr_dev(
        text_1,
        "fill",
        /*valueTextColor*/
        ctx[6]
      );
      attr_dev(text_1, "dy", text_1_dy_value = /*semiCircle*/
      ctx[16] ? (
        /*labelText*/
        ctx[9] ? -/*labelFontSize*/
        ctx[11] - 15 : -5
      ) : 0);
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/
      ctx[16] ? "middle" : null);
      add_location(text_1, file42, 82, 6, 2494);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*valueText*/
      32)
        set_data_dev(
          t,
          /*valueText*/
          ctx2[5]
        );
      if (dirty & /*semiCircle*/
      65536 && text_1_y_value !== (text_1_y_value = /*semiCircle*/
      ctx2[16] ? "100%" : "50%")) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty & /*valueFontWeight*/
      256) {
        attr_dev(
          text_1,
          "font-weight",
          /*valueFontWeight*/
          ctx2[8]
        );
      }
      if (dirty & /*valueFontSize*/
      128) {
        attr_dev(
          text_1,
          "font-size",
          /*valueFontSize*/
          ctx2[7]
        );
      }
      if (dirty & /*valueTextColor*/
      64) {
        attr_dev(
          text_1,
          "fill",
          /*valueTextColor*/
          ctx2[6]
        );
      }
      if (dirty & /*semiCircle, labelText, labelFontSize*/
      68096 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/
      ctx2[16] ? (
        /*labelText*/
        ctx2[9] ? -/*labelFontSize*/
        ctx2[11] - 15 : -5
      ) : 0)) {
        attr_dev(text_1, "dy", text_1_dy_value);
      }
      if (dirty & /*semiCircle*/
      65536 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/
      ctx2[16] ? "middle" : null)) {
        attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(82:4) {#if valueText}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let text_1;
  let t;
  let text_1_y_value;
  let text_1_dy_value;
  let text_1_dominant_baseline_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t = text(
        /*labelText*/
        ctx[9]
      );
      attr_dev(text_1, "class", "gauge-label-text");
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", text_1_y_value = /*semiCircle*/
      ctx[16] ? "100%" : "50%");
      attr_dev(
        text_1,
        "font-weight",
        /*labelFontWeight*/
        ctx[12]
      );
      attr_dev(
        text_1,
        "font-size",
        /*labelFontSize*/
        ctx[11]
      );
      attr_dev(
        text_1,
        "fill",
        /*labelTextColor*/
        ctx[10]
      );
      attr_dev(text_1, "dy", text_1_dy_value = /*semiCircle*/
      ctx[16] ? -5 : (
        /*valueText*/
        ctx[5] ? (
          /*valueFontSize*/
          ctx[7] / 2 + 10
        ) : 0
      ));
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/
      ctx[16] ? "middle" : null);
      add_location(text_1, file42, 97, 6, 2925);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      512)
        set_data_dev(
          t,
          /*labelText*/
          ctx2[9]
        );
      if (dirty & /*semiCircle*/
      65536 && text_1_y_value !== (text_1_y_value = /*semiCircle*/
      ctx2[16] ? "100%" : "50%")) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty & /*labelFontWeight*/
      4096) {
        attr_dev(
          text_1,
          "font-weight",
          /*labelFontWeight*/
          ctx2[12]
        );
      }
      if (dirty & /*labelFontSize*/
      2048) {
        attr_dev(
          text_1,
          "font-size",
          /*labelFontSize*/
          ctx2[11]
        );
      }
      if (dirty & /*labelTextColor*/
      1024) {
        attr_dev(
          text_1,
          "fill",
          /*labelTextColor*/
          ctx2[10]
        );
      }
      if (dirty & /*semiCircle, valueText, valueFontSize*/
      65696 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/
      ctx2[16] ? -5 : (
        /*valueText*/
        ctx2[5] ? (
          /*valueFontSize*/
          ctx2[7] / 2 + 10
        ) : 0
      ))) {
        attr_dev(text_1, "dy", text_1_dy_value);
      }
      if (dirty & /*semiCircle*/
      65536 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/
      ctx2[16] ? "middle" : null)) {
        attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(97:4) {#if labelText}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let div;
  let svg;
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block2_anchor;
  let svg_width_value;
  let svg_height_value;
  let svg_viewBox_value;
  let if_block0 = (
    /*semiCircle*/
    ctx[16] && create_if_block_44(ctx)
  );
  let if_block1 = !/*semiCircle*/
  ctx[16] && create_if_block_28(ctx);
  let if_block2 = (
    /*valueText*/
    ctx[5] && create_if_block_18(ctx)
  );
  let if_block3 = (
    /*labelText*/
    ctx[9] && create_if_block14(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[17]
  ) }, restProps(
    /*$$restProps*/
    ctx[18]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      attr_dev(svg, "class", "gauge-svg");
      attr_dev(svg, "width", svg_width_value = `${/*size*/
      ctx[0]}px`);
      attr_dev(svg, "height", svg_height_value = `${/*semiCircle*/
      ctx[16] ? (
        /*size*/
        ctx[0] / 2
      ) : (
        /*size*/
        ctx[0]
      )}px`);
      attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*size*/
      ctx[0]} ${/*semiCircle*/
      ctx[16] ? (
        /*size*/
        ctx[0] / 2
      ) : (
        /*size*/
        ctx[0]
      )}`);
      add_location(svg, file42, 32, 2, 977);
      set_attributes(div, div_data);
      add_location(div, file42, 31, 0, 925);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      if (if_block0)
        if_block0.m(svg, null);
      append_dev(svg, if_block0_anchor);
      if (if_block1)
        if_block1.m(svg, null);
      append_dev(svg, if_block1_anchor);
      if (if_block2)
        if_block2.m(svg, null);
      append_dev(svg, if_block2_anchor);
      if (if_block3)
        if_block3.m(svg, null);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*semiCircle*/
        ctx2[16]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_44(ctx2);
          if_block0.c();
          if_block0.m(svg, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*semiCircle*/
      ctx2[16]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_28(ctx2);
          if_block1.c();
          if_block1.m(svg, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*valueText*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_18(ctx2);
          if_block2.c();
          if_block2.m(svg, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*labelText*/
        ctx2[9]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block14(ctx2);
          if_block3.c();
          if_block3.m(svg, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty & /*size*/
      1 && svg_width_value !== (svg_width_value = `${/*size*/
      ctx2[0]}px`)) {
        attr_dev(svg, "width", svg_width_value);
      }
      if (dirty & /*semiCircle, size*/
      65537 && svg_height_value !== (svg_height_value = `${/*semiCircle*/
      ctx2[16] ? (
        /*size*/
        ctx2[0] / 2
      ) : (
        /*size*/
        ctx2[0]
      )}px`)) {
        attr_dev(svg, "height", svg_height_value);
      }
      if (dirty & /*size, semiCircle*/
      65537 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*size*/
      ctx2[0]} ${/*semiCircle*/
      ctx2[16] ? (
        /*size*/
        ctx2[0] / 2
      ) : (
        /*size*/
        ctx2[0]
      )}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*classes*/
        131072 && { class: (
          /*classes*/
          ctx2[17]
        ) },
        dirty & /*$$restProps*/
        262144 && restProps(
          /*$$restProps*/
          ctx2[18]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let classes;
  let semiCircle;
  let radius;
  let length;
  let progress;
  const omit_props_names = [
    "class",
    "type",
    "value",
    "size",
    "bgColor",
    "borderBgColor",
    "borderColor",
    "borderWidth",
    "valueText",
    "valueTextColor",
    "valueFontSize",
    "valueFontWeight",
    "labelText",
    "labelTextColor",
    "labelFontSize",
    "labelFontWeight"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gauge", slots, []);
  let { class: className = void 0 } = $$props;
  let { type = "circle" } = $$props;
  let { value = 0 } = $$props;
  let { size = 200 } = $$props;
  let { bgColor = "transparent" } = $$props;
  let { borderBgColor = "#eeeeee" } = $$props;
  let { borderColor = "#000000" } = $$props;
  let { borderWidth = 10 } = $$props;
  let { valueText = void 0 } = $$props;
  let { valueTextColor = "#000000" } = $$props;
  let { valueFontSize = 31 } = $$props;
  let { valueFontWeight = 500 } = $$props;
  let { labelText = void 0 } = $$props;
  let { labelTextColor = "#888888" } = $$props;
  let { labelFontSize = 14 } = $$props;
  let { labelFontWeight = 400 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(19, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(20, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(21, value = $$new_props.value);
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("bgColor" in $$new_props)
      $$invalidate(1, bgColor = $$new_props.bgColor);
    if ("borderBgColor" in $$new_props)
      $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
    if ("borderColor" in $$new_props)
      $$invalidate(3, borderColor = $$new_props.borderColor);
    if ("borderWidth" in $$new_props)
      $$invalidate(4, borderWidth = $$new_props.borderWidth);
    if ("valueText" in $$new_props)
      $$invalidate(5, valueText = $$new_props.valueText);
    if ("valueTextColor" in $$new_props)
      $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
    if ("valueFontSize" in $$new_props)
      $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
    if ("valueFontWeight" in $$new_props)
      $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
    if ("labelText" in $$new_props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("labelTextColor" in $$new_props)
      $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
    if ("labelFontSize" in $$new_props)
      $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
    if ("labelFontWeight" in $$new_props)
      $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
  };
  $$self.$capture_state = () => ({
    classNames,
    restProps,
    className,
    type,
    value,
    size,
    bgColor,
    borderBgColor,
    borderColor,
    borderWidth,
    valueText,
    valueTextColor,
    valueFontSize,
    valueFontWeight,
    labelText,
    labelTextColor,
    labelFontSize,
    labelFontWeight,
    progress,
    radius,
    length,
    semiCircle,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(19, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(20, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(21, value = $$new_props.value);
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("bgColor" in $$props)
      $$invalidate(1, bgColor = $$new_props.bgColor);
    if ("borderBgColor" in $$props)
      $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
    if ("borderColor" in $$props)
      $$invalidate(3, borderColor = $$new_props.borderColor);
    if ("borderWidth" in $$props)
      $$invalidate(4, borderWidth = $$new_props.borderWidth);
    if ("valueText" in $$props)
      $$invalidate(5, valueText = $$new_props.valueText);
    if ("valueTextColor" in $$props)
      $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
    if ("valueFontSize" in $$props)
      $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
    if ("valueFontWeight" in $$props)
      $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
    if ("labelText" in $$props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("labelTextColor" in $$props)
      $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
    if ("labelFontSize" in $$props)
      $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
    if ("labelFontWeight" in $$props)
      $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
    if ("progress" in $$props)
      $$invalidate(14, progress = $$new_props.progress);
    if ("radius" in $$props)
      $$invalidate(13, radius = $$new_props.radius);
    if ("length" in $$props)
      $$invalidate(15, length = $$new_props.length);
    if ("semiCircle" in $$props)
      $$invalidate(16, semiCircle = $$new_props.semiCircle);
    if ("classes" in $$props)
      $$invalidate(17, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    524288) {
      $:
        $$invalidate(17, classes = classNames(className, "gauge"));
    }
    if ($$self.$$.dirty & /*type*/
    1048576) {
      $:
        $$invalidate(16, semiCircle = type === "semicircle");
    }
    if ($$self.$$.dirty & /*size, borderWidth*/
    17) {
      $:
        $$invalidate(13, radius = size / 2 - borderWidth / 2);
    }
    if ($$self.$$.dirty & /*radius*/
    8192) {
      $:
        $$invalidate(15, length = 2 * Math.PI * radius);
    }
    if ($$self.$$.dirty & /*value*/
    2097152) {
      $:
        $$invalidate(14, progress = Math.max(Math.min(value, 1), 0));
    }
  };
  return [
    size,
    bgColor,
    borderBgColor,
    borderColor,
    borderWidth,
    valueText,
    valueTextColor,
    valueFontSize,
    valueFontWeight,
    labelText,
    labelTextColor,
    labelFontSize,
    labelFontWeight,
    radius,
    progress,
    length,
    semiCircle,
    classes,
    $$restProps,
    className,
    type,
    value
  ];
}
var Gauge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment45, safe_not_equal, {
      class: 19,
      type: 20,
      value: 21,
      size: 0,
      bgColor: 1,
      borderBgColor: 2,
      borderColor: 3,
      borderWidth: 4,
      valueText: 5,
      valueTextColor: 6,
      valueFontSize: 7,
      valueFontWeight: 8,
      labelText: 9,
      labelTextColor: 10,
      labelFontSize: 11,
      labelFontWeight: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gauge",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderBgColor() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderBgColor(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueText() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueText(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueTextColor() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueTextColor(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFontSize() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFontSize(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFontWeight() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFontWeight(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelTextColor() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelTextColor(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontSize() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontSize(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontWeight() {
    throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontWeight(value) {
    throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var gauge_default = Gauge;

// node_modules/framework7-svelte/components/toggle.svelte
var file43 = "node_modules/framework7-svelte/components/toggle.svelte";
function create_fragment46(ctx) {
  let label;
  let input;
  let input_value_value;
  let t;
  let span;
  let useTooltip_action;
  let mounted;
  let dispose;
  let label_levels = [{ class: (
    /*classes*/
    ctx[9]
  ) }, restProps(
    /*$$restProps*/
    ctx[11]
  )];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      span = element("span");
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[3]
      );
      input.disabled = /*disabled*/
      ctx[1];
      input.readOnly = /*readonly*/
      ctx[2];
      input.checked = /*checked*/
      ctx[0];
      input.value = input_value_value = typeof /*value*/
      ctx[4] === "undefined" ? "" : (
        /*value*/
        ctx[4]
      );
      add_location(input, file43, 85, 2, 1840);
      attr_dev(span, "class", "toggle-icon");
      add_location(span, file43, 95, 2, 2032);
      set_attributes(label, label_data);
      add_location(label, file43, 79, 0, 1717);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, input);
      ctx[15](input);
      append_dev(label, t);
      append_dev(label, span);
      ctx[16](label);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, label, {
            tooltip: (
              /*tooltip*/
              ctx[5]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[6]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*name*/
      8) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled*/
      2) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (dirty & /*readonly*/
      4) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[2]
        );
      }
      if (dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      16 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[4] === "undefined" ? "" : (
        /*value*/
        ctx2[4]
      ))) {
        prop_dev(input, "value", input_value_value);
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & /*classes*/
        512 && { class: (
          /*classes*/
          ctx2[9]
        ) },
        dirty & /*$$restProps*/
        2048 && restProps(
          /*$$restProps*/
          ctx2[11]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      96)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[5]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[6]
          )
        });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[15](null);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_18($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "init",
    "checked",
    "disabled",
    "readonly",
    "name",
    "value",
    "tooltip",
    "tooltipTrigger",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, []);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { checked = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let el;
  let inputEl;
  let f7Toggle;
  function instance87() {
    return f7Toggle;
  }
  let initialWatched = false;
  function watchChecked(isChecked) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Toggle)
      return;
    f7Toggle.checked = isChecked;
  }
  function onChange(event) {
    emit("change", [event]);
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      f7Toggle = app.f7.toggle.create({
        el,
        on: {
          change(toggle) {
            emit("toggleChange", [toggle.checked]);
            $$invalidate(0, checked = toggle.checked);
          }
        }
      });
    });
  });
  onDestroy(() => {
    if (f7Toggle && f7Toggle.destroy && f7Toggle.$el) {
      f7Toggle.destroy();
      f7Toggle = null;
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(8, inputEl);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("init" in $$new_props)
      $$invalidate(13, init2 = $$new_props.init);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(2, readonly = $$new_props.readonly);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("tooltip" in $$new_props)
      $$invalidate(5, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(6, tooltipTrigger = $$new_props.tooltipTrigger);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTooltip,
    emit,
    className,
    init: init2,
    checked,
    disabled,
    readonly,
    name,
    value,
    tooltip,
    tooltipTrigger,
    el,
    inputEl,
    f7Toggle,
    instance: instance87,
    initialWatched,
    watchChecked,
    onChange,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("init" in $$props)
      $$invalidate(13, init2 = $$new_props.init);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(2, readonly = $$new_props.readonly);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("tooltip" in $$props)
      $$invalidate(5, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(6, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("el" in $$props)
      $$invalidate(7, el = $$new_props.el);
    if ("inputEl" in $$props)
      $$invalidate(8, inputEl = $$new_props.inputEl);
    if ("f7Toggle" in $$props)
      f7Toggle = $$new_props.f7Toggle;
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(9, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classes = classNames("toggle", className, { disabled }, colorClasses($$props)));
    if ($$self.$$.dirty & /*checked*/
    1) {
      $:
        watchChecked(checked);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    disabled,
    readonly,
    name,
    value,
    tooltip,
    tooltipTrigger,
    el,
    inputEl,
    classes,
    onChange,
    $$restProps,
    className,
    init2,
    instance87,
    input_binding,
    label_binding
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_18, create_fragment46, safe_not_equal, {
      class: 12,
      init: 13,
      checked: 0,
      disabled: 1,
      readonly: 2,
      name: 3,
      value: 4,
      tooltip: 5,
      tooltipTrigger: 6,
      instance: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[14];
  }
  set instance(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var toggle_default = Toggle;

// node_modules/framework7-svelte/components/range.svelte
var file44 = "node_modules/framework7-svelte/components/range.svelte";
var get_default_slot_changes8 = (dirty) => ({ range: dirty[0] & /*f7Range*/
16 });
var get_default_slot_context8 = (ctx) => ({ range: (
  /*f7Range*/
  ctx[4]
) });
function create_if_block15(ctx) {
  let input_1;
  const block = {
    c: function create() {
      input_1 = element("input");
      attr_dev(input_1, "type", "range");
      attr_dev(
        input_1,
        "name",
        /*name*/
        ctx[0]
      );
      attr_dev(
        input_1,
        "id",
        /*inputId*/
        ctx[2]
      );
      add_location(input_1, file44, 103, 13, 2480);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      1) {
        attr_dev(
          input_1,
          "name",
          /*name*/
          ctx2[0]
        );
      }
      if (dirty[0] & /*inputId*/
      4) {
        attr_dev(
          input_1,
          "id",
          /*inputId*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(104:2) {#if input}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*input*/
    ctx[1] && create_if_block15(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_default_slot_context8
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[5]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file44, 102, 0, 2402);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[28](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*input*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Range*/
        67108880)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        32) && { class: (
          /*classes*/
          ctx2[5]
        ) },
        dirty[0] & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[28](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_19($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "init",
    "value",
    "min",
    "max",
    "step",
    "label",
    "dual",
    "vertical",
    "verticalReversed",
    "draggableBar",
    "formatLabel",
    "scale",
    "scaleSteps",
    "scaleSubSteps",
    "formatScaleLabel",
    "limitKnobPosition",
    "name",
    "input",
    "inputId",
    "disabled",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Range", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { label = false } = $$props;
  let { dual = false } = $$props;
  let { vertical = false } = $$props;
  let { verticalReversed = false } = $$props;
  let { draggableBar = true } = $$props;
  let { formatLabel = void 0 } = $$props;
  let { scale = false } = $$props;
  let { scaleSteps = 5 } = $$props;
  let { scaleSubSteps = 0 } = $$props;
  let { formatScaleLabel = void 0 } = $$props;
  let { limitKnobPosition = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { input = false } = $$props;
  let { inputId = void 0 } = $$props;
  let { disabled = false } = $$props;
  let el;
  let f7Range;
  function instance87() {
    return f7Range;
  }
  function watchValue(newValue) {
    if (!f7Range)
      return;
    f7Range.setValue(newValue);
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      $$invalidate(4, f7Range = app.f7.range.create(noUndefinedProps({
        el,
        value,
        min,
        max,
        step,
        label,
        dual,
        draggableBar,
        vertical,
        verticalReversed,
        formatLabel,
        scale,
        scaleSteps,
        scaleSubSteps,
        formatScaleLabel,
        limitKnobPosition,
        on: {
          change(range, val) {
            emit("rangeChange", [val]);
          },
          changed(range, val) {
            emit("rangeChanged", [val]);
            $$invalidate(7, value = val);
          }
        }
      })));
    });
  });
  onDestroy(() => {
    if (f7Range && f7Range.destroy) {
      f7Range.destroy();
      $$invalidate(4, f7Range = null);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("init" in $$new_props)
      $$invalidate(9, init2 = $$new_props.init);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(10, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(11, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(12, step = $$new_props.step);
    if ("label" in $$new_props)
      $$invalidate(13, label = $$new_props.label);
    if ("dual" in $$new_props)
      $$invalidate(14, dual = $$new_props.dual);
    if ("vertical" in $$new_props)
      $$invalidate(15, vertical = $$new_props.vertical);
    if ("verticalReversed" in $$new_props)
      $$invalidate(16, verticalReversed = $$new_props.verticalReversed);
    if ("draggableBar" in $$new_props)
      $$invalidate(17, draggableBar = $$new_props.draggableBar);
    if ("formatLabel" in $$new_props)
      $$invalidate(18, formatLabel = $$new_props.formatLabel);
    if ("scale" in $$new_props)
      $$invalidate(19, scale = $$new_props.scale);
    if ("scaleSteps" in $$new_props)
      $$invalidate(20, scaleSteps = $$new_props.scaleSteps);
    if ("scaleSubSteps" in $$new_props)
      $$invalidate(21, scaleSubSteps = $$new_props.scaleSubSteps);
    if ("formatScaleLabel" in $$new_props)
      $$invalidate(22, formatScaleLabel = $$new_props.formatScaleLabel);
    if ("limitKnobPosition" in $$new_props)
      $$invalidate(23, limitKnobPosition = $$new_props.limitKnobPosition);
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("input" in $$new_props)
      $$invalidate(1, input = $$new_props.input);
    if ("inputId" in $$new_props)
      $$invalidate(2, inputId = $$new_props.inputId);
    if ("disabled" in $$new_props)
      $$invalidate(24, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    init: init2,
    value,
    min,
    max,
    step,
    label,
    dual,
    vertical,
    verticalReversed,
    draggableBar,
    formatLabel,
    scale,
    scaleSteps,
    scaleSubSteps,
    formatScaleLabel,
    limitKnobPosition,
    name,
    input,
    inputId,
    disabled,
    el,
    f7Range,
    instance: instance87,
    watchValue,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("init" in $$props)
      $$invalidate(9, init2 = $$new_props.init);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(10, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(11, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(12, step = $$new_props.step);
    if ("label" in $$props)
      $$invalidate(13, label = $$new_props.label);
    if ("dual" in $$props)
      $$invalidate(14, dual = $$new_props.dual);
    if ("vertical" in $$props)
      $$invalidate(15, vertical = $$new_props.vertical);
    if ("verticalReversed" in $$props)
      $$invalidate(16, verticalReversed = $$new_props.verticalReversed);
    if ("draggableBar" in $$props)
      $$invalidate(17, draggableBar = $$new_props.draggableBar);
    if ("formatLabel" in $$props)
      $$invalidate(18, formatLabel = $$new_props.formatLabel);
    if ("scale" in $$props)
      $$invalidate(19, scale = $$new_props.scale);
    if ("scaleSteps" in $$props)
      $$invalidate(20, scaleSteps = $$new_props.scaleSteps);
    if ("scaleSubSteps" in $$props)
      $$invalidate(21, scaleSubSteps = $$new_props.scaleSubSteps);
    if ("formatScaleLabel" in $$props)
      $$invalidate(22, formatScaleLabel = $$new_props.formatScaleLabel);
    if ("limitKnobPosition" in $$props)
      $$invalidate(23, limitKnobPosition = $$new_props.limitKnobPosition);
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
    if ("input" in $$props)
      $$invalidate(1, input = $$new_props.input);
    if ("inputId" in $$props)
      $$invalidate(2, inputId = $$new_props.inputId);
    if ("disabled" in $$props)
      $$invalidate(24, disabled = $$new_props.disabled);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("f7Range" in $$props)
      $$invalidate(4, f7Range = $$new_props.f7Range);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classes = classNames(
        className,
        "range-slider",
        {
          "range-slider-horizontal": !vertical,
          "range-slider-vertical": vertical,
          "range-slider-vertical-reversed": vertical && verticalReversed,
          disabled
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*value*/
    128) {
      $:
        watchValue(value);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    input,
    inputId,
    el,
    f7Range,
    classes,
    $$restProps,
    value,
    className,
    init2,
    min,
    max,
    step,
    label,
    dual,
    vertical,
    verticalReversed,
    draggableBar,
    formatLabel,
    scale,
    scaleSteps,
    scaleSubSteps,
    formatScaleLabel,
    limitKnobPosition,
    disabled,
    instance87,
    $$scope,
    slots,
    div_binding
  ];
}
var Range = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_19,
      create_fragment47,
      safe_not_equal,
      {
        class: 8,
        init: 9,
        value: 7,
        min: 10,
        max: 11,
        step: 12,
        label: 13,
        dual: 14,
        vertical: 15,
        verticalReversed: 16,
        draggableBar: 17,
        formatLabel: 18,
        scale: 19,
        scaleSteps: 20,
        scaleSubSteps: 21,
        formatScaleLabel: 22,
        limitKnobPosition: 23,
        name: 0,
        input: 1,
        inputId: 2,
        disabled: 24,
        instance: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range",
      options,
      id: create_fragment47.name
    });
  }
  get class() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dual() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dual(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get verticalReversed() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set verticalReversed(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggableBar() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggableBar(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatLabel() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatLabel(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleSteps() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleSteps(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleSubSteps() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleSubSteps(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatScaleLabel() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatScaleLabel(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limitKnobPosition() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limitKnobPosition(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[25];
  }
  set instance(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var range_default = Range;

// node_modules/framework7-svelte/components/text-editor.svelte
var file45 = "node_modules/framework7-svelte/components/text-editor.svelte";
var get_root_slot_changes2 = (dirty) => ({
  textEditor: dirty[0] & /*f7TextEditor*/
  2
});
var get_root_slot_context2 = (ctx) => ({ textEditor: (
  /*f7TextEditor*/
  ctx[1]
) });
var get_root_end_slot_changes = (dirty) => ({
  textEditor: dirty[0] & /*f7TextEditor*/
  2
});
var get_root_end_slot_context = (ctx) => ({ textEditor: (
  /*f7TextEditor*/
  ctx[1]
) });
var get_default_slot_changes9 = (dirty) => ({
  textEditor: dirty[0] & /*f7TextEditor*/
  2
});
var get_default_slot_context9 = (ctx) => ({ textEditor: (
  /*f7TextEditor*/
  ctx[1]
) });
var get_root_start_slot_changes = (dirty) => ({
  textEditor: dirty[0] & /*f7TextEditor*/
  2
});
var get_root_start_slot_context = (ctx) => ({ textEditor: (
  /*f7TextEditor*/
  ctx[1]
) });
function create_fragment48(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let current;
  const root_start_slot_template = (
    /*#slots*/
    ctx[17]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_root_start_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context9
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[17]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_root_end_slot_context
  );
  const root_slot_template = (
    /*#slots*/
    ctx[17].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_root_slot_context2
  );
  let div1_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (root_start_slot)
        root_start_slot.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (root_end_slot)
        root_end_slot.c();
      t2 = space();
      if (root_slot)
        root_slot.c();
      attr_dev(div0, "class", "text-editor-content");
      attr_dev(div0, "contenteditable", "");
      add_location(div0, file45, 120, 2, 2996);
      set_attributes(div1, div1_data);
      add_location(div1, file45, 118, 0, 2874);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (root_start_slot) {
        root_start_slot.m(div1, null);
      }
      append_dev(div1, t0);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_dev(div1, t1);
      if (root_end_slot) {
        root_end_slot.m(div1, null);
      }
      append_dev(div1, t2);
      if (root_slot) {
        root_slot.m(div1, null);
      }
      ctx[18](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/
        65538)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_root_start_slot_changes
            ),
            get_root_start_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/
        65538)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/
        65538)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_root_end_slot_changes
            ),
            get_root_end_slot_context
          );
        }
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/
        65538)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_root_slot_changes2
            ),
            get_root_slot_context2
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty[0] & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(root_start_slot, local);
      transition_in(default_slot, local);
      transition_in(root_end_slot, local);
      transition_in(root_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(root_start_slot, local);
      transition_out(default_slot, local);
      transition_out(root_end_slot, local);
      transition_out(root_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (root_start_slot)
        root_start_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (root_end_slot)
        root_end_slot.d(detaching);
      if (root_slot)
        root_slot.d(detaching);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_110($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "mode",
    "value",
    "buttons",
    "customButtons",
    "dividers",
    "imageUrlText",
    "linkUrlText",
    "placeholder",
    "clearFormattingOnPaste",
    "resizable",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text_editor", slots, ["root-start", "default", "root-end", "root"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { mode = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { buttons = void 0 } = $$props;
  let { customButtons = void 0 } = $$props;
  let { dividers = void 0 } = $$props;
  let { imageUrlText = void 0 } = $$props;
  let { linkUrlText = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { clearFormattingOnPaste = void 0 } = $$props;
  let { resizable = false } = $$props;
  let el;
  let f7TextEditor;
  function instance87() {
    return f7TextEditor;
  }
  function watchValue(newValue) {
    if (f7TextEditor) {
      f7TextEditor.setValue(newValue);
    }
  }
  function onChange(editor, editorValue) {
    emit("textEditorChange", [editorValue]);
  }
  function onInput(editor, editorValue) {
    emit("textEditorInput", [editorValue]);
  }
  function onFocus() {
    emit("textEditorFocus");
  }
  function onBlur() {
    emit("textEditorBlur");
  }
  function onButtonClick(editor, button) {
    emit("textEditorButtonClick", [button]);
  }
  function onKeyboardOpen() {
    emit("textEditorKeyboardOpen");
  }
  function onKeyboardClose() {
    emit("textEditorKeyboardClose");
  }
  function onPopoverOpen() {
    emit("textEditorPopoverOpen");
  }
  function onPopoverClose() {
    emit("textEditorPopoverClose");
  }
  const onInsertLink = (editor, url) => {
    emit("textEditorInsertLink", [url]);
  };
  const onInsertImage = (editor, url) => {
    emit("textEditorInsertImage", [url]);
  };
  onMount(() => {
    const params = noUndefinedProps({
      el,
      mode,
      value,
      buttons,
      customButtons,
      dividers,
      imageUrlText,
      linkUrlText,
      placeholder,
      clearFormattingOnPaste,
      on: {
        change: onChange,
        input: onInput,
        focus: onFocus,
        blur: onBlur,
        buttonClick: onButtonClick,
        keyboardOpen: onKeyboardOpen,
        keyboardClose: onKeyboardClose,
        popoverOpen: onPopoverOpen,
        popoverClose: onPopoverClose,
        insertLink: onInsertLink,
        insertImage: onInsertImage
      }
    });
    f7ready(() => {
      $$invalidate(1, f7TextEditor = app.f7.textEditor.create(params));
    });
  });
  onDestroy(() => {
    if (f7TextEditor && f7TextEditor.destroy) {
      f7TextEditor.destroy();
      $$invalidate(1, f7TextEditor = null);
    }
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("mode" in $$new_props)
      $$invalidate(5, mode = $$new_props.mode);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("buttons" in $$new_props)
      $$invalidate(7, buttons = $$new_props.buttons);
    if ("customButtons" in $$new_props)
      $$invalidate(8, customButtons = $$new_props.customButtons);
    if ("dividers" in $$new_props)
      $$invalidate(9, dividers = $$new_props.dividers);
    if ("imageUrlText" in $$new_props)
      $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    if ("linkUrlText" in $$new_props)
      $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    if ("placeholder" in $$new_props)
      $$invalidate(12, placeholder = $$new_props.placeholder);
    if ("clearFormattingOnPaste" in $$new_props)
      $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    if ("resizable" in $$new_props)
      $$invalidate(14, resizable = $$new_props.resizable);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    mode,
    value,
    buttons,
    customButtons,
    dividers,
    imageUrlText,
    linkUrlText,
    placeholder,
    clearFormattingOnPaste,
    resizable,
    el,
    f7TextEditor,
    instance: instance87,
    watchValue,
    onChange,
    onInput,
    onFocus,
    onBlur,
    onButtonClick,
    onKeyboardOpen,
    onKeyboardClose,
    onPopoverOpen,
    onPopoverClose,
    onInsertLink,
    onInsertImage,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("mode" in $$props)
      $$invalidate(5, mode = $$new_props.mode);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("buttons" in $$props)
      $$invalidate(7, buttons = $$new_props.buttons);
    if ("customButtons" in $$props)
      $$invalidate(8, customButtons = $$new_props.customButtons);
    if ("dividers" in $$props)
      $$invalidate(9, dividers = $$new_props.dividers);
    if ("imageUrlText" in $$props)
      $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    if ("linkUrlText" in $$props)
      $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    if ("placeholder" in $$props)
      $$invalidate(12, placeholder = $$new_props.placeholder);
    if ("clearFormattingOnPaste" in $$props)
      $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    if ("resizable" in $$props)
      $$invalidate(14, resizable = $$new_props.resizable);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("f7TextEditor" in $$props)
      $$invalidate(1, f7TextEditor = $$new_props.f7TextEditor);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "text-editor", resizable && "text-editor-resizable", colorClasses($$props)));
    if ($$self.$$.dirty[0] & /*value*/
    64) {
      $:
        watchValue(value);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    el,
    f7TextEditor,
    classes,
    $$restProps,
    className,
    mode,
    value,
    buttons,
    customButtons,
    dividers,
    imageUrlText,
    linkUrlText,
    placeholder,
    clearFormattingOnPaste,
    resizable,
    instance87,
    $$scope,
    slots,
    div1_binding
  ];
}
var Text_editor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_110,
      create_fragment48,
      safe_not_equal,
      {
        class: 4,
        mode: 5,
        value: 6,
        buttons: 7,
        customButtons: 8,
        dividers: 9,
        imageUrlText: 10,
        linkUrlText: 11,
        placeholder: 12,
        clearFormattingOnPaste: 13,
        resizable: 14,
        instance: 15
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text_editor",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttons() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customButtons() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customButtons(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dividers() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dividers(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageUrlText() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageUrlText(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linkUrlText() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkUrlText(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearFormattingOnPaste() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearFormattingOnPaste(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[15];
  }
  set instance(value) {
    throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var text_editor_default = Text_editor;

// node_modules/framework7-svelte/components/input.svelte
var file46 = "node_modules/framework7-svelte/components/input.svelte";
var get_info_slot_changes = (dirty) => ({});
var get_info_slot_context = (ctx) => ({});
var get_error_message_slot_changes = (dirty) => ({});
var get_error_message_slot_context = (ctx) => ({});
function create_else_block_13(ctx) {
  let input;
  let input_validate_value;
  let input_data_validate_value;
  let input_data_validate_on_blur_value;
  let input_data_error_message_value;
  let input_value_value;
  let mounted;
  let dispose;
  let input_levels = [
    { style: (
      /*inputStyle*/
      ctx[23]
    ) },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { type: (
      /*inputType*/
      ctx[35]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { id: (
      /*inputId*/
      ctx[4]
    ) },
    { size: (
      /*size*/
      ctx[5]
    ) },
    { accept: (
      /*accept*/
      ctx[6]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx[7]
    ) },
    { autocorrect: (
      /*autocorrect*/
      ctx[8]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[9]
      )
    },
    { spellcheck: (
      /*spellcheck*/
      ctx[10]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx[11]
    ) },
    { autosave: (
      /*autosave*/
      ctx[12]
    ) },
    { checked: (
      /*checked*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { max: (
      /*max*/
      ctx[15]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[18]
    ) },
    { min: (
      /*min*/
      ctx[16]
    ) },
    { minlength: (
      /*minlength*/
      ctx[19]
    ) },
    { step: (
      /*step*/
      ctx[17]
    ) },
    { multiple: (
      /*multiple*/
      ctx[20]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[21]
    ) },
    { required: (
      /*required*/
      ctx[22]
    ) },
    { pattern: (
      /*pattern*/
      ctx[24]
    ) },
    {
      validate: input_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0
    },
    {
      "data-validate": input_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    {
      "data-validate-on-blur": input_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    { tabindex: (
      /*tabindex*/
      ctx[27]
    ) },
    {
      "data-error-message": input_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      )
    },
    { class: (
      /*inputClassName*/
      ctx[39]
    ) },
    {
      value: input_value_value = /*type*/
      ctx[1] === "datepicker" || /*type*/
      ctx[1] === "colorpicker" || /*type*/
      ctx[1] === "file" ? "" : (
        /*inputValue*/
        ctx[41]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file46, 626, 2, 16406);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx[65](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*inputStyle*/
        8388608 && { style: (
          /*inputStyle*/
          ctx2[23]
        ) },
        dirty[0] & /*name*/
        4 && { name: (
          /*name*/
          ctx2[2]
        ) },
        dirty[1] & /*inputType*/
        16 && { type: (
          /*inputType*/
          ctx2[35]
        ) },
        dirty[0] & /*placeholder*/
        8 && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        dirty[0] & /*inputId*/
        16 && { id: (
          /*inputId*/
          ctx2[4]
        ) },
        dirty[0] & /*size*/
        32 && { size: (
          /*size*/
          ctx2[5]
        ) },
        dirty[0] & /*accept*/
        64 && { accept: (
          /*accept*/
          ctx2[6]
        ) },
        dirty[0] & /*autocomplete*/
        128 && { autocomplete: (
          /*autocomplete*/
          ctx2[7]
        ) },
        dirty[0] & /*autocorrect*/
        256 && { autocorrect: (
          /*autocorrect*/
          ctx2[8]
        ) },
        dirty[0] & /*autocapitalize*/
        512 && {
          autocapitalize: (
            /*autocapitalize*/
            ctx2[9]
          )
        },
        dirty[0] & /*spellcheck*/
        1024 && { spellcheck: (
          /*spellcheck*/
          ctx2[10]
        ) },
        dirty[0] & /*autofocus*/
        2048 && { autofocus: (
          /*autofocus*/
          ctx2[11]
        ) },
        dirty[0] & /*autosave*/
        4096 && { autosave: (
          /*autosave*/
          ctx2[12]
        ) },
        dirty[0] & /*checked*/
        8192 && { checked: (
          /*checked*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        dirty[0] & /*max*/
        32768 && { max: (
          /*max*/
          ctx2[15]
        ) },
        dirty[0] & /*maxlength*/
        262144 && { maxlength: (
          /*maxlength*/
          ctx2[18]
        ) },
        dirty[0] & /*min*/
        65536 && { min: (
          /*min*/
          ctx2[16]
        ) },
        dirty[0] & /*minlength*/
        524288 && { minlength: (
          /*minlength*/
          ctx2[19]
        ) },
        dirty[0] & /*step*/
        131072 && { step: (
          /*step*/
          ctx2[17]
        ) },
        dirty[0] & /*multiple*/
        1048576 && { multiple: (
          /*multiple*/
          ctx2[20]
        ) },
        dirty[0] & /*readonly*/
        2097152 && { readOnly: (
          /*readonly*/
          ctx2[21]
        ) },
        dirty[0] & /*required*/
        4194304 && { required: (
          /*required*/
          ctx2[22]
        ) },
        dirty[0] & /*pattern*/
        16777216 && { pattern: (
          /*pattern*/
          ctx2[24]
        ) },
        dirty[0] & /*validate*/
        33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/
        ctx2[25] === "string" && /*validate*/
        ctx2[25].length ? (
          /*validate*/
          ctx2[25]
        ) : void 0) && { validate: input_validate_value },
        dirty[0] & /*validate, validateOnBlur*/
        100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/
        ctx2[25] === true || /*validate*/
        ctx2[25] === "" || /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0) && {
          "data-validate": input_data_validate_value
        },
        dirty[0] & /*validateOnBlur*/
        67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0) && {
          "data-validate-on-blur": input_data_validate_on_blur_value
        },
        dirty[0] & /*tabindex*/
        134217728 && { tabindex: (
          /*tabindex*/
          ctx2[27]
        ) },
        dirty[0] & /*errorMessage*/
        1073741824 | dirty[1] & /*errorMessageForce*/
        1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/
        ctx2[31] ? void 0 : (
          /*errorMessage*/
          ctx2[30]
        )) && {
          "data-error-message": input_data_error_message_value
        },
        dirty[1] & /*inputClassName*/
        256 && { class: (
          /*inputClassName*/
          ctx2[39]
        ) },
        dirty[0] & /*type*/
        2 | dirty[1] & /*inputValue*/
        1024 && input_value_value !== (input_value_value = /*type*/
        ctx2[1] === "datepicker" || /*type*/
        ctx2[1] === "colorpicker" || /*type*/
        ctx2[1] === "file" ? "" : (
          /*inputValue*/
          ctx2[41]
        )) && input.value !== input_value_value && { value: input_value_value },
        dirty[1] & /*$$restProps*/
        32768 && restProps(
          /*$$restProps*/
          ctx2[46]
        )
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[65](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(626:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let texteditor;
  let current;
  const texteditor_spread_levels = [
    {
      value: typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      )
    },
    { resizable: (
      /*resizable*/
      ctx[28]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { onTextEditorFocus: (
      /*onFocus*/
      ctx[43]
    ) },
    { onTextEditorBlur: (
      /*onBlur*/
      ctx[44]
    ) },
    { onTextEditorInput: (
      /*onInput*/
      ctx[42]
    ) },
    { onTextEditorChange: (
      /*onChange*/
      ctx[45]
    ) },
    /*textEditorParams*/
    ctx[34],
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let texteditor_props = {};
  for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
  }
  texteditor = new text_editor_default({ props: texteditor_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(texteditor.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(texteditor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const texteditor_changes = dirty[0] & /*value, resizable, placeholder*/
      268435465 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams, $$restProps*/
      63496 ? get_spread_update(texteditor_spread_levels, [
        dirty[0] & /*value*/
        1 && {
          value: typeof /*value*/
          ctx2[0] === "undefined" ? "" : (
            /*value*/
            ctx2[0]
          )
        },
        dirty[0] & /*resizable*/
        268435456 && { resizable: (
          /*resizable*/
          ctx2[28]
        ) },
        dirty[0] & /*placeholder*/
        8 && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        dirty[1] & /*onFocus*/
        4096 && { onTextEditorFocus: (
          /*onFocus*/
          ctx2[43]
        ) },
        dirty[1] & /*onBlur*/
        8192 && { onTextEditorBlur: (
          /*onBlur*/
          ctx2[44]
        ) },
        dirty[1] & /*onInput*/
        2048 && { onTextEditorInput: (
          /*onInput*/
          ctx2[42]
        ) },
        dirty[1] & /*onChange*/
        16384 && { onTextEditorChange: (
          /*onChange*/
          ctx2[45]
        ) },
        dirty[1] & /*textEditorParams*/
        8 && get_spread_object(
          /*textEditorParams*/
          ctx2[34]
        ),
        dirty[1] & /*$$restProps*/
        32768 && get_spread_object(restProps(
          /*$$restProps*/
          ctx2[46]
        ))
      ]) : {};
      texteditor.$set(texteditor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(texteditor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(texteditor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(texteditor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(614:32) ",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let range;
  let current;
  const range_spread_levels = [
    { value: (
      /*value*/
      ctx[0]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { min: (
      /*min*/
      ctx[16]
    ) },
    { max: (
      /*max*/
      ctx[15]
    ) },
    { step: (
      /*step*/
      ctx[17]
    ) },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { id: (
      /*inputId*/
      ctx[4]
    ) },
    { input: true },
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let range_props = {};
  for (let i = 0; i < range_spread_levels.length; i += 1) {
    range_props = assign(range_props, range_spread_levels[i]);
  }
  range = new range_default({ props: range_props, $$inline: true });
  range.$on(
    "rangeChange",
    /*onChange*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(range.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(range, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const range_changes = dirty[0] & /*value, disabled, min, max, step, name, inputId*/
      245781 | dirty[1] & /*$$restProps*/
      32768 ? get_spread_update(range_spread_levels, [
        dirty[0] & /*value*/
        1 && { value: (
          /*value*/
          ctx2[0]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        dirty[0] & /*min*/
        65536 && { min: (
          /*min*/
          ctx2[16]
        ) },
        dirty[0] & /*max*/
        32768 && { max: (
          /*max*/
          ctx2[15]
        ) },
        dirty[0] & /*step*/
        131072 && { step: (
          /*step*/
          ctx2[17]
        ) },
        dirty[0] & /*name*/
        4 && { name: (
          /*name*/
          ctx2[2]
        ) },
        dirty[0] & /*inputId*/
        16 && { id: (
          /*inputId*/
          ctx2[4]
        ) },
        range_spread_levels[7],
        dirty[1] & /*$$restProps*/
        32768 && get_spread_object(restProps(
          /*$$restProps*/
          ctx2[46]
        ))
      ]) : {};
      range.$set(range_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(range.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(range.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(range, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(601:27) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let toggle;
  let current;
  const toggle_spread_levels = [
    { checked: (
      /*checked*/
      ctx[13]
    ) },
    { readonly: (
      /*readonly*/
      ctx[21]
    ) },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { value: (
      /*value*/
      ctx[0]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { id: (
      /*inputId*/
      ctx[4]
    ) },
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let toggle_props = {};
  for (let i = 0; i < toggle_spread_levels.length; i += 1) {
    toggle_props = assign(toggle_props, toggle_spread_levels[i]);
  }
  toggle = new toggle_default({ props: toggle_props, $$inline: true });
  toggle.$on(
    "change",
    /*onChange*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(toggle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toggle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toggle_changes = dirty[0] & /*checked, readonly, name, value, disabled, inputId*/
      2121749 | dirty[1] & /*$$restProps*/
      32768 ? get_spread_update(toggle_spread_levels, [
        dirty[0] & /*checked*/
        8192 && { checked: (
          /*checked*/
          ctx2[13]
        ) },
        dirty[0] & /*readonly*/
        2097152 && { readonly: (
          /*readonly*/
          ctx2[21]
        ) },
        dirty[0] & /*name*/
        4 && { name: (
          /*name*/
          ctx2[2]
        ) },
        dirty[0] & /*value*/
        1 && { value: (
          /*value*/
          ctx2[0]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        dirty[0] & /*inputId*/
        16 && { id: (
          /*inputId*/
          ctx2[4]
        ) },
        dirty[1] & /*$$restProps*/
        32768 && get_spread_object(restProps(
          /*$$restProps*/
          ctx2[46]
        ))
      ]) : {};
      toggle.$set(toggle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(590:28) ",
    ctx
  });
  return block;
}
function create_if_block_102(ctx) {
  let textarea;
  let textarea_validate_value;
  let textarea_data_validate_value;
  let textarea_data_validate_on_blur_value;
  let textarea_data_error_message_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    { style: (
      /*inputStyle*/
      ctx[23]
    ) },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { id: (
      /*inputId*/
      ctx[4]
    ) },
    { size: (
      /*size*/
      ctx[5]
    ) },
    { accept: (
      /*accept*/
      ctx[6]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx[7]
    ) },
    { autocorrect: (
      /*autocorrect*/
      ctx[8]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[9]
      )
    },
    { spellcheck: (
      /*spellcheck*/
      ctx[10]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx[11]
    ) },
    { autosave: (
      /*autosave*/
      ctx[12]
    ) },
    { checked: (
      /*checked*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { max: (
      /*max*/
      ctx[15]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[18]
    ) },
    { min: (
      /*min*/
      ctx[16]
    ) },
    { minlength: (
      /*minlength*/
      ctx[19]
    ) },
    { step: (
      /*step*/
      ctx[17]
    ) },
    { multiple: (
      /*multiple*/
      ctx[20]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[21]
    ) },
    { required: (
      /*required*/
      ctx[22]
    ) },
    { pattern: (
      /*pattern*/
      ctx[24]
    ) },
    {
      validate: textarea_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0
    },
    {
      "data-validate": textarea_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    {
      "data-validate-on-blur": textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    { tabindex: (
      /*tabindex*/
      ctx[27]
    ) },
    {
      "data-error-message": textarea_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      )
    },
    { class: (
      /*inputClassName*/
      ctx[39]
    ) },
    { value: (
      /*inputValue*/
      ctx[41]
    ) },
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file46, 546, 2, 14696);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      ctx[64](textarea);
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty[0] & /*inputStyle*/
        8388608 && { style: (
          /*inputStyle*/
          ctx2[23]
        ) },
        dirty[0] & /*name*/
        4 && { name: (
          /*name*/
          ctx2[2]
        ) },
        dirty[0] & /*placeholder*/
        8 && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        dirty[0] & /*inputId*/
        16 && { id: (
          /*inputId*/
          ctx2[4]
        ) },
        dirty[0] & /*size*/
        32 && { size: (
          /*size*/
          ctx2[5]
        ) },
        dirty[0] & /*accept*/
        64 && { accept: (
          /*accept*/
          ctx2[6]
        ) },
        dirty[0] & /*autocomplete*/
        128 && { autocomplete: (
          /*autocomplete*/
          ctx2[7]
        ) },
        dirty[0] & /*autocorrect*/
        256 && { autocorrect: (
          /*autocorrect*/
          ctx2[8]
        ) },
        dirty[0] & /*autocapitalize*/
        512 && {
          autocapitalize: (
            /*autocapitalize*/
            ctx2[9]
          )
        },
        dirty[0] & /*spellcheck*/
        1024 && { spellcheck: (
          /*spellcheck*/
          ctx2[10]
        ) },
        dirty[0] & /*autofocus*/
        2048 && { autofocus: (
          /*autofocus*/
          ctx2[11]
        ) },
        dirty[0] & /*autosave*/
        4096 && { autosave: (
          /*autosave*/
          ctx2[12]
        ) },
        dirty[0] & /*checked*/
        8192 && { checked: (
          /*checked*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        dirty[0] & /*max*/
        32768 && { max: (
          /*max*/
          ctx2[15]
        ) },
        dirty[0] & /*maxlength*/
        262144 && { maxlength: (
          /*maxlength*/
          ctx2[18]
        ) },
        dirty[0] & /*min*/
        65536 && { min: (
          /*min*/
          ctx2[16]
        ) },
        dirty[0] & /*minlength*/
        524288 && { minlength: (
          /*minlength*/
          ctx2[19]
        ) },
        dirty[0] & /*step*/
        131072 && { step: (
          /*step*/
          ctx2[17]
        ) },
        dirty[0] & /*multiple*/
        1048576 && { multiple: (
          /*multiple*/
          ctx2[20]
        ) },
        dirty[0] & /*readonly*/
        2097152 && { readOnly: (
          /*readonly*/
          ctx2[21]
        ) },
        dirty[0] & /*required*/
        4194304 && { required: (
          /*required*/
          ctx2[22]
        ) },
        dirty[0] & /*pattern*/
        16777216 && { pattern: (
          /*pattern*/
          ctx2[24]
        ) },
        dirty[0] & /*validate*/
        33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/
        ctx2[25] === "string" && /*validate*/
        ctx2[25].length ? (
          /*validate*/
          ctx2[25]
        ) : void 0) && { validate: textarea_validate_value },
        dirty[0] & /*validate, validateOnBlur*/
        100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/
        ctx2[25] === true || /*validate*/
        ctx2[25] === "" || /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0) && {
          "data-validate": textarea_data_validate_value
        },
        dirty[0] & /*validateOnBlur*/
        67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0) && {
          "data-validate-on-blur": textarea_data_validate_on_blur_value
        },
        dirty[0] & /*tabindex*/
        134217728 && { tabindex: (
          /*tabindex*/
          ctx2[27]
        ) },
        dirty[0] & /*errorMessage*/
        1073741824 | dirty[1] & /*errorMessageForce*/
        1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/
        ctx2[31] ? void 0 : (
          /*errorMessage*/
          ctx2[30]
        )) && {
          "data-error-message": textarea_data_error_message_value
        },
        dirty[1] & /*inputClassName*/
        256 && { class: (
          /*inputClassName*/
          ctx2[39]
        ) },
        dirty[1] & /*inputValue*/
        1024 && { value: (
          /*inputValue*/
          ctx2[41]
        ) },
        dirty[1] & /*$$restProps*/
        32768 && restProps(
          /*$$restProps*/
          ctx2[46]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[64](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(546:30) ",
    ctx
  });
  return block;
}
function create_if_block_92(ctx) {
  let select;
  let select_validate_value;
  let select_data_validate_value;
  let select_data_validate_on_blur_value;
  let select_data_error_message_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[59].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    null
  );
  let select_levels = [
    { style: (
      /*inputStyle*/
      ctx[23]
    ) },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { id: (
      /*inputId*/
      ctx[4]
    ) },
    { size: (
      /*size*/
      ctx[5]
    ) },
    { accept: (
      /*accept*/
      ctx[6]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx[7]
    ) },
    { autocorrect: (
      /*autocorrect*/
      ctx[8]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[9]
      )
    },
    { spellcheck: (
      /*spellcheck*/
      ctx[10]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx[11]
    ) },
    { autosave: (
      /*autosave*/
      ctx[12]
    ) },
    { checked: (
      /*checked*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { max: (
      /*max*/
      ctx[15]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[18]
    ) },
    { min: (
      /*min*/
      ctx[16]
    ) },
    { minlength: (
      /*minlength*/
      ctx[19]
    ) },
    { step: (
      /*step*/
      ctx[17]
    ) },
    { multiple: (
      /*multiple*/
      ctx[20]
    ) },
    { readonly: (
      /*readonly*/
      ctx[21]
    ) },
    { required: (
      /*required*/
      ctx[22]
    ) },
    { pattern: (
      /*pattern*/
      ctx[24]
    ) },
    {
      validate: select_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0
    },
    {
      "data-validate": select_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    {
      "data-validate-on-blur": select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0
    },
    { tabindex: (
      /*tabindex*/
      ctx[27]
    ) },
    {
      "data-error-message": select_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      )
    },
    { class: (
      /*inputClassName*/
      ctx[39]
    ) },
    { value: (
      /*inputValue*/
      ctx[41]
    ) },
    restProps(
      /*$$restProps*/
      ctx[46]
    )
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      set_attributes(select, select_data);
      add_location(select, file46, 500, 2, 13659);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      ctx[63](select);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        (!current || dirty[0] & /*inputStyle*/
        8388608) && { style: (
          /*inputStyle*/
          ctx2[23]
        ) },
        (!current || dirty[0] & /*name*/
        4) && { name: (
          /*name*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*placeholder*/
        8) && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*inputId*/
        16) && { id: (
          /*inputId*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*size*/
        32) && { size: (
          /*size*/
          ctx2[5]
        ) },
        (!current || dirty[0] & /*accept*/
        64) && { accept: (
          /*accept*/
          ctx2[6]
        ) },
        (!current || dirty[0] & /*autocomplete*/
        128) && { autocomplete: (
          /*autocomplete*/
          ctx2[7]
        ) },
        (!current || dirty[0] & /*autocorrect*/
        256) && { autocorrect: (
          /*autocorrect*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*autocapitalize*/
        512) && {
          autocapitalize: (
            /*autocapitalize*/
            ctx2[9]
          )
        },
        (!current || dirty[0] & /*spellcheck*/
        1024) && { spellcheck: (
          /*spellcheck*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*autofocus*/
        2048) && { autofocus: (
          /*autofocus*/
          ctx2[11]
        ) },
        (!current || dirty[0] & /*autosave*/
        4096) && { autosave: (
          /*autosave*/
          ctx2[12]
        ) },
        (!current || dirty[0] & /*checked*/
        8192) && { checked: (
          /*checked*/
          ctx2[13]
        ) },
        (!current || dirty[0] & /*disabled*/
        16384) && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        (!current || dirty[0] & /*max*/
        32768) && { max: (
          /*max*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*maxlength*/
        262144) && { maxlength: (
          /*maxlength*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*min*/
        65536) && { min: (
          /*min*/
          ctx2[16]
        ) },
        (!current || dirty[0] & /*minlength*/
        524288) && { minlength: (
          /*minlength*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*step*/
        131072) && { step: (
          /*step*/
          ctx2[17]
        ) },
        (!current || dirty[0] & /*multiple*/
        1048576) && { multiple: (
          /*multiple*/
          ctx2[20]
        ) },
        (!current || dirty[0] & /*readonly*/
        2097152) && { readonly: (
          /*readonly*/
          ctx2[21]
        ) },
        (!current || dirty[0] & /*required*/
        4194304) && { required: (
          /*required*/
          ctx2[22]
        ) },
        (!current || dirty[0] & /*pattern*/
        16777216) && { pattern: (
          /*pattern*/
          ctx2[24]
        ) },
        (!current || dirty[0] & /*validate*/
        33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/
        ctx2[25] === "string" && /*validate*/
        ctx2[25].length ? (
          /*validate*/
          ctx2[25]
        ) : void 0)) && { validate: select_validate_value },
        (!current || dirty[0] & /*validate, validateOnBlur*/
        100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/
        ctx2[25] === true || /*validate*/
        ctx2[25] === "" || /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0)) && {
          "data-validate": select_data_validate_value
        },
        (!current || dirty[0] & /*validateOnBlur*/
        67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/
        ctx2[26] === true || /*validateOnBlur*/
        ctx2[26] === "" ? true : void 0)) && {
          "data-validate-on-blur": select_data_validate_on_blur_value
        },
        (!current || dirty[0] & /*tabindex*/
        134217728) && { tabindex: (
          /*tabindex*/
          ctx2[27]
        ) },
        (!current || dirty[0] & /*errorMessage*/
        1073741824 | dirty[1] & /*errorMessageForce*/
        1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/
        ctx2[31] ? void 0 : (
          /*errorMessage*/
          ctx2[30]
        ))) && {
          "data-error-message": select_data_error_message_value
        },
        (!current || dirty[1] & /*inputClassName*/
        256) && { class: (
          /*inputClassName*/
          ctx2[39]
        ) },
        (!current || dirty[1] & /*inputValue*/
        1024) && { value: (
          /*inputValue*/
          ctx2[41]
        ) },
        dirty[1] & /*$$restProps*/
        32768 && restProps(
          /*$$restProps*/
          ctx2[46]
        )
      ]));
      if (dirty[0] & /*inputStyle, name, placeholder, inputId, size, accept, autocomplete, autocorrect, autocapitalize, spellcheck, autofocus, autosave, checked, disabled, max, maxlength, min, minlength, step, multiple, readonly, required, pattern, validate, validateOnBlur, tabindex, errorMessage*/
      1342177276 | dirty[1] & /*errorMessageForce, inputClassName, inputValue, $$restProps*/
      34049 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[63](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(500:28) ",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let t2;
  let current;
  const if_block_creators = [
    create_if_block_45,
    create_if_block_52,
    create_if_block_62,
    create_if_block_72,
    create_if_block_82,
    create_else_block5
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === "select"
    )
      return 0;
    if (
      /*type*/
      ctx2[1] === "textarea"
    )
      return 1;
    if (
      /*type*/
      ctx2[1] === "toggle"
    )
      return 2;
    if (
      /*type*/
      ctx2[1] === "range"
    )
      return 3;
    if (
      /*type*/
      ctx2[1] === "texteditor"
    )
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*errorMessage*/
    (ctx[30] || /*hasErrorSlots*/
    ctx[37]) && /*errorMessageForce*/
    ctx[31] && create_if_block_37(ctx)
  );
  let if_block2 = (
    /*clearButton*/
    ctx[29] && create_if_block_29(ctx)
  );
  let if_block3 = (
    /*info*/
    (ctx[32] || /*hasInfoSlots*/
    ctx[38]) && create_if_block_19(ctx)
  );
  let div_levels = [{ class: (
    /*wrapClasses*/
    ctx[40]
  ) }, restProps(
    /*$$restProps*/
    ctx[46]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      set_attributes(div, div_data);
      add_location(div, file46, 326, 2, 8915);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t0);
      }
      if (
        /*errorMessage*/
        (ctx2[30] || /*hasErrorSlots*/
        ctx2[37]) && /*errorMessageForce*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*errorMessage*/
          1073741824 | dirty[1] & /*hasErrorSlots, errorMessageForce*/
          65) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_37(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*clearButton*/
        ctx2[29]
      ) {
        if (if_block2) {
        } else {
          if_block2 = create_if_block_29(ctx2);
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*info*/
        ctx2[32] || /*hasInfoSlots*/
        ctx2[38]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*info, hasInfoSlots*/
          130) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_19(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[1] & /*wrapClasses*/
        512) && { class: (
          /*wrapClasses*/
          ctx2[40]
        ) },
        dirty[1] & /*$$restProps*/
        32768 && restProps(
          /*$$restProps*/
          ctx2[46]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(326:0) {#if wrap}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let input;
  let input_validate_value;
  let input_data_validate_value;
  let input_data_validate_on_blur_value;
  let input_data_error_message_value;
  let input_value_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      attr_dev(
        input,
        "style",
        /*inputStyle*/
        ctx[23]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[2]
      );
      attr_dev(
        input,
        "type",
        /*inputType*/
        ctx[35]
      );
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr_dev(
        input,
        "id",
        /*inputId*/
        ctx[4]
      );
      attr_dev(
        input,
        "size",
        /*size*/
        ctx[5]
      );
      attr_dev(
        input,
        "accept",
        /*accept*/
        ctx[6]
      );
      attr_dev(
        input,
        "autocomplete",
        /*autocomplete*/
        ctx[7]
      );
      attr_dev(
        input,
        "autocorrect",
        /*autocorrect*/
        ctx[8]
      );
      attr_dev(
        input,
        "autocapitalize",
        /*autocapitalize*/
        ctx[9]
      );
      attr_dev(
        input,
        "spellcheck",
        /*spellcheck*/
        ctx[10]
      );
      input.autofocus = /*autofocus*/
      ctx[11];
      attr_dev(
        input,
        "autosave",
        /*autosave*/
        ctx[12]
      );
      input.checked = /*checked*/
      ctx[13];
      input.disabled = /*disabled*/
      ctx[14];
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[15]
      );
      attr_dev(
        input,
        "maxlength",
        /*maxlength*/
        ctx[18]
      );
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[16]
      );
      attr_dev(
        input,
        "minlength",
        /*minlength*/
        ctx[19]
      );
      attr_dev(
        input,
        "step",
        /*step*/
        ctx[17]
      );
      input.multiple = /*multiple*/
      ctx[20];
      input.readOnly = /*readonly*/
      ctx[21];
      input.required = /*required*/
      ctx[22];
      attr_dev(
        input,
        "pattern",
        /*pattern*/
        ctx[24]
      );
      attr_dev(input, "validate", input_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0);
      attr_dev(input, "data-validate", input_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(input, "data-validate-on-blur", input_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(
        input,
        "tabindex",
        /*tabindex*/
        ctx[27]
      );
      attr_dev(input, "data-error-message", input_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      ));
      attr_dev(
        input,
        "class",
        /*inputClassName*/
        ctx[39]
      );
      input.value = input_value_value = /*type*/
      ctx[1] === "datepicker" || /*type*/
      ctx[1] === "colorpicker" || /*type*/
      ctx[1] === "file" ? "" : (
        /*inputValue*/
        ctx[41]
      );
      add_location(input, file46, 441, 6, 12012);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      ctx[62](input);
      if (
        /*autofocus*/
        ctx[11]
      )
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      8388608) {
        attr_dev(
          input,
          "style",
          /*inputStyle*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*name*/
      4) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (dirty[1] & /*inputType*/
      16) {
        attr_dev(
          input,
          "type",
          /*inputType*/
          ctx2[35]
        );
      }
      if (dirty[0] & /*placeholder*/
      8) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*inputId*/
      16) {
        attr_dev(
          input,
          "id",
          /*inputId*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*size*/
      32) {
        attr_dev(
          input,
          "size",
          /*size*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*accept*/
      64) {
        attr_dev(
          input,
          "accept",
          /*accept*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*autocomplete*/
      128) {
        attr_dev(
          input,
          "autocomplete",
          /*autocomplete*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*autocorrect*/
      256) {
        attr_dev(
          input,
          "autocorrect",
          /*autocorrect*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      512) {
        attr_dev(
          input,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*spellcheck*/
      1024) {
        attr_dev(
          input,
          "spellcheck",
          /*spellcheck*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*autofocus*/
      2048) {
        prop_dev(
          input,
          "autofocus",
          /*autofocus*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*autosave*/
      4096) {
        attr_dev(
          input,
          "autosave",
          /*autosave*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*checked*/
      8192) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*disabled*/
      16384) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*max*/
      32768) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*maxlength*/
      262144) {
        attr_dev(
          input,
          "maxlength",
          /*maxlength*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*min*/
      65536) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*minlength*/
      524288) {
        attr_dev(
          input,
          "minlength",
          /*minlength*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*step*/
      131072) {
        attr_dev(
          input,
          "step",
          /*step*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*multiple*/
      1048576) {
        prop_dev(
          input,
          "multiple",
          /*multiple*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*readonly*/
      2097152) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*required*/
      4194304) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*pattern*/
      16777216) {
        attr_dev(
          input,
          "pattern",
          /*pattern*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*validate*/
      33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/
      ctx2[25] === "string" && /*validate*/
      ctx2[25].length ? (
        /*validate*/
        ctx2[25]
      ) : void 0)) {
        attr_dev(input, "validate", input_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/
      ctx2[25] === true || /*validate*/
      ctx2[25] === "" || /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(input, "data-validate", input_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(input, "data-validate-on-blur", input_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      134217728) {
        attr_dev(
          input,
          "tabindex",
          /*tabindex*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*errorMessage*/
      1073741824 | dirty[1] & /*errorMessageForce*/
      1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/
      ctx2[31] ? void 0 : (
        /*errorMessage*/
        ctx2[30]
      ))) {
        attr_dev(input, "data-error-message", input_data_error_message_value);
      }
      if (dirty[1] & /*inputClassName*/
      256) {
        attr_dev(
          input,
          "class",
          /*inputClassName*/
          ctx2[39]
        );
      }
      if (dirty[0] & /*type*/
      2 | dirty[1] & /*inputValue*/
      1024 && input_value_value !== (input_value_value = /*type*/
      ctx2[1] === "datepicker" || /*type*/
      ctx2[1] === "colorpicker" || /*type*/
      ctx2[1] === "file" ? "" : (
        /*inputValue*/
        ctx2[41]
      )) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[62](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(441:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let texteditor;
  let current;
  const texteditor_spread_levels = [
    {
      value: typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      )
    },
    { resizable: (
      /*resizable*/
      ctx[28]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    { onTextEditorFocus: (
      /*onFocus*/
      ctx[43]
    ) },
    { onTextEditorBlur: (
      /*onBlur*/
      ctx[44]
    ) },
    { onTextEditorInput: (
      /*onInput*/
      ctx[42]
    ) },
    { onTextEditorChange: (
      /*onChange*/
      ctx[45]
    ) },
    /*textEditorParams*/
    ctx[34]
  ];
  let texteditor_props = {};
  for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
  }
  texteditor = new text_editor_default({ props: texteditor_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(texteditor.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(texteditor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const texteditor_changes = dirty[0] & /*value, resizable, placeholder*/
      268435465 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams*/
      30728 ? get_spread_update(texteditor_spread_levels, [
        dirty[0] & /*value*/
        1 && {
          value: typeof /*value*/
          ctx2[0] === "undefined" ? "" : (
            /*value*/
            ctx2[0]
          )
        },
        dirty[0] & /*resizable*/
        268435456 && { resizable: (
          /*resizable*/
          ctx2[28]
        ) },
        dirty[0] & /*placeholder*/
        8 && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        dirty[1] & /*onFocus*/
        4096 && { onTextEditorFocus: (
          /*onFocus*/
          ctx2[43]
        ) },
        dirty[1] & /*onBlur*/
        8192 && { onTextEditorBlur: (
          /*onBlur*/
          ctx2[44]
        ) },
        dirty[1] & /*onInput*/
        2048 && { onTextEditorInput: (
          /*onInput*/
          ctx2[42]
        ) },
        dirty[1] & /*onChange*/
        16384 && { onTextEditorChange: (
          /*onChange*/
          ctx2[45]
        ) },
        dirty[1] & /*textEditorParams*/
        8 && get_spread_object(
          /*textEditorParams*/
          ctx2[34]
        )
      ]) : {};
      texteditor.$set(texteditor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(texteditor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(texteditor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(texteditor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(430:36) ",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let range;
  let current;
  range = new range_default({
    props: {
      value: (
        /*value*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[14]
      ),
      min: (
        /*min*/
        ctx[16]
      ),
      max: (
        /*max*/
        ctx[15]
      ),
      step: (
        /*step*/
        ctx[17]
      ),
      name: (
        /*name*/
        ctx[2]
      ),
      id: (
        /*inputId*/
        ctx[4]
      ),
      input: true
    },
    $$inline: true
  });
  range.$on(
    "rangeChange",
    /*onChange*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(range.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(range, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const range_changes = {};
      if (dirty[0] & /*value*/
      1)
        range_changes.value = /*value*/
        ctx2[0];
      if (dirty[0] & /*disabled*/
      16384)
        range_changes.disabled = /*disabled*/
        ctx2[14];
      if (dirty[0] & /*min*/
      65536)
        range_changes.min = /*min*/
        ctx2[16];
      if (dirty[0] & /*max*/
      32768)
        range_changes.max = /*max*/
        ctx2[15];
      if (dirty[0] & /*step*/
      131072)
        range_changes.step = /*step*/
        ctx2[17];
      if (dirty[0] & /*name*/
      4)
        range_changes.name = /*name*/
        ctx2[2];
      if (dirty[0] & /*inputId*/
      16)
        range_changes.id = /*inputId*/
        ctx2[4];
      range.$set(range_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(range.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(range.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(range, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(418:31) ",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let toggle;
  let current;
  toggle = new toggle_default({
    props: {
      checked: (
        /*checked*/
        ctx[13]
      ),
      readonly: (
        /*readonly*/
        ctx[21]
      ),
      name: (
        /*name*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      disabled: (
        /*disabled*/
        ctx[14]
      ),
      id: (
        /*inputId*/
        ctx[4]
      )
    },
    $$inline: true
  });
  toggle.$on(
    "change",
    /*onChange*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(toggle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toggle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toggle_changes = {};
      if (dirty[0] & /*checked*/
      8192)
        toggle_changes.checked = /*checked*/
        ctx2[13];
      if (dirty[0] & /*readonly*/
      2097152)
        toggle_changes.readonly = /*readonly*/
        ctx2[21];
      if (dirty[0] & /*name*/
      4)
        toggle_changes.name = /*name*/
        ctx2[2];
      if (dirty[0] & /*value*/
      1)
        toggle_changes.value = /*value*/
        ctx2[0];
      if (dirty[0] & /*disabled*/
      16384)
        toggle_changes.disabled = /*disabled*/
        ctx2[14];
      if (dirty[0] & /*inputId*/
      16)
        toggle_changes.id = /*inputId*/
        ctx2[4];
      toggle.$set(toggle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(416:32) ",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let textarea;
  let textarea_validate_value;
  let textarea_data_validate_value;
  let textarea_data_validate_on_blur_value;
  let textarea_data_error_message_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      textarea = element("textarea");
      attr_dev(
        textarea,
        "style",
        /*inputStyle*/
        ctx[23]
      );
      attr_dev(
        textarea,
        "name",
        /*name*/
        ctx[2]
      );
      attr_dev(
        textarea,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr_dev(
        textarea,
        "id",
        /*inputId*/
        ctx[4]
      );
      attr_dev(
        textarea,
        "size",
        /*size*/
        ctx[5]
      );
      attr_dev(
        textarea,
        "accept",
        /*accept*/
        ctx[6]
      );
      attr_dev(
        textarea,
        "autocomplete",
        /*autocomplete*/
        ctx[7]
      );
      attr_dev(
        textarea,
        "autocorrect",
        /*autocorrect*/
        ctx[8]
      );
      attr_dev(
        textarea,
        "autocapitalize",
        /*autocapitalize*/
        ctx[9]
      );
      attr_dev(
        textarea,
        "spellcheck",
        /*spellcheck*/
        ctx[10]
      );
      textarea.autofocus = /*autofocus*/
      ctx[11];
      attr_dev(
        textarea,
        "autosave",
        /*autosave*/
        ctx[12]
      );
      attr_dev(
        textarea,
        "checked",
        /*checked*/
        ctx[13]
      );
      textarea.disabled = /*disabled*/
      ctx[14];
      attr_dev(
        textarea,
        "max",
        /*max*/
        ctx[15]
      );
      attr_dev(
        textarea,
        "maxlength",
        /*maxlength*/
        ctx[18]
      );
      attr_dev(
        textarea,
        "min",
        /*min*/
        ctx[16]
      );
      attr_dev(
        textarea,
        "minlength",
        /*minlength*/
        ctx[19]
      );
      attr_dev(
        textarea,
        "step",
        /*step*/
        ctx[17]
      );
      attr_dev(
        textarea,
        "multiple",
        /*multiple*/
        ctx[20]
      );
      textarea.readOnly = /*readonly*/
      ctx[21];
      textarea.required = /*required*/
      ctx[22];
      attr_dev(
        textarea,
        "pattern",
        /*pattern*/
        ctx[24]
      );
      attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0);
      attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(
        textarea,
        "tabindex",
        /*tabindex*/
        ctx[27]
      );
      attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      ));
      attr_dev(
        textarea,
        "class",
        /*inputClassName*/
        ctx[39]
      );
      textarea.value = /*inputValue*/
      ctx[41];
      add_location(textarea, file46, 373, 6, 10188);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      ctx[61](textarea);
      if (
        /*autofocus*/
        ctx[11]
      )
        textarea.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      8388608) {
        attr_dev(
          textarea,
          "style",
          /*inputStyle*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*name*/
      4) {
        attr_dev(
          textarea,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*placeholder*/
      8) {
        attr_dev(
          textarea,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*inputId*/
      16) {
        attr_dev(
          textarea,
          "id",
          /*inputId*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*size*/
      32) {
        attr_dev(
          textarea,
          "size",
          /*size*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*accept*/
      64) {
        attr_dev(
          textarea,
          "accept",
          /*accept*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*autocomplete*/
      128) {
        attr_dev(
          textarea,
          "autocomplete",
          /*autocomplete*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*autocorrect*/
      256) {
        attr_dev(
          textarea,
          "autocorrect",
          /*autocorrect*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      512) {
        attr_dev(
          textarea,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*spellcheck*/
      1024) {
        attr_dev(
          textarea,
          "spellcheck",
          /*spellcheck*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*autofocus*/
      2048) {
        prop_dev(
          textarea,
          "autofocus",
          /*autofocus*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*autosave*/
      4096) {
        attr_dev(
          textarea,
          "autosave",
          /*autosave*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*checked*/
      8192) {
        attr_dev(
          textarea,
          "checked",
          /*checked*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*disabled*/
      16384) {
        prop_dev(
          textarea,
          "disabled",
          /*disabled*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*max*/
      32768) {
        attr_dev(
          textarea,
          "max",
          /*max*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*maxlength*/
      262144) {
        attr_dev(
          textarea,
          "maxlength",
          /*maxlength*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*min*/
      65536) {
        attr_dev(
          textarea,
          "min",
          /*min*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*minlength*/
      524288) {
        attr_dev(
          textarea,
          "minlength",
          /*minlength*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*step*/
      131072) {
        attr_dev(
          textarea,
          "step",
          /*step*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*multiple*/
      1048576) {
        attr_dev(
          textarea,
          "multiple",
          /*multiple*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*readonly*/
      2097152) {
        prop_dev(
          textarea,
          "readOnly",
          /*readonly*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*required*/
      4194304) {
        prop_dev(
          textarea,
          "required",
          /*required*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*pattern*/
      16777216) {
        attr_dev(
          textarea,
          "pattern",
          /*pattern*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*validate*/
      33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/
      ctx2[25] === "string" && /*validate*/
      ctx2[25].length ? (
        /*validate*/
        ctx2[25]
      ) : void 0)) {
        attr_dev(textarea, "validate", textarea_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/
      ctx2[25] === true || /*validate*/
      ctx2[25] === "" || /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate", textarea_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      134217728) {
        attr_dev(
          textarea,
          "tabindex",
          /*tabindex*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*errorMessage*/
      1073741824 | dirty[1] & /*errorMessageForce*/
      1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/
      ctx2[31] ? void 0 : (
        /*errorMessage*/
        ctx2[30]
      ))) {
        attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
      }
      if (dirty[1] & /*inputClassName*/
      256) {
        attr_dev(
          textarea,
          "class",
          /*inputClassName*/
          ctx2[39]
        );
      }
      if (dirty[1] & /*inputValue*/
      1024) {
        prop_dev(
          textarea,
          "value",
          /*inputValue*/
          ctx2[41]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[61](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(373:34) ",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let select;
  let select_validate_value;
  let select_data_validate_value;
  let select_data_validate_on_blur_value;
  let select_data_error_message_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[59].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    null
  );
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      attr_dev(
        select,
        "style",
        /*inputStyle*/
        ctx[23]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[2]
      );
      attr_dev(
        select,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr_dev(
        select,
        "id",
        /*inputId*/
        ctx[4]
      );
      attr_dev(
        select,
        "size",
        /*size*/
        ctx[5]
      );
      attr_dev(
        select,
        "accept",
        /*accept*/
        ctx[6]
      );
      attr_dev(
        select,
        "autocomplete",
        /*autocomplete*/
        ctx[7]
      );
      attr_dev(
        select,
        "autocorrect",
        /*autocorrect*/
        ctx[8]
      );
      attr_dev(
        select,
        "autocapitalize",
        /*autocapitalize*/
        ctx[9]
      );
      attr_dev(
        select,
        "spellcheck",
        /*spellcheck*/
        ctx[10]
      );
      select.autofocus = /*autofocus*/
      ctx[11];
      attr_dev(
        select,
        "autosave",
        /*autosave*/
        ctx[12]
      );
      attr_dev(
        select,
        "checked",
        /*checked*/
        ctx[13]
      );
      select.disabled = /*disabled*/
      ctx[14];
      attr_dev(
        select,
        "max",
        /*max*/
        ctx[15]
      );
      attr_dev(
        select,
        "maxlength",
        /*maxlength*/
        ctx[18]
      );
      attr_dev(
        select,
        "min",
        /*min*/
        ctx[16]
      );
      attr_dev(
        select,
        "minlength",
        /*minlength*/
        ctx[19]
      );
      attr_dev(
        select,
        "step",
        /*step*/
        ctx[17]
      );
      select.multiple = /*multiple*/
      ctx[20];
      attr_dev(
        select,
        "readonly",
        /*readonly*/
        ctx[21]
      );
      select.required = /*required*/
      ctx[22];
      attr_dev(
        select,
        "pattern",
        /*pattern*/
        ctx[24]
      );
      attr_dev(select, "validate", select_validate_value = typeof /*validate*/
      ctx[25] === "string" && /*validate*/
      ctx[25].length ? (
        /*validate*/
        ctx[25]
      ) : void 0);
      attr_dev(select, "data-validate", select_data_validate_value = /*validate*/
      ctx[25] === true || /*validate*/
      ctx[25] === "" || /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[26] === true || /*validateOnBlur*/
      ctx[26] === "" ? true : void 0);
      attr_dev(
        select,
        "tabindex",
        /*tabindex*/
        ctx[27]
      );
      attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/
      ctx[31] ? void 0 : (
        /*errorMessage*/
        ctx[30]
      ));
      attr_dev(
        select,
        "class",
        /*inputClassName*/
        ctx[39]
      );
      add_location(select, file46, 328, 6, 9003);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(
        select,
        /*inputValue*/
        ctx[41]
      );
      ctx[60](select);
      current = true;
      if (
        /*autofocus*/
        ctx[11]
      )
        select.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "focus",
            /*onFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*onBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*onInput*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*onChange*/
            ctx[45],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*inputStyle*/
      8388608) {
        attr_dev(
          select,
          "style",
          /*inputStyle*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*placeholder*/
      8) {
        attr_dev(
          select,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*inputId*/
      16) {
        attr_dev(
          select,
          "id",
          /*inputId*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*size*/
      32) {
        attr_dev(
          select,
          "size",
          /*size*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*accept*/
      64) {
        attr_dev(
          select,
          "accept",
          /*accept*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*autocomplete*/
      128) {
        attr_dev(
          select,
          "autocomplete",
          /*autocomplete*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*autocorrect*/
      256) {
        attr_dev(
          select,
          "autocorrect",
          /*autocorrect*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*autocapitalize*/
      512) {
        attr_dev(
          select,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*spellcheck*/
      1024) {
        attr_dev(
          select,
          "spellcheck",
          /*spellcheck*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*autofocus*/
      2048) {
        prop_dev(
          select,
          "autofocus",
          /*autofocus*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*autosave*/
      4096) {
        attr_dev(
          select,
          "autosave",
          /*autosave*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*checked*/
      8192) {
        attr_dev(
          select,
          "checked",
          /*checked*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16384) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*max*/
      32768) {
        attr_dev(
          select,
          "max",
          /*max*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*maxlength*/
      262144) {
        attr_dev(
          select,
          "maxlength",
          /*maxlength*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*min*/
      65536) {
        attr_dev(
          select,
          "min",
          /*min*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*minlength*/
      524288) {
        attr_dev(
          select,
          "minlength",
          /*minlength*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*step*/
      131072) {
        attr_dev(
          select,
          "step",
          /*step*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*multiple*/
      1048576) {
        prop_dev(
          select,
          "multiple",
          /*multiple*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      2097152) {
        attr_dev(
          select,
          "readonly",
          /*readonly*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*required*/
      4194304) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*pattern*/
      16777216) {
        attr_dev(
          select,
          "pattern",
          /*pattern*/
          ctx2[24]
        );
      }
      if (!current || dirty[0] & /*validate*/
      33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/
      ctx2[25] === "string" && /*validate*/
      ctx2[25].length ? (
        /*validate*/
        ctx2[25]
      ) : void 0)) {
        attr_dev(select, "validate", select_validate_value);
      }
      if (!current || dirty[0] & /*validate, validateOnBlur*/
      100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/
      ctx2[25] === true || /*validate*/
      ctx2[25] === "" || /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(select, "data-validate", select_data_validate_value);
      }
      if (!current || dirty[0] & /*validateOnBlur*/
      67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[26] === true || /*validateOnBlur*/
      ctx2[26] === "" ? true : void 0)) {
        attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
      }
      if (!current || dirty[0] & /*tabindex*/
      134217728) {
        attr_dev(
          select,
          "tabindex",
          /*tabindex*/
          ctx2[27]
        );
      }
      if (!current || dirty[0] & /*errorMessage*/
      1073741824 | dirty[1] & /*errorMessageForce*/
      1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/
      ctx2[31] ? void 0 : (
        /*errorMessage*/
        ctx2[30]
      ))) {
        attr_dev(select, "data-error-message", select_data_error_message_value);
      }
      if (!current || dirty[1] & /*inputClassName*/
      256) {
        attr_dev(
          select,
          "class",
          /*inputClassName*/
          ctx2[39]
        );
      }
      if (!current || dirty[1] & /*inputValue*/
      1024) {
        select_option(
          select,
          /*inputValue*/
          ctx2[41]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[60](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(328:4) {#if type === 'select'}",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const error_message_slot_template = (
    /*#slots*/
    ctx[59]["error-message"]
  );
  const error_message_slot = create_slot(
    error_message_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_error_message_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*errorMessage*/
        ctx[30]
      );
      t1 = space();
      if (error_message_slot)
        error_message_slot.c();
      attr_dev(div, "class", "input-error-message");
      add_location(div, file46, 486, 6, 13310);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (error_message_slot) {
        error_message_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*errorMessage*/
      1073741824)
        set_data_dev(
          t0,
          /*errorMessage*/
          ctx2[30]
        );
      if (error_message_slot) {
        if (error_message_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            error_message_slot,
            error_message_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              error_message_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_error_message_slot_changes
            ),
            get_error_message_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_message_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_message_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (error_message_slot)
        error_message_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(486:4) {#if (errorMessage || hasErrorSlots) && errorMessageForce}",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "input-clear-button");
      add_location(span, file46, 491, 21, 13449);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(492:4) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const info_slot_template = (
    /*#slots*/
    ctx[59].info
  );
  const info_slot = create_slot(
    info_slot_template,
    ctx,
    /*$$scope*/
    ctx[58],
    get_info_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(
        /*info*/
        ctx[32]
      );
      t1 = space();
      if (info_slot)
        info_slot.c();
      attr_dev(div, "class", "input-info");
      add_location(div, file46, 493, 6, 13527);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (info_slot) {
        info_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[1] & /*info*/
      2)
        set_data_dev(
          t0,
          /*info*/
          ctx2[32]
        );
      if (info_slot) {
        if (info_slot.p && (!current || dirty[1] & /*$$scope*/
        134217728)) {
          update_slot_base(
            info_slot,
            info_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[58],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[58]
            ) : get_slot_changes(
              info_slot_template,
              /*$$scope*/
              ctx2[58],
              dirty,
              get_info_slot_changes
            ),
            get_info_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (info_slot)
        info_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(493:4) {#if info || hasInfoSlots}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block16,
    create_if_block_92,
    create_if_block_102,
    create_if_block_11,
    create_if_block_122,
    create_if_block_132,
    create_else_block_13
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*wrap*/
      ctx2[33]
    )
      return 0;
    if (
      /*type*/
      ctx2[1] === "select"
    )
      return 1;
    if (
      /*type*/
      ctx2[1] === "textarea"
    )
      return 2;
    if (
      /*type*/
      ctx2[1] === "toggle"
    )
      return 3;
    if (
      /*type*/
      ctx2[1] === "range"
    )
      return 4;
    if (
      /*type*/
      ctx2[1] === "texteditor"
    )
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let inputType;
  let needsValue;
  let inputValue;
  let classes;
  let wrapClasses;
  let inputClassName;
  let hasInfoSlots;
  let hasErrorSlots;
  const omit_props_names = [
    "class",
    "type",
    "name",
    "value",
    "placeholder",
    "inputId",
    "size",
    "accept",
    "autocomplete",
    "autocorrect",
    "autocapitalize",
    "spellcheck",
    "autofocus",
    "autosave",
    "checked",
    "disabled",
    "max",
    "min",
    "step",
    "maxlength",
    "minlength",
    "multiple",
    "readonly",
    "required",
    "inputStyle",
    "pattern",
    "validate",
    "validateOnBlur",
    "onValidate",
    "tabindex",
    "resizable",
    "clearButton",
    "noFormStoreData",
    "noStoreData",
    "ignoreStoreData",
    "errorMessage",
    "errorMessageForce",
    "info",
    "outline",
    "wrap",
    "dropdown",
    "calendarParams",
    "colorPickerParams",
    "textEditorParams"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, ["default", "error-message", "info"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { inputId = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { accept = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocorrect = void 0 } = $$props;
  let { autocapitalize = void 0 } = $$props;
  let { spellcheck = void 0 } = $$props;
  let { autofocus = void 0 } = $$props;
  let { autosave = void 0 } = $$props;
  let { checked = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { maxlength = void 0 } = $$props;
  let { minlength = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { inputStyle = void 0 } = $$props;
  let { pattern = void 0 } = $$props;
  let { validate = void 0 } = $$props;
  let { validateOnBlur = void 0 } = $$props;
  let { onValidate = void 0 } = $$props;
  let { tabindex = void 0 } = $$props;
  let { resizable = void 0 } = $$props;
  let { clearButton = void 0 } = $$props;
  let { noFormStoreData = void 0 } = $$props;
  let { noStoreData = void 0 } = $$props;
  let { ignoreStoreData = void 0 } = $$props;
  let { errorMessage = void 0 } = $$props;
  let { errorMessageForce = void 0 } = $$props;
  let { info = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { wrap = true } = $$props;
  let { dropdown = "auto" } = $$props;
  let { calendarParams = void 0 } = $$props;
  let { colorPickerParams = void 0 } = $$props;
  let { textEditorParams = void 0 } = $$props;
  let inputEl;
  let inputFocused = false;
  let inputInvalid = false;
  let updateInputOnDidUpdate = false;
  let f7Calendar;
  let f7ColorPicker;
  function domValue() {
    if (!inputEl)
      return void 0;
    return inputEl.value;
  }
  function inputHasValue() {
    if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
      return false;
    }
    const domV = domValue();
    return typeof value === "undefined" ? domV || domV === 0 : value || value === 0;
  }
  function validateInput() {
    if (!app.f7 || !inputEl)
      return;
    const validity = inputEl.validity;
    if (!validity)
      return;
    if (!validity.valid) {
      if (onValidate)
        onValidate(false);
      if (inputInvalid !== true) {
        $$invalidate(57, inputInvalid = true);
      }
    } else {
      if (onValidate)
        onValidate(true);
      if (inputInvalid !== false) {
        $$invalidate(57, inputInvalid = false);
      }
    }
  }
  let initialWatched = false;
  function watchValue() {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (type === "range" || type === "toggle")
      return;
    if (!app.f7)
      return;
    updateInputOnDidUpdate = true;
    if (f7Calendar) {
      f7Calendar.setValue(value);
    }
    if (f7ColorPicker) {
      f7ColorPicker.setValue(value);
    }
  }
  function onTextareaResize(event) {
    emit("textareaResize", [event]);
  }
  function onInputNotEmpty(event) {
    emit("inputNotEmpty", [event]);
  }
  function onInputEmpty(event) {
    emit("inputEmpty", [event]);
  }
  function onInputClear(event) {
    emit("inputClear", [event]);
  }
  function onInput(...args) {
    emit("input", [...args]);
    if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
      validateInput(inputEl);
    }
    if (inputEl && type !== "texteditor" && type !== "colorpicker" && type !== "datepicker") {
      $$invalidate(0, value = inputEl.value);
    }
  }
  function onFocus(...args) {
    emit("focus", [...args]);
    $$invalidate(56, inputFocused = true);
  }
  function onBlur(...args) {
    emit("blur", [...args]);
    if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
      validateInput();
    }
    $$invalidate(56, inputFocused = false);
  }
  function onChange(...args) {
    emit("change", [...args]);
    if (type === "texteditor") {
      emit("textEditorChange", [args[1]]);
      $$invalidate(0, value = args[1]);
    }
  }
  onMount(() => {
    f7ready(() => {
      if (type === "range" || type === "toggle")
        return;
      if (!inputEl)
        return;
      inputEl.addEventListener("input:notempty", onInputNotEmpty, false);
      if (type === "textarea" && resizable) {
        inputEl.addEventListener("textarea:resize", onTextareaResize, false);
      }
      if (clearButton) {
        inputEl.addEventListener("input:empty", onInputEmpty, false);
        inputEl.addEventListener("input:clear", onInputClear, false);
      }
      if (type === "datepicker") {
        f7Calendar = app.f7.calendar.create({
          inputEl,
          value,
          on: {
            change(calendar, calendarValue) {
              emit("calendarChange", [calendarValue]);
              $$invalidate(0, value = calendarValue);
            }
          },
          ...calendarParams || {}
        });
      }
      if (type === "colorpicker") {
        f7ColorPicker = app.f7.colorPicker.create({
          inputEl,
          value,
          on: {
            change(colorPicker, colorPickerValue) {
              emit("colorpickerChange", [colorPickerValue]);
              $$invalidate(0, value = colorPickerValue);
            }
          },
          ...colorPickerParams || {}
        });
      }
      app.f7.input.checkEmptyState(inputEl);
      if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && typeof value !== "undefined" && value !== null && value !== "") {
        setTimeout(
          () => {
            validateInput();
          },
          0
        );
      }
      if (resizable) {
        app.f7.input.resizeTextarea(inputEl);
      }
    });
  });
  afterUpdate(() => {
    if (!app.f7)
      return;
    if (updateInputOnDidUpdate) {
      if (!inputEl)
        return;
      updateInputOnDidUpdate = false;
      app.f7.input.checkEmptyState(inputEl);
      if (validate && !validateOnBlur) {
        validateInput();
      }
      if (resizable) {
        app.f7.input.resizeTextarea(inputEl);
      }
    }
  });
  onDestroy(() => {
    if (type === "range" || type === "toggle")
      return;
    if (!inputEl)
      return;
    inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);
    if (type === "textarea" && resizable) {
      inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
    }
    if (clearButton) {
      inputEl.removeEventListener("input:empty", onInputEmpty, false);
      inputEl.removeEventListener("input:clear", onInputClear, false);
    }
    if (f7Calendar && f7Calendar.destroy) {
      f7Calendar.destroy();
    }
    if (f7ColorPicker && f7ColorPicker.destroy) {
      f7ColorPicker.destroy();
    }
    f7Calendar = null;
    f7ColorPicker = null;
  });
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  function select_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  function textarea_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(36, inputEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(82, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(46, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(47, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("inputId" in $$new_props)
      $$invalidate(4, inputId = $$new_props.inputId);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("accept" in $$new_props)
      $$invalidate(6, accept = $$new_props.accept);
    if ("autocomplete" in $$new_props)
      $$invalidate(7, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$new_props)
      $$invalidate(8, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$new_props)
      $$invalidate(9, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$new_props)
      $$invalidate(10, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$new_props)
      $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("autosave" in $$new_props)
      $$invalidate(12, autosave = $$new_props.autosave);
    if ("checked" in $$new_props)
      $$invalidate(13, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("max" in $$new_props)
      $$invalidate(15, max = $$new_props.max);
    if ("min" in $$new_props)
      $$invalidate(16, min = $$new_props.min);
    if ("step" in $$new_props)
      $$invalidate(17, step = $$new_props.step);
    if ("maxlength" in $$new_props)
      $$invalidate(18, maxlength = $$new_props.maxlength);
    if ("minlength" in $$new_props)
      $$invalidate(19, minlength = $$new_props.minlength);
    if ("multiple" in $$new_props)
      $$invalidate(20, multiple = $$new_props.multiple);
    if ("readonly" in $$new_props)
      $$invalidate(21, readonly = $$new_props.readonly);
    if ("required" in $$new_props)
      $$invalidate(22, required = $$new_props.required);
    if ("inputStyle" in $$new_props)
      $$invalidate(23, inputStyle = $$new_props.inputStyle);
    if ("pattern" in $$new_props)
      $$invalidate(24, pattern = $$new_props.pattern);
    if ("validate" in $$new_props)
      $$invalidate(25, validate = $$new_props.validate);
    if ("validateOnBlur" in $$new_props)
      $$invalidate(26, validateOnBlur = $$new_props.validateOnBlur);
    if ("onValidate" in $$new_props)
      $$invalidate(48, onValidate = $$new_props.onValidate);
    if ("tabindex" in $$new_props)
      $$invalidate(27, tabindex = $$new_props.tabindex);
    if ("resizable" in $$new_props)
      $$invalidate(28, resizable = $$new_props.resizable);
    if ("clearButton" in $$new_props)
      $$invalidate(29, clearButton = $$new_props.clearButton);
    if ("noFormStoreData" in $$new_props)
      $$invalidate(49, noFormStoreData = $$new_props.noFormStoreData);
    if ("noStoreData" in $$new_props)
      $$invalidate(50, noStoreData = $$new_props.noStoreData);
    if ("ignoreStoreData" in $$new_props)
      $$invalidate(51, ignoreStoreData = $$new_props.ignoreStoreData);
    if ("errorMessage" in $$new_props)
      $$invalidate(30, errorMessage = $$new_props.errorMessage);
    if ("errorMessageForce" in $$new_props)
      $$invalidate(31, errorMessageForce = $$new_props.errorMessageForce);
    if ("info" in $$new_props)
      $$invalidate(32, info = $$new_props.info);
    if ("outline" in $$new_props)
      $$invalidate(52, outline = $$new_props.outline);
    if ("wrap" in $$new_props)
      $$invalidate(33, wrap = $$new_props.wrap);
    if ("dropdown" in $$new_props)
      $$invalidate(53, dropdown = $$new_props.dropdown);
    if ("calendarParams" in $$new_props)
      $$invalidate(54, calendarParams = $$new_props.calendarParams);
    if ("colorPickerParams" in $$new_props)
      $$invalidate(55, colorPickerParams = $$new_props.colorPickerParams);
    if ("textEditorParams" in $$new_props)
      $$invalidate(34, textEditorParams = $$new_props.textEditorParams);
    if ("$$scope" in $$new_props)
      $$invalidate(58, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    afterUpdate,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    Toggle: toggle_default,
    Range: range_default,
    TextEditor: text_editor_default,
    emit,
    className,
    type,
    name,
    value,
    placeholder,
    inputId,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    checked,
    disabled,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    readonly,
    required,
    inputStyle,
    pattern,
    validate,
    validateOnBlur,
    onValidate,
    tabindex,
    resizable,
    clearButton,
    noFormStoreData,
    noStoreData,
    ignoreStoreData,
    errorMessage,
    errorMessageForce,
    info,
    outline,
    wrap,
    dropdown,
    calendarParams,
    colorPickerParams,
    textEditorParams,
    inputEl,
    inputFocused,
    inputInvalid,
    updateInputOnDidUpdate,
    f7Calendar,
    f7ColorPicker,
    domValue,
    inputHasValue,
    validateInput,
    initialWatched,
    watchValue,
    onTextareaResize,
    onInputNotEmpty,
    onInputEmpty,
    onInputClear,
    onInput,
    onFocus,
    onBlur,
    onChange,
    hasErrorSlots,
    hasInfoSlots,
    inputType,
    inputClassName,
    wrapClasses,
    classes,
    inputValue,
    needsValue
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(82, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(47, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("inputId" in $$props)
      $$invalidate(4, inputId = $$new_props.inputId);
    if ("size" in $$props)
      $$invalidate(5, size = $$new_props.size);
    if ("accept" in $$props)
      $$invalidate(6, accept = $$new_props.accept);
    if ("autocomplete" in $$props)
      $$invalidate(7, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$props)
      $$invalidate(8, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$props)
      $$invalidate(9, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$props)
      $$invalidate(10, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$props)
      $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("autosave" in $$props)
      $$invalidate(12, autosave = $$new_props.autosave);
    if ("checked" in $$props)
      $$invalidate(13, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("max" in $$props)
      $$invalidate(15, max = $$new_props.max);
    if ("min" in $$props)
      $$invalidate(16, min = $$new_props.min);
    if ("step" in $$props)
      $$invalidate(17, step = $$new_props.step);
    if ("maxlength" in $$props)
      $$invalidate(18, maxlength = $$new_props.maxlength);
    if ("minlength" in $$props)
      $$invalidate(19, minlength = $$new_props.minlength);
    if ("multiple" in $$props)
      $$invalidate(20, multiple = $$new_props.multiple);
    if ("readonly" in $$props)
      $$invalidate(21, readonly = $$new_props.readonly);
    if ("required" in $$props)
      $$invalidate(22, required = $$new_props.required);
    if ("inputStyle" in $$props)
      $$invalidate(23, inputStyle = $$new_props.inputStyle);
    if ("pattern" in $$props)
      $$invalidate(24, pattern = $$new_props.pattern);
    if ("validate" in $$props)
      $$invalidate(25, validate = $$new_props.validate);
    if ("validateOnBlur" in $$props)
      $$invalidate(26, validateOnBlur = $$new_props.validateOnBlur);
    if ("onValidate" in $$props)
      $$invalidate(48, onValidate = $$new_props.onValidate);
    if ("tabindex" in $$props)
      $$invalidate(27, tabindex = $$new_props.tabindex);
    if ("resizable" in $$props)
      $$invalidate(28, resizable = $$new_props.resizable);
    if ("clearButton" in $$props)
      $$invalidate(29, clearButton = $$new_props.clearButton);
    if ("noFormStoreData" in $$props)
      $$invalidate(49, noFormStoreData = $$new_props.noFormStoreData);
    if ("noStoreData" in $$props)
      $$invalidate(50, noStoreData = $$new_props.noStoreData);
    if ("ignoreStoreData" in $$props)
      $$invalidate(51, ignoreStoreData = $$new_props.ignoreStoreData);
    if ("errorMessage" in $$props)
      $$invalidate(30, errorMessage = $$new_props.errorMessage);
    if ("errorMessageForce" in $$props)
      $$invalidate(31, errorMessageForce = $$new_props.errorMessageForce);
    if ("info" in $$props)
      $$invalidate(32, info = $$new_props.info);
    if ("outline" in $$props)
      $$invalidate(52, outline = $$new_props.outline);
    if ("wrap" in $$props)
      $$invalidate(33, wrap = $$new_props.wrap);
    if ("dropdown" in $$props)
      $$invalidate(53, dropdown = $$new_props.dropdown);
    if ("calendarParams" in $$props)
      $$invalidate(54, calendarParams = $$new_props.calendarParams);
    if ("colorPickerParams" in $$props)
      $$invalidate(55, colorPickerParams = $$new_props.colorPickerParams);
    if ("textEditorParams" in $$props)
      $$invalidate(34, textEditorParams = $$new_props.textEditorParams);
    if ("inputEl" in $$props)
      $$invalidate(36, inputEl = $$new_props.inputEl);
    if ("inputFocused" in $$props)
      $$invalidate(56, inputFocused = $$new_props.inputFocused);
    if ("inputInvalid" in $$props)
      $$invalidate(57, inputInvalid = $$new_props.inputInvalid);
    if ("updateInputOnDidUpdate" in $$props)
      updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
    if ("f7Calendar" in $$props)
      f7Calendar = $$new_props.f7Calendar;
    if ("f7ColorPicker" in $$props)
      f7ColorPicker = $$new_props.f7ColorPicker;
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("hasErrorSlots" in $$props)
      $$invalidate(37, hasErrorSlots = $$new_props.hasErrorSlots);
    if ("hasInfoSlots" in $$props)
      $$invalidate(38, hasInfoSlots = $$new_props.hasInfoSlots);
    if ("inputType" in $$props)
      $$invalidate(35, inputType = $$new_props.inputType);
    if ("inputClassName" in $$props)
      $$invalidate(39, inputClassName = $$new_props.inputClassName);
    if ("wrapClasses" in $$props)
      $$invalidate(40, wrapClasses = $$new_props.wrapClasses);
    if ("classes" in $$props)
      classes = $$new_props.classes;
    if ("inputValue" in $$props)
      $$invalidate(41, inputValue = $$new_props.inputValue);
    if ("needsValue" in $$props)
      needsValue = $$new_props.needsValue;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        watchValue(value);
    }
    if ($$self.$$.dirty[0] & /*type*/
    2) {
      $:
        $$invalidate(35, inputType = type === "datepicker" || type === "colorpicker" ? "text" : type);
    }
    if ($$self.$$.dirty[0] & /*type*/
    2) {
      $:
        needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        $$invalidate(41, inputValue = (() => {
          let v;
          if (typeof value !== "undefined") {
            v = value;
          } else {
            v = domValue();
          }
          if (typeof v === "undefined" || v === null)
            return "";
          return v;
        })());
    }
    if ($$self.$$.dirty[0] & /*resizable, errorMessage*/
    1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/
    102563861) {
      $:
        classes = classNames(!wrap && className, {
          resizable: inputType === "textarea" && resizable,
          "no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
          "input-invalid": errorMessage && errorMessageForce || inputInvalid,
          "input-with-value": inputHasValue(),
          "input-focused": inputFocused
        });
    }
    $:
      $$invalidate(40, wrapClasses = classNames(
        className,
        "input",
        {
          "input-outline": outline,
          "input-dropdown": dropdown === "auto" ? type === "select" : dropdown,
          "input-invalid": errorMessage && errorMessageForce || inputInvalid
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*resizable, errorMessage*/
    1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/
    102563861) {
      $:
        $$invalidate(39, inputClassName = classNames(!wrap && className, {
          resizable: inputType === "textarea" && resizable,
          "no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
          "input-invalid": errorMessage && errorMessageForce || inputInvalid,
          "input-with-value": inputHasValue(),
          "input-focused": inputFocused
        }));
    }
  };
  $:
    $$invalidate(38, hasInfoSlots = $$slots.info);
  $:
    $$invalidate(37, hasErrorSlots = $$slots["error-message"]);
  $$props = exclude_internal_props($$props);
  return [
    value,
    type,
    name,
    placeholder,
    inputId,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    checked,
    disabled,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    readonly,
    required,
    inputStyle,
    pattern,
    validate,
    validateOnBlur,
    tabindex,
    resizable,
    clearButton,
    errorMessage,
    errorMessageForce,
    info,
    wrap,
    textEditorParams,
    inputType,
    inputEl,
    hasErrorSlots,
    hasInfoSlots,
    inputClassName,
    wrapClasses,
    inputValue,
    onInput,
    onFocus,
    onBlur,
    onChange,
    $$restProps,
    className,
    onValidate,
    noFormStoreData,
    noStoreData,
    ignoreStoreData,
    outline,
    dropdown,
    calendarParams,
    colorPickerParams,
    inputFocused,
    inputInvalid,
    $$scope,
    slots,
    select_binding,
    textarea_binding,
    input_binding,
    select_binding_1,
    textarea_binding_1,
    input_binding_1
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment49,
      safe_not_equal,
      {
        class: 47,
        type: 1,
        name: 2,
        value: 0,
        placeholder: 3,
        inputId: 4,
        size: 5,
        accept: 6,
        autocomplete: 7,
        autocorrect: 8,
        autocapitalize: 9,
        spellcheck: 10,
        autofocus: 11,
        autosave: 12,
        checked: 13,
        disabled: 14,
        max: 15,
        min: 16,
        step: 17,
        maxlength: 18,
        minlength: 19,
        multiple: 20,
        readonly: 21,
        required: 22,
        inputStyle: 23,
        pattern: 24,
        validate: 25,
        validateOnBlur: 26,
        onValidate: 48,
        tabindex: 27,
        resizable: 28,
        clearButton: 29,
        noFormStoreData: 49,
        noStoreData: 50,
        ignoreStoreData: 51,
        errorMessage: 30,
        errorMessageForce: 31,
        info: 32,
        outline: 52,
        wrap: 33,
        dropdown: 53,
        calendarParams: 54,
        colorPickerParams: 55,
        textEditorParams: 34
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment49.name
    });
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocorrect() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocorrect(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocapitalize() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocapitalize(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spellcheck() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spellcheck(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autosave() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autosave(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minlength() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minlength(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyle() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyle(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validate(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateOnBlur() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateOnBlur(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValidate() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValidate(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButton() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButton(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noFormStoreData() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noFormStoreData(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noStoreData() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noStoreData(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignoreStoreData() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignoreStoreData(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorMessage() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorMessage(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorMessageForce() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorMessageForce(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdown() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdown(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calendarParams() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set calendarParams(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorPickerParams() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorPickerParams(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textEditorParams() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textEditorParams(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var input_default = Input;

// node_modules/framework7-svelte/shared/use-smart-select.js
var useSmartSelect = (props, setInstance, getEl) => {
  let f7SmartSelect;
  onMount(() => {
    f7ready(() => {
      if (props.smartSelect) {
        const ssParams = extend({
          el: getEl()
        }, props.smartSelectParams || {});
        f7SmartSelect = app.f7.smartSelect.create(ssParams);
        setInstance(f7SmartSelect);
      }
    });
  });
  onDestroy(() => {
    if (f7SmartSelect && f7SmartSelect.destroy) {
      f7SmartSelect.destroy();
    }
    f7SmartSelect = null;
    setInstance(f7SmartSelect);
  });
};

// node_modules/framework7-svelte/shared/get-reactive-context.js
var getReactiveContext = (name, setValue) => {
  const ctx = getContext(name);
  if (!ctx)
    return void 0;
  const {
    value,
    subscribe,
    unsubscribe
  } = ctx;
  subscribe(setValue);
  onDestroy(() => {
    unsubscribe(setValue);
  });
  return value;
};

// node_modules/framework7-svelte/components/link.svelte
var file47 = "node_modules/framework7-svelte/components/link.svelte";
function create_if_block_210(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256)
        useicon_changes.icon = /*icon*/
        ctx2[8];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(114:2) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let span;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let current;
  let if_block = typeof /*badge*/
  ctx[1] !== "undefined" && create_if_block_110(ctx);
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      toggle_class(
        span,
        "tabbar-label",
        /*isTabbarLabel*/
        ctx[6]
      );
      add_location(span, file47, 118, 4, 3035);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t0);
      append_dev(span, t1);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (typeof /*badge*/
      ctx2[1] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_110(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*isTabbarLabel*/
      64) {
        toggle_class(
          span,
          "tabbar-label",
          /*isTabbarLabel*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(118:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      4)
        badge_1_changes.color = /*badgeColor*/
        ctx2[2];
      if (dirty[0] & /*$$scope, badge*/
      536870914) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(121:6) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[1]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      2 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[1]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(121:40) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let a;
  let t0;
  let t1;
  let useTooltip_action;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_210(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  let if_block1 = (typeof /*text*/
  ctx[0] !== "undefined" || typeof /*badge*/
  ctx[1] !== "undefined") && create_if_block17(ctx);
  let a_levels = [
    { class: (
      /*classes*/
      ctx[9]
    ) },
    /*attrs*/
    ctx[10]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      set_attributes(a, a_data);
      add_location(a, file47, 105, 0, 2754);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (if_block0)
        if_block0.m(a, null);
      append_dev(a, t0);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_dev(a, t1);
      if (if_block1)
        if_block1.m(a, null);
      ctx[28](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[3]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[4]
            )
          })),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[5]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_210(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(a, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined" || typeof /*badge*/
      ctx2[1] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*text, badge*/
          3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[0] & /*classes*/
        512) && { class: (
          /*classes*/
          ctx2[9]
        ) },
        dirty[0] & /*attrs*/
        1024 && /*attrs*/
        ctx2[10]
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      24)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[3]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[4]
          )
        });
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      32)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[5]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let isTabbarLabel;
  let hrefComputed;
  let attrs;
  let hasDefaultSlots;
  let iconOnlyComputed;
  let classes;
  let icon;
  const omit_props_names = [
    "class",
    "noLinkClass",
    "text",
    "tabLink",
    "tabLinkActive",
    "tabbarLabel",
    "iconOnly",
    "badge",
    "badgeColor",
    "href",
    "target",
    "tooltip",
    "tooltipTrigger",
    "routeProps",
    "smartSelect",
    "smartSelectParams",
    "smartSelectInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { noLinkClass = false } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { tabbarLabel = false } = $$props;
  let { iconOnly = false } = $$props;
  let { badge = void 0 } = $$props;
  let { badgeColor = void 0 } = $$props;
  let { href = "#" } = $$props;
  let { target = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let { smartSelect = false } = $$props;
  let { smartSelectParams = void 0 } = $$props;
  let el;
  let f7SmartSelect;
  function smartSelectInstance() {
    return f7SmartSelect;
  }
  let TabbarContext = getReactiveContext("TabbarContext", (newValue) => {
    $$invalidate(23, TabbarContext = newValue);
  }) || {};
  function onClick() {
    emit("click");
  }
  useSmartSelect(
    { smartSelect, smartSelectParams },
    (instance87) => {
      f7SmartSelect = instance87;
    },
    () => el
  );
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(34, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("noLinkClass" in $$new_props)
      $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$new_props)
      $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props)
      $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("tabbarLabel" in $$new_props)
      $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    if ("iconOnly" in $$new_props)
      $$invalidate(17, iconOnly = $$new_props.iconOnly);
    if ("badge" in $$new_props)
      $$invalidate(1, badge = $$new_props.badge);
    if ("badgeColor" in $$new_props)
      $$invalidate(2, badgeColor = $$new_props.badgeColor);
    if ("href" in $$new_props)
      $$invalidate(18, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(19, target = $$new_props.target);
    if ("tooltip" in $$new_props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props)
      $$invalidate(5, routeProps = $$new_props.routeProps);
    if ("smartSelect" in $$new_props)
      $$invalidate(20, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$new_props)
      $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsAttrs,
    actionsClasses,
    classNames,
    extend,
    isStringProp,
    plainText,
    createEmitter,
    restProps,
    useTooltip,
    useSmartSelect,
    useRouteProps,
    useIcon,
    getReactiveContext,
    UseIcon: use_icon_default,
    Badge: badge_default,
    emit,
    className,
    noLinkClass,
    text: text2,
    tabLink,
    tabLinkActive,
    tabbarLabel,
    iconOnly,
    badge,
    badgeColor,
    href,
    target,
    tooltip,
    tooltipTrigger,
    routeProps,
    smartSelect,
    smartSelectParams,
    el,
    f7SmartSelect,
    smartSelectInstance,
    TabbarContext,
    onClick,
    icon,
    iconOnlyComputed,
    isTabbarLabel,
    classes,
    hasDefaultSlots,
    hrefComputed,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("noLinkClass" in $$props)
      $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$props)
      $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$props)
      $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("tabbarLabel" in $$props)
      $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    if ("iconOnly" in $$props)
      $$invalidate(17, iconOnly = $$new_props.iconOnly);
    if ("badge" in $$props)
      $$invalidate(1, badge = $$new_props.badge);
    if ("badgeColor" in $$props)
      $$invalidate(2, badgeColor = $$new_props.badgeColor);
    if ("href" in $$props)
      $$invalidate(18, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(19, target = $$new_props.target);
    if ("tooltip" in $$props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$props)
      $$invalidate(5, routeProps = $$new_props.routeProps);
    if ("smartSelect" in $$props)
      $$invalidate(20, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$props)
      $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    if ("el" in $$props)
      $$invalidate(7, el = $$new_props.el);
    if ("f7SmartSelect" in $$props)
      f7SmartSelect = $$new_props.f7SmartSelect;
    if ("TabbarContext" in $$props)
      $$invalidate(23, TabbarContext = $$new_props.TabbarContext);
    if ("icon" in $$props)
      $$invalidate(8, icon = $$new_props.icon);
    if ("iconOnlyComputed" in $$props)
      $$invalidate(24, iconOnlyComputed = $$new_props.iconOnlyComputed);
    if ("isTabbarLabel" in $$props)
      $$invalidate(6, isTabbarLabel = $$new_props.isTabbarLabel);
    if ("classes" in $$props)
      $$invalidate(9, classes = $$new_props.classes);
    if ("hasDefaultSlots" in $$props)
      $$invalidate(25, hasDefaultSlots = $$new_props.hasDefaultSlots);
    if ("hrefComputed" in $$props)
      $$invalidate(26, hrefComputed = $$new_props.hrefComputed);
    if ("attrs" in $$props)
      $$invalidate(10, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/
    8454144) {
      $:
        $$invalidate(6, isTabbarLabel = tabbarLabel || TabbarContext.tabbarHasLabels);
    }
    if ($$self.$$.dirty[0] & /*href*/
    262144) {
      $:
        $$invalidate(26, hrefComputed = href === true ? "#" : href || void 0);
    }
    $:
      $$invalidate(10, attrs = extend(
        {
          href: hrefComputed,
          target,
          "data-tab": isStringProp(tabLink) && tabLink || void 0,
          ...restProps($$restProps)
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/
    33685505) {
      $:
        $$invalidate(24, iconOnlyComputed = iconOnly || !text2 && !hasDefaultSlots);
    }
    $:
      $$invalidate(9, classes = classNames(
        className,
        {
          link: !(noLinkClass || isTabbarLabel),
          "icon-only": iconOnlyComputed,
          "tab-link": tabLink || tabLink === "",
          "tab-link-active": tabLinkActive,
          "smart-select": smartSelect
        },
        colorClasses($$props),
        routerClasses($$props),
        actionsClasses($$props)
      ));
    $:
      $$invalidate(8, icon = useIcon($$props));
  };
  $:
    $$invalidate(25, hasDefaultSlots = $$slots.default);
  $$props = exclude_internal_props($$props);
  return [
    text2,
    badge,
    badgeColor,
    tooltip,
    tooltipTrigger,
    routeProps,
    isTabbarLabel,
    el,
    icon,
    classes,
    attrs,
    onClick,
    className,
    noLinkClass,
    tabLink,
    tabLinkActive,
    tabbarLabel,
    iconOnly,
    href,
    target,
    smartSelect,
    smartSelectParams,
    smartSelectInstance,
    TabbarContext,
    iconOnlyComputed,
    hasDefaultSlots,
    hrefComputed,
    slots,
    a_binding,
    $$scope
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment50,
      safe_not_equal,
      {
        class: 12,
        noLinkClass: 13,
        text: 0,
        tabLink: 14,
        tabLinkActive: 15,
        tabbarLabel: 16,
        iconOnly: 17,
        badge: 1,
        badgeColor: 2,
        href: 18,
        target: 19,
        tooltip: 3,
        tooltipTrigger: 4,
        routeProps: 5,
        smartSelect: 20,
        smartSelectParams: 21,
        smartSelectInstance: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment50.name
    });
  }
  get class() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLinkClass() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLinkClass(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLink() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLink(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLinkActive() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLinkActive(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbarLabel() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbarLabel(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconOnly() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconOnly(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badge() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badge(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badgeColor() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badgeColor(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelect() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smartSelect(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelectParams() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smartSelectParams(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelectInstance() {
    return this.$$.ctx[22];
  }
  set smartSelectInstance(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var link_default = Link;

// node_modules/framework7-svelte/components/list-button.svelte
var file48 = "node_modules/framework7-svelte/components/list-button.svelte";
function create_fragment51(ctx) {
  let li;
  let a;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let t2_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t2;
  let t3;
  let useRouteProps_action;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let a_levels = [
    { class: (
      /*classes*/
      ctx[7]
    ) },
    /*attrs*/
    ctx[8]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  let li_levels = [{ class: (
    /*className*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[10]
  )];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file48, 68, 2, 1746);
      set_attributes(li, li_data);
      add_location(li, file48, 61, 0, 1591);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, t0);
      append_dev(a, t1);
      append_dev(a, t2);
      append_dev(a, t3);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[19](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            li,
            /*routeProps*/
            ctx[5]
          )),
          action_destroyer(useTooltip_action = useTooltip.call(null, li, {
            tooltip: (
              /*tooltip*/
              ctx[3]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[4]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if ((!current || dirty & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if ((!current || dirty & /*text*/
      4) && t2_value !== (t2_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) },
        dirty & /*attrs*/
        256 && /*attrs*/
        ctx2[8]
      ]));
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*className*/
        1) && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        1024 && restProps(
          /*$$restProps*/
          ctx2[10]
        )
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/
      32)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[5]
        );
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      24)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[3]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[4]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let hrefComputed;
  let attrs;
  let classes;
  const omit_props_names = [
    "class",
    "title",
    "text",
    "tabLink",
    "tabLinkActive",
    "link",
    "href",
    "target",
    "tooltip",
    "tooltipTrigger",
    "routeProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_button", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { link = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(6, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("tabLink" in $$new_props)
      $$invalidate(11, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props)
      $$invalidate(12, tabLinkActive = $$new_props.tabLinkActive);
    if ("link" in $$new_props)
      $$invalidate(13, link = $$new_props.link);
    if ("href" in $$new_props)
      $$invalidate(14, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(15, target = $$new_props.target);
    if ("tooltip" in $$new_props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props)
      $$invalidate(5, routeProps = $$new_props.routeProps);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsAttrs,
    actionsClasses,
    classNames,
    extend,
    plainText,
    isStringProp,
    createEmitter,
    restProps,
    useTooltip,
    useRouteProps,
    emit,
    className,
    title,
    text: text2,
    tabLink,
    tabLinkActive,
    link,
    href,
    target,
    tooltip,
    tooltipTrigger,
    routeProps,
    el,
    onClick,
    classes,
    hrefComputed,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("tabLink" in $$props)
      $$invalidate(11, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$props)
      $$invalidate(12, tabLinkActive = $$new_props.tabLinkActive);
    if ("link" in $$props)
      $$invalidate(13, link = $$new_props.link);
    if ("href" in $$props)
      $$invalidate(14, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(15, target = $$new_props.target);
    if ("tooltip" in $$props)
      $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$props)
      $$invalidate(5, routeProps = $$new_props.routeProps);
    if ("el" in $$props)
      $$invalidate(6, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
    if ("hrefComputed" in $$props)
      $$invalidate(16, hrefComputed = $$new_props.hrefComputed);
    if ("attrs" in $$props)
      $$invalidate(8, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*link, href*/
    24576) {
      $:
        $$invalidate(16, hrefComputed = typeof link === "boolean" && typeof href === "boolean" ? "#" : link || href);
    }
    $:
      $$invalidate(8, attrs = extend(
        {
          href: hrefComputed,
          target,
          "data-tab": isStringProp(tabLink) && tabLink || void 0
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    $:
      $$invalidate(7, classes = classNames(
        {
          "list-button": true,
          "tab-link": tabLink || tabLink === "",
          "tab-link-active": tabLinkActive
        },
        colorClasses($$props),
        routerClasses($$props),
        actionsClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    className,
    title,
    text2,
    tooltip,
    tooltipTrigger,
    routeProps,
    el,
    classes,
    attrs,
    onClick,
    $$restProps,
    tabLink,
    tabLinkActive,
    link,
    href,
    target,
    hrefComputed,
    $$scope,
    slots,
    li_binding
  ];
}
var List_button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment51, safe_not_equal, {
      class: 0,
      title: 1,
      text: 2,
      tabLink: 11,
      tabLinkActive: 12,
      link: 13,
      href: 14,
      target: 15,
      tooltip: 3,
      tooltipTrigger: 4,
      routeProps: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_button",
      options,
      id: create_fragment51.name
    });
  }
  get class() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLink() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLink(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLinkActive() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLinkActive(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_button_default = List_button;

// node_modules/framework7-svelte/shared/set-reactive-context.js
var setReactiveContext = (name, getValue) => {
  const contextCallbacks = [];
  const contextSubscribe = (callback) => {
    contextCallbacks.push(callback);
  };
  const contextUnsubscribe = (callback) => {
    if (contextCallbacks.indexOf(callback) >= 0) {
      contextCallbacks.splice(contextCallbacks.indexOf, callback);
    }
  };
  const contextRunCallbacks = () => {
    contextCallbacks.forEach((callback) => {
      callback(getValue());
    });
  };
  setContext(name, {
    value: getValue(),
    subscribe: contextSubscribe,
    unsubscribe: contextUnsubscribe
  });
  beforeUpdate(() => {
    contextRunCallbacks();
  });
};

// node_modules/framework7-svelte/components/list-group.svelte
var file49 = "node_modules/framework7-svelte/components/list-group.svelte";
function create_fragment52(ctx) {
  let div;
  let ul;
  let div_data_sortable_move_elements_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[1]
    ) },
    {
      "data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
      ctx[0] !== "undefined" ? (
        /*sortableMoveElements*/
        ctx[0].toString()
      ) : void 0
    },
    restProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      add_location(ul, file49, 49, 2, 1486);
      set_attributes(div, div_data);
      add_location(div, file49, 42, 0, 1299);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*sortableMoveElements*/
        1 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
        ctx2[0] !== "undefined" ? (
          /*sortableMoveElements*/
          ctx2[0].toString()
        ) : void 0)) && {
          "data-sortable-move-elements": div_data_sortable_move_elements_value
        },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "mediaList",
    "sortable",
    "sortableOpposite",
    "sortableTapHold",
    "sortableMoveElements",
    "simpleList"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_group", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { mediaList = void 0 } = $$props;
  let { sortable = void 0 } = $$props;
  let { sortableOpposite = void 0 } = $$props;
  let { sortableTapHold = false } = $$props;
  let { sortableMoveElements = void 0 } = $$props;
  let { simpleList = void 0 } = $$props;
  let ListContext = getReactiveContext("ListContext", (value) => {
    ListContext = value || {};
  }) || {};
  setReactiveContext("ListContext", () => ({
    listIsMedia: mediaList || ListContext.listIsMedia,
    listIsSimple: simpleList || ListContext.listIsSimple,
    listIsSortable: sortable || ListContext.listIsSortable,
    listIsSortableOpposite: sortableOpposite || ListContext.listIsSortableOpposite
  }));
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("mediaList" in $$new_props)
      $$invalidate(4, mediaList = $$new_props.mediaList);
    if ("sortable" in $$new_props)
      $$invalidate(5, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$new_props)
      $$invalidate(6, sortableOpposite = $$new_props.sortableOpposite);
    if ("sortableTapHold" in $$new_props)
      $$invalidate(7, sortableTapHold = $$new_props.sortableTapHold);
    if ("sortableMoveElements" in $$new_props)
      $$invalidate(0, sortableMoveElements = $$new_props.sortableMoveElements);
    if ("simpleList" in $$new_props)
      $$invalidate(8, simpleList = $$new_props.simpleList);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    setReactiveContext,
    getReactiveContext,
    className,
    mediaList,
    sortable,
    sortableOpposite,
    sortableTapHold,
    sortableMoveElements,
    simpleList,
    ListContext,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("mediaList" in $$props)
      $$invalidate(4, mediaList = $$new_props.mediaList);
    if ("sortable" in $$props)
      $$invalidate(5, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$props)
      $$invalidate(6, sortableOpposite = $$new_props.sortableOpposite);
    if ("sortableTapHold" in $$props)
      $$invalidate(7, sortableTapHold = $$new_props.sortableTapHold);
    if ("sortableMoveElements" in $$props)
      $$invalidate(0, sortableMoveElements = $$new_props.sortableMoveElements);
    if ("simpleList" in $$props)
      $$invalidate(8, simpleList = $$new_props.simpleList);
    if ("ListContext" in $$props)
      ListContext = $$new_props.ListContext;
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classes = classNames(
        className,
        "list-group",
        {
          "media-list": mediaList,
          sortable,
          "sortable-tap-hold": sortableTapHold,
          "sortable-opposite": sortableOpposite
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    sortableMoveElements,
    classes,
    $$restProps,
    className,
    mediaList,
    sortable,
    sortableOpposite,
    sortableTapHold,
    simpleList,
    $$scope,
    slots
  ];
}
var List_group = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment52, safe_not_equal, {
      class: 3,
      mediaList: 4,
      sortable: 5,
      sortableOpposite: 6,
      sortableTapHold: 7,
      sortableMoveElements: 0,
      simpleList: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_group",
      options,
      id: create_fragment52.name
    });
  }
  get class() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaList() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaList(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableOpposite() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableOpposite(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableTapHold() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableTapHold(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableMoveElements() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableMoveElements(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get simpleList() {
    throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set simpleList(value) {
    throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_group_default = List_group;

// node_modules/framework7-svelte/components/list-index.svelte
var file50 = "node_modules/framework7-svelte/components/list-index.svelte";
var get_default_slot_changes10 = (dirty) => ({ listIndex: dirty & /*f7ListIndex*/
4 });
var get_default_slot_context10 = (ctx) => ({ listIndex: (
  /*f7ListIndex*/
  ctx[2]
) });
function create_fragment53(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context10
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file50, 81, 0, 1906);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[19](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7ListIndex*/
        131076)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*f7Slot*/
        1) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_111($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "init",
    "listEl",
    "indexes",
    "scrollList",
    "label",
    "iosItemHeight",
    "mdItemHeight",
    "auroraItemHeight",
    "f7Slot",
    "instance",
    "update",
    "scrollListToIndex"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_index", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { listEl = void 0 } = $$props;
  let { indexes = "auto" } = $$props;
  let { scrollList = true } = $$props;
  let { label = false } = $$props;
  let { iosItemHeight = 14 } = $$props;
  let { mdItemHeight = 14 } = $$props;
  let { auroraItemHeight = 14 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let f7ListIndex;
  function instance87() {
    return f7ListIndex;
  }
  function update() {
    if (!f7ListIndex)
      return;
    f7ListIndex.update();
  }
  function scrollListToIndex(indexContent) {
    if (!f7ListIndex)
      return;
    f7ListIndex.scrollListToIndex(indexContent);
  }
  let initialWatched = false;
  function watchIndexes() {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7ListIndex)
      return;
    $$invalidate(2, f7ListIndex.params.indexes = indexes, f7ListIndex);
    update();
  }
  onMount(() => {
    if (!init2 || !el)
      return;
    f7ready(() => {
      $$invalidate(2, f7ListIndex = app.f7.listIndex.create({
        el,
        listEl,
        indexes,
        iosItemHeight,
        mdItemHeight,
        auroraItemHeight,
        scrollList,
        label,
        on: {
          select(index, itemContent, itemIndex) {
            emit("listIndexSelect", [itemContent, itemIndex]);
          }
        }
      }));
    });
  });
  onDestroy(() => {
    if (f7ListIndex && f7ListIndex.destroy)
      f7ListIndex.destroy();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("init" in $$new_props)
      $$invalidate(6, init2 = $$new_props.init);
    if ("listEl" in $$new_props)
      $$invalidate(7, listEl = $$new_props.listEl);
    if ("indexes" in $$new_props)
      $$invalidate(8, indexes = $$new_props.indexes);
    if ("scrollList" in $$new_props)
      $$invalidate(9, scrollList = $$new_props.scrollList);
    if ("label" in $$new_props)
      $$invalidate(10, label = $$new_props.label);
    if ("iosItemHeight" in $$new_props)
      $$invalidate(11, iosItemHeight = $$new_props.iosItemHeight);
    if ("mdItemHeight" in $$new_props)
      $$invalidate(12, mdItemHeight = $$new_props.mdItemHeight);
    if ("auroraItemHeight" in $$new_props)
      $$invalidate(13, auroraItemHeight = $$new_props.auroraItemHeight);
    if ("f7Slot" in $$new_props)
      $$invalidate(0, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    init: init2,
    listEl,
    indexes,
    scrollList,
    label,
    iosItemHeight,
    mdItemHeight,
    auroraItemHeight,
    f7Slot,
    el,
    f7ListIndex,
    instance: instance87,
    update,
    scrollListToIndex,
    initialWatched,
    watchIndexes,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("init" in $$props)
      $$invalidate(6, init2 = $$new_props.init);
    if ("listEl" in $$props)
      $$invalidate(7, listEl = $$new_props.listEl);
    if ("indexes" in $$props)
      $$invalidate(8, indexes = $$new_props.indexes);
    if ("scrollList" in $$props)
      $$invalidate(9, scrollList = $$new_props.scrollList);
    if ("label" in $$props)
      $$invalidate(10, label = $$new_props.label);
    if ("iosItemHeight" in $$props)
      $$invalidate(11, iosItemHeight = $$new_props.iosItemHeight);
    if ("mdItemHeight" in $$props)
      $$invalidate(12, mdItemHeight = $$new_props.mdItemHeight);
    if ("auroraItemHeight" in $$props)
      $$invalidate(13, auroraItemHeight = $$new_props.auroraItemHeight);
    if ("f7Slot" in $$props)
      $$invalidate(0, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("f7ListIndex" in $$props)
      $$invalidate(2, f7ListIndex = $$new_props.f7ListIndex);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "list-index", colorClasses($$props)));
    if ($$self.$$.dirty & /*indexes*/
    256) {
      $:
        watchIndexes(indexes);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    f7Slot,
    el,
    f7ListIndex,
    classes,
    $$restProps,
    className,
    init2,
    listEl,
    indexes,
    scrollList,
    label,
    iosItemHeight,
    mdItemHeight,
    auroraItemHeight,
    instance87,
    update,
    scrollListToIndex,
    $$scope,
    slots,
    div_binding
  ];
}
var List_index = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_111, create_fragment53, safe_not_equal, {
      class: 5,
      init: 6,
      listEl: 7,
      indexes: 8,
      scrollList: 9,
      label: 10,
      iosItemHeight: 11,
      mdItemHeight: 12,
      auroraItemHeight: 13,
      f7Slot: 0,
      instance: 14,
      update: 15,
      scrollListToIndex: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_index",
      options,
      id: create_fragment53.name
    });
  }
  get class() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listEl() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listEl(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indexes() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indexes(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollList() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollList(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iosItemHeight() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iosItemHeight(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mdItemHeight() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mdItemHeight(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get auroraItemHeight() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set auroraItemHeight(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[14];
  }
  set instance(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    return this.$$.ctx[15];
  }
  set update(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollListToIndex() {
    return this.$$.ctx[16];
  }
  set scrollListToIndex(value) {
    throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_index_default = List_index;

// node_modules/framework7-svelte/components/list-input.svelte
var file51 = "node_modules/framework7-svelte/components/list-input.svelte";
var get_content_end_slot_changes_1 = (dirty) => ({});
var get_content_end_slot_context_1 = (ctx) => ({});
var get_content_slot_changes_1 = (dirty) => ({});
var get_content_slot_context_1 = (ctx) => ({});
var get_inner_end_slot_changes_1 = (dirty) => ({});
var get_inner_end_slot_context_1 = (ctx) => ({});
var get_inner_slot_changes_1 = (dirty) => ({});
var get_inner_slot_context_1 = (ctx) => ({});
var get_info_slot_changes_1 = (dirty) => ({});
var get_info_slot_context_1 = (ctx) => ({});
var get_error_message_slot_changes_1 = (dirty) => ({});
var get_error_message_slot_context_1 = (ctx) => ({});
var get_input_slot_changes_1 = (dirty) => ({});
var get_input_slot_context_1 = (ctx) => ({});
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_inner_start_slot_changes_1 = (dirty) => ({});
var get_inner_start_slot_context_1 = (ctx) => ({});
var get_media_slot_changes_1 = (dirty) => ({});
var get_media_slot_context_1 = (ctx) => ({});
var get_content_start_slot_changes_1 = (dirty) => ({});
var get_content_start_slot_context_1 = (ctx) => ({});
var get_root_end_slot_changes2 = (dirty) => ({});
var get_root_end_slot_context2 = (ctx) => ({});
var get_root_slot_changes3 = (dirty) => ({});
var get_root_slot_context3 = (ctx) => ({});
var get_content_end_slot_changes = (dirty) => ({});
var get_content_end_slot_context = (ctx) => ({});
var get_content_slot_changes2 = (dirty) => ({});
var get_content_slot_context2 = (ctx) => ({});
var get_inner_end_slot_changes = (dirty) => ({});
var get_inner_end_slot_context = (ctx) => ({});
var get_inner_slot_changes = (dirty) => ({});
var get_inner_slot_context = (ctx) => ({});
var get_info_slot_changes2 = (dirty) => ({});
var get_info_slot_context2 = (ctx) => ({});
var get_error_message_slot_changes2 = (dirty) => ({});
var get_error_message_slot_context2 = (ctx) => ({});
var get_input_slot_changes = (dirty) => ({});
var get_input_slot_context = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
var get_inner_start_slot_changes = (dirty) => ({});
var get_inner_start_slot_context = (ctx) => ({});
var get_media_slot_changes3 = (dirty) => ({});
var get_media_slot_context3 = (ctx) => ({});
var get_content_start_slot_changes = (dirty) => ({});
var get_content_start_slot_context = (ctx) => ({});
var get_root_start_slot_changes2 = (dirty) => ({});
var get_root_start_slot_context2 = (ctx) => ({});
function create_else_block_14(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let div1;
  let t3;
  let t4;
  let div0;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let t12;
  let current;
  const content_start_slot_template = (
    /*#slots*/
    ctx[77]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_start_slot_context_1
  );
  let if_block0 = (
    /*isSortable*/
    ctx[51] && /*isSortableOpposite*/
    ctx[50] && create_if_block_232(ctx)
  );
  let if_block1 = (
    /*media*/
    (ctx[1] || /*hasMediaSlots*/
    ctx[48]) && create_if_block_21(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[77]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_start_slot_context_1
  );
  let if_block2 = (typeof /*label*/
  ctx[36] !== "undefined" || /*hasLabelSlots*/
  ctx[47]) && create_if_block_20(ctx);
  let if_block3 = (
    /*input*/
    ctx[3] && create_if_block_162(ctx)
  );
  const input_slot_template = (
    /*#slots*/
    ctx[77].input
  );
  const input_slot = create_slot(
    input_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_input_slot_context_1
  );
  let if_block4 = (
    /*hasErrorMessage*/
    ctx[38] && /*errorMessageForce*/
    ctx[34] && create_if_block_152(ctx)
  );
  let if_block5 = (
    /*clearButton*/
    ctx[32] && create_if_block_142(ctx)
  );
  let if_block6 = (typeof /*info*/
  ctx[35] !== "undefined" || /*hasInfoSlots*/
  ctx[39]) && create_if_block_133(ctx);
  const inner_slot_template = (
    /*#slots*/
    ctx[77].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_slot_context_1
  );
  const inner_end_slot_template = (
    /*#slots*/
    ctx[77]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_end_slot_context_1
  );
  const content_slot_template = (
    /*#slots*/
    ctx[77].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_slot_context_1
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[77]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_end_slot_context_1
  );
  let div2_levels = [{ class: (
    /*itemContentClasses*/
    ctx[45]
  ) }, restProps(
    /*$$restProps*/
    ctx[56]
  )];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      div0 = element("div");
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (input_slot)
        input_slot.c();
      t6 = space();
      if (if_block4)
        if_block4.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      t9 = space();
      if (inner_slot)
        inner_slot.c();
      t10 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t11 = space();
      if (content_slot)
        content_slot.c();
      t12 = space();
      if (content_end_slot)
        content_end_slot.c();
      attr_dev(
        div0,
        "class",
        /*inputWrapClasses*/
        ctx[43]
      );
      add_location(div0, file51, 597, 6, 17815);
      attr_dev(div1, "class", "item-inner");
      add_location(div1, file51, 589, 4, 17569);
      set_attributes(div2, div2_data);
      add_location(div2, file51, 577, 2, 17193);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (content_start_slot) {
        content_start_slot.m(div2, null);
      }
      append_dev(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append_dev(div2, t2);
      append_dev(div2, div1);
      if (inner_start_slot) {
        inner_start_slot.m(div1, null);
      }
      append_dev(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t4);
      append_dev(div1, div0);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t5);
      if (input_slot) {
        input_slot.m(div0, null);
      }
      append_dev(div0, t6);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div0, t7);
      if (if_block5)
        if_block5.m(div0, null);
      append_dev(div0, t8);
      if (if_block6)
        if_block6.m(div0, null);
      append_dev(div1, t9);
      if (inner_slot) {
        inner_slot.m(div1, null);
      }
      append_dev(div1, t10);
      if (inner_end_slot) {
        inner_end_slot.m(div1, null);
      }
      append_dev(div2, t11);
      if (content_slot) {
        content_slot.m(div2, null);
      }
      append_dev(div2, t12);
      if (content_end_slot) {
        content_end_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_start_slot_changes_1
            ),
            get_content_start_slot_context_1
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[51] && /*isSortableOpposite*/
        ctx2[50]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_232(ctx2);
          if_block0.c();
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*media*/
        ctx2[1] || /*hasMediaSlots*/
        ctx2[48]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*media*/
          2 | dirty[1] & /*hasMediaSlots*/
          131072) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_21(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_start_slot_changes_1
            ),
            get_inner_start_slot_context_1
          );
        }
      }
      if (typeof /*label*/
      ctx2[36] !== "undefined" || /*hasLabelSlots*/
      ctx2[47]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*label, hasLabelSlots*/
          65568) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_20(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*input*/
        ctx2[3]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*input*/
          8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_162(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (input_slot) {
        if (input_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            input_slot,
            input_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              input_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_input_slot_changes_1
            ),
            get_input_slot_context_1
          );
        }
      }
      if (
        /*hasErrorMessage*/
        ctx2[38] && /*errorMessageForce*/
        ctx2[34]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasErrorMessage, errorMessageForce*/
          136) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_152(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, t7);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*clearButton*/
        ctx2[32]
      ) {
        if (if_block5) {
        } else {
          if_block5 = create_if_block_142(ctx2);
          if_block5.c();
          if_block5.m(div0, t8);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (typeof /*info*/
      ctx2[35] !== "undefined" || /*hasInfoSlots*/
      ctx2[39]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*info, hasInfoSlots*/
          272) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_133(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div0, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty[1] & /*inputWrapClasses*/
      4096) {
        attr_dev(
          div0,
          "class",
          /*inputWrapClasses*/
          ctx2[43]
        );
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_slot_changes_1
            ),
            get_inner_slot_context_1
          );
        }
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_end_slot_changes_1
            ),
            get_inner_end_slot_context_1
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_slot_changes_1
            ),
            get_content_slot_context_1
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_end_slot_changes_1
            ),
            get_content_end_slot_context_1
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[1] & /*itemContentClasses*/
        16384) && { class: (
          /*itemContentClasses*/
          ctx2[45]
        ) },
        dirty[1] & /*$$restProps*/
        33554432 && restProps(
          /*$$restProps*/
          ctx2[56]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(input_slot, local);
      transition_in(if_block4);
      transition_in(if_block6);
      transition_in(inner_slot, local);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(input_slot, local);
      transition_out(if_block4);
      transition_out(if_block6);
      transition_out(inner_slot, local);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (input_slot)
        input_slot.d(detaching);
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (inner_slot)
        inner_slot.d(detaching);
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(577:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let li;
  let t0;
  let div2;
  let t1;
  let t2;
  let t3;
  let div1;
  let t4;
  let t5;
  let div0;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let t15;
  let t16;
  let current;
  const root_start_slot_template = (
    /*#slots*/
    ctx[77]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_root_start_slot_context2
  );
  const content_start_slot_template = (
    /*#slots*/
    ctx[77]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_start_slot_context
  );
  let if_block0 = (
    /*isSortable*/
    ctx[51] && /*isSortableOpposite*/
    ctx[50] && create_if_block_123(ctx)
  );
  let if_block1 = (
    /*media*/
    (ctx[1] || /*hasMediaSlots*/
    ctx[48]) && create_if_block_103(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[77]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_start_slot_context
  );
  let if_block2 = (typeof /*label*/
  ctx[36] !== "undefined" || /*hasLabelSlots*/
  ctx[47]) && create_if_block_93(ctx);
  let if_block3 = (
    /*input*/
    ctx[3] && create_if_block_53(ctx)
  );
  const input_slot_template = (
    /*#slots*/
    ctx[77].input
  );
  const input_slot = create_slot(
    input_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_input_slot_context
  );
  let if_block4 = (
    /*hasErrorMessage*/
    ctx[38] && /*errorMessageForce*/
    ctx[34] && create_if_block_46(ctx)
  );
  let if_block5 = (
    /*clearButton*/
    ctx[32] && create_if_block_38(ctx)
  );
  let if_block6 = (typeof /*info*/
  ctx[35] !== "undefined" || /*hasInfoSlots*/
  ctx[39]) && create_if_block_211(ctx);
  const inner_slot_template = (
    /*#slots*/
    ctx[77].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_slot_context
  );
  const inner_end_slot_template = (
    /*#slots*/
    ctx[77]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_inner_end_slot_context
  );
  const content_slot_template = (
    /*#slots*/
    ctx[77].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_slot_context2
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[77]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_content_end_slot_context
  );
  let if_block7 = (
    /*isSortable*/
    ctx[51] && !/*isSortableOpposite*/
    ctx[50] && create_if_block_111(ctx)
  );
  const root_slot_template = (
    /*#slots*/
    ctx[77].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_root_slot_context3
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[77]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_root_end_slot_context2
  );
  let li_levels = [{ class: (
    /*classes*/
    ctx[42]
  ) }, restProps(
    /*$$restProps*/
    ctx[56]
  )];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (root_start_slot)
        root_start_slot.c();
      t0 = space();
      div2 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div1 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      div0 = element("div");
      if (if_block3)
        if_block3.c();
      t6 = space();
      if (input_slot)
        input_slot.c();
      t7 = space();
      if (if_block4)
        if_block4.c();
      t8 = space();
      if (if_block5)
        if_block5.c();
      t9 = space();
      if (if_block6)
        if_block6.c();
      t10 = space();
      if (inner_slot)
        inner_slot.c();
      t11 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t12 = space();
      if (content_slot)
        content_slot.c();
      t13 = space();
      if (content_end_slot)
        content_end_slot.c();
      t14 = space();
      if (if_block7)
        if_block7.c();
      t15 = space();
      if (root_slot)
        root_slot.c();
      t16 = space();
      if (root_end_slot)
        root_end_slot.c();
      attr_dev(
        div0,
        "class",
        /*inputWrapClasses*/
        ctx[43]
      );
      add_location(div0, file51, 395, 8, 11079);
      attr_dev(div1, "class", "item-inner");
      add_location(div1, file51, 387, 6, 10817);
      attr_dev(
        div2,
        "class",
        /*itemContentClasses*/
        ctx[45]
      );
      add_location(div2, file51, 375, 4, 10447);
      set_attributes(li, li_data);
      add_location(li, file51, 373, 2, 10363);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (root_start_slot) {
        root_start_slot.m(li, null);
      }
      append_dev(li, t0);
      append_dev(li, div2);
      if (content_start_slot) {
        content_start_slot.m(div2, null);
      }
      append_dev(div2, t1);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      append_dev(div2, t3);
      append_dev(div2, div1);
      if (inner_start_slot) {
        inner_start_slot.m(div1, null);
      }
      append_dev(div1, t4);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t5);
      append_dev(div1, div0);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t6);
      if (input_slot) {
        input_slot.m(div0, null);
      }
      append_dev(div0, t7);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div0, t8);
      if (if_block5)
        if_block5.m(div0, null);
      append_dev(div0, t9);
      if (if_block6)
        if_block6.m(div0, null);
      append_dev(div1, t10);
      if (inner_slot) {
        inner_slot.m(div1, null);
      }
      append_dev(div1, t11);
      if (inner_end_slot) {
        inner_end_slot.m(div1, null);
      }
      append_dev(div2, t12);
      if (content_slot) {
        content_slot.m(div2, null);
      }
      append_dev(div2, t13);
      if (content_end_slot) {
        content_end_slot.m(div2, null);
      }
      append_dev(li, t14);
      if (if_block7)
        if_block7.m(li, null);
      append_dev(li, t15);
      if (root_slot) {
        root_slot.m(li, null);
      }
      append_dev(li, t16);
      if (root_end_slot) {
        root_end_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_root_start_slot_changes2
            ),
            get_root_start_slot_context2
          );
        }
      }
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_start_slot_changes
            ),
            get_content_start_slot_context
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[51] && /*isSortableOpposite*/
        ctx2[50]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_123(ctx2);
          if_block0.c();
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*media*/
        ctx2[1] || /*hasMediaSlots*/
        ctx2[48]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*media*/
          2 | dirty[1] & /*hasMediaSlots*/
          131072) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_103(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_start_slot_changes
            ),
            get_inner_start_slot_context
          );
        }
      }
      if (typeof /*label*/
      ctx2[36] !== "undefined" || /*hasLabelSlots*/
      ctx2[47]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*label, hasLabelSlots*/
          65568) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_93(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*input*/
        ctx2[3]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*input*/
          8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_53(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (input_slot) {
        if (input_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            input_slot,
            input_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              input_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_input_slot_changes
            ),
            get_input_slot_context
          );
        }
      }
      if (
        /*hasErrorMessage*/
        ctx2[38] && /*errorMessageForce*/
        ctx2[34]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasErrorMessage, errorMessageForce*/
          136) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_46(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, t8);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*clearButton*/
        ctx2[32]
      ) {
        if (if_block5) {
        } else {
          if_block5 = create_if_block_38(ctx2);
          if_block5.c();
          if_block5.m(div0, t9);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (typeof /*info*/
      ctx2[35] !== "undefined" || /*hasInfoSlots*/
      ctx2[39]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*info, hasInfoSlots*/
          272) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_211(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div0, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty[1] & /*inputWrapClasses*/
      4096) {
        attr_dev(
          div0,
          "class",
          /*inputWrapClasses*/
          ctx2[43]
        );
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_slot_changes
            ),
            get_inner_slot_context
          );
        }
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_inner_end_slot_changes
            ),
            get_inner_end_slot_context
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_slot_changes2
            ),
            get_content_slot_context2
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_content_end_slot_changes
            ),
            get_content_end_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*itemContentClasses*/
      16384) {
        attr_dev(
          div2,
          "class",
          /*itemContentClasses*/
          ctx2[45]
        );
      }
      if (
        /*isSortable*/
        ctx2[51] && !/*isSortableOpposite*/
        ctx2[50]
      ) {
        if (if_block7) {
        } else {
          if_block7 = create_if_block_111(ctx2);
          if_block7.c();
          if_block7.m(li, t15);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_root_slot_changes3
            ),
            get_root_slot_context3
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_root_end_slot_changes2
            ),
            get_root_end_slot_context2
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*classes*/
        2048) && { class: (
          /*classes*/
          ctx2[42]
        ) },
        dirty[1] & /*$$restProps*/
        33554432 && restProps(
          /*$$restProps*/
          ctx2[56]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(root_start_slot, local);
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(input_slot, local);
      transition_in(if_block4);
      transition_in(if_block6);
      transition_in(inner_slot, local);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      transition_in(root_slot, local);
      transition_in(root_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(root_start_slot, local);
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(input_slot, local);
      transition_out(if_block4);
      transition_out(if_block6);
      transition_out(inner_slot, local);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      transition_out(root_slot, local);
      transition_out(root_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (root_start_slot)
        root_start_slot.d(detaching);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (input_slot)
        input_slot.d(detaching);
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (inner_slot)
        inner_slot.d(detaching);
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      if (if_block7)
        if_block7.d();
      if (root_slot)
        root_slot.d(detaching);
      if (root_end_slot)
        root_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(373:0) {#if wrap}",
    ctx
  });
  return block;
}
function create_if_block_232(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file51, 580, 6, 17337);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_232.name,
    type: "if",
    source: "(580:4) {#if isSortable && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_21(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[1] !== "undefined" && create_if_block_222(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[77].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_media_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file51, 584, 6, 17420);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[1] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_222(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_media_slot_changes_1
            ),
            get_media_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(584:4) {#if media || hasMediaSlots}",
    ctx
  });
  return block;
}
function create_if_block_222(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[1]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file51, 585, 42, 17487);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      2 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[1])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(586:8) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_20(ctx) {
  let div;
  let t0_value = plainText(
    /*label*/
    ctx[36]
  ) + "";
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[77].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_label_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (label_slot)
        label_slot.c();
      attr_dev(
        div,
        "class",
        /*labelClasses*/
        ctx[44]
      );
      add_location(div, file51, 592, 8, 17694);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (label_slot) {
        label_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*label*/
      32) && t0_value !== (t0_value = plainText(
        /*label*/
        ctx2[36]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_label_slot_changes_1
            ),
            get_label_slot_context_1
          );
        }
      }
      if (!current || dirty[1] & /*labelClasses*/
      8192) {
        attr_dev(
          div,
          "class",
          /*labelClasses*/
          ctx2[44]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(592:6) {#if typeof label !== 'undefined' || hasLabelSlots}",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_172,
    create_if_block_182,
    create_if_block_192,
    create_else_block_22
  ];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*type*/
      ctx2[4] === "select"
    )
      return 0;
    if (
      /*type*/
      ctx2[4] === "textarea"
    )
      return 1;
    if (
      /*type*/
      ctx2[4] === "texteditor"
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(599:8) {#if input}",
    ctx
  });
  return block;
}
function create_else_block_22(ctx) {
  let input_1;
  let input_1_validate_value;
  let input_1_data_validate_value;
  let input_1_data_validate_on_blur_value;
  let input_1_data_error_message_value;
  let input_1_value_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input_1 = element("input");
      attr_dev(
        input_1,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        input_1,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        input_1,
        "type",
        /*inputType*/
        ctx[40]
      );
      attr_dev(
        input_1,
        "inputmode",
        /*inputmode*/
        ctx[6]
      );
      attr_dev(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        input_1,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        input_1,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        input_1,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        input_1,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        input_1,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        input_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        input_1,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      input_1.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        input_1,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      input_1.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        input_1,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        input_1,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        input_1,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        input_1,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        input_1,
        "step",
        /*step*/
        ctx[22]
      );
      input_1.multiple = /*multiple*/
      ctx[25];
      input_1.readOnly = /*readonly*/
      ctx[7];
      input_1.required = /*required*/
      ctx[8];
      attr_dev(
        input_1,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        input_1,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        input_1,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      input_1.value = input_1_value_value = /*type*/
      ctx[4] === "datepicker" || /*type*/
      ctx[4] === "colorpicker" || /*type*/
      ctx[4] === "file" ? "" : (
        /*inputValue*/
        ctx[49]
      );
      add_location(input_1, file51, 702, 12, 21199);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input_1, anchor);
      ctx[83](input_1);
      if (
        /*autofocus*/
        ctx[18]
      )
        input_1.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input_1,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          input_1,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (dirty[0] & /*name*/
      32) {
        attr_dev(
          input_1,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (dirty[1] & /*inputType*/
      512) {
        attr_dev(
          input_1,
          "type",
          /*inputType*/
          ctx2[40]
        );
      }
      if (dirty[0] & /*inputmode*/
      64) {
        attr_dev(
          input_1,
          "inputmode",
          /*inputmode*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          input_1,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*size*/
      4096) {
        attr_dev(
          input_1,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*accept*/
      8192) {
        attr_dev(
          input_1,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          input_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          input_1,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          input_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          input_1,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          input_1,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          input_1,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*disabled*/
      512) {
        prop_dev(
          input_1,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*max*/
      1048576) {
        attr_dev(
          input_1,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          input_1,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*min*/
      2097152) {
        attr_dev(
          input_1,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          input_1,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*step*/
      4194304) {
        attr_dev(
          input_1,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*multiple*/
      33554432) {
        prop_dev(
          input_1,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (dirty[0] & /*readonly*/
      128) {
        prop_dev(
          input_1,
          "readOnly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*required*/
      256) {
        prop_dev(
          input_1,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          input_1,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*validate*/
      268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(input_1, "validate", input_1_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(input_1, "data-validate", input_1_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          input_1,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (dirty[1] & /*errorMessageForce, errorMessage*/
      12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
      }
      if (dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          input_1,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (dirty[0] & /*type*/
      16 | dirty[1] & /*inputValue*/
      262144 && input_1_value_value !== (input_1_value_value = /*type*/
      ctx2[4] === "datepicker" || /*type*/
      ctx2[4] === "colorpicker" || /*type*/
      ctx2[4] === "file" ? "" : (
        /*inputValue*/
        ctx2[49]
      )) && input_1.value !== input_1_value_value) {
        prop_dev(input_1, "value", input_1_value_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input_1);
      ctx[83](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_22.name,
    type: "else",
    source: "(702:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let texteditor;
  let current;
  const texteditor_spread_levels = [
    {
      value: typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      )
    },
    { resizable: (
      /*resizable*/
      ctx[31]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[10]
    ) },
    { onTextEditorFocus: (
      /*onFocus*/
      ctx[53]
    ) },
    { onTextEditorBlur: (
      /*onBlur*/
      ctx[54]
    ) },
    { onTextEditorInput: (
      /*onInput*/
      ctx[52]
    ) },
    { onTextEditorChange: (
      /*onChange*/
      ctx[55]
    ) },
    /*textEditorParams*/
    ctx[37]
  ];
  let texteditor_props = {};
  for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
  }
  texteditor = new text_editor_default({ props: texteditor_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(texteditor.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(texteditor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const texteditor_changes = dirty[0] & /*value, placeholder*/
      1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/
      31457345 ? get_spread_update(texteditor_spread_levels, [
        dirty[0] & /*value*/
        1 && {
          value: typeof /*value*/
          ctx2[0] === "undefined" ? "" : (
            /*value*/
            ctx2[0]
          )
        },
        dirty[1] & /*resizable*/
        1 && { resizable: (
          /*resizable*/
          ctx2[31]
        ) },
        dirty[0] & /*placeholder*/
        1024 && { placeholder: (
          /*placeholder*/
          ctx2[10]
        ) },
        dirty[1] & /*onFocus*/
        4194304 && { onTextEditorFocus: (
          /*onFocus*/
          ctx2[53]
        ) },
        dirty[1] & /*onBlur*/
        8388608 && { onTextEditorBlur: (
          /*onBlur*/
          ctx2[54]
        ) },
        dirty[1] & /*onInput*/
        2097152 && { onTextEditorInput: (
          /*onInput*/
          ctx2[52]
        ) },
        dirty[1] & /*onChange*/
        16777216 && { onTextEditorChange: (
          /*onChange*/
          ctx2[55]
        ) },
        dirty[1] & /*textEditorParams*/
        64 && get_spread_object(
          /*textEditorParams*/
          ctx2[37]
        )
      ]) : {};
      texteditor.$set(texteditor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(texteditor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(texteditor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(texteditor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(691:42) ",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let textarea;
  let textarea_validate_value;
  let textarea_data_validate_value;
  let textarea_data_validate_on_blur_value;
  let textarea_data_error_message_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      textarea = element("textarea");
      attr_dev(
        textarea,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        textarea,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        textarea,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        textarea,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        textarea,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        textarea,
        "inputmode",
        /*inputmode*/
        ctx[6]
      );
      attr_dev(
        textarea,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        textarea,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        textarea,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        textarea,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        textarea,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      textarea.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        textarea,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      textarea.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        textarea,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        textarea,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        textarea,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        textarea,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        textarea,
        "step",
        /*step*/
        ctx[22]
      );
      attr_dev(
        textarea,
        "multiple",
        /*multiple*/
        ctx[25]
      );
      textarea.readOnly = /*readonly*/
      ctx[7];
      textarea.required = /*required*/
      ctx[8];
      attr_dev(
        textarea,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        textarea,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        textarea,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      textarea.value = /*inputValue*/
      ctx[49];
      add_location(textarea, file51, 646, 12, 19373);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      ctx[82](textarea);
      if (
        /*autofocus*/
        ctx[18]
      )
        textarea.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          textarea,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (dirty[0] & /*name*/
      32) {
        attr_dev(
          textarea,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          textarea,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          textarea,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*size*/
      4096) {
        attr_dev(
          textarea,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*inputmode*/
      64) {
        attr_dev(
          textarea,
          "inputmode",
          /*inputmode*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*accept*/
      8192) {
        attr_dev(
          textarea,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          textarea,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          textarea,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          textarea,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          textarea,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          textarea,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          textarea,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*disabled*/
      512) {
        prop_dev(
          textarea,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*max*/
      1048576) {
        attr_dev(
          textarea,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          textarea,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*min*/
      2097152) {
        attr_dev(
          textarea,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          textarea,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*step*/
      4194304) {
        attr_dev(
          textarea,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*multiple*/
      33554432) {
        attr_dev(
          textarea,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (dirty[0] & /*readonly*/
      128) {
        prop_dev(
          textarea,
          "readOnly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*required*/
      256) {
        prop_dev(
          textarea,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          textarea,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*validate*/
      268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(textarea, "validate", textarea_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate", textarea_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          textarea,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (dirty[1] & /*errorMessageForce, errorMessage*/
      12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
      }
      if (dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          textarea,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (dirty[1] & /*inputValue*/
      262144) {
        prop_dev(
          textarea,
          "value",
          /*inputValue*/
          ctx2[49]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[82](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(646:40) ",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let select;
  let select_validate_value;
  let select_data_validate_value;
  let select_data_validate_on_blur_value;
  let select_data_error_message_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[77].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    null
  );
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      attr_dev(
        select,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        select,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        select,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        select,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        select,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        select,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        select,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        select,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        select,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      select.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        select,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      select.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        select,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        select,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        select,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        select,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        select,
        "step",
        /*step*/
        ctx[22]
      );
      select.multiple = /*multiple*/
      ctx[25];
      attr_dev(
        select,
        "readonly",
        /*readonly*/
        ctx[7]
      );
      select.required = /*required*/
      ctx[8];
      attr_dev(
        select,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(select, "validate", select_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(select, "data-validate", select_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        select,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        select,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      add_location(select, file51, 600, 12, 17912);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(
        select,
        /*inputValue*/
        ctx[49]
      );
      ctx[81](select);
      current = true;
      if (
        /*autofocus*/
        ctx[18]
      )
        select.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          select,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (!current || dirty[0] & /*name*/
      32) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          select,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          select,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*size*/
      4096) {
        attr_dev(
          select,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*accept*/
      8192) {
        attr_dev(
          select,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          select,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          select,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          select,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          select,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          select,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          select,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      512) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*max*/
      1048576) {
        attr_dev(
          select,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          select,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*min*/
      2097152) {
        attr_dev(
          select,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          select,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (!current || dirty[0] & /*step*/
      4194304) {
        attr_dev(
          select,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*multiple*/
      33554432) {
        prop_dev(
          select,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      128) {
        attr_dev(
          select,
          "readonly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*required*/
      256) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          select,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (!current || dirty[0] & /*validate*/
      268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(select, "validate", select_validate_value);
      }
      if (!current || dirty[0] & /*validate, validateOnBlur*/
      805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(select, "data-validate", select_data_validate_value);
      }
      if (!current || dirty[0] & /*validateOnBlur*/
      536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
      }
      if (!current || dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          select,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (!current || dirty[1] & /*errorMessageForce, errorMessage*/
      12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(select, "data-error-message", select_data_error_message_value);
      }
      if (!current || dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          select,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (!current || dirty[1] & /*inputValue*/
      262144) {
        select_option(
          select,
          /*inputValue*/
          ctx2[49]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[81](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(600:10) {#if type === 'select'}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let div;
  let t0_value = plainText(
    /*errorMessage*/
    ctx[33]
  ) + "";
  let t0;
  let t1;
  let current;
  const error_message_slot_template = (
    /*#slots*/
    ctx[77]["error-message"]
  );
  const error_message_slot = create_slot(
    error_message_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_error_message_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (error_message_slot)
        error_message_slot.c();
      attr_dev(div, "class", "item-input-error-message");
      add_location(div, file51, 753, 10, 22855);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (error_message_slot) {
        error_message_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*errorMessage*/
      4) && t0_value !== (t0_value = plainText(
        /*errorMessage*/
        ctx2[33]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (error_message_slot) {
        if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            error_message_slot,
            error_message_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              error_message_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_error_message_slot_changes_1
            ),
            get_error_message_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_message_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_message_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (error_message_slot)
        error_message_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(753:8) {#if hasErrorMessage && errorMessageForce}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "input-clear-button");
      add_location(span, file51, 758, 25, 23030);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(759:8) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_133(ctx) {
  let div;
  let t0_value = plainText(
    /*info*/
    ctx[35]
  ) + "";
  let t0;
  let t1;
  let current;
  const info_slot_template = (
    /*#slots*/
    ctx[77].info
  );
  const info_slot = create_slot(
    info_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_info_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (info_slot)
        info_slot.c();
      attr_dev(div, "class", "item-input-info");
      add_location(div, file51, 760, 10, 23139);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (info_slot) {
        info_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*info*/
      16) && t0_value !== (t0_value = plainText(
        /*info*/
        ctx2[35]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (info_slot) {
        if (info_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            info_slot,
            info_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              info_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_info_slot_changes_1
            ),
            get_info_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (info_slot)
        info_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_133.name,
    type: "if",
    source: "(760:8) {#if typeof info !== 'undefined' || hasInfoSlots}",
    ctx
  });
  return block;
}
function create_if_block_123(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file51, 378, 8, 10569);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(378:6) {#if isSortable && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_103(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[1] !== "undefined" && create_if_block_112(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[77].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_media_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file51, 382, 8, 10658);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[1] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_112(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_media_slot_changes3
            ),
            get_media_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_103.name,
    type: "if",
    source: "(382:6) {#if media || hasMediaSlots}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[1]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file51, 383, 44, 10727);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      2 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[1])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(384:10) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_93(ctx) {
  let div;
  let t0_value = plainText(
    /*label*/
    ctx[36]
  ) + "";
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[77].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_label_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (label_slot)
        label_slot.c();
      attr_dev(
        div,
        "class",
        /*labelClasses*/
        ctx[44]
      );
      add_location(div, file51, 390, 10, 10948);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (label_slot) {
        label_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*label*/
      32) && t0_value !== (t0_value = plainText(
        /*label*/
        ctx2[36]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*labelClasses*/
      8192) {
        attr_dev(
          div,
          "class",
          /*labelClasses*/
          ctx2[44]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_93.name,
    type: "if",
    source: "(390:8) {#if typeof label !== 'undefined' || hasLabelSlots}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_63, create_if_block_73, create_if_block_83, create_else_block6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[4] === "select"
    )
      return 0;
    if (
      /*type*/
      ctx2[4] === "textarea"
    )
      return 1;
    if (
      /*type*/
      ctx2[4] === "texteditor"
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(397:10) {#if input}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let input_1;
  let input_1_validate_value;
  let input_1_data_validate_value;
  let input_1_data_validate_on_blur_value;
  let input_1_data_error_message_value;
  let input_1_value_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input_1 = element("input");
      attr_dev(
        input_1,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        input_1,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        input_1,
        "type",
        /*inputType*/
        ctx[40]
      );
      attr_dev(
        input_1,
        "inputmode",
        /*inputmode*/
        ctx[6]
      );
      attr_dev(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        input_1,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        input_1,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        input_1,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        input_1,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        input_1,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        input_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        input_1,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      input_1.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        input_1,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      input_1.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        input_1,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        input_1,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        input_1,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        input_1,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        input_1,
        "step",
        /*step*/
        ctx[22]
      );
      input_1.multiple = /*multiple*/
      ctx[25];
      input_1.readOnly = /*readonly*/
      ctx[7];
      input_1.required = /*required*/
      ctx[8];
      attr_dev(
        input_1,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        input_1,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        input_1,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      input_1.value = input_1_value_value = /*type*/
      ctx[4] === "datepicker" || /*type*/
      ctx[4] === "colorpicker" || /*type*/
      ctx[4] === "file" ? "" : (
        /*inputValue*/
        ctx[49]
      );
      add_location(input_1, file51, 500, 14, 14673);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input_1, anchor);
      ctx[80](input_1);
      if (
        /*autofocus*/
        ctx[18]
      )
        input_1.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input_1,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          input_1,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (dirty[0] & /*name*/
      32) {
        attr_dev(
          input_1,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (dirty[1] & /*inputType*/
      512) {
        attr_dev(
          input_1,
          "type",
          /*inputType*/
          ctx2[40]
        );
      }
      if (dirty[0] & /*inputmode*/
      64) {
        attr_dev(
          input_1,
          "inputmode",
          /*inputmode*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          input_1,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*size*/
      4096) {
        attr_dev(
          input_1,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*accept*/
      8192) {
        attr_dev(
          input_1,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          input_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          input_1,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          input_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          input_1,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          input_1,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          input_1,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*disabled*/
      512) {
        prop_dev(
          input_1,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*max*/
      1048576) {
        attr_dev(
          input_1,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          input_1,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*min*/
      2097152) {
        attr_dev(
          input_1,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          input_1,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*step*/
      4194304) {
        attr_dev(
          input_1,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*multiple*/
      33554432) {
        prop_dev(
          input_1,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (dirty[0] & /*readonly*/
      128) {
        prop_dev(
          input_1,
          "readOnly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*required*/
      256) {
        prop_dev(
          input_1,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          input_1,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*validate*/
      268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(input_1, "validate", input_1_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(input_1, "data-validate", input_1_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          input_1,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (dirty[1] & /*errorMessageForce, errorMessage*/
      12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
      }
      if (dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          input_1,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (dirty[0] & /*type*/
      16 | dirty[1] & /*inputValue*/
      262144 && input_1_value_value !== (input_1_value_value = /*type*/
      ctx2[4] === "datepicker" || /*type*/
      ctx2[4] === "colorpicker" || /*type*/
      ctx2[4] === "file" ? "" : (
        /*inputValue*/
        ctx2[49]
      )) && input_1.value !== input_1_value_value) {
        prop_dev(input_1, "value", input_1_value_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input_1);
      ctx[80](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(500:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_83(ctx) {
  let texteditor;
  let current;
  const texteditor_spread_levels = [
    {
      value: typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      )
    },
    { resizable: (
      /*resizable*/
      ctx[31]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[10]
    ) },
    { onTextEditorFocus: (
      /*onFocus*/
      ctx[53]
    ) },
    { onTextEditorBlur: (
      /*onBlur*/
      ctx[54]
    ) },
    { onTextEditorInput: (
      /*onInput*/
      ctx[52]
    ) },
    { onTextEditorChange: (
      /*onChange*/
      ctx[55]
    ) },
    /*textEditorParams*/
    ctx[37]
  ];
  let texteditor_props = {};
  for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
  }
  texteditor = new text_editor_default({ props: texteditor_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(texteditor.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(texteditor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const texteditor_changes = dirty[0] & /*value, placeholder*/
      1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/
      31457345 ? get_spread_update(texteditor_spread_levels, [
        dirty[0] & /*value*/
        1 && {
          value: typeof /*value*/
          ctx2[0] === "undefined" ? "" : (
            /*value*/
            ctx2[0]
          )
        },
        dirty[1] & /*resizable*/
        1 && { resizable: (
          /*resizable*/
          ctx2[31]
        ) },
        dirty[0] & /*placeholder*/
        1024 && { placeholder: (
          /*placeholder*/
          ctx2[10]
        ) },
        dirty[1] & /*onFocus*/
        4194304 && { onTextEditorFocus: (
          /*onFocus*/
          ctx2[53]
        ) },
        dirty[1] & /*onBlur*/
        8388608 && { onTextEditorBlur: (
          /*onBlur*/
          ctx2[54]
        ) },
        dirty[1] & /*onInput*/
        2097152 && { onTextEditorInput: (
          /*onInput*/
          ctx2[52]
        ) },
        dirty[1] & /*onChange*/
        16777216 && { onTextEditorChange: (
          /*onChange*/
          ctx2[55]
        ) },
        dirty[1] & /*textEditorParams*/
        64 && get_spread_object(
          /*textEditorParams*/
          ctx2[37]
        )
      ]) : {};
      texteditor.$set(texteditor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(texteditor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(texteditor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(texteditor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_83.name,
    type: "if",
    source: "(489:44) ",
    ctx
  });
  return block;
}
function create_if_block_73(ctx) {
  let textarea;
  let textarea_validate_value;
  let textarea_data_validate_value;
  let textarea_data_validate_on_blur_value;
  let textarea_data_error_message_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      textarea = element("textarea");
      attr_dev(
        textarea,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        textarea,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        textarea,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        textarea,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        textarea,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        textarea,
        "inputmode",
        /*inputmode*/
        ctx[6]
      );
      attr_dev(
        textarea,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        textarea,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        textarea,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        textarea,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        textarea,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      textarea.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        textarea,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      textarea.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        textarea,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        textarea,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        textarea,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        textarea,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        textarea,
        "step",
        /*step*/
        ctx[22]
      );
      attr_dev(
        textarea,
        "multiple",
        /*multiple*/
        ctx[25]
      );
      textarea.readOnly = /*readonly*/
      ctx[7];
      textarea.required = /*required*/
      ctx[8];
      attr_dev(
        textarea,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        textarea,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        textarea,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      textarea.value = /*inputValue*/
      ctx[49];
      add_location(textarea, file51, 444, 14, 12735);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      ctx[79](textarea);
      if (
        /*autofocus*/
        ctx[18]
      )
        textarea.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          textarea,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (dirty[0] & /*name*/
      32) {
        attr_dev(
          textarea,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          textarea,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          textarea,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*size*/
      4096) {
        attr_dev(
          textarea,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*inputmode*/
      64) {
        attr_dev(
          textarea,
          "inputmode",
          /*inputmode*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*accept*/
      8192) {
        attr_dev(
          textarea,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          textarea,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          textarea,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          textarea,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          textarea,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          textarea,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          textarea,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (dirty[0] & /*disabled*/
      512) {
        prop_dev(
          textarea,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*max*/
      1048576) {
        attr_dev(
          textarea,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          textarea,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (dirty[0] & /*min*/
      2097152) {
        attr_dev(
          textarea,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          textarea,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*step*/
      4194304) {
        attr_dev(
          textarea,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (dirty[0] & /*multiple*/
      33554432) {
        attr_dev(
          textarea,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (dirty[0] & /*readonly*/
      128) {
        prop_dev(
          textarea,
          "readOnly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*required*/
      256) {
        prop_dev(
          textarea,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          textarea,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (dirty[0] & /*validate*/
      268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(textarea, "validate", textarea_validate_value);
      }
      if (dirty[0] & /*validate, validateOnBlur*/
      805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate", textarea_data_validate_value);
      }
      if (dirty[0] & /*validateOnBlur*/
      536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
      }
      if (dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          textarea,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (dirty[1] & /*errorMessageForce, errorMessage*/
      12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
      }
      if (dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          textarea,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (dirty[1] & /*inputValue*/
      262144) {
        prop_dev(
          textarea,
          "value",
          /*inputValue*/
          ctx2[49]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[79](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_73.name,
    type: "if",
    source: "(444:42) ",
    ctx
  });
  return block;
}
function create_if_block_63(ctx) {
  let select;
  let select_validate_value;
  let select_data_validate_value;
  let select_data_validate_on_blur_value;
  let select_data_error_message_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[77].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    null
  );
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      attr_dev(
        select,
        "style",
        /*inputStyle*/
        ctx[26]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[5]
      );
      attr_dev(
        select,
        "placeholder",
        /*placeholder*/
        ctx[10]
      );
      attr_dev(
        select,
        "id",
        /*inputId*/
        ctx[11]
      );
      attr_dev(
        select,
        "size",
        /*size*/
        ctx[12]
      );
      attr_dev(
        select,
        "accept",
        /*accept*/
        ctx[13]
      );
      attr_dev(
        select,
        "autocomplete",
        /*autocomplete*/
        ctx[14]
      );
      attr_dev(
        select,
        "autocorrect",
        /*autocorrect*/
        ctx[15]
      );
      attr_dev(
        select,
        "autocapitalize",
        /*autocapitalize*/
        ctx[16]
      );
      attr_dev(
        select,
        "spellcheck",
        /*spellcheck*/
        ctx[17]
      );
      select.autofocus = /*autofocus*/
      ctx[18];
      attr_dev(
        select,
        "autosave",
        /*autosave*/
        ctx[19]
      );
      select.disabled = /*disabled*/
      ctx[9];
      attr_dev(
        select,
        "max",
        /*max*/
        ctx[20]
      );
      attr_dev(
        select,
        "maxlength",
        /*maxlength*/
        ctx[23]
      );
      attr_dev(
        select,
        "min",
        /*min*/
        ctx[21]
      );
      attr_dev(
        select,
        "minlength",
        /*minlength*/
        ctx[24]
      );
      attr_dev(
        select,
        "step",
        /*step*/
        ctx[22]
      );
      select.multiple = /*multiple*/
      ctx[25];
      attr_dev(
        select,
        "readonly",
        /*readonly*/
        ctx[7]
      );
      select.required = /*required*/
      ctx[8];
      attr_dev(
        select,
        "pattern",
        /*pattern*/
        ctx[27]
      );
      attr_dev(select, "validate", select_validate_value = typeof /*validate*/
      ctx[28] === "string" && /*validate*/
      ctx[28].length ? (
        /*validate*/
        ctx[28]
      ) : void 0);
      attr_dev(select, "data-validate", select_data_validate_value = /*validate*/
      ctx[28] === true || /*validate*/
      ctx[28] === "" || /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx[29] === true || /*validateOnBlur*/
      ctx[29] === "" ? true : void 0);
      attr_dev(
        select,
        "tabindex",
        /*tabindex*/
        ctx[30]
      );
      attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/
      ctx[34] ? void 0 : (
        /*errorMessage*/
        ctx[33]
      ));
      attr_dev(
        select,
        "class",
        /*inputClasses*/
        ctx[46]
      );
      add_location(select, file51, 398, 14, 11182);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(
        select,
        /*inputValue*/
        ctx[49]
      );
      ctx[78](select);
      current = true;
      if (
        /*autofocus*/
        ctx[18]
      )
        select.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "focus",
            /*onFocus*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*onBlur*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*onInput*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*onChange*/
            ctx[55],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*inputStyle*/
      67108864) {
        attr_dev(
          select,
          "style",
          /*inputStyle*/
          ctx2[26]
        );
      }
      if (!current || dirty[0] & /*name*/
      32) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*placeholder*/
      1024) {
        attr_dev(
          select,
          "placeholder",
          /*placeholder*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*inputId*/
      2048) {
        attr_dev(
          select,
          "id",
          /*inputId*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*size*/
      4096) {
        attr_dev(
          select,
          "size",
          /*size*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*accept*/
      8192) {
        attr_dev(
          select,
          "accept",
          /*accept*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*autocomplete*/
      16384) {
        attr_dev(
          select,
          "autocomplete",
          /*autocomplete*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*autocorrect*/
      32768) {
        attr_dev(
          select,
          "autocorrect",
          /*autocorrect*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*autocapitalize*/
      65536) {
        attr_dev(
          select,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*spellcheck*/
      131072) {
        attr_dev(
          select,
          "spellcheck",
          /*spellcheck*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*autofocus*/
      262144) {
        prop_dev(
          select,
          "autofocus",
          /*autofocus*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*autosave*/
      524288) {
        attr_dev(
          select,
          "autosave",
          /*autosave*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      512) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*max*/
      1048576) {
        attr_dev(
          select,
          "max",
          /*max*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*maxlength*/
      8388608) {
        attr_dev(
          select,
          "maxlength",
          /*maxlength*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*min*/
      2097152) {
        attr_dev(
          select,
          "min",
          /*min*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*minlength*/
      16777216) {
        attr_dev(
          select,
          "minlength",
          /*minlength*/
          ctx2[24]
        );
      }
      if (!current || dirty[0] & /*step*/
      4194304) {
        attr_dev(
          select,
          "step",
          /*step*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*multiple*/
      33554432) {
        prop_dev(
          select,
          "multiple",
          /*multiple*/
          ctx2[25]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      128) {
        attr_dev(
          select,
          "readonly",
          /*readonly*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*required*/
      256) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*pattern*/
      134217728) {
        attr_dev(
          select,
          "pattern",
          /*pattern*/
          ctx2[27]
        );
      }
      if (!current || dirty[0] & /*validate*/
      268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/
      ctx2[28] === "string" && /*validate*/
      ctx2[28].length ? (
        /*validate*/
        ctx2[28]
      ) : void 0)) {
        attr_dev(select, "validate", select_validate_value);
      }
      if (!current || dirty[0] & /*validate, validateOnBlur*/
      805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/
      ctx2[28] === true || /*validate*/
      ctx2[28] === "" || /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(select, "data-validate", select_data_validate_value);
      }
      if (!current || dirty[0] & /*validateOnBlur*/
      536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/
      ctx2[29] === true || /*validateOnBlur*/
      ctx2[29] === "" ? true : void 0)) {
        attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
      }
      if (!current || dirty[0] & /*tabindex*/
      1073741824) {
        attr_dev(
          select,
          "tabindex",
          /*tabindex*/
          ctx2[30]
        );
      }
      if (!current || dirty[1] & /*errorMessageForce, errorMessage*/
      12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/
      ctx2[34] ? void 0 : (
        /*errorMessage*/
        ctx2[33]
      ))) {
        attr_dev(select, "data-error-message", select_data_error_message_value);
      }
      if (!current || dirty[1] & /*inputClasses*/
      32768) {
        attr_dev(
          select,
          "class",
          /*inputClasses*/
          ctx2[46]
        );
      }
      if (!current || dirty[1] & /*inputValue*/
      262144) {
        select_option(
          select,
          /*inputValue*/
          ctx2[49]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[78](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(398:12) {#if type === 'select'}",
    ctx
  });
  return block;
}
function create_if_block_46(ctx) {
  let div;
  let t0_value = plainText(
    /*errorMessage*/
    ctx[33]
  ) + "";
  let t0;
  let t1;
  let current;
  const error_message_slot_template = (
    /*#slots*/
    ctx[77]["error-message"]
  );
  const error_message_slot = create_slot(
    error_message_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_error_message_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (error_message_slot)
        error_message_slot.c();
      attr_dev(div, "class", "item-input-error-message");
      add_location(div, file51, 551, 12, 16431);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (error_message_slot) {
        error_message_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*errorMessage*/
      4) && t0_value !== (t0_value = plainText(
        /*errorMessage*/
        ctx2[33]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (error_message_slot) {
        if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            error_message_slot,
            error_message_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              error_message_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_error_message_slot_changes2
            ),
            get_error_message_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_message_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_message_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (error_message_slot)
        error_message_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(551:10) {#if hasErrorMessage && errorMessageForce}",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "input-clear-button");
      add_location(span, file51, 556, 27, 16616);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(557:10) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let div;
  let t0_value = plainText(
    /*info*/
    ctx[35]
  ) + "";
  let t0;
  let t1;
  let current;
  const info_slot_template = (
    /*#slots*/
    ctx[77].info
  );
  const info_slot = create_slot(
    info_slot_template,
    ctx,
    /*$$scope*/
    ctx[76],
    get_info_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (info_slot)
        info_slot.c();
      attr_dev(div, "class", "item-input-info");
      add_location(div, file51, 558, 12, 16729);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (info_slot) {
        info_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[1] & /*info*/
      16) && t0_value !== (t0_value = plainText(
        /*info*/
        ctx2[35]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (info_slot) {
        if (info_slot.p && (!current || dirty[2] & /*$$scope*/
        16384)) {
          update_slot_base(
            info_slot,
            info_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[76],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[76]
            ) : get_slot_changes(
              info_slot_template,
              /*$$scope*/
              ctx2[76],
              dirty,
              get_info_slot_changes2
            ),
            get_info_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (info_slot)
        info_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(558:10) {#if typeof info !== 'undefined' || hasInfoSlots}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file51, 571, 6, 17078);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(571:4) {#if isSortable && !isSortableOpposite}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block18, create_else_block_14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*wrap*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let isSortable;
  let isSortableOpposite;
  let inputType;
  let needsValue;
  let inputValue;
  let hasInfoSlots;
  let hasErrorSlots;
  let hasMediaSlots;
  let hasLabelSlots;
  let hasErrorMessage;
  let inputClasses;
  let itemContentClasses;
  let labelClasses;
  let inputWrapClasses;
  let classes;
  const omit_props_names = [
    "class",
    "sortable",
    "sortableOpposite",
    "media",
    "dropdown",
    "wrap",
    "input",
    "type",
    "name",
    "value",
    "inputmode",
    "readonly",
    "required",
    "disabled",
    "placeholder",
    "inputId",
    "size",
    "accept",
    "autocomplete",
    "autocorrect",
    "autocapitalize",
    "spellcheck",
    "autofocus",
    "autosave",
    "max",
    "min",
    "step",
    "maxlength",
    "minlength",
    "multiple",
    "inputStyle",
    "pattern",
    "validate",
    "validateOnBlur",
    "onValidate",
    "tabindex",
    "resizable",
    "clearButton",
    "noFormStoreData",
    "noStoreData",
    "ignoreStoreData",
    "errorMessage",
    "errorMessageForce",
    "info",
    "outline",
    "label",
    "inlineLabel",
    "floatingLabel",
    "calendarParams",
    "colorPickerParams",
    "textEditorParams",
    "calendarInstance",
    "colorPickerInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_input", slots, [
    "root-start",
    "content-start",
    "media",
    "inner-start",
    "label",
    "default",
    "input",
    "error-message",
    "info",
    "inner",
    "inner-end",
    "content",
    "content-end",
    "root",
    "root-end"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { sortable = void 0 } = $$props;
  let { sortableOpposite = void 0 } = $$props;
  let { media = void 0 } = $$props;
  let { dropdown = "auto" } = $$props;
  let { wrap = true } = $$props;
  let { input = true } = $$props;
  let { type = "text" } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { inputmode = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { inputId = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { accept = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocorrect = void 0 } = $$props;
  let { autocapitalize = void 0 } = $$props;
  let { spellcheck = void 0 } = $$props;
  let { autofocus = void 0 } = $$props;
  let { autosave = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { maxlength = void 0 } = $$props;
  let { minlength = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { inputStyle = void 0 } = $$props;
  let { pattern = void 0 } = $$props;
  let { validate = void 0 } = $$props;
  let { validateOnBlur = void 0 } = $$props;
  let { onValidate = void 0 } = $$props;
  let { tabindex = void 0 } = $$props;
  let { resizable = void 0 } = $$props;
  let { clearButton = void 0 } = $$props;
  let { noFormStoreData = void 0 } = $$props;
  let { noStoreData = void 0 } = $$props;
  let { ignoreStoreData = void 0 } = $$props;
  let { errorMessage = void 0 } = $$props;
  let { errorMessageForce = void 0 } = $$props;
  let { info = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { inlineLabel = void 0 } = $$props;
  let { floatingLabel = void 0 } = $$props;
  let { calendarParams = void 0 } = $$props;
  let { colorPickerParams = void 0 } = $$props;
  let { textEditorParams = void 0 } = $$props;
  let inputEl;
  let inputFocused = false;
  let inputInvalid = false;
  let updateInputOnDidUpdate = false;
  let f7Calendar;
  let f7ColorPicker;
  function calendarInstance() {
    return f7Calendar;
  }
  function colorPickerInstance() {
    return f7ColorPicker;
  }
  let ListContext = getReactiveContext("ListContext", (newValue) => {
    $$invalidate(74, ListContext = newValue || {});
  }) || {};
  function domValue() {
    if (!inputEl)
      return void 0;
    return inputEl.value;
  }
  function inputHasValue() {
    if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
      return false;
    }
    const domV = domValue();
    return typeof value === "undefined" ? domV || domV === 0 : value || value === 0;
  }
  function validateInput() {
    if (!app.f7 || !inputEl)
      return;
    const validity = inputEl.validity;
    if (!validity)
      return;
    if (!validity.valid) {
      if (onValidate)
        onValidate(false);
      if (inputInvalid !== true) {
        $$invalidate(73, inputInvalid = true);
      }
    } else {
      if (onValidate)
        onValidate(true);
      if (inputInvalid !== false) {
        $$invalidate(73, inputInvalid = false);
      }
    }
  }
  let initialWatched = false;
  function watchValue() {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (type === "range" || type === "toggle")
      return;
    if (!app.f7)
      return;
    updateInputOnDidUpdate = true;
    if (f7Calendar) {
      f7Calendar.setValue(value);
    }
    if (f7ColorPicker) {
      f7ColorPicker.setValue(value);
    }
  }
  function watchColorPickerParams() {
    if (!app.f7 || !f7ColorPicker)
      return;
    extend(f7ColorPicker.params, colorPickerParams || {});
  }
  function watchCalendarParams() {
    if (!app.f7 || !f7Calendar)
      return;
    extend(f7Calendar.params, calendarParams || {});
  }
  function onTextareaResize(event) {
    emit("textareaResize", [event]);
  }
  function onInputNotEmpty(event) {
    emit("inputNotEmpty", [event]);
  }
  function onInputEmpty(event) {
    emit("inputEmpty", [event]);
  }
  function onInputClear(event) {
    emit("inputClear", [event]);
  }
  function onInput(...args) {
    emit("input", [...args]);
    if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
      validateInput(inputEl);
    }
    if (inputEl && type !== "texteditor" && type !== "colorpicker" && type !== "datepicker") {
      $$invalidate(0, value = inputEl.value);
    }
  }
  function onFocus(...args) {
    emit("focus", [...args]);
    $$invalidate(72, inputFocused = true);
  }
  function onBlur(...args) {
    emit("blur", [...args]);
    if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
      validateInput();
    }
    $$invalidate(72, inputFocused = false);
  }
  function onChange(...args) {
    emit("change", [...args]);
    if (type === "texteditor") {
      emit("textEditorChange", [args[0]]);
      $$invalidate(0, value = args[0]);
    }
  }
  onMount(() => {
    f7ready(() => {
      if (type === "range" || type === "toggle")
        return;
      if (!inputEl)
        return;
      inputEl.addEventListener("input:notempty", onInputNotEmpty, false);
      if (type === "textarea" && resizable) {
        inputEl.addEventListener("textarea:resize", onTextareaResize, false);
      }
      if (clearButton) {
        inputEl.addEventListener("input:empty", onInputEmpty, false);
        inputEl.addEventListener("input:clear", onInputClear, false);
      }
      if (type === "datepicker") {
        f7Calendar = app.f7.calendar.create({
          inputEl,
          value,
          on: {
            change(calendar, calendarValue) {
              emit("calendarChange", [calendarValue]);
              $$invalidate(0, value = calendarValue);
            }
          },
          ...calendarParams || {}
        });
      }
      if (type === "colorpicker") {
        f7ColorPicker = app.f7.colorPicker.create({
          inputEl,
          value,
          on: {
            change(colorPicker, colorPickerValue) {
              emit("colorPickerChange", [colorPickerValue]);
              $$invalidate(0, value = colorPickerValue);
            }
          },
          ...colorPickerParams || {}
        });
      }
      app.f7.input.checkEmptyState(inputEl);
      if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && typeof value !== "undefined" && value !== null && value !== "") {
        setTimeout(
          () => {
            validateInput();
          },
          0
        );
      }
      if (resizable) {
        app.f7.input.resizeTextarea(inputEl);
      }
    });
  });
  afterUpdate(() => {
    if (!app.f7)
      return;
    if (updateInputOnDidUpdate) {
      if (!inputEl)
        return;
      updateInputOnDidUpdate = false;
      app.f7.input.checkEmptyState(inputEl);
      if (validate && !validateOnBlur) {
        validateInput();
      }
      if (resizable) {
        app.f7.input.resizeTextarea(inputEl);
      }
    }
  });
  onDestroy(() => {
    if (type === "range" || type === "toggle")
      return;
    if (!inputEl)
      return;
    inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);
    if (type === "textarea" && resizable) {
      inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
    }
    if (clearButton) {
      inputEl.removeEventListener("input:empty", onInputEmpty, false);
      inputEl.removeEventListener("input:clear", onInputClear, false);
    }
    if (f7Calendar && f7Calendar.destroy) {
      f7Calendar.destroy();
    }
    if (f7ColorPicker && f7ColorPicker.destroy) {
      f7ColorPicker.destroy();
    }
    f7Calendar = null;
    f7ColorPicker = null;
  });
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  function select_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  function textarea_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  function input_1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(41, inputEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(100, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(56, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(57, className = $$new_props.class);
    if ("sortable" in $$new_props)
      $$invalidate(58, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$new_props)
      $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    if ("media" in $$new_props)
      $$invalidate(1, media = $$new_props.media);
    if ("dropdown" in $$new_props)
      $$invalidate(60, dropdown = $$new_props.dropdown);
    if ("wrap" in $$new_props)
      $$invalidate(2, wrap = $$new_props.wrap);
    if ("input" in $$new_props)
      $$invalidate(3, input = $$new_props.input);
    if ("type" in $$new_props)
      $$invalidate(4, type = $$new_props.type);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("inputmode" in $$new_props)
      $$invalidate(6, inputmode = $$new_props.inputmode);
    if ("readonly" in $$new_props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("required" in $$new_props)
      $$invalidate(8, required = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("placeholder" in $$new_props)
      $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("inputId" in $$new_props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("accept" in $$new_props)
      $$invalidate(13, accept = $$new_props.accept);
    if ("autocomplete" in $$new_props)
      $$invalidate(14, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$new_props)
      $$invalidate(15, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$new_props)
      $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$new_props)
      $$invalidate(17, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$new_props)
      $$invalidate(18, autofocus = $$new_props.autofocus);
    if ("autosave" in $$new_props)
      $$invalidate(19, autosave = $$new_props.autosave);
    if ("max" in $$new_props)
      $$invalidate(20, max = $$new_props.max);
    if ("min" in $$new_props)
      $$invalidate(21, min = $$new_props.min);
    if ("step" in $$new_props)
      $$invalidate(22, step = $$new_props.step);
    if ("maxlength" in $$new_props)
      $$invalidate(23, maxlength = $$new_props.maxlength);
    if ("minlength" in $$new_props)
      $$invalidate(24, minlength = $$new_props.minlength);
    if ("multiple" in $$new_props)
      $$invalidate(25, multiple = $$new_props.multiple);
    if ("inputStyle" in $$new_props)
      $$invalidate(26, inputStyle = $$new_props.inputStyle);
    if ("pattern" in $$new_props)
      $$invalidate(27, pattern = $$new_props.pattern);
    if ("validate" in $$new_props)
      $$invalidate(28, validate = $$new_props.validate);
    if ("validateOnBlur" in $$new_props)
      $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    if ("onValidate" in $$new_props)
      $$invalidate(61, onValidate = $$new_props.onValidate);
    if ("tabindex" in $$new_props)
      $$invalidate(30, tabindex = $$new_props.tabindex);
    if ("resizable" in $$new_props)
      $$invalidate(31, resizable = $$new_props.resizable);
    if ("clearButton" in $$new_props)
      $$invalidate(32, clearButton = $$new_props.clearButton);
    if ("noFormStoreData" in $$new_props)
      $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    if ("noStoreData" in $$new_props)
      $$invalidate(63, noStoreData = $$new_props.noStoreData);
    if ("ignoreStoreData" in $$new_props)
      $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    if ("errorMessage" in $$new_props)
      $$invalidate(33, errorMessage = $$new_props.errorMessage);
    if ("errorMessageForce" in $$new_props)
      $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    if ("info" in $$new_props)
      $$invalidate(35, info = $$new_props.info);
    if ("outline" in $$new_props)
      $$invalidate(65, outline = $$new_props.outline);
    if ("label" in $$new_props)
      $$invalidate(36, label = $$new_props.label);
    if ("inlineLabel" in $$new_props)
      $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    if ("floatingLabel" in $$new_props)
      $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    if ("calendarParams" in $$new_props)
      $$invalidate(68, calendarParams = $$new_props.calendarParams);
    if ("colorPickerParams" in $$new_props)
      $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    if ("textEditorParams" in $$new_props)
      $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    if ("$$scope" in $$new_props)
      $$invalidate(76, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    afterUpdate,
    onDestroy,
    colorClasses,
    classNames,
    extend,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    getReactiveContext,
    TextEditor: text_editor_default,
    emit,
    className,
    sortable,
    sortableOpposite,
    media,
    dropdown,
    wrap,
    input,
    type,
    name,
    value,
    inputmode,
    readonly,
    required,
    disabled,
    placeholder,
    inputId,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    inputStyle,
    pattern,
    validate,
    validateOnBlur,
    onValidate,
    tabindex,
    resizable,
    clearButton,
    noFormStoreData,
    noStoreData,
    ignoreStoreData,
    errorMessage,
    errorMessageForce,
    info,
    outline,
    label,
    inlineLabel,
    floatingLabel,
    calendarParams,
    colorPickerParams,
    textEditorParams,
    inputEl,
    inputFocused,
    inputInvalid,
    updateInputOnDidUpdate,
    f7Calendar,
    f7ColorPicker,
    calendarInstance,
    colorPickerInstance,
    ListContext,
    domValue,
    inputHasValue,
    validateInput,
    initialWatched,
    watchValue,
    watchColorPickerParams,
    watchCalendarParams,
    onTextareaResize,
    onInputNotEmpty,
    onInputEmpty,
    onInputClear,
    onInput,
    onFocus,
    onBlur,
    onChange,
    classes,
    inputWrapClasses,
    labelClasses,
    hasErrorMessage,
    hasInfoSlots,
    itemContentClasses,
    inputType,
    inputClasses,
    hasErrorSlots,
    hasLabelSlots,
    hasMediaSlots,
    inputValue,
    needsValue,
    isSortableOpposite,
    isSortable
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(100, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(57, className = $$new_props.className);
    if ("sortable" in $$props)
      $$invalidate(58, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$props)
      $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    if ("media" in $$props)
      $$invalidate(1, media = $$new_props.media);
    if ("dropdown" in $$props)
      $$invalidate(60, dropdown = $$new_props.dropdown);
    if ("wrap" in $$props)
      $$invalidate(2, wrap = $$new_props.wrap);
    if ("input" in $$props)
      $$invalidate(3, input = $$new_props.input);
    if ("type" in $$props)
      $$invalidate(4, type = $$new_props.type);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("inputmode" in $$props)
      $$invalidate(6, inputmode = $$new_props.inputmode);
    if ("readonly" in $$props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("required" in $$props)
      $$invalidate(8, required = $$new_props.required);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("placeholder" in $$props)
      $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("inputId" in $$props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("size" in $$props)
      $$invalidate(12, size = $$new_props.size);
    if ("accept" in $$props)
      $$invalidate(13, accept = $$new_props.accept);
    if ("autocomplete" in $$props)
      $$invalidate(14, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$props)
      $$invalidate(15, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$props)
      $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$props)
      $$invalidate(17, spellcheck = $$new_props.spellcheck);
    if ("autofocus" in $$props)
      $$invalidate(18, autofocus = $$new_props.autofocus);
    if ("autosave" in $$props)
      $$invalidate(19, autosave = $$new_props.autosave);
    if ("max" in $$props)
      $$invalidate(20, max = $$new_props.max);
    if ("min" in $$props)
      $$invalidate(21, min = $$new_props.min);
    if ("step" in $$props)
      $$invalidate(22, step = $$new_props.step);
    if ("maxlength" in $$props)
      $$invalidate(23, maxlength = $$new_props.maxlength);
    if ("minlength" in $$props)
      $$invalidate(24, minlength = $$new_props.minlength);
    if ("multiple" in $$props)
      $$invalidate(25, multiple = $$new_props.multiple);
    if ("inputStyle" in $$props)
      $$invalidate(26, inputStyle = $$new_props.inputStyle);
    if ("pattern" in $$props)
      $$invalidate(27, pattern = $$new_props.pattern);
    if ("validate" in $$props)
      $$invalidate(28, validate = $$new_props.validate);
    if ("validateOnBlur" in $$props)
      $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    if ("onValidate" in $$props)
      $$invalidate(61, onValidate = $$new_props.onValidate);
    if ("tabindex" in $$props)
      $$invalidate(30, tabindex = $$new_props.tabindex);
    if ("resizable" in $$props)
      $$invalidate(31, resizable = $$new_props.resizable);
    if ("clearButton" in $$props)
      $$invalidate(32, clearButton = $$new_props.clearButton);
    if ("noFormStoreData" in $$props)
      $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    if ("noStoreData" in $$props)
      $$invalidate(63, noStoreData = $$new_props.noStoreData);
    if ("ignoreStoreData" in $$props)
      $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    if ("errorMessage" in $$props)
      $$invalidate(33, errorMessage = $$new_props.errorMessage);
    if ("errorMessageForce" in $$props)
      $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    if ("info" in $$props)
      $$invalidate(35, info = $$new_props.info);
    if ("outline" in $$props)
      $$invalidate(65, outline = $$new_props.outline);
    if ("label" in $$props)
      $$invalidate(36, label = $$new_props.label);
    if ("inlineLabel" in $$props)
      $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    if ("floatingLabel" in $$props)
      $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    if ("calendarParams" in $$props)
      $$invalidate(68, calendarParams = $$new_props.calendarParams);
    if ("colorPickerParams" in $$props)
      $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    if ("textEditorParams" in $$props)
      $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    if ("inputEl" in $$props)
      $$invalidate(41, inputEl = $$new_props.inputEl);
    if ("inputFocused" in $$props)
      $$invalidate(72, inputFocused = $$new_props.inputFocused);
    if ("inputInvalid" in $$props)
      $$invalidate(73, inputInvalid = $$new_props.inputInvalid);
    if ("updateInputOnDidUpdate" in $$props)
      updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
    if ("f7Calendar" in $$props)
      f7Calendar = $$new_props.f7Calendar;
    if ("f7ColorPicker" in $$props)
      f7ColorPicker = $$new_props.f7ColorPicker;
    if ("ListContext" in $$props)
      $$invalidate(74, ListContext = $$new_props.ListContext);
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(42, classes = $$new_props.classes);
    if ("inputWrapClasses" in $$props)
      $$invalidate(43, inputWrapClasses = $$new_props.inputWrapClasses);
    if ("labelClasses" in $$props)
      $$invalidate(44, labelClasses = $$new_props.labelClasses);
    if ("hasErrorMessage" in $$props)
      $$invalidate(38, hasErrorMessage = $$new_props.hasErrorMessage);
    if ("hasInfoSlots" in $$props)
      $$invalidate(39, hasInfoSlots = $$new_props.hasInfoSlots);
    if ("itemContentClasses" in $$props)
      $$invalidate(45, itemContentClasses = $$new_props.itemContentClasses);
    if ("inputType" in $$props)
      $$invalidate(40, inputType = $$new_props.inputType);
    if ("inputClasses" in $$props)
      $$invalidate(46, inputClasses = $$new_props.inputClasses);
    if ("hasErrorSlots" in $$props)
      $$invalidate(75, hasErrorSlots = $$new_props.hasErrorSlots);
    if ("hasLabelSlots" in $$props)
      $$invalidate(47, hasLabelSlots = $$new_props.hasLabelSlots);
    if ("hasMediaSlots" in $$props)
      $$invalidate(48, hasMediaSlots = $$new_props.hasMediaSlots);
    if ("inputValue" in $$props)
      $$invalidate(49, inputValue = $$new_props.inputValue);
    if ("needsValue" in $$props)
      needsValue = $$new_props.needsValue;
    if ("isSortableOpposite" in $$props)
      $$invalidate(50, isSortableOpposite = $$new_props.isSortableOpposite);
    if ("isSortable" in $$props)
      $$invalidate(51, isSortable = $$new_props.isSortable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*sortable*/
    134217728 | $$self.$$.dirty[2] & /*ListContext*/
    4096) {
      $:
        $$invalidate(51, isSortable = sortable === true || sortable === false ? sortable : ListContext.listIsSortable);
    }
    if ($$self.$$.dirty[1] & /*sortableOpposite*/
    268435456 | $$self.$$.dirty[2] & /*ListContext*/
    4096) {
      $:
        $$invalidate(50, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        watchValue(value);
    }
    if ($$self.$$.dirty[2] & /*colorPickerParams*/
    128) {
      $:
        watchColorPickerParams(colorPickerParams);
    }
    if ($$self.$$.dirty[2] & /*calendarParams*/
    64) {
      $:
        watchCalendarParams(calendarParams);
    }
    if ($$self.$$.dirty[0] & /*type*/
    16) {
      $:
        $$invalidate(40, inputType = type === "datepicker" || type === "colorpicker" ? "text" : type);
    }
    if ($$self.$$.dirty[0] & /*type*/
    16) {
      $:
        needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        $$invalidate(49, inputValue = (() => {
          let v;
          if (typeof value !== "undefined") {
            v = value;
          } else {
            v = domValue();
          }
          if (typeof v === "undefined" || v === null)
            return "";
          return v;
        })());
    }
    if ($$self.$$.dirty[1] & /*errorMessage*/
    4 | $$self.$$.dirty[2] & /*hasErrorSlots*/
    8192) {
      $:
        $$invalidate(38, hasErrorMessage = !!errorMessage || hasErrorSlots);
    }
    if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/
    525 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/
    3079) {
      $:
        $$invalidate(46, inputClasses = classNames({
          resizable: inputType === "textarea" && resizable,
          "no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
          "input-invalid": errorMessage && errorMessageForce || inputInvalid,
          "input-with-value": inputHasValue(),
          "input-focused": inputFocused
        }));
    }
    $:
      $$invalidate(45, itemContentClasses = classNames("item-content item-input", !wrap && className, !wrap && { disabled }, !wrap && colorClasses($$props), {
        "inline-label": inlineLabel,
        "item-input-outline": outline,
        "item-input-focused": inputFocused,
        "item-input-with-info": !!info || hasInfoSlots,
        "item-input-with-value": inputHasValue(),
        "item-input-with-error-message": hasErrorMessage && errorMessageForce || inputInvalid,
        "item-input-invalid": hasErrorMessage && errorMessageForce || inputInvalid
      }));
    if ($$self.$$.dirty[2] & /*floatingLabel*/
    32) {
      $:
        $$invalidate(44, labelClasses = classNames("item-title item-label", { "item-floating-label": floatingLabel }));
    }
    if ($$self.$$.dirty[0] & /*type*/
    16 | $$self.$$.dirty[1] & /*dropdown*/
    536870912) {
      $:
        $$invalidate(43, inputWrapClasses = classNames("item-input-wrap", {
          "input-dropdown": dropdown === "auto" ? type === "select" : dropdown
        }));
    }
    $:
      $$invalidate(42, classes = classNames(className, { disabled }, colorClasses($$props)));
  };
  $:
    $$invalidate(39, hasInfoSlots = $$slots.info);
  $:
    $$invalidate(75, hasErrorSlots = $$slots["error-message"]);
  $:
    $$invalidate(48, hasMediaSlots = $$slots.media);
  $:
    $$invalidate(47, hasLabelSlots = $$slots.label);
  $$props = exclude_internal_props($$props);
  return [
    value,
    media,
    wrap,
    input,
    type,
    name,
    inputmode,
    readonly,
    required,
    disabled,
    placeholder,
    inputId,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    inputStyle,
    pattern,
    validate,
    validateOnBlur,
    tabindex,
    resizable,
    clearButton,
    errorMessage,
    errorMessageForce,
    info,
    label,
    textEditorParams,
    hasErrorMessage,
    hasInfoSlots,
    inputType,
    inputEl,
    classes,
    inputWrapClasses,
    labelClasses,
    itemContentClasses,
    inputClasses,
    hasLabelSlots,
    hasMediaSlots,
    inputValue,
    isSortableOpposite,
    isSortable,
    onInput,
    onFocus,
    onBlur,
    onChange,
    $$restProps,
    className,
    sortable,
    sortableOpposite,
    dropdown,
    onValidate,
    noFormStoreData,
    noStoreData,
    ignoreStoreData,
    outline,
    inlineLabel,
    floatingLabel,
    calendarParams,
    colorPickerParams,
    calendarInstance,
    colorPickerInstance,
    inputFocused,
    inputInvalid,
    ListContext,
    hasErrorSlots,
    $$scope,
    slots,
    select_binding,
    textarea_binding,
    input_1_binding,
    select_binding_1,
    textarea_binding_1,
    input_1_binding_1
  ];
}
var List_input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance43,
      create_fragment54,
      safe_not_equal,
      {
        class: 57,
        sortable: 58,
        sortableOpposite: 59,
        media: 1,
        dropdown: 60,
        wrap: 2,
        input: 3,
        type: 4,
        name: 5,
        value: 0,
        inputmode: 6,
        readonly: 7,
        required: 8,
        disabled: 9,
        placeholder: 10,
        inputId: 11,
        size: 12,
        accept: 13,
        autocomplete: 14,
        autocorrect: 15,
        autocapitalize: 16,
        spellcheck: 17,
        autofocus: 18,
        autosave: 19,
        max: 20,
        min: 21,
        step: 22,
        maxlength: 23,
        minlength: 24,
        multiple: 25,
        inputStyle: 26,
        pattern: 27,
        validate: 28,
        validateOnBlur: 29,
        onValidate: 61,
        tabindex: 30,
        resizable: 31,
        clearButton: 32,
        noFormStoreData: 62,
        noStoreData: 63,
        ignoreStoreData: 64,
        errorMessage: 33,
        errorMessageForce: 34,
        info: 35,
        outline: 65,
        label: 36,
        inlineLabel: 66,
        floatingLabel: 67,
        calendarParams: 68,
        colorPickerParams: 69,
        textEditorParams: 37,
        calendarInstance: 70,
        colorPickerInstance: 71
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_input",
      options,
      id: create_fragment54.name
    });
  }
  get class() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableOpposite() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableOpposite(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get media() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set media(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdown() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdown(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputmode() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputmode(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocorrect() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocorrect(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocapitalize() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocapitalize(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spellcheck() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spellcheck(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autosave() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autosave(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minlength() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minlength(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyle() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyle(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validate(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateOnBlur() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateOnBlur(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValidate() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValidate(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButton() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButton(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noFormStoreData() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noFormStoreData(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noStoreData() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noStoreData(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignoreStoreData() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignoreStoreData(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorMessage() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorMessage(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorMessageForce() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorMessageForce(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get info() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set info(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inlineLabel() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inlineLabel(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingLabel() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingLabel(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calendarParams() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set calendarParams(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorPickerParams() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorPickerParams(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textEditorParams() {
    throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textEditorParams(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calendarInstance() {
    return this.$$.ctx[70];
  }
  set calendarInstance(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorPickerInstance() {
    return this.$$.ctx[71];
  }
  set colorPickerInstance(value) {
    throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_input_default = List_input;

// node_modules/framework7-svelte/components/list-item-cell.svelte
var file52 = "node_modules/framework7-svelte/components/list-item-cell.svelte";
function create_fragment55(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file52, 11, 0, 318);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_item_cell", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "item-cell", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var List_item_cell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment55, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_item_cell",
      options,
      id: create_fragment55.name
    });
  }
  get class() {
    throw new Error("<List_item_cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_item_cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_item_cell_default = List_item_cell;

// node_modules/framework7-svelte/components/list-item-row.svelte
var file53 = "node_modules/framework7-svelte/components/list-item-row.svelte";
function create_fragment56(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file53, 11, 0, 317);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_item_row", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "item-row", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var List_item_row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment56, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_item_row",
      options,
      id: create_fragment56.name
    });
  }
  get class() {
    throw new Error("<List_item_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_item_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_item_row_default = List_item_row;

// node_modules/framework7-svelte/components/list-item.svelte
var file54 = "node_modules/framework7-svelte/components/list-item.svelte";
var get_root_end_slot_changes3 = (dirty) => ({});
var get_root_end_slot_context3 = (ctx) => ({});
var get_root_slot_changes4 = (dirty) => ({});
var get_root_slot_context4 = (ctx) => ({});
var get_content_end_slot_changes_5 = (dirty) => ({});
var get_content_end_slot_context_5 = (ctx) => ({});
var get_content_slot_changes_5 = (dirty) => ({});
var get_content_slot_context_5 = (ctx) => ({});
var get_inner_end_slot_changes_5 = (dirty) => ({});
var get_inner_end_slot_context_5 = (ctx) => ({});
var get_inner_slot_changes_11 = (dirty) => ({});
var get_inner_slot_context_11 = (ctx) => ({});
var get_after_end_slot_changes_11 = (dirty) => ({});
var get_after_end_slot_context_11 = (ctx) => ({});
var get_after_slot_changes_11 = (dirty) => ({});
var get_after_slot_context_11 = (ctx) => ({});
var get_after_start_slot_changes_11 = (dirty) => ({});
var get_after_start_slot_context_11 = (ctx) => ({});
var get_after_title_slot_changes_11 = (dirty) => ({});
var get_after_title_slot_context_11 = (ctx) => ({});
var get_footer_slot_changes_11 = (dirty) => ({});
var get_footer_slot_context_11 = (ctx) => ({});
var get_title_slot_changes_11 = (dirty) => ({});
var get_title_slot_context_11 = (ctx) => ({});
var get_header_slot_changes_11 = (dirty) => ({});
var get_header_slot_context_11 = (ctx) => ({});
var get_before_title_slot_changes_11 = (dirty) => ({});
var get_before_title_slot_context_11 = (ctx) => ({});
var get_footer_slot_changes_10 = (dirty) => ({});
var get_footer_slot_context_10 = (ctx) => ({});
var get_inner_slot_changes_10 = (dirty) => ({});
var get_inner_slot_context_10 = (ctx) => ({});
var get_text_slot_changes_5 = (dirty) => ({});
var get_text_slot_context_5 = (ctx) => ({});
var get_subtitle_slot_changes_5 = (dirty) => ({});
var get_subtitle_slot_context_5 = (ctx) => ({});
var get_after_end_slot_changes_10 = (dirty) => ({});
var get_after_end_slot_context_10 = (ctx) => ({});
var get_after_slot_changes_10 = (dirty) => ({});
var get_after_slot_context_10 = (ctx) => ({});
var get_after_start_slot_changes_10 = (dirty) => ({});
var get_after_start_slot_context_10 = (ctx) => ({});
var get_after_title_slot_changes_10 = (dirty) => ({});
var get_after_title_slot_context_10 = (ctx) => ({});
var get_title_slot_changes_10 = (dirty) => ({});
var get_title_slot_context_10 = (ctx) => ({});
var get_before_title_slot_changes_10 = (dirty) => ({});
var get_before_title_slot_context_10 = (ctx) => ({});
var get_header_slot_changes_10 = (dirty) => ({});
var get_header_slot_context_10 = (ctx) => ({});
var get_inner_start_slot_changes_5 = (dirty) => ({});
var get_inner_start_slot_context_5 = (ctx) => ({});
var get_media_slot_changes_5 = (dirty) => ({});
var get_media_slot_context_5 = (ctx) => ({});
var get_content_start_slot_changes_5 = (dirty) => ({});
var get_content_start_slot_context_5 = (ctx) => ({});
var get_content_end_slot_changes_4 = (dirty) => ({});
var get_content_end_slot_context_4 = (ctx) => ({});
var get_content_slot_changes_4 = (dirty) => ({});
var get_content_slot_context_4 = (ctx) => ({});
var get_inner_end_slot_changes_4 = (dirty) => ({});
var get_inner_end_slot_context_4 = (ctx) => ({});
var get_inner_slot_changes_9 = (dirty) => ({});
var get_inner_slot_context_9 = (ctx) => ({});
var get_after_end_slot_changes_9 = (dirty) => ({});
var get_after_end_slot_context_9 = (ctx) => ({});
var get_after_slot_changes_9 = (dirty) => ({});
var get_after_slot_context_9 = (ctx) => ({});
var get_after_start_slot_changes_9 = (dirty) => ({});
var get_after_start_slot_context_9 = (ctx) => ({});
var get_after_title_slot_changes_9 = (dirty) => ({});
var get_after_title_slot_context_9 = (ctx) => ({});
var get_footer_slot_changes_9 = (dirty) => ({});
var get_footer_slot_context_9 = (ctx) => ({});
var get_title_slot_changes_9 = (dirty) => ({});
var get_title_slot_context_9 = (ctx) => ({});
var get_header_slot_changes_9 = (dirty) => ({});
var get_header_slot_context_9 = (ctx) => ({});
var get_before_title_slot_changes_9 = (dirty) => ({});
var get_before_title_slot_context_9 = (ctx) => ({});
var get_footer_slot_changes_8 = (dirty) => ({});
var get_footer_slot_context_8 = (ctx) => ({});
var get_inner_slot_changes_8 = (dirty) => ({});
var get_inner_slot_context_8 = (ctx) => ({});
var get_text_slot_changes_4 = (dirty) => ({});
var get_text_slot_context_4 = (ctx) => ({});
var get_subtitle_slot_changes_4 = (dirty) => ({});
var get_subtitle_slot_context_4 = (ctx) => ({});
var get_after_end_slot_changes_8 = (dirty) => ({});
var get_after_end_slot_context_8 = (ctx) => ({});
var get_after_slot_changes_8 = (dirty) => ({});
var get_after_slot_context_8 = (ctx) => ({});
var get_after_start_slot_changes_8 = (dirty) => ({});
var get_after_start_slot_context_8 = (ctx) => ({});
var get_after_title_slot_changes_8 = (dirty) => ({});
var get_after_title_slot_context_8 = (ctx) => ({});
var get_title_slot_changes_8 = (dirty) => ({});
var get_title_slot_context_8 = (ctx) => ({});
var get_before_title_slot_changes_8 = (dirty) => ({});
var get_before_title_slot_context_8 = (ctx) => ({});
var get_header_slot_changes_8 = (dirty) => ({});
var get_header_slot_context_8 = (ctx) => ({});
var get_inner_start_slot_changes_4 = (dirty) => ({});
var get_inner_start_slot_context_4 = (ctx) => ({});
var get_media_slot_changes_4 = (dirty) => ({});
var get_media_slot_context_4 = (ctx) => ({});
var get_content_start_slot_changes_4 = (dirty) => ({});
var get_content_start_slot_context_4 = (ctx) => ({});
var get_content_end_slot_changes_3 = (dirty) => ({});
var get_content_end_slot_context_3 = (ctx) => ({});
var get_content_slot_changes_3 = (dirty) => ({});
var get_content_slot_context_3 = (ctx) => ({});
var get_inner_end_slot_changes_3 = (dirty) => ({});
var get_inner_end_slot_context_3 = (ctx) => ({});
var get_inner_slot_changes_7 = (dirty) => ({});
var get_inner_slot_context_7 = (ctx) => ({});
var get_after_end_slot_changes_7 = (dirty) => ({});
var get_after_end_slot_context_7 = (ctx) => ({});
var get_after_slot_changes_7 = (dirty) => ({});
var get_after_slot_context_7 = (ctx) => ({});
var get_after_start_slot_changes_7 = (dirty) => ({});
var get_after_start_slot_context_7 = (ctx) => ({});
var get_after_title_slot_changes_7 = (dirty) => ({});
var get_after_title_slot_context_7 = (ctx) => ({});
var get_footer_slot_changes_7 = (dirty) => ({});
var get_footer_slot_context_7 = (ctx) => ({});
var get_title_slot_changes_7 = (dirty) => ({});
var get_title_slot_context_7 = (ctx) => ({});
var get_header_slot_changes_7 = (dirty) => ({});
var get_header_slot_context_7 = (ctx) => ({});
var get_before_title_slot_changes_7 = (dirty) => ({});
var get_before_title_slot_context_7 = (ctx) => ({});
var get_footer_slot_changes_6 = (dirty) => ({});
var get_footer_slot_context_6 = (ctx) => ({});
var get_inner_slot_changes_6 = (dirty) => ({});
var get_inner_slot_context_6 = (ctx) => ({});
var get_text_slot_changes_3 = (dirty) => ({});
var get_text_slot_context_3 = (ctx) => ({});
var get_subtitle_slot_changes_3 = (dirty) => ({});
var get_subtitle_slot_context_3 = (ctx) => ({});
var get_after_end_slot_changes_6 = (dirty) => ({});
var get_after_end_slot_context_6 = (ctx) => ({});
var get_after_slot_changes_6 = (dirty) => ({});
var get_after_slot_context_6 = (ctx) => ({});
var get_after_start_slot_changes_6 = (dirty) => ({});
var get_after_start_slot_context_6 = (ctx) => ({});
var get_after_title_slot_changes_6 = (dirty) => ({});
var get_after_title_slot_context_6 = (ctx) => ({});
var get_title_slot_changes_6 = (dirty) => ({});
var get_title_slot_context_6 = (ctx) => ({});
var get_before_title_slot_changes_6 = (dirty) => ({});
var get_before_title_slot_context_6 = (ctx) => ({});
var get_header_slot_changes_6 = (dirty) => ({});
var get_header_slot_context_6 = (ctx) => ({});
var get_inner_start_slot_changes_3 = (dirty) => ({});
var get_inner_start_slot_context_3 = (ctx) => ({});
var get_media_slot_changes_3 = (dirty) => ({});
var get_media_slot_context_3 = (ctx) => ({});
var get_content_start_slot_changes_3 = (dirty) => ({});
var get_content_start_slot_context_3 = (ctx) => ({});
var get_content_end_slot_changes_2 = (dirty) => ({});
var get_content_end_slot_context_2 = (ctx) => ({});
var get_content_slot_changes_2 = (dirty) => ({});
var get_content_slot_context_2 = (ctx) => ({});
var get_inner_end_slot_changes_2 = (dirty) => ({});
var get_inner_end_slot_context_2 = (ctx) => ({});
var get_inner_slot_changes_5 = (dirty) => ({});
var get_inner_slot_context_5 = (ctx) => ({});
var get_after_end_slot_changes_5 = (dirty) => ({});
var get_after_end_slot_context_5 = (ctx) => ({});
var get_after_slot_changes_5 = (dirty) => ({});
var get_after_slot_context_5 = (ctx) => ({});
var get_after_start_slot_changes_5 = (dirty) => ({});
var get_after_start_slot_context_5 = (ctx) => ({});
var get_after_title_slot_changes_5 = (dirty) => ({});
var get_after_title_slot_context_5 = (ctx) => ({});
var get_footer_slot_changes_5 = (dirty) => ({});
var get_footer_slot_context_5 = (ctx) => ({});
var get_title_slot_changes_5 = (dirty) => ({});
var get_title_slot_context_5 = (ctx) => ({});
var get_header_slot_changes_5 = (dirty) => ({});
var get_header_slot_context_5 = (ctx) => ({});
var get_before_title_slot_changes_5 = (dirty) => ({});
var get_before_title_slot_context_5 = (ctx) => ({});
var get_footer_slot_changes_4 = (dirty) => ({});
var get_footer_slot_context_4 = (ctx) => ({});
var get_inner_slot_changes_4 = (dirty) => ({});
var get_inner_slot_context_4 = (ctx) => ({});
var get_text_slot_changes_2 = (dirty) => ({});
var get_text_slot_context_2 = (ctx) => ({});
var get_subtitle_slot_changes_2 = (dirty) => ({});
var get_subtitle_slot_context_2 = (ctx) => ({});
var get_after_end_slot_changes_4 = (dirty) => ({});
var get_after_end_slot_context_4 = (ctx) => ({});
var get_after_slot_changes_4 = (dirty) => ({});
var get_after_slot_context_4 = (ctx) => ({});
var get_after_start_slot_changes_4 = (dirty) => ({});
var get_after_start_slot_context_4 = (ctx) => ({});
var get_after_title_slot_changes_4 = (dirty) => ({});
var get_after_title_slot_context_4 = (ctx) => ({});
var get_title_slot_changes_4 = (dirty) => ({});
var get_title_slot_context_4 = (ctx) => ({});
var get_before_title_slot_changes_4 = (dirty) => ({});
var get_before_title_slot_context_4 = (ctx) => ({});
var get_header_slot_changes_4 = (dirty) => ({});
var get_header_slot_context_4 = (ctx) => ({});
var get_inner_start_slot_changes_2 = (dirty) => ({});
var get_inner_start_slot_context_2 = (ctx) => ({});
var get_media_slot_changes_2 = (dirty) => ({});
var get_media_slot_context_2 = (ctx) => ({});
var get_content_start_slot_changes_2 = (dirty) => ({});
var get_content_start_slot_context_2 = (ctx) => ({});
var get_content_end_slot_changes_12 = (dirty) => ({});
var get_content_end_slot_context_12 = (ctx) => ({});
var get_content_slot_changes_12 = (dirty) => ({});
var get_content_slot_context_12 = (ctx) => ({});
var get_inner_end_slot_changes_12 = (dirty) => ({});
var get_inner_end_slot_context_12 = (ctx) => ({});
var get_inner_slot_changes_3 = (dirty) => ({});
var get_inner_slot_context_3 = (ctx) => ({});
var get_after_end_slot_changes_3 = (dirty) => ({});
var get_after_end_slot_context_3 = (ctx) => ({});
var get_after_slot_changes_3 = (dirty) => ({});
var get_after_slot_context_3 = (ctx) => ({});
var get_after_start_slot_changes_3 = (dirty) => ({});
var get_after_start_slot_context_3 = (ctx) => ({});
var get_after_title_slot_changes_3 = (dirty) => ({});
var get_after_title_slot_context_3 = (ctx) => ({});
var get_footer_slot_changes_3 = (dirty) => ({});
var get_footer_slot_context_3 = (ctx) => ({});
var get_title_slot_changes_3 = (dirty) => ({});
var get_title_slot_context_3 = (ctx) => ({});
var get_header_slot_changes_3 = (dirty) => ({});
var get_header_slot_context_3 = (ctx) => ({});
var get_before_title_slot_changes_3 = (dirty) => ({});
var get_before_title_slot_context_3 = (ctx) => ({});
var get_footer_slot_changes_2 = (dirty) => ({});
var get_footer_slot_context_2 = (ctx) => ({});
var get_inner_slot_changes_2 = (dirty) => ({});
var get_inner_slot_context_2 = (ctx) => ({});
var get_text_slot_changes_1 = (dirty) => ({});
var get_text_slot_context_1 = (ctx) => ({});
var get_subtitle_slot_changes_1 = (dirty) => ({});
var get_subtitle_slot_context_1 = (ctx) => ({});
var get_after_end_slot_changes_2 = (dirty) => ({});
var get_after_end_slot_context_2 = (ctx) => ({});
var get_after_slot_changes_2 = (dirty) => ({});
var get_after_slot_context_2 = (ctx) => ({});
var get_after_start_slot_changes_2 = (dirty) => ({});
var get_after_start_slot_context_2 = (ctx) => ({});
var get_after_title_slot_changes_2 = (dirty) => ({});
var get_after_title_slot_context_2 = (ctx) => ({});
var get_title_slot_changes_2 = (dirty) => ({});
var get_title_slot_context_2 = (ctx) => ({});
var get_before_title_slot_changes_2 = (dirty) => ({});
var get_before_title_slot_context_2 = (ctx) => ({});
var get_header_slot_changes_2 = (dirty) => ({});
var get_header_slot_context_2 = (ctx) => ({});
var get_inner_start_slot_changes_12 = (dirty) => ({});
var get_inner_start_slot_context_12 = (ctx) => ({});
var get_media_slot_changes_12 = (dirty) => ({});
var get_media_slot_context_12 = (ctx) => ({});
var get_content_start_slot_changes_12 = (dirty) => ({});
var get_content_start_slot_context_12 = (ctx) => ({});
var get_content_end_slot_changes2 = (dirty) => ({});
var get_content_end_slot_context2 = (ctx) => ({});
var get_content_slot_changes3 = (dirty) => ({});
var get_content_slot_context3 = (ctx) => ({});
var get_inner_end_slot_changes2 = (dirty) => ({});
var get_inner_end_slot_context2 = (ctx) => ({});
var get_inner_slot_changes_12 = (dirty) => ({});
var get_inner_slot_context_12 = (ctx) => ({});
var get_after_end_slot_changes_1 = (dirty) => ({});
var get_after_end_slot_context_1 = (ctx) => ({});
var get_after_slot_changes_1 = (dirty) => ({});
var get_after_slot_context_1 = (ctx) => ({});
var get_after_start_slot_changes_1 = (dirty) => ({});
var get_after_start_slot_context_1 = (ctx) => ({});
var get_after_title_slot_changes_1 = (dirty) => ({});
var get_after_title_slot_context_1 = (ctx) => ({});
var get_footer_slot_changes_1 = (dirty) => ({});
var get_footer_slot_context_1 = (ctx) => ({});
var get_title_slot_changes_1 = (dirty) => ({});
var get_title_slot_context_1 = (ctx) => ({});
var get_header_slot_changes_1 = (dirty) => ({});
var get_header_slot_context_1 = (ctx) => ({});
var get_before_title_slot_changes_1 = (dirty) => ({});
var get_before_title_slot_context_1 = (ctx) => ({});
var get_footer_slot_changes2 = (dirty) => ({});
var get_footer_slot_context2 = (ctx) => ({});
var get_inner_slot_changes2 = (dirty) => ({});
var get_inner_slot_context2 = (ctx) => ({});
var get_text_slot_changes3 = (dirty) => ({});
var get_text_slot_context3 = (ctx) => ({});
var get_subtitle_slot_changes = (dirty) => ({});
var get_subtitle_slot_context = (ctx) => ({});
var get_after_end_slot_changes = (dirty) => ({});
var get_after_end_slot_context = (ctx) => ({});
var get_after_slot_changes = (dirty) => ({});
var get_after_slot_context = (ctx) => ({});
var get_after_start_slot_changes = (dirty) => ({});
var get_after_start_slot_context = (ctx) => ({});
var get_after_title_slot_changes = (dirty) => ({});
var get_after_title_slot_context = (ctx) => ({});
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
var get_before_title_slot_changes = (dirty) => ({});
var get_before_title_slot_context = (ctx) => ({});
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
var get_inner_start_slot_changes2 = (dirty) => ({});
var get_inner_start_slot_context2 = (ctx) => ({});
var get_media_slot_changes4 = (dirty) => ({});
var get_media_slot_context4 = (ctx) => ({});
var get_content_start_slot_changes2 = (dirty) => ({});
var get_content_start_slot_context2 = (ctx) => ({});
var get_root_start_slot_changes3 = (dirty) => ({});
var get_root_start_slot_context3 = (ctx) => ({});
function create_else_block7(ctx) {
  let li;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let t3;
  let t4;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const root_start_slot_template = (
    /*#slots*/
    ctx[69]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_start_slot_context3
  );
  const if_block_creators = [create_if_block_47, create_if_block_67, create_else_block_7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*swipeout*/
      ctx2[14]
    )
      return 0;
    if (
      /*isLink*/
      ctx2[38]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && !/*isSortableOpposite*/
    ctx[44] && create_if_block_310(ctx)
  );
  let if_block2 = (
    /*swipeout*/
    (ctx[14] || /*accordionItem*/
    ctx[16]) && create_if_block_213(ctx)
  );
  const root_slot_template = (
    /*#slots*/
    ctx[69].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_slot_context4
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[69]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_end_slot_context3
  );
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[42]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[24]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[48]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (root_start_slot)
        root_start_slot.c();
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (root_slot)
        root_slot.c();
      t4 = space();
      if (root_end_slot)
        root_end_slot.c();
      set_attributes(li, li_data);
      add_location(li, file54, 341, 2, 9910);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (root_start_slot) {
        root_start_slot.m(li, null);
      }
      append_dev(li, t0);
      if_blocks[current_block_type_index].m(li, null);
      append_dev(li, t1);
      if (if_block1)
        if_block1.m(li, null);
      append_dev(li, t2);
      if (if_block2)
        if_block2.m(li, null);
      append_dev(li, t3);
      if (root_slot) {
        root_slot.m(li, null);
      }
      append_dev(li, t4);
      if (root_end_slot) {
        root_end_slot.m(li, null);
      }
      ctx[82](li);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, li, {
          tooltip: (
            /*tooltip*/
            ctx[7]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[8]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_start_slot_changes3
            ),
            get_root_start_slot_context3
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(li, t1);
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && !/*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_310(ctx2);
          if_block1.c();
          if_block1.m(li, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*swipeout*/
        ctx2[14] || /*accordionItem*/
        ctx2[16]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_213(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(li, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_slot_changes4
            ),
            get_root_slot_context4
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_end_slot_changes3
            ),
            get_root_end_slot_context3
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        2048) && { class: (
          /*liClasses*/
          ctx2[42]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        16777216) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[24]
          )
        },
        dirty[1] & /*$$restProps*/
        131072 && restProps(
          /*$$restProps*/
          ctx2[48]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[7]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[8]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(root_start_slot, local);
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(root_slot, local);
      transition_in(root_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(root_start_slot, local);
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(root_slot, local);
      transition_out(root_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (root_start_slot)
        root_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (root_slot)
        root_slot.d(detaching);
      if (root_end_slot)
        root_end_slot.d(detaching);
      ctx[82](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(341:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let li;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[42]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[24]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[48]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file54, 329, 2, 9656);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, t0);
      append_dev(li, t1);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[71](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, li, {
            tooltip: (
              /*tooltip*/
              ctx[7]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        2048) && { class: (
          /*liClasses*/
          ctx2[42]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        16777216) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[24]
          )
        },
        dirty[1] & /*$$restProps*/
        131072 && restProps(
          /*$$restProps*/
          ctx2[48]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[7]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[8]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[71](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(329:19) ",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let li;
  let span;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[42]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[24]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[48]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      add_location(span, file54, 326, 4, 9581);
      set_attributes(li, li_data);
      add_location(li, file54, 318, 2, 9377);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[70](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, li, {
            tooltip: (
              /*tooltip*/
              ctx[7]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*title*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1] : dirty);
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        2048) && { class: (
          /*liClasses*/
          ctx2[42]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        16777216) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[24]
          )
        },
        dirty[1] & /*$$restProps*/
        131072 && restProps(
          /*$$restProps*/
          ctx2[48]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[7]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[8]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[70](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(318:0) {#if divider || groupTitle}",
    ctx
  });
  return block;
}
function create_else_block_7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_88, create_else_block_9];
  const if_blocks = [];
  function select_block_type_8(ctx2, dirty) {
    if (
      /*checkbox*/
      ctx2[17] || /*radio*/
      ctx2[18]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_8(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_8(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_7.name,
    type: "else",
    source: "(838:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_67(ctx) {
  let a;
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_3
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_87(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_85(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_3
  );
  const if_block_creators = [create_if_block_68, create_else_block_6];
  const if_blocks = [];
  function select_block_type_7(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_7(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_3
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_3
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_3
  );
  let a_levels = [
    { class: (
      /*linkClasses*/
      ctx[40]
    ) },
    /*linkAttrs*/
    ctx[39]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t5 = space();
      if (content_slot)
        content_slot.c();
      t6 = space();
      if (content_end_slot)
        content_end_slot.c();
      attr_dev(div0, "class", "item-inner");
      add_location(div0, file54, 737, 10, 24981);
      attr_dev(
        div1,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(div1, file54, 724, 8, 24532);
      set_attributes(a, a_data);
      add_location(a, file54, 716, 6, 24333);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t0);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append_dev(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append_dev(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[77](div0);
      append_dev(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      ctx[78](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[25]
          )),
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_3
            ),
            get_content_start_slot_context_3
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_87(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_85(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_3
            ),
            get_inner_start_slot_context_3
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_7(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_3
            ),
            get_inner_end_slot_context_3
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_3
            ),
            get_content_slot_context_3
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_3
            ),
            get_content_end_slot_context_3
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          div1,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[1] & /*linkClasses*/
        512) && { class: (
          /*linkClasses*/
          ctx2[40]
        ) },
        dirty[1] & /*linkAttrs*/
        256 && /*linkAttrs*/
        ctx2[39]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      33554432)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[25]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[77](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      ctx[78](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_67.name,
    type: "if",
    source: "(716:21) ",
    ctx
  });
  return block;
}
function create_if_block_47(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_54, create_else_block_23];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*isLink*/
      ctx2[38]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      attr_dev(div, "class", "swipeout-content");
      add_location(div, file54, 350, 6, 10143);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_47.name,
    type: "if",
    source: "(350:4) {#if swipeout}",
    ctx
  });
  return block;
}
function create_else_block_9(ctx) {
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_5
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_128(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_126(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_5
  );
  const if_block_creators = [create_if_block_109, create_else_block_10];
  const if_blocks = [];
  function select_block_type_10(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_10(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_5
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_5
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_5
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t5 = space();
      if (content_slot)
        content_slot.c();
      t6 = space();
      if (content_end_slot)
        content_end_slot.c();
      attr_dev(div0, "class", "item-inner");
      add_location(div0, file54, 977, 10, 33433);
      attr_dev(
        div1,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(div1, file54, 964, 8, 32965);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t0);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append_dev(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append_dev(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[81](div0);
      append_dev(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "click",
          /*onClick*/
          ctx[46],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_5
            ),
            get_content_start_slot_context_5
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_128(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_126(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_5
            ),
            get_inner_start_slot_context_5
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_10(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_5
            ),
            get_inner_end_slot_context_5
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_5
            ),
            get_content_slot_context_5
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_5
            ),
            get_content_end_slot_context_5
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          div1,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[81](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_9.name,
    type: "else",
    source: "(964:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_88(ctx) {
  let label;
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_type_value;
  let t2;
  let i;
  let i_class_value;
  let t3;
  let t4;
  let div;
  let t5;
  let current_block_type_index;
  let if_block2;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_4
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_108(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_106(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_4
  );
  const if_block_creators = [create_if_block_89, create_else_block_8];
  const if_blocks = [];
  function select_block_type_9(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_9(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_4
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_4
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_4
  );
  const block = {
    c: function create() {
      label = element("label");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      input = element("input");
      t2 = space();
      i = element("i");
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      div = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t5 = space();
      if_block2.c();
      t6 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t7 = space();
      if (content_slot)
        content_slot.c();
      t8 = space();
      if (content_end_slot)
        content_end_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[20] === "undefined" ? "" : (
        /*value*/
        ctx[20]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[19]
      );
      input.checked = /*checked*/
      ctx[0];
      input.readOnly = /*readonly*/
      ctx[21];
      input.disabled = /*disabled*/
      ctx[23];
      input.required = /*required*/
      ctx[22];
      attr_dev(input, "type", input_type_value = /*radio*/
      ctx[18] ? "radio" : "checkbox");
      add_location(input, file54, 845, 10, 28831);
      attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/
      ctx[18] ? "radio" : "checkbox"}`);
      add_location(i, file54, 856, 10, 29146);
      attr_dev(div, "class", "item-inner");
      add_location(div, file54, 865, 10, 29452);
      attr_dev(
        label,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(label, file54, 840, 8, 28599);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (content_start_slot) {
        content_start_slot.m(label, null);
      }
      append_dev(label, t0);
      if (if_block0)
        if_block0.m(label, null);
      append_dev(label, t1);
      append_dev(label, input);
      ctx[79](input);
      append_dev(label, t2);
      append_dev(label, i);
      append_dev(label, t3);
      if (if_block1)
        if_block1.m(label, null);
      append_dev(label, t4);
      append_dev(label, div);
      if (inner_start_slot) {
        inner_start_slot.m(div, null);
      }
      append_dev(div, t5);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t6);
      if (inner_end_slot) {
        inner_end_slot.m(div, null);
      }
      ctx[80](div);
      append_dev(label, t7);
      if (content_slot) {
        content_slot.m(label, null);
      }
      append_dev(label, t8);
      if (content_end_slot) {
        content_end_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_4
            ),
            get_content_start_slot_context_4
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_108(ctx2);
          if_block0.c();
          if_block0.m(label, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*value*/
      1048576 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[20] === "undefined" ? "" : (
        /*value*/
        ctx2[20]
      )) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty[0] & /*name*/
      524288) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      2097152) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      8388608) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*required*/
      4194304) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*radio*/
      262144 && input_type_value !== (input_type_value = /*radio*/
      ctx2[18] ? "radio" : "checkbox")) {
        attr_dev(input, "type", input_type_value);
      }
      if (!current || dirty[0] & /*radio*/
      262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/
      ctx2[18] ? "radio" : "checkbox"}`)) {
        attr_dev(i, "class", i_class_value);
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_106(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_4
            ),
            get_inner_start_slot_context_4
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_9(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, t6);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_4
            ),
            get_inner_end_slot_context_4
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_4
            ),
            get_content_slot_context_4
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_4
            ),
            get_content_end_slot_context_4
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          label,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      ctx[79](null);
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[80](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_88.name,
    type: "if",
    source: "(840:6) {#if checkbox || radio}",
    ctx
  });
  return block;
}
function create_if_block_128(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 967, 12, 33136);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_128.name,
    type: "if",
    source: "(967:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_126(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_127(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 970, 12, 33222);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_127(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_5
            ),
            get_media_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_126.name,
    type: "if",
    source: "(970:10) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_127(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 972, 16, 33312);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_127.name,
    type: "if",
    source: "(972:14) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_10(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_11
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_1232(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_11
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_120(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_11
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_119(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_11
            ),
            get_before_title_slot_context_11
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1232(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_11
            ),
            get_after_title_slot_context_11
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_120(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_11
            ),
            get_inner_slot_context_11
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_119(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_10.name,
    type: "else",
    source: "(1032:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_109(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_118(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_10
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_117(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_10
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_114(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_1132(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_1122(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_10
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_1112(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_1102(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 986, 14, 33752);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_118(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_10
            ),
            get_before_title_slot_context_10
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_117(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_10
            ),
            get_after_title_slot_context_10
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_114(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1132(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1122(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_10
            ),
            get_inner_slot_context_10
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1112(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_1102(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_109.name,
    type: "if",
    source: "(980:12) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_1232(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_125(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_11
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_124(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 1034, 16, 35487);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_125(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_11
            ),
            get_title_slot_context_11
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_124(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1232.name,
    type: "if",
    source: "(1034:14) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_125(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_11
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 1036, 20, 35566);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_11
            ),
            get_header_slot_context_11
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_125.name,
    type: "if",
    source: "(1036:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_124(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_11
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 1044, 20, 35861);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_11
            ),
            get_footer_slot_context_11
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_124.name,
    type: "if",
    source: "(1044:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_11
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_1222(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_121(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_11
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_11
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 1053, 16, 36155);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_11
            ),
            get_after_start_slot_context_11
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1222(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_121(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_11
            ),
            get_after_slot_context_11
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_11
            ),
            get_after_end_slot_context_11
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(1053:14) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_1222(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 1056, 20, 36299);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1222.name,
    type: "if",
    source: "(1056:18) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(1059:18) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_11(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11.name,
    type: "slot",
    source: "(1060:20) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(1067:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_10
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 981, 16, 33590);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_10
            ),
            get_header_slot_context_10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(981:14) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_10
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 989, 18, 33875);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_10
            ),
            get_title_slot_context_10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(989:16) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_10
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_116(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_115(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_10
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_10
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 996, 18, 34121);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_10
            ),
            get_after_start_slot_context_10
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_116(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_115(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_10
            ),
            get_after_slot_context_10
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_10
            ),
            get_after_end_slot_context_10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(996:16) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 999, 22, 34271);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(999:20) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(1002:20) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_10(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: "(1003:22) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_1132(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 1010, 16, 34689);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_5
            ),
            get_subtitle_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1132.name,
    type: "if",
    source: "(1010:14) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_1122(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 1016, 16, 34887);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_5
            ),
            get_text_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1122.name,
    type: "if",
    source: "(1016:14) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_1112(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1112.name,
    type: "if",
    source: "(1023:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_1102(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_10
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 1026, 16, 35205);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_10
            ),
            get_footer_slot_context_10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1102.name,
    type: "if",
    source: "(1026:14) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_108(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 843, 12, 28772);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_108.name,
    type: "if",
    source: "(843:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_106(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_107(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 858, 12, 29241);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_107(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_4
            ),
            get_media_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_106.name,
    type: "if",
    source: "(858:10) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_107(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 860, 16, 29331);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_107.name,
    type: "if",
    source: "(860:14) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_8(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_9
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_1032(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_9
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_100(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_9
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_99(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_9
            ),
            get_before_title_slot_context_9
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1032(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_9
            ),
            get_after_title_slot_context_9
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_100(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_9
            ),
            get_inner_slot_context_9
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_99(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_8.name,
    type: "else",
    source: "(920:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_89(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_98(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_8
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_97(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_8
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_94(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_932(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_922(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_8
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_91(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_90(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 874, 14, 29771);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_98(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_8
            ),
            get_before_title_slot_context_8
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_97(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_8
            ),
            get_after_title_slot_context_8
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_94(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_932(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_922(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_8
            ),
            get_inner_slot_context_8
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_91(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_90(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_89.name,
    type: "if",
    source: "(868:12) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_1032(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_105(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_9
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_104(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 922, 16, 31506);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_105(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_9
            ),
            get_title_slot_context_9
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_104(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1032.name,
    type: "if",
    source: "(922:14) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_105(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_9
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 924, 20, 31585);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_9
            ),
            get_header_slot_context_9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_105.name,
    type: "if",
    source: "(924:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_104(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_9
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 932, 20, 31880);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_9
            ),
            get_footer_slot_context_9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_104.name,
    type: "if",
    source: "(932:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_100(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_9
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_1022(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_101(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_9
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_9
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 941, 16, 32174);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_9
            ),
            get_after_start_slot_context_9
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1022(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_101(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_9
            ),
            get_after_slot_context_9
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_9
            ),
            get_after_end_slot_context_9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_100.name,
    type: "if",
    source: "(941:14) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_1022(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 944, 20, 32318);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1022.name,
    type: "if",
    source: "(944:18) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_101(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_101.name,
    type: "if",
    source: "(947:18) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: "(948:20) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_99(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_99.name,
    type: "if",
    source: "(955:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_98(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_8
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 869, 16, 29609);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_8
            ),
            get_header_slot_context_8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_98.name,
    type: "if",
    source: "(869:14) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_97(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_8
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 877, 18, 29894);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_8
            ),
            get_title_slot_context_8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_97.name,
    type: "if",
    source: "(877:16) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_94(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_8
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_96(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_95(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_8
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_8
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 884, 18, 30140);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_8
            ),
            get_after_start_slot_context_8
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_96(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_95(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_8
            ),
            get_after_slot_context_8
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_8
            ),
            get_after_end_slot_context_8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_94.name,
    type: "if",
    source: "(884:16) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_96(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 887, 22, 30290);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_96.name,
    type: "if",
    source: "(887:20) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_95(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_95.name,
    type: "if",
    source: "(890:20) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: "(891:22) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_932(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 898, 16, 30708);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_4
            ),
            get_subtitle_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_932.name,
    type: "if",
    source: "(898:14) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_922(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 904, 16, 30906);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_4
            ),
            get_text_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_922.name,
    type: "if",
    source: "(904:14) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_91(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_91.name,
    type: "if",
    source: "(911:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_90(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_8
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 914, 16, 31224);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_8
            ),
            get_footer_slot_context_8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_90.name,
    type: "if",
    source: "(914:14) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_87(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 727, 12, 24684);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_87.name,
    type: "if",
    source: "(727:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_85(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_86(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 730, 12, 24770);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_86(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_3
            ),
            get_media_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_85.name,
    type: "if",
    source: "(730:10) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_86(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 732, 16, 24860);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_86.name,
    type: "if",
    source: "(732:14) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_6(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_7
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_822(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_7
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_79(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_7
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_78(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_7
            ),
            get_before_title_slot_context_7
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_822(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_7
            ),
            get_after_title_slot_context_7
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_79(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_7
            ),
            get_inner_slot_context_7
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_78(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_6.name,
    type: "else",
    source: "(792:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_68(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_77(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_6
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_76(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_6
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_732(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_722(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_71(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_6
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_70(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_69(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 746, 14, 25300);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_77(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_6
            ),
            get_before_title_slot_context_6
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_76(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_6
            ),
            get_after_title_slot_context_6
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_732(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_722(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_71(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_6
            ),
            get_inner_slot_context_6
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_70(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_69(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_68.name,
    type: "if",
    source: "(740:12) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_822(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_84(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_7
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_832(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 794, 16, 27035);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_84(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_7
            ),
            get_title_slot_context_7
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_832(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_822.name,
    type: "if",
    source: "(794:14) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_84(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_7
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 796, 20, 27114);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_7
            ),
            get_header_slot_context_7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_84.name,
    type: "if",
    source: "(796:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_832(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_7
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 804, 20, 27409);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_7
            ),
            get_footer_slot_context_7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_832.name,
    type: "if",
    source: "(804:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_79(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_7
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_81(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_80(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_7
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_7
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 813, 16, 27703);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_7
            ),
            get_after_start_slot_context_7
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_81(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_80(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_7
            ),
            get_after_slot_context_7
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_7
            ),
            get_after_end_slot_context_7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_79.name,
    type: "if",
    source: "(813:14) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_81(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 816, 20, 27847);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_81.name,
    type: "if",
    source: "(816:18) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_80(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_80.name,
    type: "if",
    source: "(819:18) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(820:20) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_78(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_78.name,
    type: "if",
    source: "(827:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_77(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_6
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 741, 16, 25138);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_6
            ),
            get_header_slot_context_6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_77.name,
    type: "if",
    source: "(741:14) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_76(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_6
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 749, 18, 25423);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_6
            ),
            get_title_slot_context_6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_76.name,
    type: "if",
    source: "(749:16) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_732(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_6
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_75(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_74(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_6
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_6
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 756, 18, 25669);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_6
            ),
            get_after_start_slot_context_6
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_75(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_74(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_6
            ),
            get_after_slot_context_6
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_6
            ),
            get_after_end_slot_context_6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_732.name,
    type: "if",
    source: "(756:16) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_75(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 759, 22, 25819);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_75.name,
    type: "if",
    source: "(759:20) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_74(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_74.name,
    type: "if",
    source: "(762:20) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(763:22) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_722(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 770, 16, 26237);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_3
            ),
            get_subtitle_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_722.name,
    type: "if",
    source: "(770:14) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_71(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 776, 16, 26435);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_3
            ),
            get_text_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_71.name,
    type: "if",
    source: "(776:14) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_70(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_70.name,
    type: "if",
    source: "(783:14) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_69(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_6
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 786, 16, 26753);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_6
            ),
            get_footer_slot_context_6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_69.name,
    type: "if",
    source: "(786:14) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_262, create_else_block_4];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*checkbox*/
      ctx2[17] || /*radio*/
      ctx2[18]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(474:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_54(ctx) {
  let a;
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context2
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_252(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_233(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context2
  );
  const if_block_creators = [create_if_block_610, create_else_block_15];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context2
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context3
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context2
  );
  let a_levels = [
    { class: (
      /*linkClasses*/
      ctx[40]
    ) },
    /*linkAttrs*/
    ctx[39]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t5 = space();
      if (content_slot)
        content_slot.c();
      t6 = space();
      if (content_end_slot)
        content_end_slot.c();
      attr_dev(div0, "class", "item-inner");
      add_location(div0, file54, 373, 14, 10937);
      attr_dev(
        div1,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(div1, file54, 360, 12, 10436);
      set_attributes(a, a_data);
      add_location(a, file54, 352, 10, 10205);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t0);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append_dev(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append_dev(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[72](div0);
      append_dev(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      ctx[73](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[25]
          )),
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes2
            ),
            get_content_start_slot_context2
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_252(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_233(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes2
            ),
            get_inner_start_slot_context2
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes2
            ),
            get_inner_end_slot_context2
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes3
            ),
            get_content_slot_context3
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes2
            ),
            get_content_end_slot_context2
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          div1,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[1] & /*linkClasses*/
        512) && { class: (
          /*linkClasses*/
          ctx2[40]
        ) },
        dirty[1] & /*linkAttrs*/
        256 && /*linkAttrs*/
        ctx2[39]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      33554432)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[25]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[72](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      ctx[73](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(352:8) {#if isLink}",
    ctx
  });
  return block;
}
function create_else_block_4(ctx) {
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_2
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_66(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_64(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_2
  );
  const if_block_creators = [create_if_block_472, create_else_block_5];
  const if_blocks = [];
  function select_block_type_6(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_6(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_2
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_2
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_2
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t5 = space();
      if (content_slot)
        content_slot.c();
      t6 = space();
      if (content_end_slot)
        content_end_slot.c();
      attr_dev(div0, "class", "item-inner");
      add_location(div0, file54, 613, 14, 20349);
      attr_dev(
        div1,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(div1, file54, 600, 12, 19829);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t0);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t2);
      append_dev(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append_dev(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append_dev(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[76](div0);
      append_dev(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "click",
          /*onClick*/
          ctx[46],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_2
            ),
            get_content_start_slot_context_2
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_66(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_64(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_2
            ),
            get_inner_start_slot_context_2
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_6(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_2
            ),
            get_inner_end_slot_context_2
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_2
            ),
            get_content_slot_context_2
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_2
            ),
            get_content_end_slot_context_2
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          div1,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[76](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_4.name,
    type: "else",
    source: "(600:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_262(ctx) {
  let label;
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_type_value;
  let t2;
  let i;
  let i_class_value;
  let t3;
  let t4;
  let div;
  let t5;
  let current_block_type_index;
  let if_block2;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_12
  );
  let if_block0 = (
    /*isSortable*/
    ctx[45] && /*sortable*/
    ctx[15] !== false && /*isSortableOpposite*/
    ctx[44] && create_if_block_462(ctx)
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[37] && create_if_block_442(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_12
  );
  const if_block_creators = [create_if_block_272, create_else_block_3];
  const if_blocks = [];
  function select_block_type_5(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[26]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_5(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_12
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_12
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_12
  );
  const block = {
    c: function create() {
      label = element("label");
      if (content_start_slot)
        content_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      input = element("input");
      t2 = space();
      i = element("i");
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      div = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t5 = space();
      if_block2.c();
      t6 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t7 = space();
      if (content_slot)
        content_slot.c();
      t8 = space();
      if (content_end_slot)
        content_end_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[20] === "undefined" ? "" : (
        /*value*/
        ctx[20]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[19]
      );
      input.checked = /*checked*/
      ctx[0];
      input.readOnly = /*readonly*/
      ctx[21];
      input.disabled = /*disabled*/
      ctx[23];
      input.required = /*required*/
      ctx[22];
      attr_dev(input, "type", input_type_value = /*radio*/
      ctx[18] ? "radio" : "checkbox");
      add_location(input, file54, 481, 14, 15219);
      attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/
      ctx[18] ? "radio" : "checkbox"}`);
      add_location(i, file54, 492, 14, 15578);
      attr_dev(div, "class", "item-inner");
      add_location(div, file54, 501, 14, 15920);
      attr_dev(
        label,
        "class",
        /*contentClasses*/
        ctx[41]
      );
      add_location(label, file54, 476, 12, 14967);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (content_start_slot) {
        content_start_slot.m(label, null);
      }
      append_dev(label, t0);
      if (if_block0)
        if_block0.m(label, null);
      append_dev(label, t1);
      append_dev(label, input);
      ctx[74](input);
      append_dev(label, t2);
      append_dev(label, i);
      append_dev(label, t3);
      if (if_block1)
        if_block1.m(label, null);
      append_dev(label, t4);
      append_dev(label, div);
      if (inner_start_slot) {
        inner_start_slot.m(div, null);
      }
      append_dev(div, t5);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t6);
      if (inner_end_slot) {
        inner_end_slot.m(div, null);
      }
      ctx[75](div);
      append_dev(label, t7);
      if (content_slot) {
        content_slot.m(label, null);
      }
      append_dev(label, t8);
      if (content_end_slot) {
        content_end_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "click",
            /*onClick*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_12
            ),
            get_content_start_slot_context_12
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[45] && /*sortable*/
        ctx2[15] !== false && /*isSortableOpposite*/
        ctx2[44]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_462(ctx2);
          if_block0.c();
          if_block0.m(label, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*value*/
      1048576 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[20] === "undefined" ? "" : (
        /*value*/
        ctx2[20]
      )) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty[0] & /*name*/
      524288) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*readonly*/
      2097152) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[21]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      8388608) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[23]
        );
      }
      if (!current || dirty[0] & /*required*/
      4194304) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*radio*/
      262144 && input_type_value !== (input_type_value = /*radio*/
      ctx2[18] ? "radio" : "checkbox")) {
        attr_dev(input, "type", input_type_value);
      }
      if (!current || dirty[0] & /*radio*/
      262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/
      ctx2[18] ? "radio" : "checkbox"}`)) {
        attr_dev(i, "class", i_class_value);
      }
      if (
        /*hasMedia*/
        ctx2[37]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_442(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_12
            ),
            get_inner_start_slot_context_12
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_5(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, t6);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_12
            ),
            get_inner_end_slot_context_12
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_12
            ),
            get_content_slot_context_12
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_12
            ),
            get_content_end_slot_context_12
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      1024) {
        attr_dev(
          label,
          "class",
          /*contentClasses*/
          ctx2[41]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      ctx[74](null);
      if (if_block1)
        if_block1.d();
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      ctx[75](null);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_262.name,
    type: "if",
    source: "(476:10) {#if checkbox || radio}",
    ctx
  });
  return block;
}
function create_if_block_66(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 603, 16, 20012);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_66.name,
    type: "if",
    source: "(603:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_64(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_65(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 606, 16, 20110);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_65(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_2
            ),
            get_media_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_64.name,
    type: "if",
    source: "(606:14) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_65(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 608, 20, 20208);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_65.name,
    type: "if",
    source: "(608:18) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_5
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_61(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_5
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_58(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_5
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_57(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_5
            ),
            get_before_title_slot_context_5
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_61(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_5
            ),
            get_after_title_slot_context_5
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_58(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_5
            ),
            get_inner_slot_context_5
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_57(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_5.name,
    type: "else",
    source: "(668:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_472(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_56(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_4
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_55(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_4
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_522(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_51(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_50(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_4
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_49(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_48(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 622, 18, 20704);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_56(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_4
            ),
            get_before_title_slot_context_4
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_55(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_4
            ),
            get_after_title_slot_context_4
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_522(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_51(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_50(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_4
            ),
            get_inner_slot_context_4
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_49(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_48(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_472.name,
    type: "if",
    source: "(616:16) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_61(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_632(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_5
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_622(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 670, 20, 22631);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_632(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_5
            ),
            get_title_slot_context_5
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_622(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_61.name,
    type: "if",
    source: "(670:18) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_632(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 672, 24, 22718);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_5
            ),
            get_header_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_632.name,
    type: "if",
    source: "(672:22) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_622(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 680, 24, 23045);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_5
            ),
            get_footer_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_622.name,
    type: "if",
    source: "(680:22) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_58(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_5
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_60(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_59(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_5
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_5
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 689, 20, 23375);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_5
            ),
            get_after_start_slot_context_5
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_60(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_59(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_5
            ),
            get_after_slot_context_5
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_5
            ),
            get_after_end_slot_context_5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_58.name,
    type: "if",
    source: "(689:18) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_60(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 692, 24, 23531);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_60.name,
    type: "if",
    source: "(692:22) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_59(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_59.name,
    type: "if",
    source: "(695:22) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(696:24) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_57(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_57.name,
    type: "if",
    source: "(703:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_56(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 617, 20, 20522);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_4
            ),
            get_header_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_56.name,
    type: "if",
    source: "(617:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_55(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 625, 22, 20839);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_4
            ),
            get_title_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(625:20) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_522(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_4
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_542(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_532(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_4
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 632, 22, 21113);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_4
            ),
            get_after_start_slot_context_4
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_542(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_532(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_4
            ),
            get_after_slot_context_4
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_4
            ),
            get_after_end_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_522.name,
    type: "if",
    source: "(632:20) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_542(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 635, 26, 21275);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_542.name,
    type: "if",
    source: "(635:24) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_532(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_532.name,
    type: "if",
    source: "(638:24) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_42(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_42.name,
    type: "slot",
    source: "(639:26) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_51(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 646, 20, 21737);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_2
            ),
            get_subtitle_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_51.name,
    type: "if",
    source: "(646:18) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_50(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 652, 20, 21959);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_2
            ),
            get_text_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_50.name,
    type: "if",
    source: "(652:18) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_49(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_49.name,
    type: "if",
    source: "(659:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_48(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 662, 20, 22317);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_4
            ),
            get_footer_slot_context_4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_48.name,
    type: "if",
    source: "(662:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_462(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 479, 16, 15152);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_462.name,
    type: "if",
    source: "(479:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_442(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_452(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 494, 16, 15681);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_452(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_12
            ),
            get_media_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_442.name,
    type: "if",
    source: "(494:14) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_452(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 496, 20, 15779);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_452.name,
    type: "if",
    source: "(496:18) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_3(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_3
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_41(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_3
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_382(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_3
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_372(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_3
            ),
            get_before_title_slot_context_3
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_41(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_3
            ),
            get_after_title_slot_context_3
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_382(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_3
            ),
            get_inner_slot_context_3
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_372(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_3.name,
    type: "else",
    source: "(556:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_272(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_362(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_2
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_352(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_2
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_322(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_31(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_30(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_2
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_292(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_282(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 510, 18, 16275);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_362(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_2
            ),
            get_before_title_slot_context_2
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_352(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_2
            ),
            get_after_title_slot_context_2
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_322(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_31(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_30(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_2
            ),
            get_inner_slot_context_2
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_292(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_282(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_272.name,
    type: "if",
    source: "(504:16) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_41(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_432(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_3
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_422(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 558, 20, 18202);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_432(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_3
            ),
            get_title_slot_context_3
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_422(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_41.name,
    type: "if",
    source: "(558:18) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_432(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 560, 24, 18289);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_3
            ),
            get_header_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_432.name,
    type: "if",
    source: "(560:22) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_422(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 568, 24, 18616);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_3
            ),
            get_footer_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_422.name,
    type: "if",
    source: "(568:22) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_382(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_3
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_40(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_39(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_3
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_3
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 577, 20, 18946);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_3
            ),
            get_after_start_slot_context_3
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_40(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_39(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_3
            ),
            get_after_slot_context_3
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_3
            ),
            get_after_end_slot_context_3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_382.name,
    type: "if",
    source: "(577:18) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_40(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 580, 24, 19102);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_40.name,
    type: "if",
    source: "(580:22) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_39(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(583:22) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(584:24) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_372(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_372.name,
    type: "if",
    source: "(591:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_362(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 505, 20, 16093);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_2
            ),
            get_header_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_362.name,
    type: "if",
    source: "(505:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_352(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 513, 22, 16410);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_2
            ),
            get_title_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_352.name,
    type: "if",
    source: "(513:20) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_322(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_2
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_342(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_332(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_2
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 520, 22, 16684);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_2
            ),
            get_after_start_slot_context_2
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_342(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_332(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_2
            ),
            get_after_slot_context_2
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_2
            ),
            get_after_end_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_322.name,
    type: "if",
    source: "(520:20) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_342(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 523, 26, 16846);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_342.name,
    type: "if",
    source: "(523:24) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_332(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_332.name,
    type: "if",
    source: "(526:24) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(527:26) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_31(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 534, 20, 17308);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_1
            ),
            get_subtitle_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_31.name,
    type: "if",
    source: "(534:18) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_30(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 540, 20, 17530);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_1
            ),
            get_text_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_30.name,
    type: "if",
    source: "(540:18) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_292(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_292.name,
    type: "if",
    source: "(547:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_282(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 550, 20, 17888);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_2
            ),
            get_footer_slot_context_2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_282.name,
    type: "if",
    source: "(550:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_252(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 363, 16, 10600);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_252.name,
    type: "if",
    source: "(363:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_233(ctx) {
  let div;
  let t;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_242(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (media_slot)
        media_slot.c();
      attr_dev(div, "class", "item-media");
      add_location(div, file54, 366, 16, 10698);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_242(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes4
            ),
            get_media_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(media_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (media_slot)
        media_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_233.name,
    type: "if",
    source: "(366:14) {#if hasMedia}",
    ctx
  });
  return block;
}
function create_if_block_242(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file54, 368, 20, 10796);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_242.name,
    type: "if",
    source: "(368:18) {#if typeof media !== 'undefined'}",
    ctx
  });
  return block;
}
function create_else_block_15(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_1
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[36] || /*hasHeader*/
    ctx[35] || /*hasFooter*/
    ctx[34]) && create_if_block_202(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_1
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[31] && create_if_block_173(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_12
  );
  let if_block2 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_163(ctx);
  const block = {
    c: function create() {
      if (before_title_slot)
        before_title_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (after_title_slot)
        after_title_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (inner_slot)
        inner_slot.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_1
            ),
            get_before_title_slot_context_1
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36] || /*hasHeader*/
        ctx2[35] || /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          56) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_202(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_1
            ),
            get_after_title_slot_context_1
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_173(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_12
            ),
            get_inner_slot_context_12
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_163(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(428:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_610(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_153(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[36] && create_if_block_143(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[31] && create_if_block_1110(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[33] && create_if_block_1010(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[32] && create_if_block_910(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context2
  );
  let if_block5 = !/*swipeout*/
  (ctx[14] || /*accordionItem*/
  ctx[16]) && create_if_block_810(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[34] && create_if_block_710(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot)
        before_title_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_title_slot)
        after_title_slot.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (inner_slot)
        inner_slot.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr_dev(div, "class", "item-title-row");
      add_location(div, file54, 382, 18, 11292);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert_dev(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_dev(target, if_block6_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_153(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes
            ),
            get_before_title_slot_context
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_143(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes
            ),
            get_after_title_slot_context
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[31]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*hasAfter*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1110(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[33]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1010(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[32]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_910(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes2
            ),
            get_inner_slot_context2
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[14] || /*accordionItem*/
      ctx2[16])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          81920) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_810(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_710(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (before_title_slot)
        before_title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (after_title_slot)
        after_title_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(t6);
      if (inner_slot)
        inner_slot.d(detaching);
      if (detaching)
        detach_dev(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_610.name,
    type: "if",
    source: "(376:16) {#if isMedia}",
    ctx
  });
  return block;
}
function create_if_block_202(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[35] && create_if_block_223(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_1
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[34] && create_if_block_212(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot)
        title_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 430, 20, 13219);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[35]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_223(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_1
            ),
            get_title_slot_context_1
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[34]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_212(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (title_slot)
        title_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_202.name,
    type: "if",
    source: "(430:18) {#if hasTitle || hasHeader || hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_223(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 432, 24, 13306);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_1
            ),
            get_header_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_223.name,
    type: "if",
    source: "(432:22) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 440, 24, 13633);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_1
            ),
            get_footer_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(440:22) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_173(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_1
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_193(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_183(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_1
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_1
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 449, 20, 13963);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_1
            ),
            get_after_start_slot_context_1
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_193(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_183(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_1
            ),
            get_after_slot_context_1
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_1
            ),
            get_after_end_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_173.name,
    type: "if",
    source: "(449:18) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_193(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 452, 24, 14119);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_193.name,
    type: "if",
    source: "(452:22) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_183(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_183.name,
    type: "if",
    source: "(455:22) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(456:24) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_163(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_163.name,
    type: "if",
    source: "(463:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_153(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "item-header");
      add_location(div, file54, 377, 20, 11110);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_153.name,
    type: "if",
    source: "(377:18) {#if hasHeader}",
    ctx
  });
  return block;
}
function create_if_block_143(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot)
        title_slot.c();
      attr_dev(div, "class", "item-title");
      add_location(div, file54, 385, 22, 11427);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_143.name,
    type: "if",
    source: "(385:20) {#if hasTitle}",
    ctx
  });
  return block;
}
function create_if_block_1110(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_134(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_129(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (after_start_slot)
        after_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (after_slot)
        after_slot.c();
      t3 = space();
      if (after_end_slot)
        after_end_slot.c();
      attr_dev(div, "class", "item-after");
      add_location(div, file54, 392, 22, 11701);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append_dev(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes
            ),
            get_after_start_slot_context
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_134(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_129(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes
            ),
            get_after_end_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (after_start_slot)
        after_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (after_slot)
        after_slot.d(detaching);
      if (after_end_slot)
        after_end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1110.name,
    type: "if",
    source: "(392:20) {#if hasAfter}",
    ctx
  });
  return block;
}
function create_if_block_134(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      add_location(span, file54, 395, 26, 11863);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_134.name,
    type: "if",
    source: "(395:24) {#if typeof after !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block_129(ctx) {
  let badge_1;
  let current;
  badge_1 = new badge_default({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(badge_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048)
        badge_1_changes.color = /*badgeColor*/
        ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_129.name,
    type: "if",
    source: "(398:24) {#if typeof badge !== 'undefined'}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(399:26) <Badge color={badgeColor}>",
    ctx
  });
  return block;
}
function create_if_block_1010(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot)
        subtitle_slot.c();
      attr_dev(div, "class", "item-subtitle");
      add_location(div, file54, 406, 20, 12325);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes
            ),
            get_subtitle_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1010.name,
    type: "if",
    source: "(406:18) {#if hasSubtitle}",
    ctx
  });
  return block;
}
function create_if_block_910(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "item-text");
      add_location(div, file54, 412, 20, 12547);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes3
            ),
            get_text_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_910.name,
    type: "if",
    source: "(412:18) {#if hasText}",
    ctx
  });
  return block;
}
function create_if_block_810(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_810.name,
    type: "if",
    source: "(419:18) {#if !(swipeout || accordionItem)}",
    ctx
  });
  return block;
}
function create_if_block_710(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "item-footer");
      add_location(div, file54, 422, 20, 12905);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes2
            ),
            get_footer_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_710.name,
    type: "if",
    source: "(422:18) {#if hasFooter}",
    ctx
  });
  return block;
}
function create_if_block_310(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sortable-handler");
      add_location(div, file54, 1079, 6, 37048);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(1079:4) {#if isSortable && sortable !== false && !isSortableOpposite}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(1082:4) {#if swipeout || accordionItem}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*title*/
      2 && t_value !== (t_value = plainText(
        /*title*/
        ctx2[1]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(327:16) {plainText(title)}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block19, create_if_block_113, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*divider*/
      ctx2[12] || /*groupTitle*/
      ctx2[13]
    )
      return 0;
    if (
      /*isSimple*/
      ctx2[43]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let isMedia;
  let isSortable;
  let isSortableOpposite;
  let isSimple;
  let liClasses;
  let contentClasses;
  let linkClasses;
  let linkAttrs;
  let isLink;
  let hasMedia;
  let hasTitle;
  let hasHeader;
  let hasFooter;
  let hasSubtitle;
  let hasText;
  let hasAfter;
  const omit_props_names = [
    "class",
    "title",
    "text",
    "media",
    "subtitle",
    "header",
    "footer",
    "tooltip",
    "tooltipTrigger",
    "link",
    "tabLink",
    "tabLinkActive",
    "selected",
    "href",
    "target",
    "after",
    "badge",
    "badgeColor",
    "mediaItem",
    "mediaList",
    "divider",
    "groupTitle",
    "swipeout",
    "swipeoutOpened",
    "sortable",
    "sortableOpposite",
    "accordionItem",
    "accordionItemOpened",
    "smartSelect",
    "smartSelectParams",
    "noChevron",
    "chevronCenter",
    "checkbox",
    "radio",
    "radioIcon",
    "checked",
    "indeterminate",
    "name",
    "value",
    "readonly",
    "required",
    "disabled",
    "virtualListIndex",
    "routeProps",
    "smartSelectInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List_item", slots, [
    "default",
    "root-start",
    "content-start",
    "media",
    "inner-start",
    "header",
    "before-title",
    "title",
    "after-title",
    "after-start",
    "after",
    "after-end",
    "subtitle",
    "text",
    "inner",
    "footer",
    "inner-end",
    "content",
    "content-end",
    "root",
    "root-end"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { media = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { footer = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { link = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { selected = false } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { after = void 0 } = $$props;
  let { badge = void 0 } = $$props;
  let { badgeColor = void 0 } = $$props;
  let { mediaItem = false } = $$props;
  let { mediaList = false } = $$props;
  let { divider = false } = $$props;
  let { groupTitle = false } = $$props;
  let { swipeout = false } = $$props;
  let { swipeoutOpened = false } = $$props;
  let { sortable = void 0 } = $$props;
  let { sortableOpposite = void 0 } = $$props;
  let { accordionItem = false } = $$props;
  let { accordionItemOpened = false } = $$props;
  let { smartSelect = false } = $$props;
  let { smartSelectParams = void 0 } = $$props;
  let { noChevron = void 0 } = $$props;
  let { chevronCenter = void 0 } = $$props;
  let { checkbox = void 0 } = $$props;
  let { radio = void 0 } = $$props;
  let { radioIcon = void 0 } = $$props;
  let { checked = void 0 } = $$props;
  let { indeterminate = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { virtualListIndex = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let el;
  let linkEl;
  let innerEl;
  let inputEl;
  let f7SmartSelect;
  function smartSelectInstance() {
    return f7SmartSelect;
  }
  let ListContext = getReactiveContext("ListContext", (value2) => {
    $$invalidate(68, ListContext = value2 || {});
  }) || {};
  let initialWatchedOpened = false;
  function watchSwipeoutOpened(opened) {
    if (!initialWatchedOpened) {
      initialWatchedOpened = true;
      return;
    }
    if (!swipeout)
      return;
    if (opened) {
      app.f7.swipeout.open(el);
    } else {
      app.f7.swipeout.close(el);
    }
  }
  function onClick(event) {
    if (event.target.tagName.toLowerCase() !== "input") {
      emit("click", event);
    }
  }
  function onSwipeoutOverswipeEnter(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutOverswipeEnter");
  }
  function onSwipeoutOverswipeExit(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutOverswipeExit");
  }
  function onSwipeoutDeleted(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutDeleted");
  }
  function onSwipeoutDelete(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutDelete");
  }
  function onSwipeoutClose(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutClose");
  }
  function onSwipeoutClosed(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutClosed");
  }
  function onSwipeoutOpen(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutOpen");
  }
  function onSwipeoutOpened(eventEl) {
    if (eventEl !== el)
      return;
    emit("swipeoutOpened");
  }
  function onSwipeout(eventEl, progress) {
    if (eventEl !== el)
      return;
    emit("swipeout", progress);
  }
  function onAccBeforeClose(eventEl, prevent) {
    if (eventEl !== el)
      return;
    emit("accordionBeforeClose", [prevent]);
  }
  function onAccClose(eventEl) {
    if (eventEl !== el)
      return;
    emit("accordionClose");
  }
  function onAccClosed(eventEl) {
    if (eventEl !== el)
      return;
    emit("accordionClosed");
  }
  function onAccBeforeOpen(eventEl, prevent) {
    if (eventEl !== el)
      return;
    emit("accordionBeforeOpen", [prevent]);
  }
  function onAccOpen(eventEl) {
    if (eventEl !== el)
      return;
    emit("accordionOpen");
  }
  function onAccOpened(eventEl) {
    if (eventEl !== el)
      return;
    emit("accordionOpened");
  }
  function onChange(event) {
    emit("change", [event]);
    $$invalidate(0, checked = event.target.checked);
  }
  useSmartSelect(
    { smartSelect, smartSelectParams },
    (instance87) => {
      f7SmartSelect = instance87;
    },
    () => linkEl
  );
  onMount(() => {
    if (indeterminate && inputEl) {
      $$invalidate(30, inputEl.indeterminate = true, inputEl);
    }
    f7ready(() => {
      if (swipeout) {
        app.f7.on("swipeoutOpen", onSwipeoutOpen);
        app.f7.on("swipeoutOpened", onSwipeoutOpened);
        app.f7.on("swipeoutClose", onSwipeoutClose);
        app.f7.on("swipeoutClosed", onSwipeoutClosed);
        app.f7.on("swipeoutDelete", onSwipeoutDelete);
        app.f7.on("swipeoutDeleted", onSwipeoutDeleted);
        app.f7.on("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
        app.f7.on("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
        app.f7.on("swipeout", onSwipeout);
      }
      if (accordionItem) {
        app.f7.on("accordionBeforeOpen", onAccBeforeOpen);
        app.f7.on("accordionOpen", onAccOpen);
        app.f7.on("accordionOpened", onAccOpened);
        app.f7.on("accordionBeforeClose", onAccBeforeClose);
        app.f7.on("accordionClose", onAccClose);
        app.f7.on("accordionClosed", onAccClosed);
      }
      if (swipeoutOpened) {
        app.f7.swipeout.open(el);
      }
    });
  });
  afterUpdate(() => {
    if (inputEl) {
      $$invalidate(30, inputEl.indeterminate = indeterminate, inputEl);
    }
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    if (swipeout) {
      app.f7.off("swipeoutOpen", onSwipeoutOpen);
      app.f7.off("swipeoutOpened", onSwipeoutOpened);
      app.f7.off("swipeoutClose", onSwipeoutClose);
      app.f7.off("swipeoutClosed", onSwipeoutClosed);
      app.f7.off("swipeoutDelete", onSwipeoutDelete);
      app.f7.off("swipeoutDeleted", onSwipeoutDeleted);
      app.f7.off("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
      app.f7.off("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
      app.f7.off("swipeout", onSwipeout);
    }
    if (accordionItem) {
      app.f7.off("accordionBeforeOpen", onAccBeforeOpen);
      app.f7.off("accordionOpen", onAccOpen);
      app.f7.off("accordionOpened", onAccOpened);
      app.f7.off("accordionBeforeClose", onAccBeforeClose);
      app.f7.off("accordionClose", onAccClose);
      app.f7.off("accordionClosed", onAccClosed);
    }
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(27, el);
    });
  }
  function li_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(27, el);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      linkEl = $$value;
      $$invalidate(28, linkEl);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(30, inputEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function div0_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function div0_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function a_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      linkEl = $$value;
      $$invalidate(28, linkEl);
    });
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(30, inputEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function div0_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(29, innerEl);
    });
  }
  function li_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(27, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(104, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(48, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(49, className = $$new_props.class);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("media" in $$new_props)
      $$invalidate(3, media = $$new_props.media);
    if ("subtitle" in $$new_props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("header" in $$new_props)
      $$invalidate(5, header = $$new_props.header);
    if ("footer" in $$new_props)
      $$invalidate(6, footer = $$new_props.footer);
    if ("tooltip" in $$new_props)
      $$invalidate(7, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("link" in $$new_props)
      $$invalidate(50, link = $$new_props.link);
    if ("tabLink" in $$new_props)
      $$invalidate(51, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props)
      $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    if ("selected" in $$new_props)
      $$invalidate(53, selected = $$new_props.selected);
    if ("href" in $$new_props)
      $$invalidate(54, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(55, target = $$new_props.target);
    if ("after" in $$new_props)
      $$invalidate(9, after = $$new_props.after);
    if ("badge" in $$new_props)
      $$invalidate(10, badge = $$new_props.badge);
    if ("badgeColor" in $$new_props)
      $$invalidate(11, badgeColor = $$new_props.badgeColor);
    if ("mediaItem" in $$new_props)
      $$invalidate(56, mediaItem = $$new_props.mediaItem);
    if ("mediaList" in $$new_props)
      $$invalidate(57, mediaList = $$new_props.mediaList);
    if ("divider" in $$new_props)
      $$invalidate(12, divider = $$new_props.divider);
    if ("groupTitle" in $$new_props)
      $$invalidate(13, groupTitle = $$new_props.groupTitle);
    if ("swipeout" in $$new_props)
      $$invalidate(14, swipeout = $$new_props.swipeout);
    if ("swipeoutOpened" in $$new_props)
      $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    if ("sortable" in $$new_props)
      $$invalidate(15, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$new_props)
      $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionItem" in $$new_props)
      $$invalidate(16, accordionItem = $$new_props.accordionItem);
    if ("accordionItemOpened" in $$new_props)
      $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    if ("smartSelect" in $$new_props)
      $$invalidate(61, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$new_props)
      $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    if ("noChevron" in $$new_props)
      $$invalidate(63, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$new_props)
      $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    if ("checkbox" in $$new_props)
      $$invalidate(17, checkbox = $$new_props.checkbox);
    if ("radio" in $$new_props)
      $$invalidate(18, radio = $$new_props.radio);
    if ("radioIcon" in $$new_props)
      $$invalidate(65, radioIcon = $$new_props.radioIcon);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(66, indeterminate = $$new_props.indeterminate);
    if ("name" in $$new_props)
      $$invalidate(19, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(20, value = $$new_props.value);
    if ("readonly" in $$new_props)
      $$invalidate(21, readonly = $$new_props.readonly);
    if ("required" in $$new_props)
      $$invalidate(22, required = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate(23, disabled = $$new_props.disabled);
    if ("virtualListIndex" in $$new_props)
      $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    if ("routeProps" in $$new_props)
      $$invalidate(25, routeProps = $$new_props.routeProps);
    if ("$$scope" in $$new_props)
      $$invalidate(83, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    afterUpdate,
    colorClasses,
    routerClasses,
    routerAttrs,
    actionsClasses,
    actionsAttrs,
    classNames,
    plainText,
    isStringProp,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTooltip,
    useSmartSelect,
    useRouteProps,
    getReactiveContext,
    Badge: badge_default,
    emit,
    className,
    title,
    text: text2,
    media,
    subtitle,
    header,
    footer,
    tooltip,
    tooltipTrigger,
    link,
    tabLink,
    tabLinkActive,
    selected,
    href,
    target,
    after,
    badge,
    badgeColor,
    mediaItem,
    mediaList,
    divider,
    groupTitle,
    swipeout,
    swipeoutOpened,
    sortable,
    sortableOpposite,
    accordionItem,
    accordionItemOpened,
    smartSelect,
    smartSelectParams,
    noChevron,
    chevronCenter,
    checkbox,
    radio,
    radioIcon,
    checked,
    indeterminate,
    name,
    value,
    readonly,
    required,
    disabled,
    virtualListIndex,
    routeProps,
    el,
    linkEl,
    innerEl,
    inputEl,
    f7SmartSelect,
    smartSelectInstance,
    ListContext,
    initialWatchedOpened,
    watchSwipeoutOpened,
    onClick,
    onSwipeoutOverswipeEnter,
    onSwipeoutOverswipeExit,
    onSwipeoutDeleted,
    onSwipeoutDelete,
    onSwipeoutClose,
    onSwipeoutClosed,
    onSwipeoutOpen,
    onSwipeoutOpened,
    onSwipeout,
    onAccBeforeClose,
    onAccClose,
    onAccClosed,
    onAccBeforeOpen,
    onAccOpen,
    onAccOpened,
    onChange,
    hasAfter,
    hasText,
    hasSubtitle,
    hasFooter,
    hasHeader,
    hasTitle,
    hasMedia,
    isLink,
    linkAttrs,
    linkClasses,
    contentClasses,
    isMedia,
    liClasses,
    isSimple,
    isSortableOpposite,
    isSortable
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(104, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(49, className = $$new_props.className);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("media" in $$props)
      $$invalidate(3, media = $$new_props.media);
    if ("subtitle" in $$props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("header" in $$props)
      $$invalidate(5, header = $$new_props.header);
    if ("footer" in $$props)
      $$invalidate(6, footer = $$new_props.footer);
    if ("tooltip" in $$props)
      $$invalidate(7, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("link" in $$props)
      $$invalidate(50, link = $$new_props.link);
    if ("tabLink" in $$props)
      $$invalidate(51, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$props)
      $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    if ("selected" in $$props)
      $$invalidate(53, selected = $$new_props.selected);
    if ("href" in $$props)
      $$invalidate(54, href = $$new_props.href);
    if ("target" in $$props)
      $$invalidate(55, target = $$new_props.target);
    if ("after" in $$props)
      $$invalidate(9, after = $$new_props.after);
    if ("badge" in $$props)
      $$invalidate(10, badge = $$new_props.badge);
    if ("badgeColor" in $$props)
      $$invalidate(11, badgeColor = $$new_props.badgeColor);
    if ("mediaItem" in $$props)
      $$invalidate(56, mediaItem = $$new_props.mediaItem);
    if ("mediaList" in $$props)
      $$invalidate(57, mediaList = $$new_props.mediaList);
    if ("divider" in $$props)
      $$invalidate(12, divider = $$new_props.divider);
    if ("groupTitle" in $$props)
      $$invalidate(13, groupTitle = $$new_props.groupTitle);
    if ("swipeout" in $$props)
      $$invalidate(14, swipeout = $$new_props.swipeout);
    if ("swipeoutOpened" in $$props)
      $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    if ("sortable" in $$props)
      $$invalidate(15, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$props)
      $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionItem" in $$props)
      $$invalidate(16, accordionItem = $$new_props.accordionItem);
    if ("accordionItemOpened" in $$props)
      $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    if ("smartSelect" in $$props)
      $$invalidate(61, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$props)
      $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    if ("noChevron" in $$props)
      $$invalidate(63, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$props)
      $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    if ("checkbox" in $$props)
      $$invalidate(17, checkbox = $$new_props.checkbox);
    if ("radio" in $$props)
      $$invalidate(18, radio = $$new_props.radio);
    if ("radioIcon" in $$props)
      $$invalidate(65, radioIcon = $$new_props.radioIcon);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(66, indeterminate = $$new_props.indeterminate);
    if ("name" in $$props)
      $$invalidate(19, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(20, value = $$new_props.value);
    if ("readonly" in $$props)
      $$invalidate(21, readonly = $$new_props.readonly);
    if ("required" in $$props)
      $$invalidate(22, required = $$new_props.required);
    if ("disabled" in $$props)
      $$invalidate(23, disabled = $$new_props.disabled);
    if ("virtualListIndex" in $$props)
      $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    if ("routeProps" in $$props)
      $$invalidate(25, routeProps = $$new_props.routeProps);
    if ("el" in $$props)
      $$invalidate(27, el = $$new_props.el);
    if ("linkEl" in $$props)
      $$invalidate(28, linkEl = $$new_props.linkEl);
    if ("innerEl" in $$props)
      $$invalidate(29, innerEl = $$new_props.innerEl);
    if ("inputEl" in $$props)
      $$invalidate(30, inputEl = $$new_props.inputEl);
    if ("f7SmartSelect" in $$props)
      f7SmartSelect = $$new_props.f7SmartSelect;
    if ("ListContext" in $$props)
      $$invalidate(68, ListContext = $$new_props.ListContext);
    if ("initialWatchedOpened" in $$props)
      initialWatchedOpened = $$new_props.initialWatchedOpened;
    if ("hasAfter" in $$props)
      $$invalidate(31, hasAfter = $$new_props.hasAfter);
    if ("hasText" in $$props)
      $$invalidate(32, hasText = $$new_props.hasText);
    if ("hasSubtitle" in $$props)
      $$invalidate(33, hasSubtitle = $$new_props.hasSubtitle);
    if ("hasFooter" in $$props)
      $$invalidate(34, hasFooter = $$new_props.hasFooter);
    if ("hasHeader" in $$props)
      $$invalidate(35, hasHeader = $$new_props.hasHeader);
    if ("hasTitle" in $$props)
      $$invalidate(36, hasTitle = $$new_props.hasTitle);
    if ("hasMedia" in $$props)
      $$invalidate(37, hasMedia = $$new_props.hasMedia);
    if ("isLink" in $$props)
      $$invalidate(38, isLink = $$new_props.isLink);
    if ("linkAttrs" in $$props)
      $$invalidate(39, linkAttrs = $$new_props.linkAttrs);
    if ("linkClasses" in $$props)
      $$invalidate(40, linkClasses = $$new_props.linkClasses);
    if ("contentClasses" in $$props)
      $$invalidate(41, contentClasses = $$new_props.contentClasses);
    if ("isMedia" in $$props)
      $$invalidate(26, isMedia = $$new_props.isMedia);
    if ("liClasses" in $$props)
      $$invalidate(42, liClasses = $$new_props.liClasses);
    if ("isSimple" in $$props)
      $$invalidate(43, isSimple = $$new_props.isSimple);
    if ("isSortableOpposite" in $$props)
      $$invalidate(44, isSortableOpposite = $$new_props.isSortableOpposite);
    if ("isSortable" in $$props)
      $$invalidate(45, isSortable = $$new_props.isSortable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/
    100663296 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $:
        $$invalidate(26, isMedia = mediaList || mediaItem || ListContext.listIsMedia);
    }
    if ($$self.$$.dirty[0] & /*sortable*/
    32768 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $:
        $$invalidate(45, isSortable = sortable === true || sortable === false ? sortable : ListContext.listIsSortable);
    }
    if ($$self.$$.dirty[1] & /*sortableOpposite*/
    268435456 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $:
        $$invalidate(44, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    }
    if ($$self.$$.dirty[2] & /*ListContext*/
    64) {
      $:
        $$invalidate(43, isSimple = ListContext.listIsSimple);
    }
    $:
      $$invalidate(42, liClasses = classNames(
        className,
        {
          "item-divider": divider,
          "list-group-title": groupTitle,
          "media-item": isMedia,
          swipeout,
          "accordion-item": accordionItem,
          "accordion-item-opened": accordionItemOpened,
          disabled: disabled && !(radio || checkbox),
          "no-chevron": noChevron,
          "chevron-center": chevronCenter,
          "disallow-sorting": sortable === false
        },
        colorClasses($$props)
      ));
    $:
      $$invalidate(41, contentClasses = classNames(
        className,
        "item-content",
        {
          "item-checkbox": checkbox,
          "item-radio": radio,
          "item-radio-icon-start": radio && radioIcon === "start",
          "item-radio-icon-end": radio && radioIcon === "end"
        },
        colorClasses($$props)
      ));
    $:
      $$invalidate(40, linkClasses = classNames(
        {
          "item-link": true,
          "smart-select": smartSelect,
          "tab-link": tabLink || tabLink === "",
          "tab-link-active": tabLinkActive,
          "item-selected": selected
        },
        routerClasses($$props),
        actionsClasses($$props)
      ));
    $:
      $$invalidate(39, linkAttrs = {
        href: link === true ? "" : link || href,
        target,
        "data-tab": isStringProp(tabLink) && tabLink || void 0,
        ...routerAttrs($$props),
        ...actionsAttrs($$props)
      });
    if ($$self.$$.dirty[0] & /*accordionItem*/
    65536 | $$self.$$.dirty[1] & /*link, href, smartSelect*/
    1082654720) {
      $:
        $$invalidate(38, isLink = link || href || smartSelect || accordionItem);
    }
    if ($$self.$$.dirty[0] & /*media*/
    8) {
      $:
        $$invalidate(37, hasMedia = typeof media !== "undefined" || $$slots.media);
    }
    if ($$self.$$.dirty[0] & /*title*/
    2) {
      $:
        $$invalidate(36, hasTitle = typeof title !== "undefined" || $$slots.title);
    }
    if ($$self.$$.dirty[0] & /*header*/
    32) {
      $:
        $$invalidate(35, hasHeader = typeof header !== "undefined" || $$slots.header);
    }
    if ($$self.$$.dirty[0] & /*footer*/
    64) {
      $:
        $$invalidate(34, hasFooter = typeof footer !== "undefined" || $$slots.footer);
    }
    if ($$self.$$.dirty[0] & /*subtitle*/
    16) {
      $:
        $$invalidate(33, hasSubtitle = typeof subtitle !== "undefined" || $$slots.subtitle);
    }
    if ($$self.$$.dirty[0] & /*text*/
    4) {
      $:
        $$invalidate(32, hasText = typeof text2 !== "undefined" || $$slots.text);
    }
    if ($$self.$$.dirty[0] & /*after, badge*/
    1536) {
      $:
        $$invalidate(31, hasAfter = typeof after !== "undefined" || typeof badge !== "undefined" || $$slots.after);
    }
    if ($$self.$$.dirty[1] & /*swipeoutOpened*/
    134217728) {
      $:
        watchSwipeoutOpened(swipeoutOpened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    title,
    text2,
    media,
    subtitle,
    header,
    footer,
    tooltip,
    tooltipTrigger,
    after,
    badge,
    badgeColor,
    divider,
    groupTitle,
    swipeout,
    sortable,
    accordionItem,
    checkbox,
    radio,
    name,
    value,
    readonly,
    required,
    disabled,
    virtualListIndex,
    routeProps,
    isMedia,
    el,
    linkEl,
    innerEl,
    inputEl,
    hasAfter,
    hasText,
    hasSubtitle,
    hasFooter,
    hasHeader,
    hasTitle,
    hasMedia,
    isLink,
    linkAttrs,
    linkClasses,
    contentClasses,
    liClasses,
    isSimple,
    isSortableOpposite,
    isSortable,
    onClick,
    onChange,
    $$restProps,
    className,
    link,
    tabLink,
    tabLinkActive,
    selected,
    href,
    target,
    mediaItem,
    mediaList,
    swipeoutOpened,
    sortableOpposite,
    accordionItemOpened,
    smartSelect,
    smartSelectParams,
    noChevron,
    chevronCenter,
    radioIcon,
    indeterminate,
    smartSelectInstance,
    ListContext,
    slots,
    li_binding,
    li_binding_1,
    div0_binding,
    a_binding,
    input_binding,
    div_binding,
    div0_binding_1,
    div0_binding_2,
    a_binding_1,
    input_binding_1,
    div_binding_1,
    div0_binding_3,
    li_binding_2,
    $$scope
  ];
}
var List_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance46,
      create_fragment57,
      safe_not_equal,
      {
        class: 49,
        title: 1,
        text: 2,
        media: 3,
        subtitle: 4,
        header: 5,
        footer: 6,
        tooltip: 7,
        tooltipTrigger: 8,
        link: 50,
        tabLink: 51,
        tabLinkActive: 52,
        selected: 53,
        href: 54,
        target: 55,
        after: 9,
        badge: 10,
        badgeColor: 11,
        mediaItem: 56,
        mediaList: 57,
        divider: 12,
        groupTitle: 13,
        swipeout: 14,
        swipeoutOpened: 58,
        sortable: 15,
        sortableOpposite: 59,
        accordionItem: 16,
        accordionItemOpened: 60,
        smartSelect: 61,
        smartSelectParams: 62,
        noChevron: 63,
        chevronCenter: 64,
        checkbox: 17,
        radio: 18,
        radioIcon: 65,
        checked: 0,
        indeterminate: 66,
        name: 19,
        value: 20,
        readonly: 21,
        required: 22,
        disabled: 23,
        virtualListIndex: 24,
        routeProps: 25,
        smartSelectInstance: 67
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List_item",
      options,
      id: create_fragment57.name
    });
  }
  get class() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get media() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set media(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLink() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLink(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabLinkActive() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabLinkActive(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get after() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set after(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badge() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badge(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badgeColor() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badgeColor(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaItem() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaItem(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaList() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaList(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupTitle() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupTitle(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeout() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeout(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeoutOpened() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeoutOpened(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableOpposite() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableOpposite(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionItem() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionItem(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionItemOpened() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionItemOpened(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelect() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smartSelect(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelectParams() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smartSelectParams(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noChevron() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noChevron(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronCenter() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronCenter(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkbox() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkbox(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radio() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radio(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radioIcon() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radioIcon(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualListIndex() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualListIndex(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smartSelectInstance() {
    return this.$$.ctx[67];
  }
  set smartSelectInstance(value) {
    throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_item_default = List_item;

// node_modules/framework7-svelte/components/list.svelte
var file55 = "node_modules/framework7-svelte/components/list.svelte";
var get_after_list_slot_changes_1 = (dirty) => ({});
var get_after_list_slot_context_1 = (ctx) => ({});
var get_list_slot_changes_1 = (dirty) => ({});
var get_list_slot_context_1 = (ctx) => ({});
var get_before_list_slot_changes_1 = (dirty) => ({});
var get_before_list_slot_context_1 = (ctx) => ({});
var get_after_list_slot_changes = (dirty) => ({});
var get_after_list_slot_context = (ctx) => ({});
var get_list_slot_changes = (dirty) => ({});
var get_list_slot_context = (ctx) => ({});
var get_before_list_slot_changes = (dirty) => ({});
var get_before_list_slot_context = (ctx) => ({});
function create_else_block_16(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let div_data_sortable_move_elements_value;
  let current;
  const before_list_slot_template = (
    /*#slots*/
    ctx[44]["before-list"]
  );
  const before_list_slot = create_slot(
    before_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_before_list_slot_context_1
  );
  const if_block_creators = [create_if_block_214, create_else_block_24];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*hasUlSlots*/
      ctx2[5] && /*ul*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_list_slot_template = (
    /*#slots*/
    ctx[44]["after-list"]
  );
  const after_list_slot = create_slot(
    after_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_after_list_slot_context_1
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    {
      "data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
      ctx[1] !== "undefined" ? (
        /*sortableMoveElements*/
        ctx[1].toString()
      ) : void 0
    },
    restProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (before_list_slot)
        before_list_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_list_slot)
        after_list_slot.c();
      set_attributes(div, div_data);
      add_location(div, file55, 217, 2, 6270);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (before_list_slot) {
        before_list_slot.m(div, null);
      }
      append_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t1);
      if (after_list_slot) {
        after_list_slot.m(div, null);
      }
      ctx[46](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_list_slot) {
        if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            before_list_slot,
            before_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              before_list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_before_list_slot_changes_1
            ),
            get_before_list_slot_context_1
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t1);
      }
      if (after_list_slot) {
        if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            after_list_slot,
            after_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              after_list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_after_list_slot_changes_1
            ),
            get_after_list_slot_context_1
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*sortableMoveElements*/
        2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
        ctx2[1] !== "undefined" ? (
          /*sortableMoveElements*/
          ctx2[1].toString()
        ) : void 0)) && {
          "data-sortable-move-elements": div_data_sortable_move_elements_value
        },
        dirty[0] & /*$$restProps*/
        128 && restProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_list_slot, local);
      transition_in(if_block);
      transition_in(after_list_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_list_slot, local);
      transition_out(if_block);
      transition_out(after_list_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (before_list_slot)
        before_list_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_list_slot)
        after_list_slot.d(detaching);
      ctx[46](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_16.name,
    type: "else",
    source: "(217:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let form_1;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let form_1_data_sortable_move_elements_value;
  let current;
  let mounted;
  let dispose;
  const before_list_slot_template = (
    /*#slots*/
    ctx[44]["before-list"]
  );
  const before_list_slot = create_slot(
    before_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_before_list_slot_context
  );
  const if_block_creators = [create_if_block_130, create_else_block8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*hasUlSlots*/
      ctx2[5] && /*ul*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_list_slot_template = (
    /*#slots*/
    ctx[44]["after-list"]
  );
  const after_list_slot = create_slot(
    after_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_after_list_slot_context
  );
  let form_1_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    {
      "data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
      ctx[1] !== "undefined" ? (
        /*sortableMoveElements*/
        ctx[1].toString()
      ) : void 0
    },
    restProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let form_1_data = {};
  for (let i = 0; i < form_1_levels.length; i += 1) {
    form_1_data = assign(form_1_data, form_1_levels[i]);
  }
  const block = {
    c: function create() {
      form_1 = element("form");
      if (before_list_slot)
        before_list_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_list_slot)
        after_list_slot.c();
      set_attributes(form_1, form_1_data);
      add_location(form_1, file55, 196, 2, 5812);
    },
    m: function mount(target, anchor) {
      insert_dev(target, form_1, anchor);
      if (before_list_slot) {
        before_list_slot.m(form_1, null);
      }
      append_dev(form_1, t0);
      if_blocks[current_block_type_index].m(form_1, null);
      append_dev(form_1, t1);
      if (after_list_slot) {
        after_list_slot.m(form_1, null);
      }
      ctx[45](form_1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          form_1,
          "submit",
          /*onSubmit*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (before_list_slot) {
        if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            before_list_slot,
            before_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              before_list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_before_list_slot_changes
            ),
            get_before_list_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(form_1, t1);
      }
      if (after_list_slot) {
        if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            after_list_slot,
            after_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              after_list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_after_list_slot_changes
            ),
            get_after_list_slot_context
          );
        }
      }
      set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*sortableMoveElements*/
        2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
        ctx2[1] !== "undefined" ? (
          /*sortableMoveElements*/
          ctx2[1].toString()
        ) : void 0)) && {
          "data-sortable-move-elements": form_1_data_sortable_move_elements_value
        },
        dirty[0] & /*$$restProps*/
        128 && restProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_list_slot, local);
      transition_in(if_block);
      transition_in(after_list_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_list_slot, local);
      transition_out(if_block);
      transition_out(after_list_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form_1);
      if (before_list_slot)
        before_list_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_list_slot)
        after_list_slot.d(detaching);
      ctx[45](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(196:0) {#if form}",
    ctx
  });
  return block;
}
function create_else_block_24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_24.name,
    type: "else",
    source: "(232:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_214(ctx) {
  let ul_1;
  let t;
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[44].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_list_slot_context_1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      ul_1 = element("ul");
      if (list_slot)
        list_slot.c();
      t = space();
      if (default_slot)
        default_slot.c();
      add_location(ul_1, file55, 227, 6, 6551);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul_1, anchor);
      if (list_slot) {
        list_slot.m(ul_1, null);
      }
      append_dev(ul_1, t);
      if (default_slot) {
        default_slot.m(ul_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_list_slot_changes_1
            ),
            get_list_slot_context_1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul_1);
      if (list_slot)
        list_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(227:4) {#if hasUlSlots && ul}",
    ctx
  });
  return block;
}
function create_else_block8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(212:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_130(ctx) {
  let ul_1;
  let t;
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[44].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_list_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      ul_1 = element("ul");
      if (list_slot)
        list_slot.c();
      t = space();
      if (default_slot)
        default_slot.c();
      add_location(ul_1, file55, 207, 6, 6119);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul_1, anchor);
      if (list_slot) {
        list_slot.m(ul_1, null);
      }
      append_dev(ul_1, t);
      if (default_slot) {
        default_slot.m(ul_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_list_slot_changes
            ),
            get_list_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul_1);
      if (list_slot)
        list_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_130.name,
    type: "if",
    source: "(207:4) {#if hasUlSlots && ul}",
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block20, create_else_block_16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*form*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let hasUlSlots;
  let classes;
  const omit_props_names = [
    "class",
    "ul",
    "inset",
    "xsmallInset",
    "smallInset",
    "mediumInset",
    "largeInset",
    "xlargeInset",
    "mediaList",
    "sortable",
    "sortableTapHold",
    "sortableEnabled",
    "sortableMoveElements",
    "sortableOpposite",
    "accordionList",
    "accordionOpposite",
    "contactsList",
    "simpleList",
    "linksList",
    "menuList",
    "noHairlines",
    "noHairlinesBetween",
    "noHairlinesMd",
    "noHairlinesBetweenMd",
    "noHairlinesIos",
    "noHairlinesBetweenIos",
    "noHairlinesAurora",
    "noHairlinesBetweenAurora",
    "noChevron",
    "chevronCenter",
    "tab",
    "tabActive",
    "form",
    "formStoreData",
    "inlineLabels",
    "virtualList",
    "virtualListParams",
    "virtualListInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["before-list", "list", "default", "after-list"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { ul = true } = $$props;
  let { inset = false } = $$props;
  let { xsmallInset = false } = $$props;
  let { smallInset = false } = $$props;
  let { mediumInset = false } = $$props;
  let { largeInset = false } = $$props;
  let { xlargeInset = false } = $$props;
  let { mediaList = false } = $$props;
  let { sortable = false } = $$props;
  let { sortableTapHold = false } = $$props;
  let { sortableEnabled = false } = $$props;
  let { sortableMoveElements = void 0 } = $$props;
  let { sortableOpposite = false } = $$props;
  let { accordionList = false } = $$props;
  let { accordionOpposite = false } = $$props;
  let { contactsList = false } = $$props;
  let { simpleList = false } = $$props;
  let { linksList = false } = $$props;
  let { menuList = false } = $$props;
  let { noHairlines = false } = $$props;
  let { noHairlinesBetween = false } = $$props;
  let { noHairlinesMd = false } = $$props;
  let { noHairlinesBetweenMd = false } = $$props;
  let { noHairlinesIos = false } = $$props;
  let { noHairlinesBetweenIos = false } = $$props;
  let { noHairlinesAurora = false } = $$props;
  let { noHairlinesBetweenAurora = false } = $$props;
  let { noChevron = false } = $$props;
  let { chevronCenter = false } = $$props;
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { form = false } = $$props;
  let { formStoreData = false } = $$props;
  let { inlineLabels = false } = $$props;
  let { virtualList = false } = $$props;
  let { virtualListParams = void 0 } = $$props;
  let el;
  let f7VirtualList;
  function virtualListInstance() {
    return f7VirtualList;
  }
  setReactiveContext("ListContext", () => ({
    listIsMedia: mediaList,
    listIsSimple: simpleList,
    listIsSortable: sortable,
    listIsSortableOpposite: sortableOpposite
  }));
  function onSubmit(event) {
    emit("submit", [event]);
  }
  function onSortableEnable(sortableEl) {
    if (sortableEl !== el)
      return;
    emit("sortableEnable");
  }
  function onSortableDisable(sortableEl) {
    if (sortableEl !== el)
      return;
    emit("sortableDisable");
  }
  function onSortableSort(listItemEl, sortData, listEl) {
    if (listEl !== el)
      return;
    emit("sortableSort", [sortData]);
  }
  function onSortableMove(listItemEl, listEl) {
    if (listEl !== el)
      return;
    emit("sortableMove", [listItemEl, listEl]);
  }
  useTab(() => el, emit);
  onMount(() => {
    f7ready(() => {
      app.f7.on("sortableEnable", onSortableEnable);
      app.f7.on("sortableDisable", onSortableDisable);
      app.f7.on("sortableSort", onSortableSort);
      app.f7.on("sortableMove", onSortableMove);
      if (!virtualList)
        return;
      const vlParams = virtualListParams || {};
      if (!vlParams.renderItem && !vlParams.renderExternal)
        return;
      f7VirtualList = app.f7.virtualList.create(extend(
        {
          el,
          on: {
            itemBeforeInsert(itemEl, item) {
              const vl = this;
              emit("virtualItemBeforeInsert", [vl, itemEl, item]);
            },
            beforeClear(fragment) {
              const vl = this;
              emit("virtualBeforeClear", [vl, fragment]);
            },
            itemsBeforeInsert(fragment) {
              const vl = this;
              emit("virtualItemsBeforeInsert", [vl, fragment]);
            },
            itemsAfterInsert(fragment) {
              const vl = this;
              emit("virtualItemsAfterInsert", [vl, fragment]);
            }
          }
        },
        vlParams
      ));
    });
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    app.f7.off("sortableEnable", onSortableEnable);
    app.f7.off("sortableDisable", onSortableDisable);
    app.f7.off("sortableSort", onSortableSort);
    app.f7.off("sortableMove", onSortableMove);
    if (f7VirtualList && f7VirtualList.destroy) {
      f7VirtualList.destroy();
      f7VirtualList = null;
    }
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("ul" in $$new_props)
      $$invalidate(0, ul = $$new_props.ul);
    if ("inset" in $$new_props)
      $$invalidate(9, inset = $$new_props.inset);
    if ("xsmallInset" in $$new_props)
      $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    if ("smallInset" in $$new_props)
      $$invalidate(11, smallInset = $$new_props.smallInset);
    if ("mediumInset" in $$new_props)
      $$invalidate(12, mediumInset = $$new_props.mediumInset);
    if ("largeInset" in $$new_props)
      $$invalidate(13, largeInset = $$new_props.largeInset);
    if ("xlargeInset" in $$new_props)
      $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    if ("mediaList" in $$new_props)
      $$invalidate(15, mediaList = $$new_props.mediaList);
    if ("sortable" in $$new_props)
      $$invalidate(16, sortable = $$new_props.sortable);
    if ("sortableTapHold" in $$new_props)
      $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    if ("sortableEnabled" in $$new_props)
      $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    if ("sortableMoveElements" in $$new_props)
      $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    if ("sortableOpposite" in $$new_props)
      $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionList" in $$new_props)
      $$invalidate(20, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$new_props)
      $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    if ("contactsList" in $$new_props)
      $$invalidate(22, contactsList = $$new_props.contactsList);
    if ("simpleList" in $$new_props)
      $$invalidate(23, simpleList = $$new_props.simpleList);
    if ("linksList" in $$new_props)
      $$invalidate(24, linksList = $$new_props.linksList);
    if ("menuList" in $$new_props)
      $$invalidate(25, menuList = $$new_props.menuList);
    if ("noHairlines" in $$new_props)
      $$invalidate(26, noHairlines = $$new_props.noHairlines);
    if ("noHairlinesBetween" in $$new_props)
      $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    if ("noHairlinesMd" in $$new_props)
      $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    if ("noHairlinesBetweenMd" in $$new_props)
      $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    if ("noHairlinesIos" in $$new_props)
      $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    if ("noHairlinesBetweenIos" in $$new_props)
      $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    if ("noHairlinesAurora" in $$new_props)
      $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    if ("noHairlinesBetweenAurora" in $$new_props)
      $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    if ("noChevron" in $$new_props)
      $$invalidate(34, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$new_props)
      $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    if ("tab" in $$new_props)
      $$invalidate(36, tab = $$new_props.tab);
    if ("tabActive" in $$new_props)
      $$invalidate(37, tabActive = $$new_props.tabActive);
    if ("form" in $$new_props)
      $$invalidate(2, form = $$new_props.form);
    if ("formStoreData" in $$new_props)
      $$invalidate(38, formStoreData = $$new_props.formStoreData);
    if ("inlineLabels" in $$new_props)
      $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    if ("virtualList" in $$new_props)
      $$invalidate(40, virtualList = $$new_props.virtualList);
    if ("virtualListParams" in $$new_props)
      $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    extend,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTab,
    setReactiveContext,
    emit,
    className,
    ul,
    inset,
    xsmallInset,
    smallInset,
    mediumInset,
    largeInset,
    xlargeInset,
    mediaList,
    sortable,
    sortableTapHold,
    sortableEnabled,
    sortableMoveElements,
    sortableOpposite,
    accordionList,
    accordionOpposite,
    contactsList,
    simpleList,
    linksList,
    menuList,
    noHairlines,
    noHairlinesBetween,
    noHairlinesMd,
    noHairlinesBetweenMd,
    noHairlinesIos,
    noHairlinesBetweenIos,
    noHairlinesAurora,
    noHairlinesBetweenAurora,
    noChevron,
    chevronCenter,
    tab,
    tabActive,
    form,
    formStoreData,
    inlineLabels,
    virtualList,
    virtualListParams,
    el,
    f7VirtualList,
    virtualListInstance,
    onSubmit,
    onSortableEnable,
    onSortableDisable,
    onSortableSort,
    onSortableMove,
    classes,
    hasUlSlots
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(53, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("ul" in $$props)
      $$invalidate(0, ul = $$new_props.ul);
    if ("inset" in $$props)
      $$invalidate(9, inset = $$new_props.inset);
    if ("xsmallInset" in $$props)
      $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    if ("smallInset" in $$props)
      $$invalidate(11, smallInset = $$new_props.smallInset);
    if ("mediumInset" in $$props)
      $$invalidate(12, mediumInset = $$new_props.mediumInset);
    if ("largeInset" in $$props)
      $$invalidate(13, largeInset = $$new_props.largeInset);
    if ("xlargeInset" in $$props)
      $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    if ("mediaList" in $$props)
      $$invalidate(15, mediaList = $$new_props.mediaList);
    if ("sortable" in $$props)
      $$invalidate(16, sortable = $$new_props.sortable);
    if ("sortableTapHold" in $$props)
      $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    if ("sortableEnabled" in $$props)
      $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    if ("sortableMoveElements" in $$props)
      $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    if ("sortableOpposite" in $$props)
      $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionList" in $$props)
      $$invalidate(20, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$props)
      $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    if ("contactsList" in $$props)
      $$invalidate(22, contactsList = $$new_props.contactsList);
    if ("simpleList" in $$props)
      $$invalidate(23, simpleList = $$new_props.simpleList);
    if ("linksList" in $$props)
      $$invalidate(24, linksList = $$new_props.linksList);
    if ("menuList" in $$props)
      $$invalidate(25, menuList = $$new_props.menuList);
    if ("noHairlines" in $$props)
      $$invalidate(26, noHairlines = $$new_props.noHairlines);
    if ("noHairlinesBetween" in $$props)
      $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    if ("noHairlinesMd" in $$props)
      $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    if ("noHairlinesBetweenMd" in $$props)
      $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    if ("noHairlinesIos" in $$props)
      $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    if ("noHairlinesBetweenIos" in $$props)
      $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    if ("noHairlinesAurora" in $$props)
      $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    if ("noHairlinesBetweenAurora" in $$props)
      $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    if ("noChevron" in $$props)
      $$invalidate(34, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$props)
      $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    if ("tab" in $$props)
      $$invalidate(36, tab = $$new_props.tab);
    if ("tabActive" in $$props)
      $$invalidate(37, tabActive = $$new_props.tabActive);
    if ("form" in $$props)
      $$invalidate(2, form = $$new_props.form);
    if ("formStoreData" in $$props)
      $$invalidate(38, formStoreData = $$new_props.formStoreData);
    if ("inlineLabels" in $$props)
      $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    if ("virtualList" in $$props)
      $$invalidate(40, virtualList = $$new_props.virtualList);
    if ("virtualListParams" in $$props)
      $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("f7VirtualList" in $$props)
      f7VirtualList = $$new_props.f7VirtualList;
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("hasUlSlots" in $$props)
      $$invalidate(5, hasUlSlots = $$new_props.hasUlSlots);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classes = classNames(
        className,
        "list",
        {
          inset,
          "xsmall-inset": xsmallInset,
          "small-inset": smallInset,
          "medium-inset": mediumInset,
          "large-inset": largeInset,
          "xlarge-inset": xlargeInset,
          "media-list": mediaList,
          "simple-list": simpleList,
          "links-list": linksList,
          "menu-list": menuList,
          sortable,
          "sortable-tap-hold": sortableTapHold,
          "sortable-enabled": sortableEnabled,
          "sortable-opposite": sortableOpposite,
          "accordion-list": accordionList,
          "accordion-opposite": accordionOpposite,
          "contacts-list": contactsList,
          "virtual-list": virtualList,
          tab,
          "tab-active": tabActive,
          "no-hairlines": noHairlines,
          "no-hairlines-md": noHairlinesMd,
          "no-hairlines-ios": noHairlinesIos,
          "no-hairlines-aurora": noHairlinesAurora,
          "no-hairlines-between": noHairlinesBetween,
          "no-hairlines-between-md": noHairlinesBetweenMd,
          "no-hairlines-between-ios": noHairlinesBetweenIos,
          "no-hairlines-between-aurora": noHairlinesBetweenAurora,
          "form-store-data": formStoreData,
          "inline-labels": inlineLabels,
          "no-chevron": noChevron,
          "chevron-center": chevronCenter
        },
        colorClasses($$props)
      ));
  };
  $:
    $$invalidate(5, hasUlSlots = $$slots.default || $$slots.list);
  $$props = exclude_internal_props($$props);
  return [
    ul,
    sortableMoveElements,
    form,
    el,
    classes,
    hasUlSlots,
    onSubmit,
    $$restProps,
    className,
    inset,
    xsmallInset,
    smallInset,
    mediumInset,
    largeInset,
    xlargeInset,
    mediaList,
    sortable,
    sortableTapHold,
    sortableEnabled,
    sortableOpposite,
    accordionList,
    accordionOpposite,
    contactsList,
    simpleList,
    linksList,
    menuList,
    noHairlines,
    noHairlinesBetween,
    noHairlinesMd,
    noHairlinesBetweenMd,
    noHairlinesIos,
    noHairlinesBetweenIos,
    noHairlinesAurora,
    noHairlinesBetweenAurora,
    noChevron,
    chevronCenter,
    tab,
    tabActive,
    formStoreData,
    inlineLabels,
    virtualList,
    virtualListParams,
    virtualListInstance,
    $$scope,
    slots,
    form_1_binding,
    div_binding
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance47,
      create_fragment58,
      safe_not_equal,
      {
        class: 8,
        ul: 0,
        inset: 9,
        xsmallInset: 10,
        smallInset: 11,
        mediumInset: 12,
        largeInset: 13,
        xlargeInset: 14,
        mediaList: 15,
        sortable: 16,
        sortableTapHold: 17,
        sortableEnabled: 18,
        sortableMoveElements: 1,
        sortableOpposite: 19,
        accordionList: 20,
        accordionOpposite: 21,
        contactsList: 22,
        simpleList: 23,
        linksList: 24,
        menuList: 25,
        noHairlines: 26,
        noHairlinesBetween: 27,
        noHairlinesMd: 28,
        noHairlinesBetweenMd: 29,
        noHairlinesIos: 30,
        noHairlinesBetweenIos: 31,
        noHairlinesAurora: 32,
        noHairlinesBetweenAurora: 33,
        noChevron: 34,
        chevronCenter: 35,
        tab: 36,
        tabActive: 37,
        form: 2,
        formStoreData: 38,
        inlineLabels: 39,
        virtualList: 40,
        virtualListParams: 41,
        virtualListInstance: 42
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment58.name
    });
  }
  get class() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ul() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ul(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xsmallInset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xsmallInset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallInset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallInset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediumInset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediumInset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeInset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeInset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xlargeInset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xlargeInset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mediaList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mediaList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableTapHold() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableTapHold(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableEnabled() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableEnabled(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableMoveElements() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableMoveElements(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableOpposite() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableOpposite(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accordionOpposite() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accordionOpposite(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contactsList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contactsList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get simpleList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set simpleList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linksList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linksList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlines() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlines(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesBetween() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesBetween(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesMd() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesMd(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesBetweenMd() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesBetweenMd(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesBetweenIos() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesBetweenIos(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesAurora() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesAurora(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairlinesBetweenAurora() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairlinesBetweenAurora(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noChevron() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noChevron(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronCenter() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronCenter(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabActive() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabActive(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formStoreData() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formStoreData(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inlineLabels() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inlineLabels(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualListParams() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualListParams(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualListInstance() {
    return this.$$.ctx[42];
  }
  set virtualListInstance(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var list_default = List;

// node_modules/framework7-svelte/components/login-screen-title.svelte
var file56 = "node_modules/framework7-svelte/components/login-screen-title.svelte";
function create_fragment59(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file56, 11, 0, 327);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Login_screen_title", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "login-screen-title", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Login_screen_title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment59, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Login_screen_title",
      options,
      id: create_fragment59.name
    });
  }
  get class() {
    throw new Error("<Login_screen_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Login_screen_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var login_screen_title_default = Login_screen_title;

// node_modules/framework7-svelte/components/menu-dropdown-item.svelte
var file57 = "node_modules/framework7-svelte/components/menu-dropdown-item.svelte";
function create_else_block9(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    /*attrs*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file57, 68, 2, 1636);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[16](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            div,
            /*routeProps*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*attrs*/
        32 && /*attrs*/
        ctx2[5]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/
      2)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(68:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let a;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let a_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    /*attrs*/
    ctx[5]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file57, 63, 2, 1488);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, t0);
      append_dev(a, t1);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[15](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*attrs*/
        32 && /*attrs*/
        ctx2[5]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/
      2)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(63:0) {#if isLink}",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block21, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isLink*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let hrefComputed;
  let attrs;
  let isLink;
  let classes;
  const omit_props_names = ["class", "text", "href", "link", "target", "divider", "routeProps"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu_dropdown_item", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { link = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { divider = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let el;
  function onClick(e) {
    emit("click", [e]);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("href" in $$new_props)
      $$invalidate(8, href = $$new_props.href);
    if ("link" in $$new_props)
      $$invalidate(9, link = $$new_props.link);
    if ("target" in $$new_props)
      $$invalidate(10, target = $$new_props.target);
    if ("divider" in $$new_props)
      $$invalidate(11, divider = $$new_props.divider);
    if ("routeProps" in $$new_props)
      $$invalidate(1, routeProps = $$new_props.routeProps);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsAttrs,
    actionsClasses,
    classNames,
    extend,
    plainText,
    createEmitter,
    restProps,
    useRouteProps,
    emit,
    className,
    text: text2,
    href,
    link,
    target,
    divider,
    routeProps,
    el,
    onClick,
    isLink,
    classes,
    hrefComputed,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("href" in $$props)
      $$invalidate(8, href = $$new_props.href);
    if ("link" in $$props)
      $$invalidate(9, link = $$new_props.link);
    if ("target" in $$props)
      $$invalidate(10, target = $$new_props.target);
    if ("divider" in $$props)
      $$invalidate(11, divider = $$new_props.divider);
    if ("routeProps" in $$props)
      $$invalidate(1, routeProps = $$new_props.routeProps);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("isLink" in $$props)
      $$invalidate(2, isLink = $$new_props.isLink);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("hrefComputed" in $$props)
      $$invalidate(12, hrefComputed = $$new_props.hrefComputed);
    if ("attrs" in $$props)
      $$invalidate(5, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href, link*/
    768) {
      $:
        $$invalidate(12, hrefComputed = typeof href === "undefined" && link ? "#" : href);
    }
    $:
      $$invalidate(5, attrs = extend(
        {
          href: hrefComputed,
          target,
          ...restProps($$restProps)
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    if ($$self.$$.dirty & /*link, href*/
    768) {
      $:
        $$invalidate(2, isLink = link || href || href === "");
    }
    $:
      $$invalidate(4, classes = classNames(
        {
          "menu-dropdown-link": isLink && !divider,
          "menu-dropdown-item": !isLink && !divider,
          "menu-dropdown-divider": divider
        },
        className,
        colorClasses($$props),
        routerClasses($$props),
        actionsClasses($$props),
        {
          "menu-close": typeof menuClose === "undefined"
        }
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    text2,
    routeProps,
    isLink,
    el,
    classes,
    attrs,
    onClick,
    className,
    href,
    link,
    target,
    divider,
    hrefComputed,
    $$scope,
    slots,
    a_binding,
    div_binding
  ];
}
var Menu_dropdown_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment60, safe_not_equal, {
      class: 7,
      text: 0,
      href: 8,
      link: 9,
      target: 10,
      divider: 11,
      routeProps: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu_dropdown_item",
      options,
      id: create_fragment60.name
    });
  }
  get class() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var menu_dropdown_item_default = Menu_dropdown_item;

// node_modules/framework7-svelte/components/menu-dropdown.svelte
var file58 = "node_modules/framework7-svelte/components/menu-dropdown.svelte";
function create_fragment61(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div1_levels = [{ class: (
    /*classes*/
    ctx[1]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "menu-dropdown-content");
      attr_dev(div0, "style", div0_style_value = /*contentHeight*/
      ctx[0] && `height: ${/*contentHeight*/
      ctx[0]}`);
      add_location(div0, file58, 31, 2, 786);
      set_attributes(div1, div1_data);
      add_location(div1, file58, 30, 0, 734);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*contentHeight*/
      1 && div0_style_value !== (div0_style_value = /*contentHeight*/
      ctx2[0] && `height: ${/*contentHeight*/
      ctx2[0]}`)) {
        attr_dev(div0, "style", div0_style_value);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let positionComputed;
  let classes;
  const omit_props_names = ["class", "contentHeight", "position", "left", "center", "right"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu_dropdown", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { contentHeight = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { left = void 0 } = $$props;
  let { center = void 0 } = $$props;
  let { right = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("contentHeight" in $$new_props)
      $$invalidate(0, contentHeight = $$new_props.contentHeight);
    if ("position" in $$new_props)
      $$invalidate(4, position = $$new_props.position);
    if ("left" in $$new_props)
      $$invalidate(5, left = $$new_props.left);
    if ("center" in $$new_props)
      $$invalidate(6, center = $$new_props.center);
    if ("right" in $$new_props)
      $$invalidate(7, right = $$new_props.right);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    contentHeight,
    position,
    left,
    center,
    right,
    positionComputed,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("contentHeight" in $$props)
      $$invalidate(0, contentHeight = $$new_props.contentHeight);
    if ("position" in $$props)
      $$invalidate(4, position = $$new_props.position);
    if ("left" in $$props)
      $$invalidate(5, left = $$new_props.left);
    if ("center" in $$props)
      $$invalidate(6, center = $$new_props.center);
    if ("right" in $$props)
      $$invalidate(7, right = $$new_props.right);
    if ("positionComputed" in $$props)
      $$invalidate(8, positionComputed = $$new_props.positionComputed);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*position, left, center, right*/
    240) {
      $:
        $$invalidate(8, positionComputed = (() => {
          let pos = position || "left";
          if (left)
            pos = "left";
          if (center)
            pos = "center";
          if (right)
            pos = "right";
          return pos;
        })());
    }
    $:
      $$invalidate(1, classes = classNames("menu-dropdown", `menu-dropdown-${positionComputed}`, colorClasses($$props), className));
  };
  $$props = exclude_internal_props($$props);
  return [
    contentHeight,
    classes,
    $$restProps,
    className,
    position,
    left,
    center,
    right,
    positionComputed,
    $$scope,
    slots
  ];
}
var Menu_dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment61, safe_not_equal, {
      class: 3,
      contentHeight: 0,
      position: 4,
      left: 5,
      center: 6,
      right: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu_dropdown",
      options,
      id: create_fragment61.name
    });
  }
  get class() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentHeight() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentHeight(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var menu_dropdown_default = Menu_dropdown;

// node_modules/framework7-svelte/components/menu-item.svelte
var file59 = "node_modules/framework7-svelte/components/menu-item.svelte";
var get_text_slot_changes_12 = (dirty) => ({});
var get_text_slot_context_12 = (ctx) => ({});
var get_text_slot_changes4 = (dirty) => ({});
var get_text_slot_context4 = (ctx) => ({});
function create_else_block10(ctx) {
  let div;
  let t;
  let useTooltip_action;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (typeof /*text*/
  ctx[0] !== "undefined" || /*hasTextSlots*/
  ctx[4] || /*icon*/
  ctx[7]) && create_if_block_311(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[8]
    ) },
    /*attrs*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file59, 118, 2, 2809);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, div, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          })),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            div,
            /*routeProps*/
            ctx[3]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (typeof /*text*/
      ctx2[0] !== "undefined" || /*hasTextSlots*/
      ctx2[4] || /*icon*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*text, hasTextSlots, icon*/
          145) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_311(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx2[8]
        ) },
        dirty & /*attrs*/
        512 && /*attrs*/
        ctx2[9]
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      6)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[1]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[2]
          )
        });
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/
      8)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(118:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let a;
  let t;
  let useTooltip_action;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (typeof /*text*/
  ctx[0] !== "undefined" || /*hasTextSlots*/
  ctx[4] || /*icon*/
  ctx[7]) && create_if_block_131(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let a_levels = [
    { class: (
      /*classes*/
      ctx[8]
    ) },
    /*attrs*/
    ctx[9]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file59, 98, 2, 2371);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (if_block)
        if_block.m(a, null);
      append_dev(a, t);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[21](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*onClick*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          })),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[3]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (typeof /*text*/
      ctx2[0] !== "undefined" || /*hasTextSlots*/
      ctx2[4] || /*icon*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*text, hasTextSlots, icon*/
          145) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_131(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx2[8]
        ) },
        dirty & /*attrs*/
        512 && /*attrs*/
        ctx2[9]
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      6)
        useTooltip_action.update.call(null, {
          tooltip: (
            /*tooltip*/
            ctx2[1]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx2[2]
          )
        });
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/
      8)
        useRouteProps_action.update.call(
          null,
          /*routeProps*/
          ctx2[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(98:0) {#if isLink}",
    ctx
  });
  return block;
}
function create_if_block_311(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2;
  let current;
  let if_block = (
    /*icon*/
    ctx[7] && create_if_block_410(ctx)
  );
  const text_slot_template = (
    /*#slots*/
    ctx[20].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_text_slot_context_12
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "menu-item-content");
      add_location(div, file59, 127, 6, 3047);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t2);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_410(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_text_slot_changes_12
            ),
            get_text_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_311.name,
    type: "if",
    source: "(127:4) {#if typeof text !== 'undefined' || hasTextSlots || icon}",
    ctx
  });
  return block;
}
function create_if_block_410(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[7]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty & /*icon*/
      128)
        useicon_changes.icon = /*icon*/
        ctx2[7];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_410.name,
    type: "if",
    source: "(130:8) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_131(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2;
  let current;
  let if_block = (
    /*icon*/
    ctx[7] && create_if_block_215(ctx)
  );
  const text_slot_template = (
    /*#slots*/
    ctx[20].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_text_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      if (text_slot)
        text_slot.c();
      attr_dev(div, "class", "menu-item-content");
      add_location(div, file59, 107, 6, 2607);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t2);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_215(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (text_slot) {
        if (text_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_text_slot_changes4
            ),
            get_text_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (text_slot)
        text_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_131.name,
    type: "if",
    source: "(107:4) {#if typeof text !== 'undefined' || hasTextSlots || icon}",
    ctx
  });
  return block;
}
function create_if_block_215(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[7]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty & /*icon*/
      128)
        useicon_changes.icon = /*icon*/
        ctx2[7];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_215.name,
    type: "if",
    source: "(110:8) {#if icon}",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block22, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isLink*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let hrefComputed;
  let attrs;
  let hasDefaultSlots;
  let hasTextSlots;
  let iconOnlyComputed;
  let classes;
  let icon;
  let isLink;
  const omit_props_names = [
    "class",
    "text",
    "iconOnly",
    "href",
    "link",
    "target",
    "dropdown",
    "tooltip",
    "tooltipTrigger",
    "routeProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu_item", slots, ["text", "default"]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { iconOnly = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { link = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { dropdown = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let el;
  function onClick(e) {
    emit("click", [e]);
  }
  function onOpened(itemEl) {
    if (itemEl !== el)
      return;
    emit("menuOpened", [el]);
  }
  function onClosed(itemEl) {
    if (itemEl !== el)
      return;
    emit("menuClosed", [el]);
  }
  onMount(() => {
    f7ready(() => {
      app.f7.on("menuOpened", onOpened);
      app.f7.on("menuClosed", onClosed);
    });
  });
  onDestroy(() => {
    if (!el || !app.f7)
      return;
    app.f7.off("menuOpened", onOpened);
    app.f7.off("menuClosed", onClosed);
  });
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(5, el);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(5, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("iconOnly" in $$new_props)
      $$invalidate(12, iconOnly = $$new_props.iconOnly);
    if ("href" in $$new_props)
      $$invalidate(13, href = $$new_props.href);
    if ("link" in $$new_props)
      $$invalidate(14, link = $$new_props.link);
    if ("target" in $$new_props)
      $$invalidate(15, target = $$new_props.target);
    if ("dropdown" in $$new_props)
      $$invalidate(16, dropdown = $$new_props.dropdown);
    if ("tooltip" in $$new_props)
      $$invalidate(1, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props)
      $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props)
      $$invalidate(3, routeProps = $$new_props.routeProps);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsAttrs,
    actionsClasses,
    classNames,
    extend,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTooltip,
    useRouteProps,
    useIcon,
    UseIcon: use_icon_default,
    emit,
    className,
    text: text2,
    iconOnly,
    href,
    link,
    target,
    dropdown,
    tooltip,
    tooltipTrigger,
    routeProps,
    el,
    onClick,
    onOpened,
    onClosed,
    isLink,
    icon,
    iconOnlyComputed,
    classes,
    hasTextSlots,
    hasDefaultSlots,
    hrefComputed,
    attrs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("iconOnly" in $$props)
      $$invalidate(12, iconOnly = $$new_props.iconOnly);
    if ("href" in $$props)
      $$invalidate(13, href = $$new_props.href);
    if ("link" in $$props)
      $$invalidate(14, link = $$new_props.link);
    if ("target" in $$props)
      $$invalidate(15, target = $$new_props.target);
    if ("dropdown" in $$props)
      $$invalidate(16, dropdown = $$new_props.dropdown);
    if ("tooltip" in $$props)
      $$invalidate(1, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$props)
      $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$props)
      $$invalidate(3, routeProps = $$new_props.routeProps);
    if ("el" in $$props)
      $$invalidate(5, el = $$new_props.el);
    if ("isLink" in $$props)
      $$invalidate(6, isLink = $$new_props.isLink);
    if ("icon" in $$props)
      $$invalidate(7, icon = $$new_props.icon);
    if ("iconOnlyComputed" in $$props)
      $$invalidate(17, iconOnlyComputed = $$new_props.iconOnlyComputed);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
    if ("hasTextSlots" in $$props)
      $$invalidate(4, hasTextSlots = $$new_props.hasTextSlots);
    if ("hasDefaultSlots" in $$props)
      hasDefaultSlots = $$new_props.hasDefaultSlots;
    if ("hrefComputed" in $$props)
      $$invalidate(18, hrefComputed = $$new_props.hrefComputed);
    if ("attrs" in $$props)
      $$invalidate(9, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href, link*/
    24576) {
      $:
        $$invalidate(18, hrefComputed = typeof href === "undefined" && link ? "#" : href);
    }
    $:
      $$invalidate(9, attrs = extend(
        {
          href: hrefComputed,
          target,
          ...restProps($$restProps)
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    if ($$self.$$.dirty & /*iconOnly, text, hasTextSlots*/
    4113) {
      $:
        $$invalidate(17, iconOnlyComputed = iconOnly || !text2 && !hasTextSlots);
    }
    $:
      $$invalidate(8, classes = classNames(
        {
          "menu-item": true,
          "menu-item-dropdown": dropdown || dropdown === "",
          "icon-only": iconOnlyComputed
        },
        className,
        colorClasses($$props),
        routerClasses($$props),
        actionsClasses($$props)
      ));
    $:
      $$invalidate(7, icon = useIcon($$props));
    if ($$self.$$.dirty & /*link, href*/
    24576) {
      $:
        $$invalidate(6, isLink = link || href || href === "");
    }
  };
  $:
    hasDefaultSlots = $$slots.default;
  $:
    $$invalidate(4, hasTextSlots = $$slots.text);
  $$props = exclude_internal_props($$props);
  return [
    text2,
    tooltip,
    tooltipTrigger,
    routeProps,
    hasTextSlots,
    el,
    isLink,
    icon,
    classes,
    attrs,
    onClick,
    className,
    iconOnly,
    href,
    link,
    target,
    dropdown,
    iconOnlyComputed,
    hrefComputed,
    $$scope,
    slots,
    a_binding,
    div_binding
  ];
}
var Menu_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment62, safe_not_equal, {
      class: 11,
      text: 0,
      iconOnly: 12,
      href: 13,
      link: 14,
      target: 15,
      dropdown: 16,
      tooltip: 1,
      tooltipTrigger: 2,
      routeProps: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu_item",
      options,
      id: create_fragment62.name
    });
  }
  get class() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconOnly() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconOnly(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdown() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdown(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipTrigger() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipTrigger(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routeProps() {
    throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routeProps(value) {
    throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var menu_item_default = Menu_item;

// node_modules/framework7-svelte/components/menu.svelte
var file60 = "node_modules/framework7-svelte/components/menu.svelte";
function create_fragment63(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div1_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "menu-inner");
      add_location(div0, file60, 12, 2, 365);
      set_attributes(div1, div1_data);
      add_location(div1, file60, 11, 0, 313);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "menu", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment63, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment63.name
    });
  }
  get class() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var menu_default = Menu;

// node_modules/framework7-svelte/components/message.svelte
var file61 = "node_modules/framework7-svelte/components/message.svelte";
var get_end_slot_changes = (dirty) => ({});
var get_end_slot_context = (ctx) => ({});
var get_content_end_slot_changes3 = (dirty) => ({});
var get_content_end_slot_context3 = (ctx) => ({});
var get_footer_slot_changes3 = (dirty) => ({});
var get_footer_slot_context3 = (ctx) => ({});
var get_bubble_end_slot_changes = (dirty) => ({});
var get_bubble_end_slot_context = (ctx) => ({});
var get_text_footer_slot_changes = (dirty) => ({});
var get_text_footer_slot_context = (ctx) => ({});
var get_text_slot_changes5 = (dirty) => ({});
var get_text_slot_context5 = (ctx) => ({});
var get_text_header_slot_changes = (dirty) => ({});
var get_text_header_slot_context = (ctx) => ({});
var get_image_slot_changes = (dirty) => ({});
var get_image_slot_context = (ctx) => ({});
var get_bubble_start_slot_changes = (dirty) => ({});
var get_bubble_start_slot_context = (ctx) => ({});
var get_header_slot_changes3 = (dirty) => ({});
var get_header_slot_context3 = (ctx) => ({});
var get_name_slot_changes = (dirty) => ({});
var get_name_slot_context = (ctx) => ({});
var get_content_start_slot_changes3 = (dirty) => ({});
var get_content_start_slot_context3 = (ctx) => ({});
var get_avatar_slot_changes = (dirty) => ({});
var get_avatar_slot_context = (ctx) => ({});
var get_start_slot_changes = (dirty) => ({});
var get_start_slot_context = (ctx) => ({});
function create_if_block_1011(ctx) {
  let div;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const avatar_slot_template = (
    /*#slots*/
    ctx[37].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_avatar_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (avatar_slot)
        avatar_slot.c();
      attr_dev(div, "class", "message-avatar");
      attr_dev(div, "style", div_style_value = /*avatar*/
      ctx[3] ? `background-image: url(${/*avatar*/
      ctx[3]})` : void 0);
      add_location(div, file61, 91, 4, 2382);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (avatar_slot) {
        avatar_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onAvatarClick*/
          ctx[22],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_avatar_slot_changes
            ),
            get_avatar_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*avatar*/
      8 && div_style_value !== (div_style_value = /*avatar*/
      ctx2[3] ? `background-image: url(${/*avatar*/
      ctx2[3]})` : void 0)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(avatar_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(avatar_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (avatar_slot)
        avatar_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1011.name,
    type: "if",
    source: "(91:2) {#if avatar || hasAvatarSlots}",
    ctx
  });
  return block;
}
function create_if_block_911(ctx) {
  let div;
  let t0_value = plainText(
    /*name*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const name_slot_template = (
    /*#slots*/
    ctx[37].name
  );
  const name_slot = create_slot(
    name_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_name_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (name_slot)
        name_slot.c();
      attr_dev(div, "class", "message-name");
      add_location(div, file61, 102, 6, 2674);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (name_slot) {
        name_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onNameClick*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*name*/
      4) && t0_value !== (t0_value = plainText(
        /*name*/
        ctx2[2]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (name_slot) {
        if (name_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            name_slot,
            name_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              name_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_name_slot_changes
            ),
            get_name_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(name_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(name_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (name_slot)
        name_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_911.name,
    type: "if",
    source: "(102:4) {#if hasNameSlots || name}",
    ctx
  });
  return block;
}
function create_if_block_811(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[37].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_header_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot)
        header_slot.c();
      attr_dev(div, "class", "message-header");
      add_location(div, file61, 108, 6, 2843);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onHeaderClick*/
          ctx[23],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_header_slot_changes3
            ),
            get_header_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (header_slot)
        header_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_811.name,
    type: "if",
    source: "(108:4) {#if hasHeaderSlots || header}",
    ctx
  });
  return block;
}
function create_if_block_611(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*image*/
    ctx[4] && create_if_block_711(ctx)
  );
  const image_slot_template = (
    /*#slots*/
    ctx[37].image
  );
  const image_slot = create_slot(
    image_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_image_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (image_slot)
        image_slot.c();
      attr_dev(div, "class", "message-image");
      add_location(div, file61, 116, 8, 3115);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (image_slot) {
        image_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*image*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_711(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (image_slot) {
        if (image_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            image_slot,
            image_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              image_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_image_slot_changes
            ),
            get_image_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(image_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (image_slot)
        image_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_611.name,
    type: "if",
    source: "(116:6) {#if hasImageSlots || image}",
    ctx
  });
  return block;
}
function create_if_block_711(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*image*/
      ctx[4]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file61, 118, 12, 3177);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*image*/
      16 && !src_url_equal(img.src, img_src_value = /*image*/
      ctx2[4])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_711.name,
    type: "if",
    source: "(118:10) {#if image}",
    ctx
  });
  return block;
}
function create_if_block_510(ctx) {
  let div;
  let t0_value = plainText(
    /*textHeader*/
    ctx[7]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_header_slot_template = (
    /*#slots*/
    ctx[37]["text-header"]
  );
  const text_header_slot = create_slot(
    text_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_text_header_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_header_slot)
        text_header_slot.c();
      attr_dev(div, "class", "message-text-header");
      add_location(div, file61, 124, 8, 3325);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_header_slot) {
        text_header_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*textHeader*/
      128) && t0_value !== (t0_value = plainText(
        /*textHeader*/
        ctx2[7]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_header_slot) {
        if (text_header_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            text_header_slot,
            text_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              text_header_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_text_header_slot_changes
            ),
            get_text_header_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_header_slot)
        text_header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_510.name,
    type: "if",
    source: "(124:6) {#if hasTextHeaderSlots || textHeader}",
    ctx
  });
  return block;
}
function create_if_block_216(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*htmlText*/
    ctx[1] && create_if_block_411(ctx)
  );
  const text_slot_template = (
    /*#slots*/
    ctx[37].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_text_slot_context5
  );
  let if_block1 = (
    /*typing*/
    ctx[9] && create_if_block_312(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (text_slot)
        text_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", "message-text");
      add_location(div, file61, 130, 8, 3521);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t2);
      if (text_slot) {
        text_slot.m(div, null);
      }
      append_dev(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onTextClick*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (
        /*htmlText*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_411(ctx2);
          if_block0.c();
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (text_slot) {
        if (text_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_text_slot_changes5
            ),
            get_text_slot_context5
          );
        }
      }
      if (
        /*typing*/
        ctx2[9]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_312(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (text_slot)
        text_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_216.name,
    type: "if",
    source: "(130:6) {#if hasTextSlots || text || htmlText || typing}",
    ctx
  });
  return block;
}
function create_if_block_411(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*htmlText*/
        ctx[1],
        target,
        anchor
      );
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*htmlText*/
      2)
        html_tag.p(
          /*htmlText*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_411.name,
    type: "if",
    source: "(133:10) {#if htmlText}",
    ctx
  });
  return block;
}
function create_if_block_312(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      add_location(div0, file61, 136, 14, 3764);
      add_location(div1, file61, 137, 14, 3786);
      add_location(div2, file61, 138, 14, 3808);
      attr_dev(div3, "class", "message-typing-indicator");
      add_location(div3, file61, 135, 12, 3711);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div0);
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div3, t1);
      append_dev(div3, div2);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_312.name,
    type: "if",
    source: "(135:10) {#if typing}",
    ctx
  });
  return block;
}
function create_if_block_135(ctx) {
  let div;
  let t0_value = plainText(
    /*textFooter*/
    ctx[8]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_footer_slot_template = (
    /*#slots*/
    ctx[37]["text-footer"]
  );
  const text_footer_slot = create_slot(
    text_footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_text_footer_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_footer_slot)
        text_footer_slot.c();
      attr_dev(div, "class", "message-text-footer");
      add_location(div, file61, 144, 8, 3931);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (text_footer_slot) {
        text_footer_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*textFooter*/
      256) && t0_value !== (t0_value = plainText(
        /*textFooter*/
        ctx2[8]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (text_footer_slot) {
        if (text_footer_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            text_footer_slot,
            text_footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              text_footer_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_text_footer_slot_changes
            ),
            get_text_footer_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (text_footer_slot)
        text_footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_135.name,
    type: "if",
    source: "(144:6) {#if hasTextFooterSlots || textFooter}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const footer_slot_template = (
    /*#slots*/
    ctx[37].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_footer_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      attr_dev(div, "class", "message-footer");
      add_location(div, file61, 153, 6, 4164);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onFooterClick*/
          ctx[24],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_footer_slot_changes3
            ),
            get_footer_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (footer_slot)
        footer_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(153:4) {#if hasFooterSlots || footer}",
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let div2;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let div0;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let t12;
  let t13;
  let current;
  let mounted;
  let dispose;
  const start_slot_template = (
    /*#slots*/
    ctx[37].start
  );
  const start_slot = create_slot(
    start_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_start_slot_context
  );
  let if_block0 = (
    /*avatar*/
    (ctx[3] || /*hasAvatarSlots*/
    ctx[17]) && create_if_block_1011(ctx)
  );
  const content_start_slot_template = (
    /*#slots*/
    ctx[37]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_content_start_slot_context3
  );
  let if_block1 = (
    /*hasNameSlots*/
    (ctx[16] || /*name*/
    ctx[2]) && create_if_block_911(ctx)
  );
  let if_block2 = (
    /*hasHeaderSlots*/
    (ctx[15] || /*header*/
    ctx[5]) && create_if_block_811(ctx)
  );
  const bubble_start_slot_template = (
    /*#slots*/
    ctx[37]["bubble-start"]
  );
  const bubble_start_slot = create_slot(
    bubble_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_bubble_start_slot_context
  );
  let if_block3 = (
    /*hasImageSlots*/
    (ctx[14] || /*image*/
    ctx[4]) && create_if_block_611(ctx)
  );
  let if_block4 = (
    /*hasTextHeaderSlots*/
    (ctx[13] || /*textHeader*/
    ctx[7]) && create_if_block_510(ctx)
  );
  let if_block5 = (
    /*hasTextSlots*/
    (ctx[11] || /*text*/
    ctx[0] || /*htmlText*/
    ctx[1] || /*typing*/
    ctx[9]) && create_if_block_216(ctx)
  );
  let if_block6 = (
    /*hasTextFooterSlots*/
    (ctx[12] || /*textFooter*/
    ctx[8]) && create_if_block_135(ctx)
  );
  const bubble_end_slot_template = (
    /*#slots*/
    ctx[37]["bubble-end"]
  );
  const bubble_end_slot = create_slot(
    bubble_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_bubble_end_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  let if_block7 = (
    /*hasFooterSlots*/
    (ctx[10] || /*footer*/
    ctx[6]) && create_if_block23(ctx)
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[37]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_content_end_slot_context3
  );
  const end_slot_template = (
    /*#slots*/
    ctx[37].end
  );
  const end_slot = create_slot(
    end_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_end_slot_context
  );
  let div2_levels = [{ class: (
    /*classes*/
    ctx[18]
  ) }, restProps(
    /*$$restProps*/
    ctx[26]
  )];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (start_slot)
        start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      div0 = element("div");
      if (bubble_start_slot)
        bubble_start_slot.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      if (if_block4)
        if_block4.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      t9 = space();
      if (bubble_end_slot)
        bubble_end_slot.c();
      t10 = space();
      if (default_slot)
        default_slot.c();
      t11 = space();
      if (if_block7)
        if_block7.c();
      t12 = space();
      if (content_end_slot)
        content_end_slot.c();
      t13 = space();
      if (end_slot)
        end_slot.c();
      attr_dev(div0, "class", "message-bubble");
      add_location(div0, file61, 113, 4, 2983);
      attr_dev(div1, "class", "message-content");
      add_location(div1, file61, 99, 2, 2573);
      set_attributes(div2, div2_data);
      add_location(div2, file61, 88, 0, 2252);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (start_slot) {
        start_slot.m(div2, null);
      }
      append_dev(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t4);
      append_dev(div1, div0);
      if (bubble_start_slot) {
        bubble_start_slot.m(div0, null);
      }
      append_dev(div0, t5);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t6);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div0, t7);
      if (if_block5)
        if_block5.m(div0, null);
      append_dev(div0, t8);
      if (if_block6)
        if_block6.m(div0, null);
      append_dev(div0, t9);
      if (bubble_end_slot) {
        bubble_end_slot.m(div0, null);
      }
      append_dev(div0, t10);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_dev(div1, t11);
      if (if_block7)
        if_block7.m(div1, null);
      append_dev(div1, t12);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      append_dev(div2, t13);
      if (end_slot) {
        end_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "click",
            /*onBubbleClick*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*onClick*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (start_slot) {
        if (start_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            start_slot,
            start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              start_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_start_slot_changes
            ),
            get_start_slot_context
          );
        }
      }
      if (
        /*avatar*/
        ctx2[3] || /*hasAvatarSlots*/
        ctx2[17]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*avatar, hasAvatarSlots*/
          131080) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1011(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_content_start_slot_changes3
            ),
            get_content_start_slot_context3
          );
        }
      }
      if (
        /*hasNameSlots*/
        ctx2[16] || /*name*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasNameSlots, name*/
          65540) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_911(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*hasHeaderSlots*/
        ctx2[15] || /*header*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasHeaderSlots, header*/
          32800) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_811(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (bubble_start_slot) {
        if (bubble_start_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            bubble_start_slot,
            bubble_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              bubble_start_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_bubble_start_slot_changes
            ),
            get_bubble_start_slot_context
          );
        }
      }
      if (
        /*hasImageSlots*/
        ctx2[14] || /*image*/
        ctx2[4]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*hasImageSlots, image*/
          16400) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_611(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasTextHeaderSlots*/
        ctx2[13] || /*textHeader*/
        ctx2[7]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*hasTextHeaderSlots, textHeader*/
          8320) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_510(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, t7);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*hasTextSlots*/
        ctx2[11] || /*text*/
        ctx2[0] || /*htmlText*/
        ctx2[1] || /*typing*/
        ctx2[9]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*hasTextSlots, text, htmlText, typing*/
          2563) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_216(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div0, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasTextFooterSlots*/
        ctx2[12] || /*textFooter*/
        ctx2[8]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*hasTextFooterSlots, textFooter*/
          4352) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_135(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div0, t9);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (bubble_end_slot) {
        if (bubble_end_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            bubble_end_slot,
            bubble_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              bubble_end_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_bubble_end_slot_changes
            ),
            get_bubble_end_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*hasFooterSlots*/
        ctx2[10] || /*footer*/
        ctx2[6]
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & /*hasFooterSlots, footer*/
          1088) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block23(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div1, t12);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_content_end_slot_changes3
            ),
            get_content_end_slot_context3
          );
        }
      }
      if (end_slot) {
        if (end_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            end_slot,
            end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              end_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_end_slot_changes
            ),
            get_end_slot_context
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*classes*/
        262144) && { class: (
          /*classes*/
          ctx2[18]
        ) },
        dirty[0] & /*$$restProps*/
        67108864 && restProps(
          /*$$restProps*/
          ctx2[26]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(start_slot, local);
      transition_in(if_block0);
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(bubble_start_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(bubble_end_slot, local);
      transition_in(default_slot, local);
      transition_in(if_block7);
      transition_in(content_end_slot, local);
      transition_in(end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(start_slot, local);
      transition_out(if_block0);
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(bubble_start_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(bubble_end_slot, local);
      transition_out(default_slot, local);
      transition_out(if_block7);
      transition_out(content_end_slot, local);
      transition_out(end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (start_slot)
        start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (bubble_start_slot)
        bubble_start_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (bubble_end_slot)
        bubble_end_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block7)
        if_block7.d();
      if (content_end_slot)
        content_end_slot.d(detaching);
      if (end_slot)
        end_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let classes;
  let hasAvatarSlots;
  let hasNameSlots;
  let hasHeaderSlots;
  let hasImageSlots;
  let hasTextHeaderSlots;
  let hasTextFooterSlots;
  let hasTextSlots;
  let hasFooterSlots;
  const omit_props_names = [
    "class",
    "text",
    "htmlText",
    "name",
    "avatar",
    "type",
    "image",
    "header",
    "footer",
    "textHeader",
    "textFooter",
    "first",
    "last",
    "tail",
    "sameName",
    "sameHeader",
    "sameFooter",
    "sameAvatar",
    "typing"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Message", slots, [
    "start",
    "avatar",
    "content-start",
    "name",
    "header",
    "bubble-start",
    "image",
    "text-header",
    "text",
    "text-footer",
    "bubble-end",
    "default",
    "footer",
    "content-end",
    "end"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { htmlText = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { avatar = void 0 } = $$props;
  let { type = "sent" } = $$props;
  let { image = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { footer = void 0 } = $$props;
  let { textHeader = void 0 } = $$props;
  let { textFooter = void 0 } = $$props;
  let { first = void 0 } = $$props;
  let { last = void 0 } = $$props;
  let { tail = void 0 } = $$props;
  let { sameName = void 0 } = $$props;
  let { sameHeader = void 0 } = $$props;
  let { sameFooter = void 0 } = $$props;
  let { sameAvatar = void 0 } = $$props;
  let { typing = void 0 } = $$props;
  function onClick() {
    emit("click");
  }
  function onNameClick() {
    emit("clickName");
  }
  function onTextClick() {
    emit("clickText");
  }
  function onAvatarClick() {
    emit("clickAvatar");
  }
  function onHeaderClick() {
    emit("clickHeader");
  }
  function onFooterClick() {
    emit("clickFooter");
  }
  function onBubbleClick() {
    emit("clickBubble");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(27, className = $$new_props.class);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("htmlText" in $$new_props)
      $$invalidate(1, htmlText = $$new_props.htmlText);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("avatar" in $$new_props)
      $$invalidate(3, avatar = $$new_props.avatar);
    if ("type" in $$new_props)
      $$invalidate(28, type = $$new_props.type);
    if ("image" in $$new_props)
      $$invalidate(4, image = $$new_props.image);
    if ("header" in $$new_props)
      $$invalidate(5, header = $$new_props.header);
    if ("footer" in $$new_props)
      $$invalidate(6, footer = $$new_props.footer);
    if ("textHeader" in $$new_props)
      $$invalidate(7, textHeader = $$new_props.textHeader);
    if ("textFooter" in $$new_props)
      $$invalidate(8, textFooter = $$new_props.textFooter);
    if ("first" in $$new_props)
      $$invalidate(29, first = $$new_props.first);
    if ("last" in $$new_props)
      $$invalidate(30, last = $$new_props.last);
    if ("tail" in $$new_props)
      $$invalidate(31, tail = $$new_props.tail);
    if ("sameName" in $$new_props)
      $$invalidate(32, sameName = $$new_props.sameName);
    if ("sameHeader" in $$new_props)
      $$invalidate(33, sameHeader = $$new_props.sameHeader);
    if ("sameFooter" in $$new_props)
      $$invalidate(34, sameFooter = $$new_props.sameFooter);
    if ("sameAvatar" in $$new_props)
      $$invalidate(35, sameAvatar = $$new_props.sameAvatar);
    if ("typing" in $$new_props)
      $$invalidate(9, typing = $$new_props.typing);
    if ("$$scope" in $$new_props)
      $$invalidate(36, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    emit,
    className,
    text: text2,
    htmlText,
    name,
    avatar,
    type,
    image,
    header,
    footer,
    textHeader,
    textFooter,
    first,
    last,
    tail,
    sameName,
    sameHeader,
    sameFooter,
    sameAvatar,
    typing,
    onClick,
    onNameClick,
    onTextClick,
    onAvatarClick,
    onHeaderClick,
    onFooterClick,
    onBubbleClick,
    hasFooterSlots,
    hasTextSlots,
    hasTextFooterSlots,
    hasTextHeaderSlots,
    hasImageSlots,
    hasHeaderSlots,
    hasNameSlots,
    hasAvatarSlots,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(27, className = $$new_props.className);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("htmlText" in $$props)
      $$invalidate(1, htmlText = $$new_props.htmlText);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("avatar" in $$props)
      $$invalidate(3, avatar = $$new_props.avatar);
    if ("type" in $$props)
      $$invalidate(28, type = $$new_props.type);
    if ("image" in $$props)
      $$invalidate(4, image = $$new_props.image);
    if ("header" in $$props)
      $$invalidate(5, header = $$new_props.header);
    if ("footer" in $$props)
      $$invalidate(6, footer = $$new_props.footer);
    if ("textHeader" in $$props)
      $$invalidate(7, textHeader = $$new_props.textHeader);
    if ("textFooter" in $$props)
      $$invalidate(8, textFooter = $$new_props.textFooter);
    if ("first" in $$props)
      $$invalidate(29, first = $$new_props.first);
    if ("last" in $$props)
      $$invalidate(30, last = $$new_props.last);
    if ("tail" in $$props)
      $$invalidate(31, tail = $$new_props.tail);
    if ("sameName" in $$props)
      $$invalidate(32, sameName = $$new_props.sameName);
    if ("sameHeader" in $$props)
      $$invalidate(33, sameHeader = $$new_props.sameHeader);
    if ("sameFooter" in $$props)
      $$invalidate(34, sameFooter = $$new_props.sameFooter);
    if ("sameAvatar" in $$props)
      $$invalidate(35, sameAvatar = $$new_props.sameAvatar);
    if ("typing" in $$props)
      $$invalidate(9, typing = $$new_props.typing);
    if ("hasFooterSlots" in $$props)
      $$invalidate(10, hasFooterSlots = $$new_props.hasFooterSlots);
    if ("hasTextSlots" in $$props)
      $$invalidate(11, hasTextSlots = $$new_props.hasTextSlots);
    if ("hasTextFooterSlots" in $$props)
      $$invalidate(12, hasTextFooterSlots = $$new_props.hasTextFooterSlots);
    if ("hasTextHeaderSlots" in $$props)
      $$invalidate(13, hasTextHeaderSlots = $$new_props.hasTextHeaderSlots);
    if ("hasImageSlots" in $$props)
      $$invalidate(14, hasImageSlots = $$new_props.hasImageSlots);
    if ("hasHeaderSlots" in $$props)
      $$invalidate(15, hasHeaderSlots = $$new_props.hasHeaderSlots);
    if ("hasNameSlots" in $$props)
      $$invalidate(16, hasNameSlots = $$new_props.hasNameSlots);
    if ("hasAvatarSlots" in $$props)
      $$invalidate(17, hasAvatarSlots = $$new_props.hasAvatarSlots);
    if ("classes" in $$props)
      $$invalidate(18, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(18, classes = classNames(
        className,
        "message",
        {
          "message-sent": type === "sent" || !type,
          "message-received": type === "received",
          "message-typing": typing,
          "message-first": first,
          "message-last": last,
          "message-tail": tail,
          "message-same-name": sameName,
          "message-same-header": sameHeader,
          "message-same-footer": sameFooter,
          "message-same-avatar": sameAvatar
        },
        colorClasses($$props)
      ));
  };
  $:
    $$invalidate(17, hasAvatarSlots = $$slots.avatar);
  $:
    $$invalidate(16, hasNameSlots = $$slots.name);
  $:
    $$invalidate(15, hasHeaderSlots = $$slots.header);
  $:
    $$invalidate(14, hasImageSlots = $$slots.image);
  $:
    $$invalidate(13, hasTextHeaderSlots = $$slots["text-header"]);
  $:
    $$invalidate(12, hasTextFooterSlots = $$slots["text-footer"]);
  $:
    $$invalidate(11, hasTextSlots = $$slots.text);
  $:
    $$invalidate(10, hasFooterSlots = $$slots.footer);
  $$props = exclude_internal_props($$props);
  return [
    text2,
    htmlText,
    name,
    avatar,
    image,
    header,
    footer,
    textHeader,
    textFooter,
    typing,
    hasFooterSlots,
    hasTextSlots,
    hasTextFooterSlots,
    hasTextHeaderSlots,
    hasImageSlots,
    hasHeaderSlots,
    hasNameSlots,
    hasAvatarSlots,
    classes,
    onClick,
    onNameClick,
    onTextClick,
    onAvatarClick,
    onHeaderClick,
    onFooterClick,
    onBubbleClick,
    $$restProps,
    className,
    type,
    first,
    last,
    tail,
    sameName,
    sameHeader,
    sameFooter,
    sameAvatar,
    $$scope,
    slots
  ];
}
var Message = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance53,
      create_fragment64,
      safe_not_equal,
      {
        class: 27,
        text: 0,
        htmlText: 1,
        name: 2,
        avatar: 3,
        type: 28,
        image: 4,
        header: 5,
        footer: 6,
        textHeader: 7,
        textFooter: 8,
        first: 29,
        last: 30,
        tail: 31,
        sameName: 32,
        sameHeader: 33,
        sameFooter: 34,
        sameAvatar: 35,
        typing: 9
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Message",
      options,
      id: create_fragment64.name
    });
  }
  get class() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get htmlText() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set htmlText(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avatar() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avatar(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get image() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set image(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textHeader() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textHeader(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textFooter() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textFooter(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tail() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tail(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameName() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameName(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameHeader() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameHeader(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameFooter() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameFooter(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameAvatar() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameAvatar(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get typing() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set typing(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var message_default = Message;

// node_modules/framework7-svelte/components/messagebar-attachment.svelte
var file62 = "node_modules/framework7-svelte/components/messagebar-attachment.svelte";
function create_if_block_136(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*image*/
      ctx[0]))
        attr_dev(img, "src", img_src_value);
      add_location(img, file62, 28, 4, 804);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*image*/
      1 && !src_url_equal(img.src, img_src_value = /*image*/
      ctx2[0])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_136.name,
    type: "if",
    source: "(28:2) {#if image}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let span;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "messagebar-attachment-delete");
      add_location(span, file62, 31, 4, 854);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onDeleteClick*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(31:2) {#if deletable}",
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*image*/
    ctx[0] && create_if_block_136(ctx)
  );
  let if_block1 = (
    /*deletable*/
    ctx[1] && create_if_block24(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[5]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file62, 26, 0, 717);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onClick*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*image*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_136(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*deletable*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "image", "deletable"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar_attachment", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { image = void 0 } = $$props;
  let { deletable = true } = $$props;
  function onClick(event) {
    emit("attachmentClick", [event]);
  }
  function onDeleteClick(event) {
    emit("attachmentDelete", [event]);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("image" in $$new_props)
      $$invalidate(0, image = $$new_props.image);
    if ("deletable" in $$new_props)
      $$invalidate(1, deletable = $$new_props.deletable);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    emit,
    className,
    image,
    deletable,
    onClick,
    onDeleteClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("image" in $$props)
      $$invalidate(0, image = $$new_props.image);
    if ("deletable" in $$props)
      $$invalidate(1, deletable = $$new_props.deletable);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "messagebar-attachment", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    image,
    deletable,
    classes,
    onClick,
    onDeleteClick,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var Messagebar_attachment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment65, safe_not_equal, { class: 6, image: 0, deletable: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar_attachment",
      options,
      id: create_fragment65.name
    });
  }
  get class() {
    throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get image() {
    throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set image(value) {
    throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deletable() {
    throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deletable(value) {
    throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_attachment_default = Messagebar_attachment;

// node_modules/framework7-svelte/components/messagebar-attachments.svelte
var file63 = "node_modules/framework7-svelte/components/messagebar-attachments.svelte";
function create_fragment66(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file63, 11, 0, 331);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar_attachments", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "messagebar-attachments", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Messagebar_attachments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment66, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar_attachments",
      options,
      id: create_fragment66.name
    });
  }
  get class() {
    throw new Error("<Messagebar_attachments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar_attachments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_attachments_default = Messagebar_attachments;

// node_modules/framework7-svelte/components/messagebar-sheet-image.svelte
var file64 = "node_modules/framework7-svelte/components/messagebar-sheet-image.svelte";
function create_fragment67(ctx) {
  let label;
  let input;
  let t0;
  let i;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let label_levels = [
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { style: (
      /*styles*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign(label_data, label_levels[i2]);
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t0 = space();
      i = element("i");
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "checkbox");
      input.checked = /*checked*/
      ctx[0];
      add_location(input, file64, 29, 2, 911);
      attr_dev(i, "class", "icon icon-checkbox");
      add_location(i, file64, 30, 2, 970);
      set_attributes(label, label_data);
      add_location(label, file64, 28, 0, 842);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, input);
      append_dev(label, t0);
      append_dev(label, i);
      append_dev(label, t1);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*onChange*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*styles*/
        2) && { style: (
          /*styles*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let classes;
  let styles;
  const omit_props_names = ["style", "class", "image", "checked"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar_sheet_image", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let { image = void 0 } = $$props;
  let { checked = false } = $$props;
  function onChange(event) {
    if (event.target.checked)
      emit("checked", [event]);
    else
      emit("unchecked", [event]);
    emit("change", [event]);
    $$invalidate(0, checked = event.target.checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(5, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("image" in $$new_props)
      $$invalidate(7, image = $$new_props.image);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    emit,
    style,
    className,
    image,
    checked,
    onChange,
    styles,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("image" in $$props)
      $$invalidate(7, image = $$new_props.image);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("styles" in $$props)
      $$invalidate(1, styles = $$new_props.styles);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "messagebar-sheet-image", "checkbox", colorClasses($$props)));
    if ($$self.$$.dirty & /*image, style*/
    160) {
      $:
        $$invalidate(1, styles = `${image ? `background-image: url(${image});` : ""}${style || ""}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    styles,
    classes,
    onChange,
    $$restProps,
    style,
    className,
    image,
    $$scope,
    slots
  ];
}
var Messagebar_sheet_image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment67, safe_not_equal, { style: 5, class: 6, image: 7, checked: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar_sheet_image",
      options,
      id: create_fragment67.name
    });
  }
  get style() {
    throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get image() {
    throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set image(value) {
    throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_sheet_image_default = Messagebar_sheet_image;

// node_modules/framework7-svelte/components/messagebar-sheet-item.svelte
var file65 = "node_modules/framework7-svelte/components/messagebar-sheet-item.svelte";
function create_fragment68(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file65, 11, 0, 330);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar_sheet_item", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "messagebar-sheet-item", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Messagebar_sheet_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment68, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar_sheet_item",
      options,
      id: create_fragment68.name
    });
  }
  get class() {
    throw new Error("<Messagebar_sheet_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar_sheet_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_sheet_item_default = Messagebar_sheet_item;

// node_modules/framework7-svelte/components/messagebar-sheet.svelte
var file66 = "node_modules/framework7-svelte/components/messagebar-sheet.svelte";
function create_fragment69(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file66, 11, 0, 325);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar_sheet", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "messagebar-sheet", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Messagebar_sheet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment69, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar_sheet",
      options,
      id: create_fragment69.name
    });
  }
  get class() {
    throw new Error("<Messagebar_sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar_sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_sheet_default = Messagebar_sheet;

// node_modules/framework7-svelte/components/messagebar.svelte
var file67 = "node_modules/framework7-svelte/components/messagebar.svelte";
var get_after_inner_slot_changes_1 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_after_inner_slot_context_1 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_default_slot_changes11 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_default_slot_context11 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_inner_end_slot_changes3 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_inner_end_slot_context3 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_send_link_slot_changes = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_send_link_slot_context = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_after_inner_slot_changes2 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_after_inner_slot_context2 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_before_area_slot_changes = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_before_area_slot_context = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_inner_start_slot_changes3 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_inner_start_slot_context3 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
var get_before_inner_slot_changes2 = (dirty) => ({
  messagebar: dirty[0] & /*f7Messagebar*/
  1024
});
var get_before_inner_slot_context2 = (ctx) => ({ messagebar: (
  /*f7Messagebar*/
  ctx[10]
) });
function create_if_block25(ctx) {
  let link;
  let current;
  link = new link_default({
    props: {
      onClick: (
        /*onClick*/
        ctx[17]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const link_changes = {};
      if (dirty[0] & /*sendLink, f7Messagebar*/
      1028 | dirty[1] & /*$$scope*/
      1) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(204:4) {#if (sendLink && sendLink.length > 0) || hasSendLinkSlots}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let t0;
  let t1;
  let current;
  const send_link_slot_template = (
    /*#slots*/
    ctx[29]["send-link"]
  );
  const send_link_slot = create_slot(
    send_link_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_send_link_slot_context
  );
  const block = {
    c: function create() {
      if (send_link_slot)
        send_link_slot.c();
      t0 = space();
      t1 = text(
        /*sendLink*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      if (send_link_slot) {
        send_link_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (send_link_slot) {
        if (send_link_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            send_link_slot,
            send_link_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              send_link_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_send_link_slot_changes
            ),
            get_send_link_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*sendLink*/
      4)
        set_data_dev(
          t1,
          /*sendLink*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(send_link_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(send_link_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (send_link_slot)
        send_link_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(205:6) <Link {onClick}>",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let input;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let current;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[29]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_before_inner_slot_context2
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[29]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_inner_start_slot_context3
  );
  const before_area_slot_template = (
    /*#slots*/
    ctx[29]["before-area"]
  );
  const before_area_slot = create_slot(
    before_area_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_before_area_slot_context
  );
  input = new input_default({
    props: {
      id: (
        /*textareaId*/
        ctx[5]
      ),
      type: "textarea",
      wrap: false,
      placeholder: (
        /*placeholder*/
        ctx[7]
      ),
      disabled: (
        /*disabled*/
        ctx[3]
      ),
      name: (
        /*name*/
        ctx[6]
      ),
      readonly: (
        /*readonly*/
        ctx[4]
      ),
      resizable: (
        /*resizable*/
        ctx[1]
      ),
      value: typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      )
    },
    $$inline: true
  });
  input.$on(
    "input",
    /*onInput*/
    ctx[14]
  );
  input.$on(
    "change",
    /*onChange*/
    ctx[13]
  );
  input.$on(
    "focus",
    /*onFocus*/
    ctx[15]
  );
  input.$on(
    "blur",
    /*onBlur*/
    ctx[16]
  );
  const after_inner_slot_template = (
    /*#slots*/
    ctx[29]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_after_inner_slot_context2
  );
  let if_block = (
    /*sendLink*/
    (ctx[2] && /*sendLink*/
    ctx[2].length > 0 || /*hasSendLinkSlots*/
    ctx[11]) && create_if_block25(ctx)
  );
  const inner_end_slot_template = (
    /*#slots*/
    ctx[29]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_inner_end_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    get_default_slot_context11
  );
  const after_inner_slot_template_1 = (
    /*#slots*/
    ctx[29]["after-inner"]
  );
  const after_inner_slot_1 = create_slot(
    after_inner_slot_template_1,
    ctx,
    /*$$scope*/
    ctx[31],
    get_after_inner_slot_context_1
  );
  let div2_levels = [
    { class: (
      /*classes*/
      ctx[12]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[8]
    ) },
    restProps(
      /*$$restProps*/
      ctx[18]
    )
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (before_inner_slot)
        before_inner_slot.c();
      t0 = space();
      div1 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t1 = space();
      div0 = element("div");
      if (before_area_slot)
        before_area_slot.c();
      t2 = space();
      create_component(input.$$.fragment);
      t3 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t6 = space();
      if (default_slot)
        default_slot.c();
      t7 = space();
      if (after_inner_slot_1)
        after_inner_slot_1.c();
      attr_dev(div0, "class", "messagebar-area");
      add_location(div0, file67, 184, 4, 5079);
      attr_dev(div1, "class", "toolbar-inner");
      add_location(div1, file67, 182, 2, 4989);
      set_attributes(div2, div2_data);
      add_location(div2, file67, 180, 0, 4843);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (before_inner_slot) {
        before_inner_slot.m(div2, null);
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      if (inner_start_slot) {
        inner_start_slot.m(div1, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      if (before_area_slot) {
        before_area_slot.m(div0, null);
      }
      append_dev(div0, t2);
      mount_component(input, div0, null);
      append_dev(div0, t3);
      if (after_inner_slot) {
        after_inner_slot.m(div0, null);
      }
      append_dev(div1, t4);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t5);
      if (inner_end_slot) {
        inner_end_slot.m(div1, null);
      }
      append_dev(div1, t6);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div2, t7);
      if (after_inner_slot_1) {
        after_inner_slot_1.m(div2, null);
      }
      ctx[30](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_before_inner_slot_changes2
            ),
            get_before_inner_slot_context2
          );
        }
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_inner_start_slot_changes3
            ),
            get_inner_start_slot_context3
          );
        }
      }
      if (before_area_slot) {
        if (before_area_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            before_area_slot,
            before_area_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              before_area_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_before_area_slot_changes
            ),
            get_before_area_slot_context
          );
        }
      }
      const input_changes = {};
      if (dirty[0] & /*textareaId*/
      32)
        input_changes.id = /*textareaId*/
        ctx2[5];
      if (dirty[0] & /*placeholder*/
      128)
        input_changes.placeholder = /*placeholder*/
        ctx2[7];
      if (dirty[0] & /*disabled*/
      8)
        input_changes.disabled = /*disabled*/
        ctx2[3];
      if (dirty[0] & /*name*/
      64)
        input_changes.name = /*name*/
        ctx2[6];
      if (dirty[0] & /*readonly*/
      16)
        input_changes.readonly = /*readonly*/
        ctx2[4];
      if (dirty[0] & /*resizable*/
      2)
        input_changes.resizable = /*resizable*/
        ctx2[1];
      if (dirty[0] & /*value*/
      1)
        input_changes.value = typeof /*value*/
        ctx2[0] === "undefined" ? "" : (
          /*value*/
          ctx2[0]
        );
      input.$set(input_changes);
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_after_inner_slot_changes2
            ),
            get_after_inner_slot_context2
          );
        }
      }
      if (
        /*sendLink*/
        ctx2[2] && /*sendLink*/
        ctx2[2].length > 0 || /*hasSendLinkSlots*/
        ctx2[11]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*sendLink, hasSendLinkSlots*/
          2052) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t5);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_inner_end_slot_changes3
            ),
            get_inner_end_slot_context3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
      if (after_inner_slot_1) {
        if (after_inner_slot_1.p && (!current || dirty[0] & /*f7Messagebar*/
        1024 | dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            after_inner_slot_1,
            after_inner_slot_template_1,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              after_inner_slot_template_1,
              /*$$scope*/
              ctx2[31],
              dirty,
              get_after_inner_slot_changes_1
            ),
            get_after_inner_slot_context_1
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*classes*/
        4096) && { class: (
          /*classes*/
          ctx2[12]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        256) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[8]
        ) },
        dirty[0] & /*$$restProps*/
        262144 && restProps(
          /*$$restProps*/
          ctx2[18]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(inner_start_slot, local);
      transition_in(before_area_slot, local);
      transition_in(input.$$.fragment, local);
      transition_in(after_inner_slot, local);
      transition_in(if_block);
      transition_in(inner_end_slot, local);
      transition_in(default_slot, local);
      transition_in(after_inner_slot_1, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(inner_start_slot, local);
      transition_out(before_area_slot, local);
      transition_out(input.$$.fragment, local);
      transition_out(after_inner_slot, local);
      transition_out(if_block);
      transition_out(inner_end_slot, local);
      transition_out(default_slot, local);
      transition_out(after_inner_slot_1, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if (before_area_slot)
        before_area_slot.d(detaching);
      destroy_component(input);
      if (after_inner_slot)
        after_inner_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (after_inner_slot_1)
        after_inner_slot_1.d(detaching);
      ctx[30](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_112($$self, $$props, $$invalidate) {
  let classes;
  let hasSendLinkSlots;
  const omit_props_names = [
    "class",
    "sheetVisible",
    "attachmentsVisible",
    "top",
    "resizable",
    "bottomOffset",
    "topOffset",
    "maxHeight",
    "resizePage",
    "sendLink",
    "value",
    "disabled",
    "readonly",
    "textareaId",
    "name",
    "placeholder",
    "init",
    "f7Slot",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messagebar", slots, [
    "before-inner",
    "inner-start",
    "before-area",
    "after-inner",
    "send-link",
    "inner-end",
    "default"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { sheetVisible = false } = $$props;
  let { attachmentsVisible = false } = $$props;
  let { top = false } = $$props;
  let { resizable = true } = $$props;
  let { bottomOffset = 0 } = $$props;
  let { topOffset = 0 } = $$props;
  let { maxHeight = void 0 } = $$props;
  let { resizePage = true } = $$props;
  let { sendLink = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { textareaId = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { placeholder = "Message" } = $$props;
  let { init: init2 = true } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let f7Messagebar;
  let updateSheetVisible;
  let updateAttachmentsVisible;
  function instance87() {
    return f7Messagebar;
  }
  let initialWatchedSheet = false;
  function watchSheetVisible() {
    if (!initialWatchedSheet) {
      initialWatchedSheet = true;
      return;
    }
    if (!resizable || !f7Messagebar)
      return;
    updateSheetVisible = true;
  }
  let initialWatchedAttachments;
  function watchAttachmentsVisible() {
    if (!initialWatchedAttachments) {
      initialWatchedAttachments = true;
      return;
    }
    if (!resizable || !f7Messagebar)
      return;
    updateAttachmentsVisible = true;
  }
  function onChange(event) {
    emit("change", [...event.detail]);
  }
  function onInput(event) {
    emit("input", [...event.detail]);
    $$invalidate(0, value = event.detail[0].target.value);
  }
  function onFocus(event) {
    emit("focus", [...event.detail]);
  }
  function onBlur(event) {
    emit("blur", [...event.detail]);
  }
  function onClick(event) {
    const inputValue = el.querySelector("textarea");
    const clear = f7Messagebar ? () => {
      f7Messagebar.clear();
    } : () => {
    };
    emit("submit", [inputValue, clear]);
    emit("send", [inputValue, clear]);
    emit("click", [event]);
  }
  function onAttachmentDelete(inst, attachmentEl, attachmentElIndex) {
    emit("messagebarAttachmentDelete", [inst, attachmentEl, attachmentElIndex]);
  }
  function onAttachmentClick(inst, attachmentEl, attachmentElIndex) {
    emit("messagebarAttachmentClick", [inst, attachmentEl, attachmentElIndex]);
  }
  function onResizePage(inst) {
    emit("messagebarResizePage", [inst]);
  }
  onMount(() => {
    if (!init2 || !el)
      return;
    f7ready(() => {
      if (el) {
        const dom7 = app.f7.$;
        const attachmentsEl = dom7(el).find(".toolbar-inner > .messagebar-attachments");
        if (attachmentsEl.length)
          dom7(el).find(".messagebar-area").prepend(attachmentsEl);
        const sheetEl = dom7(el).find(".toolbar-inner > .messagebar-sheet");
        if (sheetEl.length)
          dom7(el).append(sheetEl);
      }
      $$invalidate(10, f7Messagebar = app.f7.messagebar.create(noUndefinedProps({
        el,
        top,
        resizePage,
        bottomOffset,
        topOffset,
        maxHeight,
        on: {
          attachmentDelete: onAttachmentDelete,
          attachmentClick: onAttachmentClick,
          resizePage: onResizePage
        }
      })));
    });
  });
  afterUpdate(() => {
    if (!f7Messagebar)
      return;
    if (el && app.f7) {
      const dom7 = app.f7.$;
      const attachmentsEl = dom7(el).find(".toolbar-inner > .messagebar-attachments");
      if (attachmentsEl.length)
        dom7(el).find(".messagebar-area").prepend(attachmentsEl);
      const sheetEl = dom7(el).find(".toolbar-inner > .messagebar-sheet");
      if (sheetEl.length)
        dom7(el).append(sheetEl);
    }
    if (updateSheetVisible) {
      updateSheetVisible = false;
      $$invalidate(10, f7Messagebar.sheetVisible = sheetVisible, f7Messagebar);
      f7Messagebar.resizePage();
    }
    if (updateAttachmentsVisible) {
      updateAttachmentsVisible = false;
      $$invalidate(10, f7Messagebar.attachmentsVisible = attachmentsVisible, f7Messagebar);
      f7Messagebar.resizePage();
    }
  });
  onDestroy(() => {
    if (f7Messagebar && f7Messagebar.destroy) {
      f7Messagebar.destroy();
      $$invalidate(10, f7Messagebar = null);
    }
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(9, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(43, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(19, className = $$new_props.class);
    if ("sheetVisible" in $$new_props)
      $$invalidate(20, sheetVisible = $$new_props.sheetVisible);
    if ("attachmentsVisible" in $$new_props)
      $$invalidate(21, attachmentsVisible = $$new_props.attachmentsVisible);
    if ("top" in $$new_props)
      $$invalidate(22, top = $$new_props.top);
    if ("resizable" in $$new_props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("bottomOffset" in $$new_props)
      $$invalidate(23, bottomOffset = $$new_props.bottomOffset);
    if ("topOffset" in $$new_props)
      $$invalidate(24, topOffset = $$new_props.topOffset);
    if ("maxHeight" in $$new_props)
      $$invalidate(25, maxHeight = $$new_props.maxHeight);
    if ("resizePage" in $$new_props)
      $$invalidate(26, resizePage = $$new_props.resizePage);
    if ("sendLink" in $$new_props)
      $$invalidate(2, sendLink = $$new_props.sendLink);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("textareaId" in $$new_props)
      $$invalidate(5, textareaId = $$new_props.textareaId);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("placeholder" in $$new_props)
      $$invalidate(7, placeholder = $$new_props.placeholder);
    if ("init" in $$new_props)
      $$invalidate(27, init2 = $$new_props.init);
    if ("f7Slot" in $$new_props)
      $$invalidate(8, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    afterUpdate,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    restProps,
    app,
    f7ready,
    Link: link_default,
    Input: input_default,
    emit,
    className,
    sheetVisible,
    attachmentsVisible,
    top,
    resizable,
    bottomOffset,
    topOffset,
    maxHeight,
    resizePage,
    sendLink,
    value,
    disabled,
    readonly,
    textareaId,
    name,
    placeholder,
    init: init2,
    f7Slot,
    el,
    f7Messagebar,
    updateSheetVisible,
    updateAttachmentsVisible,
    instance: instance87,
    initialWatchedSheet,
    watchSheetVisible,
    initialWatchedAttachments,
    watchAttachmentsVisible,
    onChange,
    onInput,
    onFocus,
    onBlur,
    onClick,
    onAttachmentDelete,
    onAttachmentClick,
    onResizePage,
    hasSendLinkSlots,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(43, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(19, className = $$new_props.className);
    if ("sheetVisible" in $$props)
      $$invalidate(20, sheetVisible = $$new_props.sheetVisible);
    if ("attachmentsVisible" in $$props)
      $$invalidate(21, attachmentsVisible = $$new_props.attachmentsVisible);
    if ("top" in $$props)
      $$invalidate(22, top = $$new_props.top);
    if ("resizable" in $$props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("bottomOffset" in $$props)
      $$invalidate(23, bottomOffset = $$new_props.bottomOffset);
    if ("topOffset" in $$props)
      $$invalidate(24, topOffset = $$new_props.topOffset);
    if ("maxHeight" in $$props)
      $$invalidate(25, maxHeight = $$new_props.maxHeight);
    if ("resizePage" in $$props)
      $$invalidate(26, resizePage = $$new_props.resizePage);
    if ("sendLink" in $$props)
      $$invalidate(2, sendLink = $$new_props.sendLink);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("textareaId" in $$props)
      $$invalidate(5, textareaId = $$new_props.textareaId);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("placeholder" in $$props)
      $$invalidate(7, placeholder = $$new_props.placeholder);
    if ("init" in $$props)
      $$invalidate(27, init2 = $$new_props.init);
    if ("f7Slot" in $$props)
      $$invalidate(8, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(9, el = $$new_props.el);
    if ("f7Messagebar" in $$props)
      $$invalidate(10, f7Messagebar = $$new_props.f7Messagebar);
    if ("updateSheetVisible" in $$props)
      updateSheetVisible = $$new_props.updateSheetVisible;
    if ("updateAttachmentsVisible" in $$props)
      updateAttachmentsVisible = $$new_props.updateAttachmentsVisible;
    if ("initialWatchedSheet" in $$props)
      initialWatchedSheet = $$new_props.initialWatchedSheet;
    if ("initialWatchedAttachments" in $$props)
      initialWatchedAttachments = $$new_props.initialWatchedAttachments;
    if ("hasSendLinkSlots" in $$props)
      $$invalidate(11, hasSendLinkSlots = $$new_props.hasSendLinkSlots);
    if ("classes" in $$props)
      $$invalidate(12, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(12, classes = classNames(
        className,
        "toolbar",
        "messagebar",
        {
          "messagebar-attachments-visible": attachmentsVisible,
          "messagebar-sheet-visible": sheetVisible
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*sheetVisible*/
    1048576) {
      $:
        watchSheetVisible(sheetVisible);
    }
    if ($$self.$$.dirty[0] & /*attachmentsVisible*/
    2097152) {
      $:
        watchAttachmentsVisible(attachmentsVisible);
    }
  };
  $:
    $$invalidate(11, hasSendLinkSlots = $$slots["send-link"]);
  $$props = exclude_internal_props($$props);
  return [
    value,
    resizable,
    sendLink,
    disabled,
    readonly,
    textareaId,
    name,
    placeholder,
    f7Slot,
    el,
    f7Messagebar,
    hasSendLinkSlots,
    classes,
    onChange,
    onInput,
    onFocus,
    onBlur,
    onClick,
    $$restProps,
    className,
    sheetVisible,
    attachmentsVisible,
    top,
    bottomOffset,
    topOffset,
    maxHeight,
    resizePage,
    init2,
    instance87,
    slots,
    div2_binding,
    $$scope
  ];
}
var Messagebar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_112,
      create_fragment70,
      safe_not_equal,
      {
        class: 19,
        sheetVisible: 20,
        attachmentsVisible: 21,
        top: 22,
        resizable: 1,
        bottomOffset: 23,
        topOffset: 24,
        maxHeight: 25,
        resizePage: 26,
        sendLink: 2,
        value: 0,
        disabled: 3,
        readonly: 4,
        textareaId: 5,
        name: 6,
        placeholder: 7,
        init: 27,
        f7Slot: 8,
        instance: 28
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messagebar",
      options,
      id: create_fragment70.name
    });
  }
  get class() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sheetVisible() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sheetVisible(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attachmentsVisible() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attachmentsVisible(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottomOffset() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottomOffset(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topOffset() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topOffset(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizePage() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizePage(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sendLink() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sendLink(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textareaId() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textareaId(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[28];
  }
  set instance(value) {
    throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messagebar_default = Messagebar;

// node_modules/framework7-svelte/components/messages-title.svelte
var file68 = "node_modules/framework7-svelte/components/messages-title.svelte";
function create_fragment71(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file68, 11, 0, 323);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messages_title", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "messages-title", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Messages_title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment71, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messages_title",
      options,
      id: create_fragment71.name
    });
  }
  get class() {
    throw new Error("<Messages_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messages_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messages_title_default = Messages_title;

// node_modules/framework7-svelte/components/messages.svelte
var file69 = "node_modules/framework7-svelte/components/messages.svelte";
var get_default_slot_changes12 = (dirty) => ({ messages: dirty & /*f7Messages*/
2 });
var get_default_slot_context12 = (ctx) => ({ messages: (
  /*f7Messages*/
  ctx[1]
) });
function create_fragment72(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_default_slot_context12
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file69, 123, 0, 3187);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[24](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7Messages*/
        4194306)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_113($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "autoLayout",
    "messages",
    "newMessagesFirst",
    "scrollMessages",
    "scrollMessagesOnEdge",
    "firstMessageRule",
    "lastMessageRule",
    "tailMessageRule",
    "sameNameMessageRule",
    "sameHeaderMessageRule",
    "sameFooterMessageRule",
    "sameAvatarMessageRule",
    "customClassMessageRule",
    "renderMessage",
    "typing",
    "init",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Messages", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { autoLayout = false } = $$props;
  let { messages = [] } = $$props;
  let { newMessagesFirst = false } = $$props;
  let { scrollMessages = true } = $$props;
  let { scrollMessagesOnEdge = true } = $$props;
  let { firstMessageRule = void 0 } = $$props;
  let { lastMessageRule = void 0 } = $$props;
  let { tailMessageRule = void 0 } = $$props;
  let { sameNameMessageRule = void 0 } = $$props;
  let { sameHeaderMessageRule = void 0 } = $$props;
  let { sameFooterMessageRule = void 0 } = $$props;
  let { sameAvatarMessageRule = void 0 } = $$props;
  let { customClassMessageRule = void 0 } = $$props;
  let { renderMessage = void 0 } = $$props;
  let { typing = false } = $$props;
  let { init: init2 = true } = $$props;
  let el;
  let f7Messages;
  let childrenBeforeUpdated = null;
  function instance87() {
    return f7Messages;
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      $$invalidate(1, f7Messages = app.f7.messages.create(noUndefinedProps({
        el,
        autoLayout,
        messages,
        newMessagesFirst,
        scrollMessages,
        scrollMessagesOnEdge,
        firstMessageRule,
        lastMessageRule,
        tailMessageRule,
        sameNameMessageRule,
        sameHeaderMessageRule,
        sameFooterMessageRule,
        sameAvatarMessageRule,
        customClassMessageRule,
        renderMessage
      })));
      if (typing)
        f7Messages.showTyping();
    });
  });
  beforeUpdate(() => {
    if (!init2 || !el)
      return;
    const children = el.children;
    if (!children)
      return;
    childrenBeforeUpdated = children.length;
    for (let i = 0; i < children.length; i += 1) {
      children[i].classList.add("message-appeared");
    }
  });
  afterUpdate(() => {
    if (!init2)
      return;
    if (!el)
      return;
    const children = el.children;
    if (!children)
      return;
    const childrenAfterUpdated = children.length;
    for (let i = 0; i < children.length; i += 1) {
      if (!children[i].classList.contains("message-appeared")) {
        children[i].classList.add("message-appear-from-bottom");
      }
    }
    if (f7Messages && f7Messages.layout && autoLayout) {
      f7Messages.layout();
    }
    if (childrenBeforeUpdated !== childrenAfterUpdated && f7Messages && f7Messages.scroll && scrollMessages) {
      f7Messages.scroll();
    }
  });
  onDestroy(() => {
    if (f7Messages && f7Messages.destroy) {
      f7Messages.destroy();
      $$invalidate(1, f7Messages = null);
    }
  });
  let initialWatched = false;
  function watchTyping(typingPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Messages)
      return;
    if (typingPassed)
      f7Messages.showTyping();
    else
      f7Messages.hideTyping();
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("autoLayout" in $$new_props)
      $$invalidate(5, autoLayout = $$new_props.autoLayout);
    if ("messages" in $$new_props)
      $$invalidate(6, messages = $$new_props.messages);
    if ("newMessagesFirst" in $$new_props)
      $$invalidate(7, newMessagesFirst = $$new_props.newMessagesFirst);
    if ("scrollMessages" in $$new_props)
      $$invalidate(8, scrollMessages = $$new_props.scrollMessages);
    if ("scrollMessagesOnEdge" in $$new_props)
      $$invalidate(9, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
    if ("firstMessageRule" in $$new_props)
      $$invalidate(10, firstMessageRule = $$new_props.firstMessageRule);
    if ("lastMessageRule" in $$new_props)
      $$invalidate(11, lastMessageRule = $$new_props.lastMessageRule);
    if ("tailMessageRule" in $$new_props)
      $$invalidate(12, tailMessageRule = $$new_props.tailMessageRule);
    if ("sameNameMessageRule" in $$new_props)
      $$invalidate(13, sameNameMessageRule = $$new_props.sameNameMessageRule);
    if ("sameHeaderMessageRule" in $$new_props)
      $$invalidate(14, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
    if ("sameFooterMessageRule" in $$new_props)
      $$invalidate(15, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
    if ("sameAvatarMessageRule" in $$new_props)
      $$invalidate(16, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
    if ("customClassMessageRule" in $$new_props)
      $$invalidate(17, customClassMessageRule = $$new_props.customClassMessageRule);
    if ("renderMessage" in $$new_props)
      $$invalidate(18, renderMessage = $$new_props.renderMessage);
    if ("typing" in $$new_props)
      $$invalidate(19, typing = $$new_props.typing);
    if ("init" in $$new_props)
      $$invalidate(20, init2 = $$new_props.init);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    beforeUpdate,
    afterUpdate,
    colorClasses,
    classNames,
    noUndefinedProps,
    restProps,
    app,
    f7ready,
    className,
    autoLayout,
    messages,
    newMessagesFirst,
    scrollMessages,
    scrollMessagesOnEdge,
    firstMessageRule,
    lastMessageRule,
    tailMessageRule,
    sameNameMessageRule,
    sameHeaderMessageRule,
    sameFooterMessageRule,
    sameAvatarMessageRule,
    customClassMessageRule,
    renderMessage,
    typing,
    init: init2,
    el,
    f7Messages,
    childrenBeforeUpdated,
    instance: instance87,
    initialWatched,
    watchTyping,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("autoLayout" in $$props)
      $$invalidate(5, autoLayout = $$new_props.autoLayout);
    if ("messages" in $$props)
      $$invalidate(6, messages = $$new_props.messages);
    if ("newMessagesFirst" in $$props)
      $$invalidate(7, newMessagesFirst = $$new_props.newMessagesFirst);
    if ("scrollMessages" in $$props)
      $$invalidate(8, scrollMessages = $$new_props.scrollMessages);
    if ("scrollMessagesOnEdge" in $$props)
      $$invalidate(9, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
    if ("firstMessageRule" in $$props)
      $$invalidate(10, firstMessageRule = $$new_props.firstMessageRule);
    if ("lastMessageRule" in $$props)
      $$invalidate(11, lastMessageRule = $$new_props.lastMessageRule);
    if ("tailMessageRule" in $$props)
      $$invalidate(12, tailMessageRule = $$new_props.tailMessageRule);
    if ("sameNameMessageRule" in $$props)
      $$invalidate(13, sameNameMessageRule = $$new_props.sameNameMessageRule);
    if ("sameHeaderMessageRule" in $$props)
      $$invalidate(14, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
    if ("sameFooterMessageRule" in $$props)
      $$invalidate(15, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
    if ("sameAvatarMessageRule" in $$props)
      $$invalidate(16, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
    if ("customClassMessageRule" in $$props)
      $$invalidate(17, customClassMessageRule = $$new_props.customClassMessageRule);
    if ("renderMessage" in $$props)
      $$invalidate(18, renderMessage = $$new_props.renderMessage);
    if ("typing" in $$props)
      $$invalidate(19, typing = $$new_props.typing);
    if ("init" in $$props)
      $$invalidate(20, init2 = $$new_props.init);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("f7Messages" in $$props)
      $$invalidate(1, f7Messages = $$new_props.f7Messages);
    if ("childrenBeforeUpdated" in $$props)
      childrenBeforeUpdated = $$new_props.childrenBeforeUpdated;
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "messages", colorClasses($$props)));
    if ($$self.$$.dirty & /*typing*/
    524288) {
      $:
        watchTyping(typing);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    el,
    f7Messages,
    classes,
    $$restProps,
    className,
    autoLayout,
    messages,
    newMessagesFirst,
    scrollMessages,
    scrollMessagesOnEdge,
    firstMessageRule,
    lastMessageRule,
    tailMessageRule,
    sameNameMessageRule,
    sameHeaderMessageRule,
    sameFooterMessageRule,
    sameAvatarMessageRule,
    customClassMessageRule,
    renderMessage,
    typing,
    init2,
    instance87,
    $$scope,
    slots,
    div_binding
  ];
}
var Messages = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_113, create_fragment72, safe_not_equal, {
      class: 4,
      autoLayout: 5,
      messages: 6,
      newMessagesFirst: 7,
      scrollMessages: 8,
      scrollMessagesOnEdge: 9,
      firstMessageRule: 10,
      lastMessageRule: 11,
      tailMessageRule: 12,
      sameNameMessageRule: 13,
      sameHeaderMessageRule: 14,
      sameFooterMessageRule: 15,
      sameAvatarMessageRule: 16,
      customClassMessageRule: 17,
      renderMessage: 18,
      typing: 19,
      init: 20,
      instance: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Messages",
      options,
      id: create_fragment72.name
    });
  }
  get class() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoLayout() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoLayout(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messages() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messages(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get newMessagesFirst() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set newMessagesFirst(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollMessages() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollMessages(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollMessagesOnEdge() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollMessagesOnEdge(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get firstMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set firstMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lastMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lastMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tailMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tailMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameNameMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameNameMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameHeaderMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameHeaderMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameFooterMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameFooterMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sameAvatarMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sameAvatarMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customClassMessageRule() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customClassMessageRule(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderMessage() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderMessage(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get typing() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set typing(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[21];
  }
  set instance(value) {
    throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var messages_default = Messages;

// node_modules/framework7-svelte/components/nav-left.svelte
var file70 = "node_modules/framework7-svelte/components/nav-left.svelte";
function create_if_block26(ctx) {
  let link;
  let current;
  link = new link_default({
    props: {
      href: (
        /*backLinkUrl*/
        ctx[1] || "#"
      ),
      back: true,
      icon: "icon-back",
      force: (
        /*backLinkForce*/
        ctx[2] || void 0
      ),
      class: !/*backLinkText*/
      ctx[3] ? "icon-only" : void 0,
      text: (
        /*backLinkText*/
        ctx[3]
      ),
      onClick: (
        /*onBackClick*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const link_changes = {};
      if (dirty & /*backLinkUrl*/
      2)
        link_changes.href = /*backLinkUrl*/
        ctx2[1] || "#";
      if (dirty & /*backLinkForce*/
      4)
        link_changes.force = /*backLinkForce*/
        ctx2[2] || void 0;
      if (dirty & /*backLinkText*/
      8)
        link_changes.class = !/*backLinkText*/
        ctx2[3] ? "icon-only" : void 0;
      if (dirty & /*backLinkText*/
      8)
        link_changes.text = /*backLinkText*/
        ctx2[3];
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(46:2) {#if backLink}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*backLink*/
    ctx[0] && create_if_block26(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file70, 44, 0, 1114);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*backLink*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*backLink*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let classes;
  let needBackLinkText;
  let backLinkText;
  const omit_props_names = ["class", "backLink", "backLinkUrl", "backLinkForce", "backLinkShowText", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav_left", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { backLink = void 0 } = $$props;
  let { backLinkUrl = void 0 } = $$props;
  let { backLinkForce = void 0 } = $$props;
  let { backLinkShowText = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  let theme2 = useTheme((t) => {
    $$invalidate(10, theme2 = t);
  });
  function onBackClick() {
    emit("clickBack");
    emit("backClick");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("backLink" in $$new_props)
      $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$new_props)
      $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$new_props)
      $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$new_props)
      $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$new_props)
      $$invalidate(9, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    useTheme,
    Link: link_default,
    emit,
    className,
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkShowText,
    sliding,
    theme: theme2,
    onBackClick,
    needBackLinkText,
    backLinkText,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("backLink" in $$props)
      $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$props)
      $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$props)
      $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$props)
      $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$props)
      $$invalidate(9, sliding = $$new_props.sliding);
    if ("theme" in $$props)
      $$invalidate(10, theme2 = $$new_props.theme);
    if ("needBackLinkText" in $$props)
      $$invalidate(11, needBackLinkText = $$new_props.needBackLinkText);
    if ("backLinkText" in $$props)
      $$invalidate(3, backLinkText = $$new_props.backLinkText);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classes = classNames(className, "left", { sliding }, colorClasses($$props)));
    if ($$self.$$.dirty & /*backLinkShowText*/
    256) {
      $:
        $$invalidate(11, needBackLinkText = backLinkShowText);
    }
    if ($$self.$$.dirty & /*needBackLinkText, theme*/
    3072) {
      $:
        if (typeof needBackLinkText === "undefined")
          $$invalidate(11, needBackLinkText = theme2 && !theme2.md);
    }
    if ($$self.$$.dirty & /*backLink, needBackLinkText*/
    2049) {
      $:
        $$invalidate(3, backLinkText = backLink !== true && needBackLinkText ? backLink : void 0);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkText,
    classes,
    onBackClick,
    $$restProps,
    className,
    backLinkShowText,
    sliding,
    theme2,
    needBackLinkText,
    $$scope,
    slots
  ];
}
var Nav_left = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment73, safe_not_equal, {
      class: 7,
      backLink: 0,
      backLinkUrl: 1,
      backLinkForce: 2,
      backLinkShowText: 8,
      sliding: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav_left",
      options,
      id: create_fragment73.name
    });
  }
  get class() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLink() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLink(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkUrl() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkUrl(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkForce() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkForce(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkShowText() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkShowText(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sliding() {
    throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sliding(value) {
    throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var nav_left_default = Nav_left;

// node_modules/framework7-svelte/components/nav-right.svelte
var file71 = "node_modules/framework7-svelte/components/nav-right.svelte";
function create_fragment74(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file71, 20, 0, 394);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav_right", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("sliding" in $$new_props)
      $$invalidate(3, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    sliding,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("sliding" in $$props)
      $$invalidate(3, sliding = $$new_props.sliding);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "right", { sliding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, sliding, $$scope, slots];
}
var Nav_right = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment74, safe_not_equal, { class: 2, sliding: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav_right",
      options,
      id: create_fragment74.name
    });
  }
  get class() {
    throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sliding() {
    throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sliding(value) {
    throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var nav_right_default = Nav_right;

// node_modules/framework7-svelte/components/nav-title-large.svelte
var file72 = "node_modules/framework7-svelte/components/nav-title-large.svelte";
function create_fragment75(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div1_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "title-large-text");
      add_location(div0, file72, 12, 2, 372);
      set_attributes(div1, div1_data);
      add_location(div1, file72, 11, 0, 320);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav_title_large", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "title-large", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Nav_title_large = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment75, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav_title_large",
      options,
      id: create_fragment75.name
    });
  }
  get class() {
    throw new Error("<Nav_title_large>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav_title_large>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var nav_title_large_default = Nav_title_large;

// node_modules/framework7-svelte/components/nav-title.svelte
var file73 = "node_modules/framework7-svelte/components/nav-title.svelte";
function create_if_block_137(ctx) {
  let t_value = plainText(
    /*title*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      1 && t_value !== (t_value = plainText(
        /*title*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_137.name,
    type: "if",
    source: "(24:2) {#if typeof title !== 'undefined'}",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let span;
  let t_value = plainText(
    /*subtitle*/
    ctx[1]
  ) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      attr_dev(span, "class", "subtitle");
      add_location(span, file73, 24, 39, 621);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*subtitle*/
      2 && t_value !== (t_value = plainText(
        /*subtitle*/
        ctx2[1]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(25:2) {#if typeof subtitle !== 'undefined'}",
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = typeof /*title*/
  ctx[0] !== "undefined" && create_if_block_137(ctx);
  let if_block1 = typeof /*subtitle*/
  ctx[1] !== "undefined" && create_if_block27(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file73, 22, 0, 472);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (typeof /*title*/
      ctx2[0] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_137(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*subtitle*/
      ctx2[1] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block27(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "title", "subtitle", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav_title", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(1, subtitle = $$new_props.subtitle);
    if ("sliding" in $$new_props)
      $$invalidate(5, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    plainText,
    restProps,
    className,
    title,
    subtitle,
    sliding,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(1, subtitle = $$new_props.subtitle);
    if ("sliding" in $$props)
      $$invalidate(5, sliding = $$new_props.sliding);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classes = classNames(className, "title", { sliding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [title, subtitle, classes, $$restProps, className, sliding, $$scope, slots];
}
var Nav_title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment76, safe_not_equal, {
      class: 4,
      title: 0,
      subtitle: 1,
      sliding: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav_title",
      options,
      id: create_fragment76.name
    });
  }
  get class() {
    throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sliding() {
    throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sliding(value) {
    throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var nav_title_default = Nav_title;

// node_modules/framework7-svelte/components/navbar.svelte
var file74 = "node_modules/framework7-svelte/components/navbar.svelte";
var get_after_inner_slot_changes3 = (dirty) => ({});
var get_after_inner_slot_context3 = (ctx) => ({});
var get_title_large_slot_changes = (dirty) => ({});
var get_title_large_slot_context = (ctx) => ({});
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_nav_right_slot_changes = (dirty) => ({});
var get_nav_right_slot_context = (ctx) => ({});
var get_title_slot_changes2 = (dirty) => ({});
var get_title_slot_context2 = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
var get_nav_left_slot_changes = (dirty) => ({});
var get_nav_left_slot_context = (ctx) => ({});
var get_before_inner_slot_changes3 = (dirty) => ({});
var get_before_inner_slot_context3 = (ctx) => ({});
function create_if_block_313(ctx) {
  let navleft;
  let current;
  navleft = new nav_left_default({
    props: {
      backLink: (
        /*backLink*/
        ctx[0]
      ),
      backLinkUrl: (
        /*backLinkUrl*/
        ctx[1]
      ),
      backLinkForce: (
        /*backLinkForce*/
        ctx[2]
      ),
      backLinkShowText: (
        /*backLinkShowText*/
        ctx[3]
      ),
      onBackClick: (
        /*onBackClick*/
        ctx[15]
      ),
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navleft.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navleft, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navleft_changes = {};
      if (dirty[0] & /*backLink*/
      1)
        navleft_changes.backLink = /*backLink*/
        ctx2[0];
      if (dirty[0] & /*backLinkUrl*/
      2)
        navleft_changes.backLinkUrl = /*backLinkUrl*/
        ctx2[1];
      if (dirty[0] & /*backLinkForce*/
      4)
        navleft_changes.backLinkForce = /*backLinkForce*/
        ctx2[2];
      if (dirty[0] & /*backLinkShowText*/
      8)
        navleft_changes.backLinkShowText = /*backLinkShowText*/
        ctx2[3];
      if (dirty[1] & /*$$scope*/
      16384) {
        navleft_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navleft.$set(navleft_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navleft.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navleft.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navleft, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_313.name,
    type: "if",
    source: "(197:4) {#if backLink || hasLeftSlots}",
    ctx
  });
  return block;
}
function create_default_slot_24(ctx) {
  let t;
  let current;
  const nav_left_slot_template = (
    /*#slots*/
    ctx[43]["nav-left"]
  );
  const nav_left_slot = create_slot(
    nav_left_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_nav_left_slot_context
  );
  const left_slot_template = (
    /*#slots*/
    ctx[43].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_left_slot_context
  );
  const block = {
    c: function create() {
      if (nav_left_slot)
        nav_left_slot.c();
      t = space();
      if (left_slot)
        left_slot.c();
    },
    m: function mount(target, anchor) {
      if (nav_left_slot) {
        nav_left_slot.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (left_slot) {
        left_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (nav_left_slot) {
        if (nav_left_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            nav_left_slot,
            nav_left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              nav_left_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_nav_left_slot_changes
            ),
            get_nav_left_slot_context
          );
        }
      }
      if (left_slot) {
        if (left_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav_left_slot, local);
      transition_in(left_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav_left_slot, local);
      transition_out(left_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (nav_left_slot)
        nav_left_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (left_slot)
        left_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: "(198:6) <NavLeft {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}>",
    ctx
  });
  return block;
}
function create_if_block_217(ctx) {
  let navtitle;
  let current;
  navtitle = new nav_title_default({
    props: {
      title: (
        /*title*/
        ctx[4]
      ),
      subtitle: (
        /*subtitle*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navtitle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navtitle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navtitle_changes = {};
      if (dirty[0] & /*title*/
      16)
        navtitle_changes.title = /*title*/
        ctx2[4];
      if (dirty[0] & /*subtitle*/
      32)
        navtitle_changes.subtitle = /*subtitle*/
        ctx2[5];
      if (dirty[1] & /*$$scope*/
      16384) {
        navtitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navtitle.$set(navtitle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navtitle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navtitle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navtitle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_217.name,
    type: "if",
    source: "(203:4) {#if title || subtitle || hasTitleSlots}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[43].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_title_slot_context2
  );
  const block = {
    c: function create() {
      if (title_slot)
        title_slot.c();
    },
    m: function mount(target, anchor) {
      if (title_slot) {
        title_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_title_slot_changes2
            ),
            get_title_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(204:6) <NavTitle {title} {subtitle}>",
    ctx
  });
  return block;
}
function create_if_block_138(ctx) {
  let navright;
  let current;
  navright = new nav_right_default({
    props: {
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navright.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navright, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navright_changes = {};
      if (dirty[1] & /*$$scope*/
      16384) {
        navright_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navright.$set(navright_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navright, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_138.name,
    type: "if",
    source: "(208:4) {#if hasRightSlots}",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let t;
  let current;
  const nav_right_slot_template = (
    /*#slots*/
    ctx[43]["nav-right"]
  );
  const nav_right_slot = create_slot(
    nav_right_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_nav_right_slot_context
  );
  const right_slot_template = (
    /*#slots*/
    ctx[43].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_right_slot_context
  );
  const block = {
    c: function create() {
      if (nav_right_slot)
        nav_right_slot.c();
      t = space();
      if (right_slot)
        right_slot.c();
    },
    m: function mount(target, anchor) {
      if (nav_right_slot) {
        nav_right_slot.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (right_slot) {
        right_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (nav_right_slot) {
        if (nav_right_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            nav_right_slot,
            nav_right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              nav_right_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_nav_right_slot_changes
            ),
            get_nav_right_slot_context
          );
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav_right_slot, local);
      transition_in(right_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav_right_slot, local);
      transition_out(right_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (nav_right_slot)
        nav_right_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (right_slot)
        right_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(209:6) <NavRight>",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let div1;
  let div0;
  let t0_value = plainText(
    /*largeTitle*/
    ctx[11]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_large_slot_template = (
    /*#slots*/
    ctx[43]["title-large"]
  );
  const title_large_slot = create_slot(
    title_large_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_title_large_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_large_slot)
        title_large_slot.c();
      attr_dev(div0, "class", "title-large-text");
      add_location(div0, file74, 215, 8, 6835);
      attr_dev(div1, "class", "title-large");
      add_location(div1, file74, 214, 6, 6801);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, t0);
      append_dev(div0, t1);
      if (title_large_slot) {
        title_large_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*largeTitle*/
      2048) && t0_value !== (t0_value = plainText(
        /*largeTitle*/
        ctx2[11]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (title_large_slot) {
        if (title_large_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            title_large_slot,
            title_large_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              title_large_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_title_large_slot_changes
            ),
            get_title_large_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_large_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_large_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (title_large_slot)
        title_large_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(214:4) {#if largeTitle || hasTitleLargeSlots}",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let current;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[43]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_before_inner_slot_context3
  );
  let if_block0 = (
    /*backLink*/
    (ctx[0] || /*hasLeftSlots*/
    ctx[14]) && create_if_block_313(ctx)
  );
  let if_block1 = (
    /*title*/
    (ctx[4] || /*subtitle*/
    ctx[5] || /*hasTitleSlots*/
    ctx[12]) && create_if_block_217(ctx)
  );
  let if_block2 = (
    /*hasRightSlots*/
    ctx[13] && create_if_block_138(ctx)
  );
  let if_block3 = (
    /*largeTitle*/
    (ctx[11] || /*hasTitleLargeSlots*/
    ctx[10]) && create_if_block28(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[43].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    null
  );
  const after_inner_slot_template = (
    /*#slots*/
    ctx[43]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    get_after_inner_slot_context3
  );
  let div2_levels = [
    { class: (
      /*classes*/
      ctx[9]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[6]
    ) },
    restProps(
      /*$$restProps*/
      ctx[16]
    )
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (before_inner_slot)
        before_inner_slot.c();
      t1 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (default_slot)
        default_slot.c();
      t6 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      attr_dev(div0, "class", "navbar-bg");
      add_location(div0, file74, 193, 2, 6180);
      attr_dev(
        div1,
        "class",
        /*innerClasses*/
        ctx[8]
      );
      add_location(div1, file74, 195, 2, 6239);
      set_attributes(div2, div2_data);
      add_location(div2, file74, 192, 0, 6091);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t0);
      if (before_inner_slot) {
        before_inner_slot.m(div2, null);
      }
      append_dev(div2, t1);
      append_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      append_dev(div1, t5);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div2, t6);
      if (after_inner_slot) {
        after_inner_slot.m(div2, null);
      }
      ctx[44](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_before_inner_slot_changes3
            ),
            get_before_inner_slot_context3
          );
        }
      }
      if (
        /*backLink*/
        ctx2[0] || /*hasLeftSlots*/
        ctx2[14]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*backLink, hasLeftSlots*/
          16385) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_313(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        ctx2[4] || /*subtitle*/
        ctx2[5] || /*hasTitleSlots*/
        ctx2[12]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*title, subtitle, hasTitleSlots*/
          4144) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_217(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*hasRightSlots*/
        ctx2[13]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasRightSlots*/
          8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_138(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*largeTitle*/
        ctx2[11] || /*hasTitleLargeSlots*/
        ctx2[10]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/
          3072) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block28(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*innerClasses*/
      256) {
        attr_dev(
          div1,
          "class",
          /*innerClasses*/
          ctx2[8]
        );
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              get_after_inner_slot_changes3
            ),
            get_after_inner_slot_context3
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*classes*/
        512) && { class: (
          /*classes*/
          ctx2[9]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        64) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[6]
        ) },
        dirty[0] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[16]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(default_slot, local);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(default_slot, local);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (default_slot)
        default_slot.d(detaching);
      if (after_inner_slot)
        after_inner_slot.d(detaching);
      ctx[44](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let hasLeftSlots;
  let hasRightSlots;
  let hasTitleSlots;
  let largeTitle;
  let hasTitleLargeSlots;
  let addLeftTitleClass;
  let addCenterTitleClass;
  let isLarge;
  let isTransparent;
  let isTransparentVisible;
  let classes;
  let innerClasses;
  const omit_props_names = [
    "class",
    "backLink",
    "backLinkUrl",
    "backLinkForce",
    "backLinkShowText",
    "sliding",
    "title",
    "subtitle",
    "hidden",
    "noShadow",
    "noHairline",
    "innerClass",
    "innerClassName",
    "large",
    "largeTransparent",
    "transparent",
    "titleLarge",
    "f7Slot",
    "hide",
    "show",
    "size"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, [
    "before-inner",
    "nav-left",
    "left",
    "title",
    "nav-right",
    "right",
    "title-large",
    "default",
    "after-inner"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { backLink = void 0 } = $$props;
  let { backLinkUrl = void 0 } = $$props;
  let { backLinkForce = false } = $$props;
  let { backLinkShowText = void 0 } = $$props;
  let { sliding = true } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { hidden = false } = $$props;
  let { noShadow = false } = $$props;
  let { noHairline = false } = $$props;
  let { innerClass = void 0 } = $$props;
  let { innerClassName = void 0 } = $$props;
  let { large = false } = $$props;
  let { largeTransparent = false } = $$props;
  let { transparent = false } = $$props;
  let { titleLarge = void 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let theme2 = useTheme((t) => {
    $$invalidate(31, theme2 = t);
  });
  let routerPositionClass = "";
  let largeCollapsed = false;
  let routerNavbarRole = null;
  let routerNavbarRoleDetailRoot = false;
  let routerNavbarMasterStack = false;
  let transparentVisible = false;
  function hide(animate) {
    app.f7.navbar.hide(el, animate);
  }
  function show(animate) {
    app.f7.navbar.show(el, animate);
  }
  function size() {
    app.f7.navbar.size(el);
  }
  function onHide(navbarEl) {
    if (el !== navbarEl)
      return;
    emit("navbarHide");
  }
  function onShow(navbarEl) {
    if (el !== navbarEl)
      return;
    emit("navbarShow");
  }
  function onNavbarTransparentShow(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(37, transparentVisible = true);
    emit("navbarTransparentShow");
  }
  function onNavbarTransparentHide(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(37, transparentVisible = false);
    emit("navbarTransparentHide");
  }
  function onExpand(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(33, largeCollapsed = false);
    emit("navbarExpand");
  }
  function onCollapse(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(33, largeCollapsed = true);
    emit("navbarCollapse");
  }
  function onNavbarPosition(navbarEl, position) {
    if (el !== navbarEl)
      return;
    $$invalidate(32, routerPositionClass = position ? `navbar-${position}` : position);
  }
  function onNavbarRole(navbarEl, rolesData) {
    if (el !== navbarEl)
      return;
    $$invalidate(34, routerNavbarRole = rolesData.role);
    $$invalidate(35, routerNavbarRoleDetailRoot = rolesData.detailRoot);
  }
  function onNavbarMasterStack(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(36, routerNavbarMasterStack = true);
  }
  function onNavbarMasterUnstack(navbarEl) {
    if (el !== navbarEl)
      return;
    $$invalidate(36, routerNavbarMasterStack = false);
  }
  function onBackClick() {
    emit("clickBack");
  }
  function mountNavbar() {
    app.f7.on("navbarShow", onShow);
    app.f7.on("navbarHide", onHide);
    app.f7.on("navbarCollapse", onCollapse);
    app.f7.on("navbarExpand", onExpand);
    app.f7.on("navbarPosition", onNavbarPosition);
    app.f7.on("navbarRole", onNavbarRole);
    app.f7.on("navbarMasterStack", onNavbarMasterStack);
    app.f7.on("navbarMasterUnstack", onNavbarMasterUnstack);
    app.f7.on("navbarTransparentShow", onNavbarTransparentShow);
    app.f7.on("navbarTransparentHide", onNavbarTransparentHide);
  }
  function destroyNavbar() {
    app.f7.off("navbarShow", onShow);
    app.f7.off("navbarHide", onHide);
    app.f7.off("navbarCollapse", onCollapse);
    app.f7.off("navbarExpand", onExpand);
    app.f7.off("navbarPosition", onNavbarPosition);
    app.f7.off("navbarRole", onNavbarRole);
    app.f7.off("navbarMasterStack", onNavbarMasterStack);
    app.f7.off("navbarMasterUnstack", onNavbarMasterUnstack);
    app.f7.off("navbarTransparentShow", onNavbarTransparentShow);
    app.f7.off("navbarTransparentHide", onNavbarTransparentHide);
  }
  onMount(() => {
    f7ready(() => {
      mountNavbar();
    });
  });
  afterUpdate(() => {
    if (!app.f7)
      return;
    app.f7.navbar.size(el);
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    destroyNavbar();
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(59, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(17, className = $$new_props.class);
    if ("backLink" in $$new_props)
      $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$new_props)
      $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$new_props)
      $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$new_props)
      $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$new_props)
      $$invalidate(18, sliding = $$new_props.sliding);
    if ("title" in $$new_props)
      $$invalidate(4, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(5, subtitle = $$new_props.subtitle);
    if ("hidden" in $$new_props)
      $$invalidate(19, hidden = $$new_props.hidden);
    if ("noShadow" in $$new_props)
      $$invalidate(20, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$new_props)
      $$invalidate(21, noHairline = $$new_props.noHairline);
    if ("innerClass" in $$new_props)
      $$invalidate(22, innerClass = $$new_props.innerClass);
    if ("innerClassName" in $$new_props)
      $$invalidate(23, innerClassName = $$new_props.innerClassName);
    if ("large" in $$new_props)
      $$invalidate(24, large = $$new_props.large);
    if ("largeTransparent" in $$new_props)
      $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    if ("transparent" in $$new_props)
      $$invalidate(26, transparent = $$new_props.transparent);
    if ("titleLarge" in $$new_props)
      $$invalidate(27, titleLarge = $$new_props.titleLarge);
    if ("f7Slot" in $$new_props)
      $$invalidate(6, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(45, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    afterUpdate,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    f7ready,
    app,
    useTheme,
    NavLeft: nav_left_default,
    NavTitle: nav_title_default,
    NavRight: nav_right_default,
    emit,
    className,
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkShowText,
    sliding,
    title,
    subtitle,
    hidden,
    noShadow,
    noHairline,
    innerClass,
    innerClassName,
    large,
    largeTransparent,
    transparent,
    titleLarge,
    f7Slot,
    el,
    theme: theme2,
    routerPositionClass,
    largeCollapsed,
    routerNavbarRole,
    routerNavbarRoleDetailRoot,
    routerNavbarMasterStack,
    transparentVisible,
    hide,
    show,
    size,
    onHide,
    onShow,
    onNavbarTransparentShow,
    onNavbarTransparentHide,
    onExpand,
    onCollapse,
    onNavbarPosition,
    onNavbarRole,
    onNavbarMasterStack,
    onNavbarMasterUnstack,
    onBackClick,
    mountNavbar,
    destroyNavbar,
    addCenterTitleClass,
    addLeftTitleClass,
    innerClasses,
    isTransparentVisible,
    isTransparent,
    isLarge,
    classes,
    hasTitleLargeSlots,
    largeTitle,
    hasTitleSlots,
    hasRightSlots,
    hasLeftSlots
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(59, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(17, className = $$new_props.className);
    if ("backLink" in $$props)
      $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$props)
      $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$props)
      $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$props)
      $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$props)
      $$invalidate(18, sliding = $$new_props.sliding);
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(5, subtitle = $$new_props.subtitle);
    if ("hidden" in $$props)
      $$invalidate(19, hidden = $$new_props.hidden);
    if ("noShadow" in $$props)
      $$invalidate(20, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$props)
      $$invalidate(21, noHairline = $$new_props.noHairline);
    if ("innerClass" in $$props)
      $$invalidate(22, innerClass = $$new_props.innerClass);
    if ("innerClassName" in $$props)
      $$invalidate(23, innerClassName = $$new_props.innerClassName);
    if ("large" in $$props)
      $$invalidate(24, large = $$new_props.large);
    if ("largeTransparent" in $$props)
      $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    if ("transparent" in $$props)
      $$invalidate(26, transparent = $$new_props.transparent);
    if ("titleLarge" in $$props)
      $$invalidate(27, titleLarge = $$new_props.titleLarge);
    if ("f7Slot" in $$props)
      $$invalidate(6, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(7, el = $$new_props.el);
    if ("theme" in $$props)
      $$invalidate(31, theme2 = $$new_props.theme);
    if ("routerPositionClass" in $$props)
      $$invalidate(32, routerPositionClass = $$new_props.routerPositionClass);
    if ("largeCollapsed" in $$props)
      $$invalidate(33, largeCollapsed = $$new_props.largeCollapsed);
    if ("routerNavbarRole" in $$props)
      $$invalidate(34, routerNavbarRole = $$new_props.routerNavbarRole);
    if ("routerNavbarRoleDetailRoot" in $$props)
      $$invalidate(35, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
    if ("routerNavbarMasterStack" in $$props)
      $$invalidate(36, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
    if ("transparentVisible" in $$props)
      $$invalidate(37, transparentVisible = $$new_props.transparentVisible);
    if ("addCenterTitleClass" in $$props)
      $$invalidate(38, addCenterTitleClass = $$new_props.addCenterTitleClass);
    if ("addLeftTitleClass" in $$props)
      $$invalidate(39, addLeftTitleClass = $$new_props.addLeftTitleClass);
    if ("innerClasses" in $$props)
      $$invalidate(8, innerClasses = $$new_props.innerClasses);
    if ("isTransparentVisible" in $$props)
      $$invalidate(40, isTransparentVisible = $$new_props.isTransparentVisible);
    if ("isTransparent" in $$props)
      $$invalidate(41, isTransparent = $$new_props.isTransparent);
    if ("isLarge" in $$props)
      $$invalidate(42, isLarge = $$new_props.isLarge);
    if ("classes" in $$props)
      $$invalidate(9, classes = $$new_props.classes);
    if ("hasTitleLargeSlots" in $$props)
      $$invalidate(10, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
    if ("largeTitle" in $$props)
      $$invalidate(11, largeTitle = $$new_props.largeTitle);
    if ("hasTitleSlots" in $$props)
      $$invalidate(12, hasTitleSlots = $$new_props.hasTitleSlots);
    if ("hasRightSlots" in $$props)
      $$invalidate(13, hasRightSlots = $$new_props.hasRightSlots);
    if ("hasLeftSlots" in $$props)
      $$invalidate(14, hasLeftSlots = $$new_props.hasLeftSlots);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*titleLarge, large, title*/
    150994960) {
      $:
        $$invalidate(11, largeTitle = titleLarge || large && title);
    }
    if ($$self.$$.dirty[1] & /*theme*/
    1) {
      $:
        $$invalidate(39, addLeftTitleClass = theme2 && theme2.ios && app.f7 && !app.f7.params.navbar.iosCenterTitle);
    }
    if ($$self.$$.dirty[1] & /*theme*/
    1) {
      $:
        $$invalidate(38, addCenterTitleClass = theme2 && theme2.md && app.f7 && app.f7.params.navbar.mdCenterTitle || theme2 && theme2.aurora && app.f7 && app.f7.params.navbar.auroraCenterTitle);
    }
    if ($$self.$$.dirty[0] & /*large, largeTransparent*/
    50331648) {
      $:
        $$invalidate(42, isLarge = large || largeTransparent);
    }
    if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/
    100663296 | $$self.$$.dirty[1] & /*isLarge*/
    2048) {
      $:
        $$invalidate(41, isTransparent = transparent || isLarge && largeTransparent);
    }
    if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/
    1088) {
      $:
        $$invalidate(40, isTransparentVisible = isTransparent && transparentVisible);
    }
    $:
      $$invalidate(9, classes = classNames(
        className,
        "navbar",
        routerPositionClass,
        {
          "navbar-hidden": hidden,
          "navbar-large": isLarge,
          "navbar-large-collapsed": isLarge && largeCollapsed,
          "navbar-transparent": isTransparent,
          "navbar-transparent-visible": isTransparentVisible,
          "navbar-master": routerNavbarRole === "master",
          "navbar-master-detail": routerNavbarRole === "detail",
          "navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
          "navbar-master-stacked": routerNavbarMasterStack === true,
          "no-shadow": noShadow,
          "no-hairline": noHairline
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/
    12845056 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/
    384) {
      $:
        $$invalidate(8, innerClasses = classNames("navbar-inner", innerClass, innerClassName, {
          sliding,
          "navbar-inner-left-title": addLeftTitleClass,
          "navbar-inner-centered-title": addCenterTitleClass
        }));
    }
  };
  $:
    $$invalidate(14, hasLeftSlots = $$slots["nav-left"] || $$slots["left"]);
  $:
    $$invalidate(13, hasRightSlots = $$slots["nav-right"] || $$slots["right"]);
  $:
    $$invalidate(12, hasTitleSlots = $$slots["title"]);
  $:
    $$invalidate(10, hasTitleLargeSlots = $$slots["title-large"]);
  $$props = exclude_internal_props($$props);
  return [
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkShowText,
    title,
    subtitle,
    f7Slot,
    el,
    innerClasses,
    classes,
    hasTitleLargeSlots,
    largeTitle,
    hasTitleSlots,
    hasRightSlots,
    hasLeftSlots,
    onBackClick,
    $$restProps,
    className,
    sliding,
    hidden,
    noShadow,
    noHairline,
    innerClass,
    innerClassName,
    large,
    largeTransparent,
    transparent,
    titleLarge,
    hide,
    show,
    size,
    theme2,
    routerPositionClass,
    largeCollapsed,
    routerNavbarRole,
    routerNavbarRoleDetailRoot,
    routerNavbarMasterStack,
    transparentVisible,
    addCenterTitleClass,
    addLeftTitleClass,
    isTransparentVisible,
    isTransparent,
    isLarge,
    slots,
    div2_binding,
    $$scope
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance64,
      create_fragment77,
      safe_not_equal,
      {
        class: 17,
        backLink: 0,
        backLinkUrl: 1,
        backLinkForce: 2,
        backLinkShowText: 3,
        sliding: 18,
        title: 4,
        subtitle: 5,
        hidden: 19,
        noShadow: 20,
        noHairline: 21,
        innerClass: 22,
        innerClassName: 23,
        large: 24,
        largeTransparent: 25,
        transparent: 26,
        titleLarge: 27,
        f7Slot: 6,
        hide: 28,
        show: 29,
        size: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment77.name
    });
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLink() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLink(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkUrl() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkUrl(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkForce() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkForce(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backLinkShowText() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backLinkShowText(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sliding() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sliding(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noShadow() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noShadow(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairline() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairline(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerClassName() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerClassName(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeTransparent() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeTransparent(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleLarge() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleLarge(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hide() {
    return this.$$.ctx[28];
  }
  set hide(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get show() {
    return this.$$.ctx[29];
  }
  set show(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    return this.$$.ctx[30];
  }
  set size(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var navbar_default = Navbar;

// node_modules/framework7-svelte/components/page-content.svelte
var file75 = "node_modules/framework7-svelte/components/page-content.svelte";
function create_if_block_314(ctx) {
  let div1;
  let preloader;
  let t;
  let div0;
  let current;
  preloader = new preloader_default({ $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(preloader.$$.fragment);
      t = space();
      div0 = element("div");
      attr_dev(div0, "class", "ptr-arrow");
      add_location(div0, file75, 127, 6, 3544);
      attr_dev(div1, "class", "ptr-preloader");
      add_location(div1, file75, 125, 4, 3490);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(preloader, div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(preloader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_314.name,
    type: "if",
    source: "(125:2) {#if ptr && ptrPreloader && !ptrBottom}",
    ctx
  });
  return block;
}
function create_if_block_218(ctx) {
  let preloader;
  let current;
  preloader = new preloader_default({
    props: { class: "infinite-scroll-preloader" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(preloader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(preloader, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_218.name,
    type: "if",
    source: "(131:2) {#if infinite && infiniteTop && infinitePreloader}",
    ctx
  });
  return block;
}
function create_if_block_139(ctx) {
  let preloader;
  let current;
  preloader = new preloader_default({
    props: { class: "infinite-scroll-preloader" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(preloader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(preloader, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(preloader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_139.name,
    type: "if",
    source: "(135:2) {#if infinite && !infiniteTop && infinitePreloader}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let div1;
  let preloader;
  let t;
  let div0;
  let current;
  preloader = new preloader_default({ $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(preloader.$$.fragment);
      t = space();
      div0 = element("div");
      attr_dev(div0, "class", "ptr-arrow");
      add_location(div0, file75, 140, 6, 3926);
      attr_dev(div1, "class", "ptr-preloader");
      add_location(div1, file75, 138, 4, 3872);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      mount_component(preloader, div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(preloader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(138:2) {#if ptr && ptrPreloader && ptrBottom}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let div_data_ptr_mousewheel_value;
  let div_data_infinite_distance_value;
  let current;
  let if_block0 = (
    /*ptr*/
    ctx[0] && /*ptrPreloader*/
    ctx[2] && !/*ptrBottom*/
    ctx[3] && create_if_block_314(ctx)
  );
  let if_block1 = (
    /*infinite*/
    ctx[5] && /*infiniteTop*/
    ctx[6] && /*infinitePreloader*/
    ctx[8] && create_if_block_218(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let if_block2 = (
    /*infinite*/
    ctx[5] && !/*infiniteTop*/
    ctx[6] && /*infinitePreloader*/
    ctx[8] && create_if_block_139(ctx)
  );
  let if_block3 = (
    /*ptr*/
    ctx[0] && /*ptrPreloader*/
    ctx[2] && /*ptrBottom*/
    ctx[3] && create_if_block29(ctx)
  );
  let div_levels = [
    { class: (
      /*pageContentClasses*/
      ctx[10]
    ) },
    {
      "data-ptr-distance": (
        /*ptrDistance*/
        ctx[1]
      )
    },
    {
      "data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/
      ctx[4] || void 0
    },
    {
      "data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/
      ctx[7] || void 0
    },
    restProps(
      /*$$restProps*/
      ctx[11]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      set_attributes(div, div_data);
      add_location(div, file75, 116, 0, 3208);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t2);
      if (if_block2)
        if_block2.m(div, null);
      append_dev(div, t3);
      if (if_block3)
        if_block3.m(div, null);
      ctx[22](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ptr*/
        ctx2[0] && /*ptrPreloader*/
        ctx2[2] && !/*ptrBottom*/
        ctx2[3]
      ) {
        if (if_block0) {
          if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/
          13) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_314(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*infinite*/
        ctx2[5] && /*infiniteTop*/
        ctx2[6] && /*infinitePreloader*/
        ctx2[8]
      ) {
        if (if_block1) {
          if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/
          352) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_218(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*infinite*/
        ctx2[5] && !/*infiniteTop*/
        ctx2[6] && /*infinitePreloader*/
        ctx2[8]
      ) {
        if (if_block2) {
          if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/
          352) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_139(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*ptr*/
        ctx2[0] && /*ptrPreloader*/
        ctx2[2] && /*ptrBottom*/
        ctx2[3]
      ) {
        if (if_block3) {
          if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/
          13) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block29(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*pageContentClasses*/
        1024) && { class: (
          /*pageContentClasses*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*ptrDistance*/
        2) && {
          "data-ptr-distance": (
            /*ptrDistance*/
            ctx2[1]
          )
        },
        (!current || dirty[0] & /*ptrMousewheel*/
        16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/
        ctx2[4] || void 0)) && {
          "data-ptr-mousewheel": div_data_ptr_mousewheel_value
        },
        (!current || dirty[0] & /*infiniteDistance*/
        128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/
        ctx2[7] || void 0)) && {
          "data-infinite-distance": div_data_infinite_distance_value
        },
        dirty[0] & /*$$restProps*/
        2048 && restProps(
          /*$$restProps*/
          ctx2[11]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let pageContentClasses;
  const omit_props_names = [
    "tab",
    "tabActive",
    "ptr",
    "ptrDistance",
    "ptrPreloader",
    "ptrBottom",
    "ptrMousewheel",
    "infinite",
    "infiniteTop",
    "infiniteDistance",
    "infinitePreloader",
    "hideBarsOnScroll",
    "hideNavbarOnScroll",
    "hideToolbarOnScroll",
    "messagesContent",
    "loginScreen",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Page_content", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { ptr = false } = $$props;
  let { ptrDistance = void 0 } = $$props;
  let { ptrPreloader = true } = $$props;
  let { ptrBottom = false } = $$props;
  let { ptrMousewheel = false } = $$props;
  let { infinite = false } = $$props;
  let { infiniteTop = false } = $$props;
  let { infiniteDistance = void 0 } = $$props;
  let { infinitePreloader = true } = $$props;
  let { hideBarsOnScroll = false } = $$props;
  let { hideNavbarOnScroll = false } = $$props;
  let { hideToolbarOnScroll = false } = $$props;
  let { messagesContent = false } = $$props;
  let { loginScreen = false } = $$props;
  let { class: className = void 0 } = $$props;
  let pageContentEl;
  function onPtrPullStart(ptrEl) {
    if (ptrEl !== pageContentEl)
      return;
    emit("ptrPullStart");
  }
  function onPtrPullMove(ptrEl) {
    if (ptrEl !== pageContentEl)
      return;
    emit("ptrPullMove");
  }
  function onPtrPullEnd(ptrEl) {
    if (ptrEl !== pageContentEl)
      return;
    emit("ptrPullEnd");
  }
  function onPtrRefresh(ptrEl, done) {
    if (ptrEl !== pageContentEl)
      return;
    emit("ptrRefresh", [done]);
  }
  function onPtrDone(ptrEl) {
    if (ptrEl !== pageContentEl)
      return;
    emit("ptrDone");
  }
  function onInfinite(infEl) {
    if (infEl !== pageContentEl)
      return;
    emit("infinite");
  }
  function mountPageContent() {
    if (ptr) {
      app.f7.on("ptrPullStart", onPtrPullStart);
      app.f7.on("ptrPullMove", onPtrPullMove);
      app.f7.on("ptrPullEnd", onPtrPullEnd);
      app.f7.on("ptrRefresh", onPtrRefresh);
      app.f7.on("ptrDone", onPtrDone);
    }
    if (infinite) {
      app.f7.on("infinite", onInfinite);
    }
  }
  function destroyPageContent() {
    if (ptr) {
      app.f7.off("ptrPullStart", onPtrPullStart);
      app.f7.off("ptrPullMove", onPtrPullMove);
      app.f7.off("ptrPullEnd", onPtrPullEnd);
      app.f7.off("ptrRefresh", onPtrRefresh);
      app.f7.off("ptrDone", onPtrDone);
    }
    if (infinite) {
      app.f7.off("infinite", onInfinite);
    }
  }
  useTab(() => pageContentEl, emit);
  onMount(() => {
    f7ready(() => {
      mountPageContent();
    });
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    destroyPageContent();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pageContentEl = $$value;
      $$invalidate(9, pageContentEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tab" in $$new_props)
      $$invalidate(12, tab = $$new_props.tab);
    if ("tabActive" in $$new_props)
      $$invalidate(13, tabActive = $$new_props.tabActive);
    if ("ptr" in $$new_props)
      $$invalidate(0, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$new_props)
      $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$new_props)
      $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$new_props)
      $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$new_props)
      $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$new_props)
      $$invalidate(5, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$new_props)
      $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$new_props)
      $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$new_props)
      $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$new_props)
      $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$new_props)
      $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$new_props)
      $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$new_props)
      $$invalidate(17, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$new_props)
      $$invalidate(18, loginScreen = $$new_props.loginScreen);
    if ("class" in $$new_props)
      $$invalidate(19, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    createEventDispatcher,
    restProps,
    colorClasses,
    classNames,
    createEmitter,
    app,
    f7ready,
    useTab,
    Preloader: preloader_default,
    emit,
    tab,
    tabActive,
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    className,
    pageContentEl,
    onPtrPullStart,
    onPtrPullMove,
    onPtrPullEnd,
    onPtrRefresh,
    onPtrDone,
    onInfinite,
    mountPageContent,
    destroyPageContent,
    pageContentClasses
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("tab" in $$props)
      $$invalidate(12, tab = $$new_props.tab);
    if ("tabActive" in $$props)
      $$invalidate(13, tabActive = $$new_props.tabActive);
    if ("ptr" in $$props)
      $$invalidate(0, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$props)
      $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$props)
      $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$props)
      $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$props)
      $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$props)
      $$invalidate(5, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$props)
      $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$props)
      $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$props)
      $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$props)
      $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$props)
      $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$props)
      $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$props)
      $$invalidate(17, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$props)
      $$invalidate(18, loginScreen = $$new_props.loginScreen);
    if ("className" in $$props)
      $$invalidate(19, className = $$new_props.className);
    if ("pageContentEl" in $$props)
      $$invalidate(9, pageContentEl = $$new_props.pageContentEl);
    if ("pageContentClasses" in $$props)
      $$invalidate(10, pageContentClasses = $$new_props.pageContentClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, pageContentClasses = classNames(
        className,
        "page-content",
        {
          tab,
          "tab-active": tabActive,
          "ptr-content": ptr,
          "ptr-bottom": ptrBottom,
          "infinite-scroll-content": infinite,
          "infinite-scroll-top": infiniteTop,
          "hide-bars-on-scroll": hideBarsOnScroll,
          "hide-navbar-on-scroll": hideNavbarOnScroll,
          "hide-toolbar-on-scroll": hideToolbarOnScroll,
          "messages-content": messagesContent,
          "login-screen-content": loginScreen
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    pageContentEl,
    pageContentClasses,
    $$restProps,
    tab,
    tabActive,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    className,
    $$scope,
    slots,
    div_binding
  ];
}
var Page_content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance65,
      create_fragment78,
      safe_not_equal,
      {
        tab: 12,
        tabActive: 13,
        ptr: 0,
        ptrDistance: 1,
        ptrPreloader: 2,
        ptrBottom: 3,
        ptrMousewheel: 4,
        infinite: 5,
        infiniteTop: 6,
        infiniteDistance: 7,
        infinitePreloader: 8,
        hideBarsOnScroll: 14,
        hideNavbarOnScroll: 15,
        hideToolbarOnScroll: 16,
        messagesContent: 17,
        loginScreen: 18,
        class: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Page_content",
      options,
      id: create_fragment78.name
    });
  }
  get tab() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabActive() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabActive(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptr() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptr(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrDistance() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrDistance(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrPreloader() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrPreloader(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrBottom() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrBottom(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrMousewheel() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrMousewheel(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinite() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinite(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteTop() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteTop(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteDistance() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteDistance(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinitePreloader() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinitePreloader(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideBarsOnScroll() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideBarsOnScroll(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideNavbarOnScroll() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideNavbarOnScroll(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideToolbarOnScroll() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideToolbarOnScroll(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messagesContent() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messagesContent(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loginScreen() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loginScreen(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var page_content_default = Page_content;

// node_modules/framework7-svelte/components/page.svelte
var file76 = "node_modules/framework7-svelte/components/page.svelte";
var get_static_slot_changes_1 = (dirty) => ({});
var get_static_slot_context_1 = (ctx) => ({});
var get_static_slot_changes2 = (dirty) => ({});
var get_static_slot_context2 = (ctx) => ({});
var get_fixed_slot_changes2 = (dirty) => ({});
var get_fixed_slot_context2 = (ctx) => ({});
function create_else_block11(ctx) {
  let t;
  let current;
  const static_slot_template = (
    /*#slots*/
    ctx[46].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    get_static_slot_context_1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[46].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    null
  );
  const block = {
    c: function create() {
      if (static_slot)
        static_slot.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (static_slot) {
        static_slot.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (static_slot) {
        if (static_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              get_static_slot_changes_1
            ),
            get_static_slot_context_1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(static_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(static_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (static_slot)
        static_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(342:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block30(ctx) {
  let pagecontent;
  let current;
  pagecontent = new page_content_default({
    props: {
      ptr: (
        /*ptr*/
        ctx[2]
      ),
      ptrDistance: (
        /*ptrDistance*/
        ctx[3]
      ),
      ptrPreloader: (
        /*ptrPreloader*/
        ctx[4]
      ),
      ptrBottom: (
        /*ptrBottom*/
        ctx[5]
      ),
      ptrMousewheel: (
        /*ptrMousewheel*/
        ctx[6]
      ),
      infinite: (
        /*infinite*/
        ctx[7]
      ),
      infiniteTop: (
        /*infiniteTop*/
        ctx[8]
      ),
      infiniteDistance: (
        /*infiniteDistance*/
        ctx[9]
      ),
      infinitePreloader: (
        /*infinitePreloader*/
        ctx[10]
      ),
      hideBarsOnScroll: (
        /*hideBarsOnScroll*/
        ctx[11]
      ),
      hideNavbarOnScroll: (
        /*hideNavbarOnScroll*/
        ctx[12]
      ),
      hideToolbarOnScroll: (
        /*hideToolbarOnScroll*/
        ctx[13]
      ),
      messagesContent: (
        /*messagesContent*/
        ctx[14]
      ),
      loginScreen: (
        /*loginScreen*/
        ctx[15]
      ),
      onPtrPullStart: (
        /*onPtrPullStart*/
        ctx[18]
      ),
      onPtrPullMove: (
        /*onPtrPullMove*/
        ctx[19]
      ),
      onPtrPullEnd: (
        /*onPtrPullEnd*/
        ctx[20]
      ),
      onPtrRefresh: (
        /*onPtrRefresh*/
        ctx[21]
      ),
      onPtrDone: (
        /*onPtrDone*/
        ctx[22]
      ),
      onInfinite: (
        /*onInfinite*/
        ctx[23]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(pagecontent.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(pagecontent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pagecontent_changes = {};
      if (dirty[0] & /*ptr*/
      4)
        pagecontent_changes.ptr = /*ptr*/
        ctx2[2];
      if (dirty[0] & /*ptrDistance*/
      8)
        pagecontent_changes.ptrDistance = /*ptrDistance*/
        ctx2[3];
      if (dirty[0] & /*ptrPreloader*/
      16)
        pagecontent_changes.ptrPreloader = /*ptrPreloader*/
        ctx2[4];
      if (dirty[0] & /*ptrBottom*/
      32)
        pagecontent_changes.ptrBottom = /*ptrBottom*/
        ctx2[5];
      if (dirty[0] & /*ptrMousewheel*/
      64)
        pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/
        ctx2[6];
      if (dirty[0] & /*infinite*/
      128)
        pagecontent_changes.infinite = /*infinite*/
        ctx2[7];
      if (dirty[0] & /*infiniteTop*/
      256)
        pagecontent_changes.infiniteTop = /*infiniteTop*/
        ctx2[8];
      if (dirty[0] & /*infiniteDistance*/
      512)
        pagecontent_changes.infiniteDistance = /*infiniteDistance*/
        ctx2[9];
      if (dirty[0] & /*infinitePreloader*/
      1024)
        pagecontent_changes.infinitePreloader = /*infinitePreloader*/
        ctx2[10];
      if (dirty[0] & /*hideBarsOnScroll*/
      2048)
        pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/
        ctx2[11];
      if (dirty[0] & /*hideNavbarOnScroll*/
      4096)
        pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/
        ctx2[12];
      if (dirty[0] & /*hideToolbarOnScroll*/
      8192)
        pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/
        ctx2[13];
      if (dirty[0] & /*messagesContent*/
      16384)
        pagecontent_changes.messagesContent = /*messagesContent*/
        ctx2[14];
      if (dirty[0] & /*loginScreen*/
      32768)
        pagecontent_changes.loginScreen = /*loginScreen*/
        ctx2[15];
      if (dirty[1] & /*$$scope*/
      131072) {
        pagecontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pagecontent.$set(pagecontent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pagecontent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pagecontent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pagecontent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(316:2) {#if pageContent}",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let t;
  let current;
  const static_slot_template = (
    /*#slots*/
    ctx[46].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    get_static_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[46].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    null
  );
  const block = {
    c: function create() {
      if (static_slot)
        static_slot.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (static_slot) {
        static_slot.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (static_slot) {
        if (static_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              get_static_slot_changes2
            ),
            get_static_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(static_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(static_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (static_slot)
        static_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(317:4) <PageContent       {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}     >",
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  const fixed_slot_template = (
    /*#slots*/
    ctx[46].fixed
  );
  const fixed_slot = create_slot(
    fixed_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    get_fixed_slot_context2
  );
  const if_block_creators = [create_if_block30, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*pageContent*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    { class: (
      /*classes*/
      ctx[17]
    ) },
    { "data-name": (
      /*name*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[24]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (fixed_slot)
        fixed_slot.c();
      t = space();
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file76, 313, 0, 9763);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (fixed_slot) {
        fixed_slot.m(div, null);
      }
      append_dev(div, t);
      if_blocks[current_block_type_index].m(div, null);
      ctx[47](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (fixed_slot) {
        if (fixed_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            fixed_slot,
            fixed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              fixed_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              get_fixed_slot_changes2
            ),
            get_fixed_slot_context2
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        131072) && { class: (
          /*classes*/
          ctx2[17]
        ) },
        (!current || dirty[0] & /*name*/
        1) && { "data-name": (
          /*name*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        16777216 && restProps(
          /*$$restProps*/
          ctx2[24]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fixed_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(fixed_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (fixed_slot)
        fixed_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[47](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let forceSubnavbar;
  let forceNavbarLarge;
  let classes;
  const omit_props_names = [
    "name",
    "stacked",
    "withSubnavbar",
    "subnavbar",
    "withNavbarLarge",
    "navbarLarge",
    "noNavbar",
    "noToolbar",
    "tabs",
    "pageContent",
    "noSwipeback",
    "ptr",
    "ptrDistance",
    "ptrPreloader",
    "ptrBottom",
    "ptrMousewheel",
    "infinite",
    "infiniteTop",
    "infiniteDistance",
    "infinitePreloader",
    "hideBarsOnScroll",
    "hideNavbarOnScroll",
    "hideToolbarOnScroll",
    "messagesContent",
    "loginScreen",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Page", slots, ["fixed", "static", "default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { name = void 0 } = $$props;
  let { stacked = void 0 } = $$props;
  let { withSubnavbar = void 0 } = $$props;
  let { subnavbar = void 0 } = $$props;
  let { withNavbarLarge = void 0 } = $$props;
  let { navbarLarge = void 0 } = $$props;
  let { noNavbar = void 0 } = $$props;
  let { noToolbar = void 0 } = $$props;
  let { tabs = void 0 } = $$props;
  let { pageContent = true } = $$props;
  let { noSwipeback = void 0 } = $$props;
  let { ptr = void 0 } = $$props;
  let { ptrDistance = void 0 } = $$props;
  let { ptrPreloader = true } = $$props;
  let { ptrBottom = void 0 } = $$props;
  let { ptrMousewheel = void 0 } = $$props;
  let { infinite = void 0 } = $$props;
  let { infiniteTop = void 0 } = $$props;
  let { infiniteDistance = void 0 } = $$props;
  let { infinitePreloader = true } = $$props;
  let { hideBarsOnScroll = void 0 } = $$props;
  let { hideNavbarOnScroll = void 0 } = $$props;
  let { hideToolbarOnScroll = void 0 } = $$props;
  let { messagesContent = void 0 } = $$props;
  let { loginScreen = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let el;
  let hasSubnavbar = false;
  let hasNavbarLarge = false;
  let hasNavbarLargeCollapsed = false;
  let hasCardExpandableOpened = false;
  let routerPositionClass = "";
  let routerForceUnstack = false;
  let routerPageRole = null;
  let routerPageRoleDetailRoot = false;
  let routerPageMasterStack = false;
  function onPtrPullStart() {
    emit("ptrPullStart");
  }
  function onPtrPullMove() {
    emit("ptrPullMove");
  }
  function onPtrPullEnd() {
    emit("ptrPullEnd");
  }
  function onPtrRefresh(done) {
    emit("ptrRefresh", [done]);
  }
  function onPtrDone() {
    emit("ptrDone");
  }
  function onInfinite() {
    emit("infinite");
  }
  function onPageMounted(page) {
    if (el !== page.el)
      return;
    emit("pageMounted", [page]);
  }
  function onPageInit(page) {
    if (el !== page.el)
      return;
    if (typeof withSubnavbar === "undefined" && typeof subnavbar === "undefined") {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length || page.$el.children(".navbar").find(".subnavbar").length) {
        $$invalidate(35, hasSubnavbar = true);
      }
    }
    if (typeof withNavbarLarge === "undefined" && typeof navbarLarge === "undefined") {
      if (page.$navbarEl && page.$navbarEl.hasClass("navbar-large") || page.$el.children(".navbar-large").length) {
        $$invalidate(36, hasNavbarLarge = true);
      }
    }
    emit("pageInit", [page]);
  }
  function onPageReinit(page) {
    if (el !== page.el)
      return;
    emit("pageReinit", [page]);
  }
  function onPageBeforeIn(page) {
    if (el !== page.el)
      return;
    if (!page.swipeBack) {
      if (page.from === "next") {
        $$invalidate(39, routerPositionClass = "page-next");
      }
      if (page.from === "previous") {
        $$invalidate(39, routerPositionClass = "page-previous");
      }
    }
    emit("pageBeforeIn", [page]);
  }
  function onPageBeforeOut(page) {
    if (el !== page.el)
      return;
    emit("pageBeforeOut", [page]);
  }
  function onPageAfterOut(page) {
    if (el !== page.el)
      return;
    if (page.to === "next") {
      $$invalidate(39, routerPositionClass = "page-next");
    }
    if (page.to === "previous") {
      $$invalidate(39, routerPositionClass = "page-previous");
    }
    emit("pageAfterOut", [page]);
  }
  function onPageAfterIn(page) {
    if (el !== page.el)
      return;
    $$invalidate(39, routerPositionClass = "page-current");
    emit("pageAfterIn", [page]);
  }
  function onPageBeforeRemove(page) {
    if (el !== page.el)
      return;
    if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
      page.$el.prepend(page.$navbarEl);
    }
    emit("pageBeforeRemove", [page]);
  }
  function onPageBeforeUnmount(page) {
    if (el !== page.el)
      return;
    emit("pageBeforeUnmount", [page]);
  }
  function onPageStack(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(40, routerForceUnstack = false);
  }
  function onPageUnstack(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(40, routerForceUnstack = true);
  }
  function onPagePosition(pageEl, position) {
    if (el !== pageEl)
      return;
    $$invalidate(39, routerPositionClass = `page-${position}`);
  }
  function onPageRole(pageEl, rolesData) {
    if (el !== pageEl)
      return;
    $$invalidate(41, routerPageRole = rolesData.role);
    $$invalidate(42, routerPageRoleDetailRoot = rolesData.detailRoot);
  }
  function onPageMasterStack(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(43, routerPageMasterStack = true);
  }
  function onPageMasterUnstack(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(43, routerPageMasterStack = false);
  }
  function onPageNavbarLargeCollapsed(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(37, hasNavbarLargeCollapsed = true);
  }
  function onPageNavbarLargeExpanded(pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(37, hasNavbarLargeCollapsed = false);
  }
  function onCardOpened(cardEl, pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(38, hasCardExpandableOpened = true);
  }
  function onCardClose(cardEl, pageEl) {
    if (el !== pageEl)
      return;
    $$invalidate(38, hasCardExpandableOpened = false);
  }
  function onPageTabShow(pageEl) {
    if (el !== pageEl)
      return;
    emit("pageTabShow");
  }
  function onPageTabHide(pageEl) {
    if (el !== pageEl)
      return;
    emit("pageTabHide");
  }
  function mountPage() {
    app.f7.on("pageMounted", onPageMounted);
    app.f7.on("pageInit", onPageInit);
    app.f7.on("pageReinit", onPageReinit);
    app.f7.on("pageBeforeIn", onPageBeforeIn);
    app.f7.on("pageBeforeOut", onPageBeforeOut);
    app.f7.on("pageAfterOut", onPageAfterOut);
    app.f7.on("pageAfterIn", onPageAfterIn);
    app.f7.on("pageBeforeRemove", onPageBeforeRemove);
    app.f7.on("pageBeforeUnmount", onPageBeforeUnmount);
    app.f7.on("pageStack", onPageStack);
    app.f7.on("pageUnstack", onPageUnstack);
    app.f7.on("pagePosition", onPagePosition);
    app.f7.on("pageRole", onPageRole);
    app.f7.on("pageMasterStack", onPageMasterStack);
    app.f7.on("pageMasterUnstack", onPageMasterUnstack);
    app.f7.on("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
    app.f7.on("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
    app.f7.on("cardOpened", onCardOpened);
    app.f7.on("cardClose", onCardClose);
    app.f7.on("pageTabShow", onPageTabShow);
    app.f7.on("pageTabHide", onPageTabHide);
  }
  function destroyPage() {
    app.f7.off("pageMounted", onPageMounted);
    app.f7.off("pageInit", onPageInit);
    app.f7.off("pageReinit", onPageReinit);
    app.f7.off("pageBeforeIn", onPageBeforeIn);
    app.f7.off("pageBeforeOut", onPageBeforeOut);
    app.f7.off("pageAfterOut", onPageAfterOut);
    app.f7.off("pageAfterIn", onPageAfterIn);
    app.f7.off("pageBeforeRemove", onPageBeforeRemove);
    app.f7.off("pageBeforeUnmount", onPageBeforeUnmount);
    app.f7.off("pageStack", onPageStack);
    app.f7.off("pageUnstack", onPageUnstack);
    app.f7.off("pagePosition", onPagePosition);
    app.f7.off("pageRole", onPageRole);
    app.f7.off("pageMasterStack", onPageMasterStack);
    app.f7.off("pageMasterUnstack", onPageMasterUnstack);
    app.f7.off("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
    app.f7.off("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
    app.f7.off("cardOpened", onCardOpened);
    app.f7.off("cardClose", onCardClose);
    app.f7.off("pageTabShow", onPageTabShow);
    app.f7.off("pageTabHide", onPageTabHide);
  }
  onMount(() => {
    f7ready(() => {
      if (el) {
        const dom7 = app.f7.$;
        const fixedEls = dom7(el).children(".page-content").children('[data-f7-slot="fixed"]');
        if (fixedEls.length) {
          for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
            dom7(el).prepend(fixedEls[i]);
          }
        }
      }
      mountPage();
    });
  });
  afterUpdate(() => {
    if (el && app.f7) {
      const dom7 = app.f7.$;
      const fixedEls = dom7(el).children(".page-content").children('[data-f7-slot="fixed"]');
      if (fixedEls.length) {
        for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
          dom7(el).prepend(fixedEls[i]);
        }
      }
    }
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    destroyPage();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(16, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("stacked" in $$new_props)
      $$invalidate(25, stacked = $$new_props.stacked);
    if ("withSubnavbar" in $$new_props)
      $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    if ("subnavbar" in $$new_props)
      $$invalidate(27, subnavbar = $$new_props.subnavbar);
    if ("withNavbarLarge" in $$new_props)
      $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    if ("navbarLarge" in $$new_props)
      $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    if ("noNavbar" in $$new_props)
      $$invalidate(30, noNavbar = $$new_props.noNavbar);
    if ("noToolbar" in $$new_props)
      $$invalidate(31, noToolbar = $$new_props.noToolbar);
    if ("tabs" in $$new_props)
      $$invalidate(32, tabs = $$new_props.tabs);
    if ("pageContent" in $$new_props)
      $$invalidate(1, pageContent = $$new_props.pageContent);
    if ("noSwipeback" in $$new_props)
      $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    if ("ptr" in $$new_props)
      $$invalidate(2, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$new_props)
      $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$new_props)
      $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$new_props)
      $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$new_props)
      $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$new_props)
      $$invalidate(7, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$new_props)
      $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$new_props)
      $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$new_props)
      $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$new_props)
      $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$new_props)
      $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$new_props)
      $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$new_props)
      $$invalidate(14, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$new_props)
      $$invalidate(15, loginScreen = $$new_props.loginScreen);
    if ("class" in $$new_props)
      $$invalidate(34, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(48, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    afterUpdate,
    onDestroy,
    createEventDispatcher,
    restProps,
    colorClasses,
    classNames,
    createEmitter,
    app,
    f7ready,
    PageContent: page_content_default,
    emit,
    name,
    stacked,
    withSubnavbar,
    subnavbar,
    withNavbarLarge,
    navbarLarge,
    noNavbar,
    noToolbar,
    tabs,
    pageContent,
    noSwipeback,
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    className,
    el,
    hasSubnavbar,
    hasNavbarLarge,
    hasNavbarLargeCollapsed,
    hasCardExpandableOpened,
    routerPositionClass,
    routerForceUnstack,
    routerPageRole,
    routerPageRoleDetailRoot,
    routerPageMasterStack,
    onPtrPullStart,
    onPtrPullMove,
    onPtrPullEnd,
    onPtrRefresh,
    onPtrDone,
    onInfinite,
    onPageMounted,
    onPageInit,
    onPageReinit,
    onPageBeforeIn,
    onPageBeforeOut,
    onPageAfterOut,
    onPageAfterIn,
    onPageBeforeRemove,
    onPageBeforeUnmount,
    onPageStack,
    onPageUnstack,
    onPagePosition,
    onPageRole,
    onPageMasterStack,
    onPageMasterUnstack,
    onPageNavbarLargeCollapsed,
    onPageNavbarLargeExpanded,
    onCardOpened,
    onCardClose,
    onPageTabShow,
    onPageTabHide,
    mountPage,
    destroyPage,
    forceNavbarLarge,
    forceSubnavbar,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
    if ("stacked" in $$props)
      $$invalidate(25, stacked = $$new_props.stacked);
    if ("withSubnavbar" in $$props)
      $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    if ("subnavbar" in $$props)
      $$invalidate(27, subnavbar = $$new_props.subnavbar);
    if ("withNavbarLarge" in $$props)
      $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    if ("navbarLarge" in $$props)
      $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    if ("noNavbar" in $$props)
      $$invalidate(30, noNavbar = $$new_props.noNavbar);
    if ("noToolbar" in $$props)
      $$invalidate(31, noToolbar = $$new_props.noToolbar);
    if ("tabs" in $$props)
      $$invalidate(32, tabs = $$new_props.tabs);
    if ("pageContent" in $$props)
      $$invalidate(1, pageContent = $$new_props.pageContent);
    if ("noSwipeback" in $$props)
      $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    if ("ptr" in $$props)
      $$invalidate(2, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$props)
      $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$props)
      $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$props)
      $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$props)
      $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$props)
      $$invalidate(7, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$props)
      $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$props)
      $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$props)
      $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$props)
      $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$props)
      $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$props)
      $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$props)
      $$invalidate(14, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$props)
      $$invalidate(15, loginScreen = $$new_props.loginScreen);
    if ("className" in $$props)
      $$invalidate(34, className = $$new_props.className);
    if ("el" in $$props)
      $$invalidate(16, el = $$new_props.el);
    if ("hasSubnavbar" in $$props)
      $$invalidate(35, hasSubnavbar = $$new_props.hasSubnavbar);
    if ("hasNavbarLarge" in $$props)
      $$invalidate(36, hasNavbarLarge = $$new_props.hasNavbarLarge);
    if ("hasNavbarLargeCollapsed" in $$props)
      $$invalidate(37, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
    if ("hasCardExpandableOpened" in $$props)
      $$invalidate(38, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
    if ("routerPositionClass" in $$props)
      $$invalidate(39, routerPositionClass = $$new_props.routerPositionClass);
    if ("routerForceUnstack" in $$props)
      $$invalidate(40, routerForceUnstack = $$new_props.routerForceUnstack);
    if ("routerPageRole" in $$props)
      $$invalidate(41, routerPageRole = $$new_props.routerPageRole);
    if ("routerPageRoleDetailRoot" in $$props)
      $$invalidate(42, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
    if ("routerPageMasterStack" in $$props)
      $$invalidate(43, routerPageMasterStack = $$new_props.routerPageMasterStack);
    if ("forceNavbarLarge" in $$props)
      $$invalidate(44, forceNavbarLarge = $$new_props.forceNavbarLarge);
    if ("forceSubnavbar" in $$props)
      $$invalidate(45, forceSubnavbar = $$new_props.forceSubnavbar);
    if ("classes" in $$props)
      $$invalidate(17, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/
    201326592 | $$self.$$.dirty[1] & /*hasSubnavbar*/
    16) {
      $:
        $$invalidate(45, forceSubnavbar = typeof subnavbar === "undefined" && typeof withSubnavbar === "undefined" ? hasSubnavbar : false);
    }
    if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/
    805306368 | $$self.$$.dirty[1] & /*hasNavbarLarge*/
    32) {
      $:
        $$invalidate(44, forceNavbarLarge = typeof navbarLarge === "undefined" && typeof withNavbarLarge === "undefined" ? hasNavbarLarge : false);
    }
    $:
      $$invalidate(17, classes = classNames(
        className,
        "page",
        routerPositionClass,
        {
          stacked: stacked && !routerForceUnstack,
          tabs,
          "page-with-subnavbar": subnavbar || withSubnavbar || forceSubnavbar,
          "page-with-navbar-large": navbarLarge || withNavbarLarge || forceNavbarLarge,
          "no-navbar": noNavbar,
          "no-toolbar": noToolbar,
          "no-swipeback": noSwipeback,
          "page-master": routerPageRole === "master",
          "page-master-detail": routerPageRole === "detail",
          "page-master-detail-root": routerPageRoleDetailRoot === true,
          "page-master-stacked": routerPageMasterStack === true,
          "page-with-navbar-large-collapsed": hasNavbarLargeCollapsed === true,
          "page-with-card-opened": hasCardExpandableOpened === true,
          "login-screen-page": loginScreen
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    pageContent,
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    el,
    classes,
    onPtrPullStart,
    onPtrPullMove,
    onPtrPullEnd,
    onPtrRefresh,
    onPtrDone,
    onInfinite,
    $$restProps,
    stacked,
    withSubnavbar,
    subnavbar,
    withNavbarLarge,
    navbarLarge,
    noNavbar,
    noToolbar,
    tabs,
    noSwipeback,
    className,
    hasSubnavbar,
    hasNavbarLarge,
    hasNavbarLargeCollapsed,
    hasCardExpandableOpened,
    routerPositionClass,
    routerForceUnstack,
    routerPageRole,
    routerPageRoleDetailRoot,
    routerPageMasterStack,
    forceNavbarLarge,
    forceSubnavbar,
    slots,
    div_binding,
    $$scope
  ];
}
var Page = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance66,
      create_fragment79,
      safe_not_equal,
      {
        name: 0,
        stacked: 25,
        withSubnavbar: 26,
        subnavbar: 27,
        withNavbarLarge: 28,
        navbarLarge: 29,
        noNavbar: 30,
        noToolbar: 31,
        tabs: 32,
        pageContent: 1,
        noSwipeback: 33,
        ptr: 2,
        ptrDistance: 3,
        ptrPreloader: 4,
        ptrBottom: 5,
        ptrMousewheel: 6,
        infinite: 7,
        infiniteTop: 8,
        infiniteDistance: 9,
        infinitePreloader: 10,
        hideBarsOnScroll: 11,
        hideNavbarOnScroll: 12,
        hideToolbarOnScroll: 13,
        messagesContent: 14,
        loginScreen: 15,
        class: 34
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Page",
      options,
      id: create_fragment79.name
    });
  }
  get name() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stacked() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stacked(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withSubnavbar() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withSubnavbar(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subnavbar() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subnavbar(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withNavbarLarge() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withNavbarLarge(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbarLarge() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbarLarge(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noNavbar() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noNavbar(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noToolbar() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noToolbar(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageContent() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageContent(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noSwipeback() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noSwipeback(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptr() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptr(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrDistance() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrDistance(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrPreloader() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrPreloader(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrBottom() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrBottom(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ptrMousewheel() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ptrMousewheel(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinite() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinite(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteTop() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteTop(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteDistance() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteDistance(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinitePreloader() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinitePreloader(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideBarsOnScroll() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideBarsOnScroll(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideNavbarOnScroll() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideNavbarOnScroll(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideToolbarOnScroll() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideToolbarOnScroll(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messagesContent() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messagesContent(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loginScreen() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loginScreen(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var page_default = Page;

// node_modules/framework7-svelte/components/photo-browser.svelte
function create_fragment80(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_114($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Photo_browser", slots, []);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { init: init2 = true } = $$props;
  let { params = void 0 } = $$props;
  let { photos = void 0 } = $$props;
  let { exposition = true } = $$props;
  let { expositionHideCaptions = false } = $$props;
  let { type = void 0 } = $$props;
  let { navbar = true } = $$props;
  let { toolbar = true } = $$props;
  let { theme: theme2 = void 0 } = $$props;
  let { captionsTheme = void 0 } = $$props;
  let { iconsColor = void 0 } = $$props;
  let { swipeToClose = true } = $$props;
  let { pageBackLinkText = void 0 } = $$props;
  let { popupCloseLinkText = void 0 } = $$props;
  let { navbarOfText = void 0 } = $$props;
  let { navbarShowCount = void 0 } = $$props;
  let { swiper = void 0 } = $$props;
  let { url = void 0 } = $$props;
  let { routableModals = false } = $$props;
  let { virtualSlides = true } = $$props;
  let { view = void 0 } = $$props;
  let { renderNavbar = void 0 } = $$props;
  let { renderToolbar = void 0 } = $$props;
  let { renderCaption = void 0 } = $$props;
  let { renderObject = void 0 } = $$props;
  let { renderLazyPhoto = void 0 } = $$props;
  let { renderPhoto = void 0 } = $$props;
  let { renderPage = void 0 } = $$props;
  let { renderPopup = void 0 } = $$props;
  let { renderStandalone = void 0 } = $$props;
  let f7PhotoBrowser;
  function instance87() {
    return f7PhotoBrowser;
  }
  function open(index) {
    return f7PhotoBrowser.open(index);
  }
  function close() {
    return f7PhotoBrowser.close();
  }
  function expositionToggle() {
    return f7PhotoBrowser.expositionToggle();
  }
  function expositionEnable() {
    return f7PhotoBrowser.expositionEnable();
  }
  function expositionDisable() {
    return f7PhotoBrowser.expositionDisable();
  }
  let initialWatched = false;
  function watchPhotos(newValue) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7PhotoBrowser)
      return;
    f7PhotoBrowser.params.photos = newValue;
    if (f7PhotoBrowser.opened && f7PhotoBrowser.swiper) {
      f7PhotoBrowser.swiper.update();
    }
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      let pbParams;
      if (typeof params !== "undefined")
        pbParams = params;
      else {
        pbParams = {
          photos,
          exposition,
          expositionHideCaptions,
          type,
          navbar,
          toolbar,
          theme: theme2,
          captionsTheme,
          iconsColor,
          swipeToClose,
          pageBackLinkText,
          popupCloseLinkText,
          navbarOfText,
          navbarShowCount,
          swiper,
          url,
          routableModals,
          virtualSlides,
          view,
          renderNavbar,
          renderToolbar,
          renderCaption,
          renderObject,
          renderLazyPhoto,
          renderPhoto,
          renderPage,
          renderPopup,
          renderStandalone
        };
      }
      Object.keys(pbParams).forEach((param) => {
        if (typeof pbParams[param] === "undefined" || pbParams[param] === "")
          delete pbParams[param];
      });
      pbParams = extend({}, pbParams, {
        on: {
          open() {
            emit("photoBrowserOpen");
          },
          close() {
            emit("photoBrowserClose");
          },
          opened() {
            emit("photoBrowserOpened");
          },
          closed() {
            emit("photoBrowserClosed");
          },
          swipeToClose() {
            emit("photoBrowserSwipeToClose");
          }
        }
      });
      f7PhotoBrowser = app.f7.photoBrowser.create(pbParams);
    });
  });
  onDestroy(() => {
    if (f7PhotoBrowser && f7PhotoBrowser.destroy) {
      f7PhotoBrowser.destroy();
      f7PhotoBrowser = null;
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("init" in $$new_props)
      $$invalidate(0, init2 = $$new_props.init);
    if ("params" in $$new_props)
      $$invalidate(1, params = $$new_props.params);
    if ("photos" in $$new_props)
      $$invalidate(2, photos = $$new_props.photos);
    if ("exposition" in $$new_props)
      $$invalidate(3, exposition = $$new_props.exposition);
    if ("expositionHideCaptions" in $$new_props)
      $$invalidate(4, expositionHideCaptions = $$new_props.expositionHideCaptions);
    if ("type" in $$new_props)
      $$invalidate(5, type = $$new_props.type);
    if ("navbar" in $$new_props)
      $$invalidate(6, navbar = $$new_props.navbar);
    if ("toolbar" in $$new_props)
      $$invalidate(7, toolbar = $$new_props.toolbar);
    if ("theme" in $$new_props)
      $$invalidate(8, theme2 = $$new_props.theme);
    if ("captionsTheme" in $$new_props)
      $$invalidate(9, captionsTheme = $$new_props.captionsTheme);
    if ("iconsColor" in $$new_props)
      $$invalidate(10, iconsColor = $$new_props.iconsColor);
    if ("swipeToClose" in $$new_props)
      $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
    if ("pageBackLinkText" in $$new_props)
      $$invalidate(12, pageBackLinkText = $$new_props.pageBackLinkText);
    if ("popupCloseLinkText" in $$new_props)
      $$invalidate(13, popupCloseLinkText = $$new_props.popupCloseLinkText);
    if ("navbarOfText" in $$new_props)
      $$invalidate(14, navbarOfText = $$new_props.navbarOfText);
    if ("navbarShowCount" in $$new_props)
      $$invalidate(15, navbarShowCount = $$new_props.navbarShowCount);
    if ("swiper" in $$new_props)
      $$invalidate(16, swiper = $$new_props.swiper);
    if ("url" in $$new_props)
      $$invalidate(17, url = $$new_props.url);
    if ("routableModals" in $$new_props)
      $$invalidate(18, routableModals = $$new_props.routableModals);
    if ("virtualSlides" in $$new_props)
      $$invalidate(19, virtualSlides = $$new_props.virtualSlides);
    if ("view" in $$new_props)
      $$invalidate(20, view = $$new_props.view);
    if ("renderNavbar" in $$new_props)
      $$invalidate(21, renderNavbar = $$new_props.renderNavbar);
    if ("renderToolbar" in $$new_props)
      $$invalidate(22, renderToolbar = $$new_props.renderToolbar);
    if ("renderCaption" in $$new_props)
      $$invalidate(23, renderCaption = $$new_props.renderCaption);
    if ("renderObject" in $$new_props)
      $$invalidate(24, renderObject = $$new_props.renderObject);
    if ("renderLazyPhoto" in $$new_props)
      $$invalidate(25, renderLazyPhoto = $$new_props.renderLazyPhoto);
    if ("renderPhoto" in $$new_props)
      $$invalidate(26, renderPhoto = $$new_props.renderPhoto);
    if ("renderPage" in $$new_props)
      $$invalidate(27, renderPage = $$new_props.renderPage);
    if ("renderPopup" in $$new_props)
      $$invalidate(28, renderPopup = $$new_props.renderPopup);
    if ("renderStandalone" in $$new_props)
      $$invalidate(29, renderStandalone = $$new_props.renderStandalone);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    extend,
    createEmitter,
    app,
    f7ready,
    emit,
    init: init2,
    params,
    photos,
    exposition,
    expositionHideCaptions,
    type,
    navbar,
    toolbar,
    theme: theme2,
    captionsTheme,
    iconsColor,
    swipeToClose,
    pageBackLinkText,
    popupCloseLinkText,
    navbarOfText,
    navbarShowCount,
    swiper,
    url,
    routableModals,
    virtualSlides,
    view,
    renderNavbar,
    renderToolbar,
    renderCaption,
    renderObject,
    renderLazyPhoto,
    renderPhoto,
    renderPage,
    renderPopup,
    renderStandalone,
    f7PhotoBrowser,
    instance: instance87,
    open,
    close,
    expositionToggle,
    expositionEnable,
    expositionDisable,
    initialWatched,
    watchPhotos
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("init" in $$props)
      $$invalidate(0, init2 = $$new_props.init);
    if ("params" in $$props)
      $$invalidate(1, params = $$new_props.params);
    if ("photos" in $$props)
      $$invalidate(2, photos = $$new_props.photos);
    if ("exposition" in $$props)
      $$invalidate(3, exposition = $$new_props.exposition);
    if ("expositionHideCaptions" in $$props)
      $$invalidate(4, expositionHideCaptions = $$new_props.expositionHideCaptions);
    if ("type" in $$props)
      $$invalidate(5, type = $$new_props.type);
    if ("navbar" in $$props)
      $$invalidate(6, navbar = $$new_props.navbar);
    if ("toolbar" in $$props)
      $$invalidate(7, toolbar = $$new_props.toolbar);
    if ("theme" in $$props)
      $$invalidate(8, theme2 = $$new_props.theme);
    if ("captionsTheme" in $$props)
      $$invalidate(9, captionsTheme = $$new_props.captionsTheme);
    if ("iconsColor" in $$props)
      $$invalidate(10, iconsColor = $$new_props.iconsColor);
    if ("swipeToClose" in $$props)
      $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
    if ("pageBackLinkText" in $$props)
      $$invalidate(12, pageBackLinkText = $$new_props.pageBackLinkText);
    if ("popupCloseLinkText" in $$props)
      $$invalidate(13, popupCloseLinkText = $$new_props.popupCloseLinkText);
    if ("navbarOfText" in $$props)
      $$invalidate(14, navbarOfText = $$new_props.navbarOfText);
    if ("navbarShowCount" in $$props)
      $$invalidate(15, navbarShowCount = $$new_props.navbarShowCount);
    if ("swiper" in $$props)
      $$invalidate(16, swiper = $$new_props.swiper);
    if ("url" in $$props)
      $$invalidate(17, url = $$new_props.url);
    if ("routableModals" in $$props)
      $$invalidate(18, routableModals = $$new_props.routableModals);
    if ("virtualSlides" in $$props)
      $$invalidate(19, virtualSlides = $$new_props.virtualSlides);
    if ("view" in $$props)
      $$invalidate(20, view = $$new_props.view);
    if ("renderNavbar" in $$props)
      $$invalidate(21, renderNavbar = $$new_props.renderNavbar);
    if ("renderToolbar" in $$props)
      $$invalidate(22, renderToolbar = $$new_props.renderToolbar);
    if ("renderCaption" in $$props)
      $$invalidate(23, renderCaption = $$new_props.renderCaption);
    if ("renderObject" in $$props)
      $$invalidate(24, renderObject = $$new_props.renderObject);
    if ("renderLazyPhoto" in $$props)
      $$invalidate(25, renderLazyPhoto = $$new_props.renderLazyPhoto);
    if ("renderPhoto" in $$props)
      $$invalidate(26, renderPhoto = $$new_props.renderPhoto);
    if ("renderPage" in $$props)
      $$invalidate(27, renderPage = $$new_props.renderPage);
    if ("renderPopup" in $$props)
      $$invalidate(28, renderPopup = $$new_props.renderPopup);
    if ("renderStandalone" in $$props)
      $$invalidate(29, renderStandalone = $$new_props.renderStandalone);
    if ("f7PhotoBrowser" in $$props)
      f7PhotoBrowser = $$new_props.f7PhotoBrowser;
    if ("initialWatched" in $$props)
      initialWatched = $$new_props.initialWatched;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*photos*/
    4) {
      $:
        watchPhotos(photos);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    init2,
    params,
    photos,
    exposition,
    expositionHideCaptions,
    type,
    navbar,
    toolbar,
    theme2,
    captionsTheme,
    iconsColor,
    swipeToClose,
    pageBackLinkText,
    popupCloseLinkText,
    navbarOfText,
    navbarShowCount,
    swiper,
    url,
    routableModals,
    virtualSlides,
    view,
    renderNavbar,
    renderToolbar,
    renderCaption,
    renderObject,
    renderLazyPhoto,
    renderPhoto,
    renderPage,
    renderPopup,
    renderStandalone,
    instance87,
    open,
    close,
    expositionToggle,
    expositionEnable,
    expositionDisable
  ];
}
var Photo_browser = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_114,
      create_fragment80,
      safe_not_equal,
      {
        init: 0,
        params: 1,
        photos: 2,
        exposition: 3,
        expositionHideCaptions: 4,
        type: 5,
        navbar: 6,
        toolbar: 7,
        theme: 8,
        captionsTheme: 9,
        iconsColor: 10,
        swipeToClose: 11,
        pageBackLinkText: 12,
        popupCloseLinkText: 13,
        navbarOfText: 14,
        navbarShowCount: 15,
        swiper: 16,
        url: 17,
        routableModals: 18,
        virtualSlides: 19,
        view: 20,
        renderNavbar: 21,
        renderToolbar: 22,
        renderCaption: 23,
        renderObject: 24,
        renderLazyPhoto: 25,
        renderPhoto: 26,
        renderPage: 27,
        renderPopup: 28,
        renderStandalone: 29,
        instance: 30,
        open: 31,
        close: 32,
        expositionToggle: 33,
        expositionEnable: 34,
        expositionDisable: 35
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Photo_browser",
      options,
      id: create_fragment80.name
    });
  }
  get init() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get params() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set params(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get photos() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set photos(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exposition() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exposition(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expositionHideCaptions() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expositionHideCaptions(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toolbar() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toolbar(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionsTheme() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionsTheme(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconsColor() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconsColor(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeToClose() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeToClose(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageBackLinkText() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageBackLinkText(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get popupCloseLinkText() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popupCloseLinkText(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbarOfText() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbarOfText(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbarShowCount() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbarShowCount(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swiper() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swiper(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routableModals() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routableModals(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualSlides() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualSlides(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get view() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set view(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderNavbar() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderNavbar(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderToolbar() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderToolbar(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderCaption() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderCaption(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderObject() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderObject(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderLazyPhoto() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderLazyPhoto(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderPhoto() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderPhoto(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderPage() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderPage(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderPopup() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderPopup(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderStandalone() {
    throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderStandalone(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[30];
  }
  set instance(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    return this.$$.ctx[31];
  }
  set open(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    return this.$$.ctx[32];
  }
  set close(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expositionToggle() {
    return this.$$.ctx[33];
  }
  set expositionToggle(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expositionEnable() {
    return this.$$.ctx[34];
  }
  set expositionEnable(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expositionDisable() {
    return this.$$.ctx[35];
  }
  set expositionDisable(value) {
    throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var photo_browser_default = Photo_browser;

// node_modules/framework7-svelte/components/pie-chart.svelte
var file77 = "node_modules/framework7-svelte/components/pie-chart.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  child_ctx[29] = i;
  return child_ctx;
}
function create_each_block4(key_1, ctx) {
  let path;
  let path_d_value;
  let path_fill_value;
  let path_data_index_value;
  let path_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[13](
        /*index*/
        ctx[29]
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[14](
        /*index*/
        ctx[29]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "d", path_d_value = /*path*/
      ctx[27].points);
      attr_dev(path, "fill", path_fill_value = /*path*/
      ctx[27].color);
      attr_dev(path, "data-index", path_data_index_value = /*index*/
      ctx[29]);
      attr_dev(path, "class", path_class_value = classNames({
        "pie-chart-hidden": (
          /*currentIndex*/
          ctx[1] !== null && /*currentIndex*/
          ctx[1] !== /*index*/
          ctx[29]
        )
      }));
      add_location(path, file77, 160, 6, 4255);
      this.first = path;
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(path, "click", click_handler, false, false, false, false),
          listen_dev(path, "mouseenter", mouseenter_handler, false, false, false, false),
          listen_dev(
            path,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*paths*/
      8 && path_d_value !== (path_d_value = /*path*/
      ctx[27].points)) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*paths*/
      8 && path_fill_value !== (path_fill_value = /*path*/
      ctx[27].color)) {
        attr_dev(path, "fill", path_fill_value);
      }
      if (dirty & /*paths*/
      8 && path_data_index_value !== (path_data_index_value = /*index*/
      ctx[29])) {
        attr_dev(path, "data-index", path_data_index_value);
      }
      if (dirty & /*currentIndex, paths*/
      10 && path_class_value !== (path_class_value = classNames({
        "pie-chart-hidden": (
          /*currentIndex*/
          ctx[1] !== null && /*currentIndex*/
          ctx[1] !== /*index*/
          ctx[29]
        )
      }))) {
        attr_dev(path, "class", path_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(160:4) {#each paths as path, index (index)}",
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let div;
  let svg;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svg_viewBox_value;
  let t;
  let current;
  let each_value = (
    /*paths*/
    ctx[3]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*index*/
    ctx2[29]
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = `-${/*size*/
      ctx[0] / 3} -${/*size*/
      ctx[0] / 3} ${/*size*/
      ctx[0] * 2 / 3} ${/*size*/
      ctx[0] * 2 / 3}`);
      set_style(svg, "transform", "rotate(-90deg)");
      add_location(svg, file77, 152, 2, 4009);
      set_attributes(div, div_data);
      add_location(div, file77, 151, 0, 3942);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[16](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*paths, classNames, currentIndex, setCurrentIndex*/
      42) {
        each_value = /*paths*/
        ctx2[3];
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svg, destroy_block, create_each_block4, null, get_each_context4);
      }
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1 && svg_viewBox_value !== (svg_viewBox_value = `-${/*size*/
      ctx2[0] / 3} -${/*size*/
      ctx2[0] / 3} ${/*size*/
      ctx2[0] * 2 / 3} ${/*size*/
      ctx2[0] * 2 / 3}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let classes;
  let paths;
  const omit_props_names = ["class", "size", "tooltip", "datasets", "formatTooltip"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pie_chart", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { size = 320 } = $$props;
  let { tooltip = false } = $$props;
  let { datasets = [] } = $$props;
  let { formatTooltip = void 0 } = $$props;
  let el;
  let currentIndex = null;
  let previousIndex = null;
  let f7Tooltip = null;
  let timeout = null;
  const setCurrentIndex = (index) => {
    if (index === null) {
      timeout = setTimeout(() => {
        previousIndex = currentIndex;
        $$invalidate(1, currentIndex = index);
      });
    } else {
      clearTimeout(timeout);
      previousIndex = currentIndex;
      $$invalidate(1, currentIndex = index);
    }
  };
  const getSummValue = () => {
    let summ = 0;
    datasets.map((d) => d.value || 0).forEach((value) => {
      summ += value;
    });
    return summ;
  };
  const getPaths = () => {
    const paths2 = [];
    let cumulativePercentage = 0;
    function getCoordinatesForPercentage(percentage) {
      const x = Math.cos(2 * Math.PI * percentage) * (size / 3);
      const y = Math.sin(2 * Math.PI * percentage) * (size / 3);
      return [x, y];
    }
    datasets.forEach(({ value, label, color }) => {
      const percentage = value / getSummValue();
      const [startX, startY] = getCoordinatesForPercentage(cumulativePercentage);
      cumulativePercentage += percentage;
      const [endX, endY] = getCoordinatesForPercentage(cumulativePercentage);
      const largeArcFlag = percentage > 0.5 ? 1 : 0;
      const points = [
        `M ${startX} ${startY}`,
        `A ${size / 3} ${size / 3} 0 ${largeArcFlag} 1 ${endX} ${endY}`,
        "L 0 0"
      ].join(" ");
      paths2.push({ points, label, color });
    });
    return paths2;
  };
  const formatTooltipText = () => {
    if (currentIndex === null)
      return "";
    const { value, label, color } = datasets[currentIndex];
    const percentage = value / getSummValue() * 100;
    const round = (v) => {
      if (parseInt(v, 10) === v)
        return v;
      return Math.round(v * 100) / 100;
    };
    if (formatTooltip) {
      return formatTooltip({
        index: currentIndex,
        value,
        label,
        color,
        percentage
      });
    }
    const tooltipText = `${label ? `${label}: ` : ""}${round(value)} (${round(percentage)}%)`;
    return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${color};"></span> ${tooltipText}
      </div>
    `;
  };
  const setTooltip = () => {
    if (currentIndex === null && !f7Tooltip)
      return;
    if (!tooltip || !el || !app.f7)
      return;
    if (currentIndex !== null && !f7Tooltip) {
      f7Tooltip = app.f7.tooltip.create({
        trigger: "manual",
        containerEl: el,
        targetEl: el.querySelector(`path[data-index="${currentIndex}"]`),
        text: formatTooltipText(),
        cssClass: "pie-chart-tooltip"
      });
      f7Tooltip.show();
      return;
    }
    if (!f7Tooltip)
      return;
    if (currentIndex !== null) {
      f7Tooltip.setText(formatTooltipText());
      f7Tooltip.setTargetEl(el.querySelector(`path[data-index="${currentIndex}"]`));
      f7Tooltip.show();
    } else {
      f7Tooltip.hide();
    }
  };
  const watchCurrentIndex = () => {
    if (currentIndex === previousIndex)
      return;
    emit("select", [currentIndex, datasets[currentIndex]]);
    setTooltip();
  };
  onDestroy(() => {
    if (f7Tooltip && f7Tooltip.destroy) {
      f7Tooltip.destroy();
    }
    f7Tooltip = null;
  });
  const click_handler = (index) => setCurrentIndex(index);
  const mouseenter_handler = (index) => setCurrentIndex(index);
  const mouseleave_handler = () => setCurrentIndex(null);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("tooltip" in $$new_props)
      $$invalidate(8, tooltip = $$new_props.tooltip);
    if ("datasets" in $$new_props)
      $$invalidate(9, datasets = $$new_props.datasets);
    if ("formatTooltip" in $$new_props)
      $$invalidate(10, formatTooltip = $$new_props.formatTooltip);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    classNames,
    createEmitter,
    restProps,
    app,
    emit,
    className,
    size,
    tooltip,
    datasets,
    formatTooltip,
    el,
    currentIndex,
    previousIndex,
    f7Tooltip,
    timeout,
    setCurrentIndex,
    getSummValue,
    getPaths,
    formatTooltipText,
    setTooltip,
    watchCurrentIndex,
    paths,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("tooltip" in $$props)
      $$invalidate(8, tooltip = $$new_props.tooltip);
    if ("datasets" in $$props)
      $$invalidate(9, datasets = $$new_props.datasets);
    if ("formatTooltip" in $$props)
      $$invalidate(10, formatTooltip = $$new_props.formatTooltip);
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("currentIndex" in $$props)
      $$invalidate(1, currentIndex = $$new_props.currentIndex);
    if ("previousIndex" in $$props)
      previousIndex = $$new_props.previousIndex;
    if ("f7Tooltip" in $$props)
      f7Tooltip = $$new_props.f7Tooltip;
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
    if ("paths" in $$props)
      $$invalidate(3, paths = $$new_props.paths);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    128) {
      $:
        $$invalidate(4, classes = classNames("pie-chart", className));
    }
    if ($$self.$$.dirty & /*datasets*/
    512) {
      $:
        $$invalidate(3, paths = getPaths(datasets));
    }
    if ($$self.$$.dirty & /*currentIndex*/
    2) {
      $:
        watchCurrentIndex(currentIndex);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    size,
    currentIndex,
    el,
    paths,
    classes,
    setCurrentIndex,
    $$restProps,
    className,
    tooltip,
    datasets,
    formatTooltip,
    $$scope,
    slots,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    div_binding
  ];
}
var Pie_chart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment81, safe_not_equal, {
      class: 7,
      size: 0,
      tooltip: 8,
      datasets: 9,
      formatTooltip: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pie_chart",
      options,
      id: create_fragment81.name
    });
  }
  get class() {
    throw new Error("<Pie_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pie_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Pie_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Pie_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<Pie_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<Pie_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get datasets() {
    throw new Error("<Pie_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set datasets(value) {
    throw new Error("<Pie_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatTooltip() {
    throw new Error("<Pie_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTooltip(value) {
    throw new Error("<Pie_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var pie_chart_default = Pie_chart;

// node_modules/framework7-svelte/components/progressbar.svelte
var file78 = "node_modules/framework7-svelte/components/progressbar.svelte";
function create_fragment82(ctx) {
  let span1;
  let span0;
  let span1_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-progress": (
      /*progress*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let span1_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span1_data = assign(span1_data, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      attr_dev(
        span0,
        "style",
        /*transformStyle*/
        ctx[2]
      );
      add_location(span0, file78, 35, 2, 896);
      set_attributes(span1, span1_data);
      add_location(span1, file78, 34, 0, 803);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, span0);
      ctx[8](span1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*transformStyle*/
      4) {
        attr_dev(
          span0,
          "style",
          /*transformStyle*/
          ctx2[2]
        );
      }
      set_attributes(span1, span1_data = get_spread_update(span1_levels, [
        dirty & /*classes*/
        8 && { class: (
          /*classes*/
          ctx2[3]
        ) },
        dirty & /*progress*/
        1 && { "data-progress": (
          /*progress*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let classes;
  let transformStyle;
  const omit_props_names = ["class", "progress", "infinite", "set"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progressbar", slots, []);
  let { class: className = void 0 } = $$props;
  let { progress = 0 } = $$props;
  let { infinite = false } = $$props;
  let el;
  function set(progress2, speed) {
    if (!app.f7)
      return;
    app.f7.progressbar.set(el, progress2, speed);
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("progress" in $$new_props)
      $$invalidate(0, progress = $$new_props.progress);
    if ("infinite" in $$new_props)
      $$invalidate(6, infinite = $$new_props.infinite);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    app,
    className,
    progress,
    infinite,
    el,
    set,
    transformStyle,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("progress" in $$props)
      $$invalidate(0, progress = $$new_props.progress);
    if ("infinite" in $$props)
      $$invalidate(6, infinite = $$new_props.infinite);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("transformStyle" in $$props)
      $$invalidate(2, transformStyle = $$new_props.transformStyle);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "progressbar", { "progressbar-infinite": infinite }, colorClasses($$props)));
    if ($$self.$$.dirty & /*progress*/
    1) {
      $:
        $$invalidate(2, transformStyle = {
          transform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : "",
          WebkitTransform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : ""
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    progress,
    el,
    transformStyle,
    classes,
    $$restProps,
    className,
    infinite,
    set,
    span1_binding
  ];
}
var Progressbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment82, safe_not_equal, {
      class: 5,
      progress: 0,
      infinite: 6,
      set: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progressbar",
      options,
      id: create_fragment82.name
    });
  }
  get class() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infinite() {
    throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infinite(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get set() {
    return this.$$.ctx[7];
  }
  set set(value) {
    throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var progressbar_default = Progressbar;

// node_modules/framework7-svelte/components/radio.svelte
var file79 = "node_modules/framework7-svelte/components/radio.svelte";
function create_fragment83(ctx) {
  let label;
  let input;
  let input_value_value;
  let t0;
  let i;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let label_levels = [{ class: (
    /*classes*/
    ctx[6]
  ) }, restProps(
    /*$$restProps*/
    ctx[8]
  )];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign(label_data, label_levels[i2]);
  }
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t0 = space();
      i = element("i");
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.value = input_value_value = typeof /*value*/
      ctx[2] === "undefined" ? "" : (
        /*value*/
        ctx[2]
      );
      input.disabled = /*disabled*/
      ctx[3];
      input.readOnly = /*readonly*/
      ctx[4];
      input.checked = /*checked*/
      ctx[0];
      add_location(input, file79, 35, 2, 825);
      attr_dev(i, "class", "icon-radio");
      add_location(i, file79, 45, 2, 1014);
      set_attributes(label, label_data);
      add_location(label, file79, 34, 0, 771);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, input);
      ctx[12](input);
      append_dev(label, t0);
      append_dev(label, i);
      append_dev(label, t1);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*onChange*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*value*/
      4 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[2] === "undefined" ? "" : (
        /*value*/
        ctx2[2]
      ))) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*readonly*/
      16) {
        prop_dev(
          input,
          "readOnly",
          /*readonly*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        256 && restProps(
          /*$$restProps*/
          ctx2[8]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[12](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "checked", "name", "value", "disabled", "readonly"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radio", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { checked = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let inputEl;
  function onChange(event) {
    emit("change", [event]);
    $$invalidate(0, checked = event.target.checked);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    emit,
    className,
    checked,
    name,
    value,
    disabled,
    readonly,
    inputEl,
    onChange,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(4, readonly = $$new_props.readonly);
    if ("inputEl" in $$props)
      $$invalidate(5, inputEl = $$new_props.inputEl);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classes = classNames(className, "radio", { disabled }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    name,
    value,
    disabled,
    readonly,
    inputEl,
    classes,
    onChange,
    $$restProps,
    className,
    $$scope,
    slots,
    input_binding
  ];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment83, safe_not_equal, {
      class: 9,
      checked: 0,
      name: 1,
      value: 2,
      disabled: 3,
      readonly: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment83.name
    });
  }
  get class() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var radio_default = Radio;

// node_modules/framework7-svelte/components/row.svelte
var file80 = "node_modules/framework7-svelte/components/row.svelte";
function create_if_block_219(ctx) {
  let p;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let if_block = (
    /*resizable*/
    ctx[1] && /*resizableHandler*/
    ctx[2] && create_if_block_315(ctx)
  );
  let p_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(p, p_data);
      add_location(p, file80, 58, 2, 1435);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      append_dev(p, t);
      if (if_block)
        if_block.m(p, null);
      ctx[14](p);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          p,
          "click",
          /*onClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*resizable*/
        ctx2[1] && /*resizableHandler*/
        ctx2[2]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_315(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[14](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_219.name,
    type: "if",
    source: "(58:22) ",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let div;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let if_block = (
    /*resizable*/
    ctx[1] && /*resizableHandler*/
    ctx[2] && create_if_block_140(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file80, 53, 2, 1228);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[13](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*onClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*resizable*/
        ctx2[1] && /*resizableHandler*/
        ctx2[2]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_140(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(53:0) {#if tag === 'div'}",
    ctx
  });
  return block;
}
function create_if_block_315(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "resize-handler");
      add_location(span, file80, 60, 39, 1569);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_315.name,
    type: "if",
    source: "(61:4) {#if resizable && resizableHandler}",
    ctx
  });
  return block;
}
function create_if_block_140(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "resize-handler");
      add_location(span, file80, 55, 39, 1364);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_140.name,
    type: "if",
    source: "(56:4) {#if resizable && resizableHandler}",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_if_block_219];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "div"
    )
      return 0;
    if (
      /*tag*/
      ctx2[0] === "p"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "noGap",
    "tag",
    "resizable",
    "resizableFixed",
    "resizableAbsolute",
    "resizableHandler"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { noGap = false } = $$props;
  let { tag = "div" } = $$props;
  let { resizable = false } = $$props;
  let { resizableFixed = false } = $$props;
  let { resizableAbsolute = false } = $$props;
  let { resizableHandler = true } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function onResize(targetEl) {
    if (el !== targetEl)
      return;
    emit("gridResize");
  }
  onMount(() => {
    f7ready(() => {
      app.f7.on("gridResize", onResize);
    });
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    app.f7.off("gridResize", onResize);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function p_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("noGap" in $$new_props)
      $$invalidate(8, noGap = $$new_props.noGap);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("resizable" in $$new_props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("resizableFixed" in $$new_props)
      $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
    if ("resizableAbsolute" in $$new_props)
      $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
    if ("resizableHandler" in $$new_props)
      $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    noGap,
    tag,
    resizable,
    resizableFixed,
    resizableAbsolute,
    resizableHandler,
    el,
    onClick,
    onResize,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("noGap" in $$props)
      $$invalidate(8, noGap = $$new_props.noGap);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("resizable" in $$props)
      $$invalidate(1, resizable = $$new_props.resizable);
    if ("resizableFixed" in $$props)
      $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
    if ("resizableAbsolute" in $$props)
      $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
    if ("resizableHandler" in $$props)
      $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classes = classNames(
        className,
        "row",
        {
          "no-gap": noGap,
          resizable,
          "resizable-fixed": resizableFixed,
          "resizable-absolute": resizableAbsolute
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    tag,
    resizable,
    resizableHandler,
    el,
    classes,
    onClick,
    $$restProps,
    className,
    noGap,
    resizableFixed,
    resizableAbsolute,
    $$scope,
    slots,
    div_binding,
    p_binding
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment84, safe_not_equal, {
      class: 7,
      noGap: 8,
      tag: 0,
      resizable: 1,
      resizableFixed: 9,
      resizableAbsolute: 10,
      resizableHandler: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment84.name
    });
  }
  get class() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGap() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGap(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableFixed() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableFixed(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableAbsolute() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableAbsolute(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizableHandler() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizableHandler(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var row_default = Row;

// node_modules/framework7-svelte/components/searchbar.svelte
var file81 = "node_modules/framework7-svelte/components/searchbar.svelte";
var get_after_inner_slot_changes_12 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_after_inner_slot_context_12 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_default_slot_changes_1 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_default_slot_context_1 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_inner_end_slot_changes_13 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_inner_end_slot_context_13 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_input_wrap_end_slot_changes_1 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_input_wrap_end_slot_context_1 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_input_wrap_start_slot_changes_1 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_input_wrap_start_slot_context_1 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_inner_start_slot_changes_13 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_inner_start_slot_context_13 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_before_inner_slot_changes_1 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_before_inner_slot_context_1 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_after_inner_slot_changes4 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_after_inner_slot_context4 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_default_slot_changes13 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_default_slot_context13 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_inner_end_slot_changes4 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_inner_end_slot_context4 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_input_wrap_end_slot_changes = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_input_wrap_end_slot_context = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_input_wrap_start_slot_changes = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_input_wrap_start_slot_context = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_inner_start_slot_changes4 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_inner_start_slot_context4 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
var get_before_inner_slot_changes4 = (dirty) => ({
  searchbar: dirty[0] & /*f7Searchbar*/
  4096
});
var get_before_inner_slot_context4 = (ctx) => ({ searchbar: (
  /*f7Searchbar*/
  ctx[12]
) });
function create_else_block12(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let input;
  let input_value_value;
  let t3;
  let i;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let current;
  let mounted;
  let dispose;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[52]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_before_inner_slot_context_1
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[52]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_inner_start_slot_context_13
  );
  const input_wrap_start_slot_template = (
    /*#slots*/
    ctx[52]["input-wrap-start"]
  );
  const input_wrap_start_slot = create_slot(
    input_wrap_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_input_wrap_start_slot_context_1
  );
  let if_block0 = (
    /*clearButton*/
    ctx[9] && create_if_block_412(ctx)
  );
  const input_wrap_end_slot_template = (
    /*#slots*/
    ctx[52]["input-wrap-end"]
  );
  const input_wrap_end_slot = create_slot(
    input_wrap_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_input_wrap_end_slot_context_1
  );
  let if_block1 = (
    /*disableButton*/
    ctx[7] && create_if_block_316(ctx)
  );
  const inner_end_slot_template = (
    /*#slots*/
    ctx[52]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_inner_end_slot_context_13
  );
  const default_slot_template = (
    /*#slots*/
    ctx[52].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_default_slot_context_1
  );
  const after_inner_slot_template = (
    /*#slots*/
    ctx[52]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_after_inner_slot_context_12
  );
  let div2_levels = [
    { class: (
      /*classes*/
      ctx[13]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[10]
    ) },
    restProps(
      /*$$restProps*/
      ctx[21]
    )
  ];
  let div2_data = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div2_data = assign(div2_data, div2_levels[i2]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (before_inner_slot)
        before_inner_slot.c();
      t0 = space();
      div1 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t1 = space();
      div0 = element("div");
      if (input_wrap_start_slot)
        input_wrap_start_slot.c();
      t2 = space();
      input = element("input");
      t3 = space();
      i = element("i");
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (input_wrap_end_slot)
        input_wrap_end_slot.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t8 = space();
      if (default_slot)
        default_slot.c();
      t9 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      );
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      attr_dev(
        input,
        "autocomplete",
        /*autocomplete*/
        ctx[3]
      );
      attr_dev(
        input,
        "autocorrect",
        /*autocorrect*/
        ctx[4]
      );
      attr_dev(
        input,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr_dev(
        input,
        "spellcheck",
        /*spellcheck*/
        ctx[6]
      );
      attr_dev(input, "type", "search");
      add_location(input, file81, 222, 8, 6155);
      attr_dev(i, "class", "searchbar-icon");
      add_location(i, file81, 235, 8, 6504);
      attr_dev(div0, "class", "searchbar-input-wrap");
      add_location(div0, file81, 220, 6, 6047);
      attr_dev(div1, "class", "searchbar-inner");
      add_location(div1, file81, 218, 4, 5953);
      set_attributes(div2, div2_data);
      add_location(div2, file81, 216, 2, 5805);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (before_inner_slot) {
        before_inner_slot.m(div2, null);
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      if (inner_start_slot) {
        inner_start_slot.m(div1, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      if (input_wrap_start_slot) {
        input_wrap_start_slot.m(div0, null);
      }
      append_dev(div0, t2);
      append_dev(div0, input);
      append_dev(div0, t3);
      append_dev(div0, i);
      append_dev(div0, t4);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t5);
      if (input_wrap_end_slot) {
        input_wrap_end_slot.m(div0, null);
      }
      append_dev(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t7);
      if (inner_end_slot) {
        inner_end_slot.m(div1, null);
      }
      append_dev(div1, t8);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div2, t9);
      if (after_inner_slot) {
        after_inner_slot.m(div2, null);
      }
      ctx[54](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*onFocus*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onBlur*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_before_inner_slot_changes_1
            ),
            get_before_inner_slot_context_1
          );
        }
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_inner_start_slot_changes_13
            ),
            get_inner_start_slot_context_13
          );
        }
      }
      if (input_wrap_start_slot) {
        if (input_wrap_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_wrap_start_slot,
            input_wrap_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              input_wrap_start_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_input_wrap_start_slot_changes_1
            ),
            get_input_wrap_start_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*value*/
      1 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[0] === "undefined" ? "" : (
        /*value*/
        ctx2[0]
      )) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty[0] & /*placeholder*/
      4) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*autocomplete*/
      8) {
        attr_dev(
          input,
          "autocomplete",
          /*autocomplete*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*autocorrect*/
      16) {
        attr_dev(
          input,
          "autocorrect",
          /*autocorrect*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*autocapitalize*/
      32) {
        attr_dev(
          input,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*spellcheck*/
      64) {
        attr_dev(
          input,
          "spellcheck",
          /*spellcheck*/
          ctx2[6]
        );
      }
      if (
        /*clearButton*/
        ctx2[9]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_412(ctx2);
          if_block0.c();
          if_block0.m(div0, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (input_wrap_end_slot) {
        if (input_wrap_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_wrap_end_slot,
            input_wrap_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              input_wrap_end_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_input_wrap_end_slot_changes_1
            ),
            get_input_wrap_end_slot_context_1
          );
        }
      }
      if (
        /*disableButton*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_316(ctx2);
          if_block1.c();
          if_block1.m(div1, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_inner_end_slot_changes_13
            ),
            get_inner_end_slot_context_13
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_after_inner_slot_changes_12
            ),
            get_after_inner_slot_context_12
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*classes*/
        8192) && { class: (
          /*classes*/
          ctx2[13]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        1024) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[10]
        ) },
        dirty[0] & /*$$restProps*/
        2097152 && restProps(
          /*$$restProps*/
          ctx2[21]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(inner_start_slot, local);
      transition_in(input_wrap_start_slot, local);
      transition_in(input_wrap_end_slot, local);
      transition_in(inner_end_slot, local);
      transition_in(default_slot, local);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(inner_start_slot, local);
      transition_out(input_wrap_start_slot, local);
      transition_out(input_wrap_end_slot, local);
      transition_out(inner_end_slot, local);
      transition_out(default_slot, local);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if (input_wrap_start_slot)
        input_wrap_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (input_wrap_end_slot)
        input_wrap_end_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (after_inner_slot)
        after_inner_slot.d(detaching);
      ctx[54](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(216:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let form_1;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let input;
  let input_value_value;
  let t3;
  let i;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let current;
  let mounted;
  let dispose;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[52]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_before_inner_slot_context4
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[52]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_inner_start_slot_context4
  );
  const input_wrap_start_slot_template = (
    /*#slots*/
    ctx[52]["input-wrap-start"]
  );
  const input_wrap_start_slot = create_slot(
    input_wrap_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_input_wrap_start_slot_context
  );
  let if_block0 = (
    /*clearButton*/
    ctx[9] && create_if_block_220(ctx)
  );
  const input_wrap_end_slot_template = (
    /*#slots*/
    ctx[52]["input-wrap-end"]
  );
  const input_wrap_end_slot = create_slot(
    input_wrap_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_input_wrap_end_slot_context
  );
  let if_block1 = (
    /*disableButton*/
    ctx[7] && create_if_block_141(ctx)
  );
  const inner_end_slot_template = (
    /*#slots*/
    ctx[52]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_inner_end_slot_context4
  );
  const default_slot_template = (
    /*#slots*/
    ctx[52].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_default_slot_context13
  );
  const after_inner_slot_template = (
    /*#slots*/
    ctx[52]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[51],
    get_after_inner_slot_context4
  );
  let form_1_levels = [
    { class: (
      /*classes*/
      ctx[13]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[10]
    ) },
    restProps(
      /*$$restProps*/
      ctx[21]
    )
  ];
  let form_1_data = {};
  for (let i2 = 0; i2 < form_1_levels.length; i2 += 1) {
    form_1_data = assign(form_1_data, form_1_levels[i2]);
  }
  const block = {
    c: function create() {
      form_1 = element("form");
      if (before_inner_slot)
        before_inner_slot.c();
      t0 = space();
      div1 = element("div");
      if (inner_start_slot)
        inner_start_slot.c();
      t1 = space();
      div0 = element("div");
      if (input_wrap_start_slot)
        input_wrap_start_slot.c();
      t2 = space();
      input = element("input");
      t3 = space();
      i = element("i");
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (input_wrap_end_slot)
        input_wrap_end_slot.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (inner_end_slot)
        inner_end_slot.c();
      t8 = space();
      if (default_slot)
        default_slot.c();
      t9 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      );
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      attr_dev(
        input,
        "autocomplete",
        /*autocomplete*/
        ctx[3]
      );
      attr_dev(
        input,
        "autocorrect",
        /*autocorrect*/
        ctx[4]
      );
      attr_dev(
        input,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr_dev(
        input,
        "spellcheck",
        /*spellcheck*/
        ctx[6]
      );
      attr_dev(input, "type", "search");
      add_location(input, file81, 188, 8, 4909);
      attr_dev(i, "class", "searchbar-icon");
      add_location(i, file81, 201, 8, 5258);
      attr_dev(div0, "class", "searchbar-input-wrap");
      add_location(div0, file81, 186, 6, 4801);
      attr_dev(div1, "class", "searchbar-inner");
      add_location(div1, file81, 184, 4, 4707);
      set_attributes(form_1, form_1_data);
      add_location(form_1, file81, 176, 2, 4514);
    },
    m: function mount(target, anchor) {
      insert_dev(target, form_1, anchor);
      if (before_inner_slot) {
        before_inner_slot.m(form_1, null);
      }
      append_dev(form_1, t0);
      append_dev(form_1, div1);
      if (inner_start_slot) {
        inner_start_slot.m(div1, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      if (input_wrap_start_slot) {
        input_wrap_start_slot.m(div0, null);
      }
      append_dev(div0, t2);
      append_dev(div0, input);
      append_dev(div0, t3);
      append_dev(div0, i);
      append_dev(div0, t4);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t5);
      if (input_wrap_end_slot) {
        input_wrap_end_slot.m(div0, null);
      }
      append_dev(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t7);
      if (inner_end_slot) {
        inner_end_slot.m(div1, null);
      }
      append_dev(div1, t8);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(form_1, t9);
      if (after_inner_slot) {
        after_inner_slot.m(form_1, null);
      }
      ctx[53](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*onFocus*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onBlur*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form_1,
            "submit",
            /*onSubmit*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_before_inner_slot_changes4
            ),
            get_before_inner_slot_context4
          );
        }
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_inner_start_slot_changes4
            ),
            get_inner_start_slot_context4
          );
        }
      }
      if (input_wrap_start_slot) {
        if (input_wrap_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_wrap_start_slot,
            input_wrap_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              input_wrap_start_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_input_wrap_start_slot_changes
            ),
            get_input_wrap_start_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*value*/
      1 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[0] === "undefined" ? "" : (
        /*value*/
        ctx2[0]
      )) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty[0] & /*placeholder*/
      4) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*autocomplete*/
      8) {
        attr_dev(
          input,
          "autocomplete",
          /*autocomplete*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*autocorrect*/
      16) {
        attr_dev(
          input,
          "autocorrect",
          /*autocorrect*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*autocapitalize*/
      32) {
        attr_dev(
          input,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*spellcheck*/
      64) {
        attr_dev(
          input,
          "spellcheck",
          /*spellcheck*/
          ctx2[6]
        );
      }
      if (
        /*clearButton*/
        ctx2[9]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_220(ctx2);
          if_block0.c();
          if_block0.m(div0, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (input_wrap_end_slot) {
        if (input_wrap_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_wrap_end_slot,
            input_wrap_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              input_wrap_end_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_input_wrap_end_slot_changes
            ),
            get_input_wrap_end_slot_context
          );
        }
      }
      if (
        /*disableButton*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_141(ctx2);
          if_block1.c();
          if_block1.m(div1, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_inner_end_slot_changes4
            ),
            get_inner_end_slot_context4
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/
        4096 | dirty[1] & /*$$scope*/
        1048576)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[51],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[51]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[51],
              dirty,
              get_after_inner_slot_changes4
            ),
            get_after_inner_slot_context4
          );
        }
      }
      set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
        (!current || dirty[0] & /*classes*/
        8192) && { class: (
          /*classes*/
          ctx2[13]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        1024) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[10]
        ) },
        dirty[0] & /*$$restProps*/
        2097152 && restProps(
          /*$$restProps*/
          ctx2[21]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(inner_start_slot, local);
      transition_in(input_wrap_start_slot, local);
      transition_in(input_wrap_end_slot, local);
      transition_in(inner_end_slot, local);
      transition_in(default_slot, local);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(inner_start_slot, local);
      transition_out(input_wrap_start_slot, local);
      transition_out(input_wrap_end_slot, local);
      transition_out(inner_end_slot, local);
      transition_out(default_slot, local);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form_1);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if (inner_start_slot)
        inner_start_slot.d(detaching);
      if (input_wrap_start_slot)
        input_wrap_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (input_wrap_end_slot)
        input_wrap_end_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (inner_end_slot)
        inner_end_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (after_inner_slot)
        after_inner_slot.d(detaching);
      ctx[53](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(176:0) {#if form}",
    ctx
  });
  return block;
}
function create_if_block_412(ctx) {
  let span;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "input-clear-button");
      add_location(span, file81, 236, 25, 6558);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onClearButtonClick*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_412.name,
    type: "if",
    source: "(237:8) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_316(ctx) {
  let span;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*disableButtonText*/
        ctx[8]
      );
      attr_dev(span, "class", "searchbar-disable-button");
      add_location(span, file81, 240, 8, 6739);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onDisableButtonClick*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*disableButtonText*/
      256)
        set_data_dev(
          t,
          /*disableButtonText*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_316.name,
    type: "if",
    source: "(240:6) {#if disableButton}",
    ctx
  });
  return block;
}
function create_if_block_220(ctx) {
  let span;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "input-clear-button");
      add_location(span, file81, 202, 25, 5312);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onClearButtonClick*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_220.name,
    type: "if",
    source: "(203:8) {#if clearButton}",
    ctx
  });
  return block;
}
function create_if_block_141(ctx) {
  let span;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*disableButtonText*/
        ctx[8]
      );
      attr_dev(span, "class", "searchbar-disable-button");
      add_location(span, file81, 206, 8, 5493);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onDisableButtonClick*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*disableButtonText*/
      256)
        set_data_dev(
          t,
          /*disableButtonText*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_141.name,
    type: "if",
    source: "(206:6) {#if disableButton}",
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block32, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*form*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_115($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "noShadow",
    "noHairline",
    "form",
    "placeholder",
    "autocomplete",
    "autocorrect",
    "autocapitalize",
    "spellcheck",
    "disableButton",
    "disableButtonText",
    "clearButton",
    "value",
    "inputEvents",
    "expandable",
    "inline",
    "searchContainer",
    "searchIn",
    "searchItem",
    "searchGroup",
    "searchGroupTitle",
    "foundEl",
    "notFoundEl",
    "backdrop",
    "backdropEl",
    "hideOnEnableEl",
    "hideOnSearchEl",
    "ignore",
    "customSearch",
    "removeDiacritics",
    "hideDividers",
    "hideGroups",
    "init",
    "f7Slot",
    "instance",
    "search",
    "enable",
    "disable",
    "toggle",
    "clear"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Searchbar", slots, [
    "before-inner",
    "inner-start",
    "input-wrap-start",
    "input-wrap-end",
    "inner-end",
    "default",
    "after-inner"
  ]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { noShadow = false } = $$props;
  let { noHairline = false } = $$props;
  let { form = true } = $$props;
  let { placeholder = "Search" } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocorrect = void 0 } = $$props;
  let { autocapitalize = void 0 } = $$props;
  let { spellcheck = void 0 } = $$props;
  let { disableButton = true } = $$props;
  let { disableButtonText = "Cancel" } = $$props;
  let { clearButton = true } = $$props;
  let { value = void 0 } = $$props;
  let { inputEvents = "change input compositionend" } = $$props;
  let { expandable = false } = $$props;
  let { inline = false } = $$props;
  let { searchContainer = void 0 } = $$props;
  let { searchIn = ".item-title" } = $$props;
  let { searchItem = "li" } = $$props;
  let { searchGroup = ".list-group" } = $$props;
  let { searchGroupTitle = ".item-divider, .list-group-title" } = $$props;
  let { foundEl = ".searchbar-found" } = $$props;
  let { notFoundEl = ".searchbar-not-found" } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { hideOnEnableEl = ".searchbar-hide-on-enable" } = $$props;
  let { hideOnSearchEl = ".searchbar-hide-on-search" } = $$props;
  let { ignore = ".searchbar-ignore" } = $$props;
  let { customSearch = false } = $$props;
  let { removeDiacritics = false } = $$props;
  let { hideDividers = true } = $$props;
  let { hideGroups = true } = $$props;
  let { init: init2 = true } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let f7Searchbar;
  function instance87() {
    return f7Searchbar;
  }
  function search(query) {
    if (!f7Searchbar)
      return void 0;
    return f7Searchbar.search(query);
  }
  function enable() {
    if (!f7Searchbar)
      return void 0;
    return f7Searchbar.enable();
  }
  function disable() {
    if (!f7Searchbar)
      return void 0;
    return f7Searchbar.disable();
  }
  function toggle() {
    if (!f7Searchbar)
      return void 0;
    return f7Searchbar.toggle();
  }
  function clear() {
    if (!f7Searchbar)
      return void 0;
    return f7Searchbar.clear();
  }
  function onChange(event) {
    emit("change", [event]);
  }
  function onInput(event) {
    emit("input", [event]);
    $$invalidate(0, value = event.target.value);
  }
  function onFocus(event) {
    emit("focus", [event]);
  }
  function onBlur(event) {
    emit("blur", [event]);
  }
  function onSubmit(event) {
    emit("submit", [event]);
  }
  function onClearButtonClick(event) {
    emit("click:clear", [event]);
  }
  function onDisableButtonClick(event) {
    emit("click:disable", [event]);
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      const params = noUndefinedProps({
        el,
        inputEvents,
        searchContainer,
        searchIn,
        searchItem,
        searchGroup,
        searchGroupTitle,
        hideOnEnableEl,
        hideOnSearchEl,
        foundEl,
        notFoundEl,
        backdrop,
        backdropEl,
        disableButton,
        ignore,
        customSearch,
        removeDiacritics,
        hideDividers,
        hideGroups,
        expandable,
        inline,
        on: {
          search(searchbar, query, previousQuery) {
            emit("searchbarSearch", [searchbar, query, previousQuery]);
          },
          clear(searchbar, previousQuery) {
            emit("searchbarClear", [searchbar, previousQuery]);
          },
          enable(searchbar) {
            emit("searchbarEnable", [searchbar]);
          },
          disable(searchbar) {
            emit("searchbarDisable", [searchbar]);
          }
        }
      });
      Object.keys(params).forEach((key) => {
        if (params[key] === "") {
          delete params[key];
        }
      });
      $$invalidate(12, f7Searchbar = app.f7.searchbar.create(params));
    });
  });
  onDestroy(() => {
    if (f7Searchbar && f7Searchbar.destroy) {
      f7Searchbar.destroy();
      $$invalidate(12, f7Searchbar = null);
    }
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(11, el);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(11, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(56, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(22, className = $$new_props.class);
    if ("noShadow" in $$new_props)
      $$invalidate(23, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$new_props)
      $$invalidate(24, noHairline = $$new_props.noHairline);
    if ("form" in $$new_props)
      $$invalidate(1, form = $$new_props.form);
    if ("placeholder" in $$new_props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$new_props)
      $$invalidate(3, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$new_props)
      $$invalidate(4, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$new_props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$new_props)
      $$invalidate(6, spellcheck = $$new_props.spellcheck);
    if ("disableButton" in $$new_props)
      $$invalidate(7, disableButton = $$new_props.disableButton);
    if ("disableButtonText" in $$new_props)
      $$invalidate(8, disableButtonText = $$new_props.disableButtonText);
    if ("clearButton" in $$new_props)
      $$invalidate(9, clearButton = $$new_props.clearButton);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("inputEvents" in $$new_props)
      $$invalidate(25, inputEvents = $$new_props.inputEvents);
    if ("expandable" in $$new_props)
      $$invalidate(26, expandable = $$new_props.expandable);
    if ("inline" in $$new_props)
      $$invalidate(27, inline = $$new_props.inline);
    if ("searchContainer" in $$new_props)
      $$invalidate(28, searchContainer = $$new_props.searchContainer);
    if ("searchIn" in $$new_props)
      $$invalidate(29, searchIn = $$new_props.searchIn);
    if ("searchItem" in $$new_props)
      $$invalidate(30, searchItem = $$new_props.searchItem);
    if ("searchGroup" in $$new_props)
      $$invalidate(31, searchGroup = $$new_props.searchGroup);
    if ("searchGroupTitle" in $$new_props)
      $$invalidate(32, searchGroupTitle = $$new_props.searchGroupTitle);
    if ("foundEl" in $$new_props)
      $$invalidate(33, foundEl = $$new_props.foundEl);
    if ("notFoundEl" in $$new_props)
      $$invalidate(34, notFoundEl = $$new_props.notFoundEl);
    if ("backdrop" in $$new_props)
      $$invalidate(35, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props)
      $$invalidate(36, backdropEl = $$new_props.backdropEl);
    if ("hideOnEnableEl" in $$new_props)
      $$invalidate(37, hideOnEnableEl = $$new_props.hideOnEnableEl);
    if ("hideOnSearchEl" in $$new_props)
      $$invalidate(38, hideOnSearchEl = $$new_props.hideOnSearchEl);
    if ("ignore" in $$new_props)
      $$invalidate(39, ignore = $$new_props.ignore);
    if ("customSearch" in $$new_props)
      $$invalidate(40, customSearch = $$new_props.customSearch);
    if ("removeDiacritics" in $$new_props)
      $$invalidate(41, removeDiacritics = $$new_props.removeDiacritics);
    if ("hideDividers" in $$new_props)
      $$invalidate(42, hideDividers = $$new_props.hideDividers);
    if ("hideGroups" in $$new_props)
      $$invalidate(43, hideGroups = $$new_props.hideGroups);
    if ("init" in $$new_props)
      $$invalidate(44, init2 = $$new_props.init);
    if ("f7Slot" in $$new_props)
      $$invalidate(10, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(51, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    noUndefinedProps,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    noShadow,
    noHairline,
    form,
    placeholder,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    disableButton,
    disableButtonText,
    clearButton,
    value,
    inputEvents,
    expandable,
    inline,
    searchContainer,
    searchIn,
    searchItem,
    searchGroup,
    searchGroupTitle,
    foundEl,
    notFoundEl,
    backdrop,
    backdropEl,
    hideOnEnableEl,
    hideOnSearchEl,
    ignore,
    customSearch,
    removeDiacritics,
    hideDividers,
    hideGroups,
    init: init2,
    f7Slot,
    el,
    f7Searchbar,
    instance: instance87,
    search,
    enable,
    disable,
    toggle,
    clear,
    onChange,
    onInput,
    onFocus,
    onBlur,
    onSubmit,
    onClearButtonClick,
    onDisableButtonClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(56, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(22, className = $$new_props.className);
    if ("noShadow" in $$props)
      $$invalidate(23, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$props)
      $$invalidate(24, noHairline = $$new_props.noHairline);
    if ("form" in $$props)
      $$invalidate(1, form = $$new_props.form);
    if ("placeholder" in $$props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$props)
      $$invalidate(3, autocomplete = $$new_props.autocomplete);
    if ("autocorrect" in $$props)
      $$invalidate(4, autocorrect = $$new_props.autocorrect);
    if ("autocapitalize" in $$props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("spellcheck" in $$props)
      $$invalidate(6, spellcheck = $$new_props.spellcheck);
    if ("disableButton" in $$props)
      $$invalidate(7, disableButton = $$new_props.disableButton);
    if ("disableButtonText" in $$props)
      $$invalidate(8, disableButtonText = $$new_props.disableButtonText);
    if ("clearButton" in $$props)
      $$invalidate(9, clearButton = $$new_props.clearButton);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("inputEvents" in $$props)
      $$invalidate(25, inputEvents = $$new_props.inputEvents);
    if ("expandable" in $$props)
      $$invalidate(26, expandable = $$new_props.expandable);
    if ("inline" in $$props)
      $$invalidate(27, inline = $$new_props.inline);
    if ("searchContainer" in $$props)
      $$invalidate(28, searchContainer = $$new_props.searchContainer);
    if ("searchIn" in $$props)
      $$invalidate(29, searchIn = $$new_props.searchIn);
    if ("searchItem" in $$props)
      $$invalidate(30, searchItem = $$new_props.searchItem);
    if ("searchGroup" in $$props)
      $$invalidate(31, searchGroup = $$new_props.searchGroup);
    if ("searchGroupTitle" in $$props)
      $$invalidate(32, searchGroupTitle = $$new_props.searchGroupTitle);
    if ("foundEl" in $$props)
      $$invalidate(33, foundEl = $$new_props.foundEl);
    if ("notFoundEl" in $$props)
      $$invalidate(34, notFoundEl = $$new_props.notFoundEl);
    if ("backdrop" in $$props)
      $$invalidate(35, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$props)
      $$invalidate(36, backdropEl = $$new_props.backdropEl);
    if ("hideOnEnableEl" in $$props)
      $$invalidate(37, hideOnEnableEl = $$new_props.hideOnEnableEl);
    if ("hideOnSearchEl" in $$props)
      $$invalidate(38, hideOnSearchEl = $$new_props.hideOnSearchEl);
    if ("ignore" in $$props)
      $$invalidate(39, ignore = $$new_props.ignore);
    if ("customSearch" in $$props)
      $$invalidate(40, customSearch = $$new_props.customSearch);
    if ("removeDiacritics" in $$props)
      $$invalidate(41, removeDiacritics = $$new_props.removeDiacritics);
    if ("hideDividers" in $$props)
      $$invalidate(42, hideDividers = $$new_props.hideDividers);
    if ("hideGroups" in $$props)
      $$invalidate(43, hideGroups = $$new_props.hideGroups);
    if ("init" in $$props)
      $$invalidate(44, init2 = $$new_props.init);
    if ("f7Slot" in $$props)
      $$invalidate(10, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(11, el = $$new_props.el);
    if ("f7Searchbar" in $$props)
      $$invalidate(12, f7Searchbar = $$new_props.f7Searchbar);
    if ("classes" in $$props)
      $$invalidate(13, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(13, classes = classNames(
        className,
        "searchbar",
        {
          "searchbar-inline": inline,
          "no-shadow": noShadow,
          "no-hairline": noHairline,
          "searchbar-expandable": expandable
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    form,
    placeholder,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    disableButton,
    disableButtonText,
    clearButton,
    f7Slot,
    el,
    f7Searchbar,
    classes,
    onChange,
    onInput,
    onFocus,
    onBlur,
    onSubmit,
    onClearButtonClick,
    onDisableButtonClick,
    $$restProps,
    className,
    noShadow,
    noHairline,
    inputEvents,
    expandable,
    inline,
    searchContainer,
    searchIn,
    searchItem,
    searchGroup,
    searchGroupTitle,
    foundEl,
    notFoundEl,
    backdrop,
    backdropEl,
    hideOnEnableEl,
    hideOnSearchEl,
    ignore,
    customSearch,
    removeDiacritics,
    hideDividers,
    hideGroups,
    init2,
    instance87,
    search,
    enable,
    disable,
    toggle,
    clear,
    $$scope,
    slots,
    form_1_binding,
    div2_binding
  ];
}
var Searchbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_115,
      create_fragment85,
      safe_not_equal,
      {
        class: 22,
        noShadow: 23,
        noHairline: 24,
        form: 1,
        placeholder: 2,
        autocomplete: 3,
        autocorrect: 4,
        autocapitalize: 5,
        spellcheck: 6,
        disableButton: 7,
        disableButtonText: 8,
        clearButton: 9,
        value: 0,
        inputEvents: 25,
        expandable: 26,
        inline: 27,
        searchContainer: 28,
        searchIn: 29,
        searchItem: 30,
        searchGroup: 31,
        searchGroupTitle: 32,
        foundEl: 33,
        notFoundEl: 34,
        backdrop: 35,
        backdropEl: 36,
        hideOnEnableEl: 37,
        hideOnSearchEl: 38,
        ignore: 39,
        customSearch: 40,
        removeDiacritics: 41,
        hideDividers: 42,
        hideGroups: 43,
        init: 44,
        f7Slot: 10,
        instance: 45,
        search: 46,
        enable: 47,
        disable: 48,
        toggle: 49,
        clear: 50
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Searchbar",
      options,
      id: create_fragment85.name
    });
  }
  get class() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noShadow() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noShadow(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairline() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairline(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocorrect() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocorrect(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocapitalize() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocapitalize(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spellcheck() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spellcheck(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableButton() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableButton(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableButtonText() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableButtonText(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearButton() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearButton(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputEvents() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputEvents(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchContainer() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchContainer(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchIn() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchIn(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchItem() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchItem(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchGroup() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchGroup(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchGroupTitle() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchGroupTitle(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get foundEl() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set foundEl(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notFoundEl() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notFoundEl(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdropEl() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdropEl(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideOnEnableEl() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideOnEnableEl(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideOnSearchEl() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideOnSearchEl(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignore() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignore(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customSearch() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customSearch(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeDiacritics() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set removeDiacritics(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideDividers() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideDividers(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideGroups() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideGroups(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[45];
  }
  set instance(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get search() {
    return this.$$.ctx[46];
  }
  set search(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enable() {
    return this.$$.ctx[47];
  }
  set enable(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disable() {
    return this.$$.ctx[48];
  }
  set disable(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    return this.$$.ctx[49];
  }
  set toggle(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clear() {
    return this.$$.ctx[50];
  }
  set clear(value) {
    throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var searchbar_default = Searchbar;

// node_modules/framework7-svelte/components/segmented.svelte
var file82 = "node_modules/framework7-svelte/components/segmented.svelte";
function create_if_block_221(ctx) {
  let p;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*strong*/
    (ctx[0] || /*strongIos*/
    ctx[1] || /*strongMd*/
    ctx[2] || /*strongAurora*/
    ctx[3]) && create_if_block_317(ctx)
  );
  let p_levels = [{ class: (
    /*classes*/
    ctx[5]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(p, p_data);
      add_location(p, file82, 49, 2, 1451);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      append_dev(p, t);
      if (if_block)
        if_block.m(p, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*strong*/
        ctx2[0] || /*strongIos*/
        ctx2[1] || /*strongMd*/
        ctx2[2] || /*strongAurora*/
        ctx2[3]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_317(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*classes*/
        32) && { class: (
          /*classes*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_221.name,
    type: "if",
    source: "(49:22) ",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*strong*/
    (ctx[0] || /*strongIos*/
    ctx[1] || /*strongMd*/
    ctx[2] || /*strongAurora*/
    ctx[3]) && create_if_block_144(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[5]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file82, 44, 2, 1255);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*strong*/
        ctx2[0] || /*strongIos*/
        ctx2[1] || /*strongMd*/
        ctx2[2] || /*strongAurora*/
        ctx2[3]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_144(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        32) && { class: (
          /*classes*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(44:0) {#if tag === 'div'}",
    ctx
  });
  return block;
}
function create_if_block_317(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "segmented-highlight");
      add_location(span, file82, 51, 57, 1569);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_317.name,
    type: "if",
    source: "(52:4) {#if strong || strongIos || strongMd || strongAurora}",
    ctx
  });
  return block;
}
function create_if_block_144(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "segmented-highlight");
      add_location(span, file82, 46, 57, 1375);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_144.name,
    type: "if",
    source: "(47:4) {#if strong || strongIos || strongMd || strongAurora}",
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block33, create_if_block_221];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[4] === "div"
    )
      return 0;
    if (
      /*tag*/
      ctx2[4] === "p"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "raised",
    "raisedIos",
    "raisedMd",
    "raisedAurora",
    "round",
    "roundIos",
    "roundMd",
    "roundAurora",
    "strong",
    "strongIos",
    "strongMd",
    "strongAurora",
    "tag"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Segmented", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { raised = false } = $$props;
  let { raisedIos = false } = $$props;
  let { raisedMd = false } = $$props;
  let { raisedAurora = false } = $$props;
  let { round = false } = $$props;
  let { roundIos = false } = $$props;
  let { roundMd = false } = $$props;
  let { roundAurora = false } = $$props;
  let { strong = false } = $$props;
  let { strongIos = false } = $$props;
  let { strongMd = false } = $$props;
  let { strongAurora = false } = $$props;
  let { tag = "div" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("raised" in $$new_props)
      $$invalidate(8, raised = $$new_props.raised);
    if ("raisedIos" in $$new_props)
      $$invalidate(9, raisedIos = $$new_props.raisedIos);
    if ("raisedMd" in $$new_props)
      $$invalidate(10, raisedMd = $$new_props.raisedMd);
    if ("raisedAurora" in $$new_props)
      $$invalidate(11, raisedAurora = $$new_props.raisedAurora);
    if ("round" in $$new_props)
      $$invalidate(12, round = $$new_props.round);
    if ("roundIos" in $$new_props)
      $$invalidate(13, roundIos = $$new_props.roundIos);
    if ("roundMd" in $$new_props)
      $$invalidate(14, roundMd = $$new_props.roundMd);
    if ("roundAurora" in $$new_props)
      $$invalidate(15, roundAurora = $$new_props.roundAurora);
    if ("strong" in $$new_props)
      $$invalidate(0, strong = $$new_props.strong);
    if ("strongIos" in $$new_props)
      $$invalidate(1, strongIos = $$new_props.strongIos);
    if ("strongMd" in $$new_props)
      $$invalidate(2, strongMd = $$new_props.strongMd);
    if ("strongAurora" in $$new_props)
      $$invalidate(3, strongAurora = $$new_props.strongAurora);
    if ("tag" in $$new_props)
      $$invalidate(4, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    raised,
    raisedIos,
    raisedMd,
    raisedAurora,
    round,
    roundIos,
    roundMd,
    roundAurora,
    strong,
    strongIos,
    strongMd,
    strongAurora,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("raised" in $$props)
      $$invalidate(8, raised = $$new_props.raised);
    if ("raisedIos" in $$props)
      $$invalidate(9, raisedIos = $$new_props.raisedIos);
    if ("raisedMd" in $$props)
      $$invalidate(10, raisedMd = $$new_props.raisedMd);
    if ("raisedAurora" in $$props)
      $$invalidate(11, raisedAurora = $$new_props.raisedAurora);
    if ("round" in $$props)
      $$invalidate(12, round = $$new_props.round);
    if ("roundIos" in $$props)
      $$invalidate(13, roundIos = $$new_props.roundIos);
    if ("roundMd" in $$props)
      $$invalidate(14, roundMd = $$new_props.roundMd);
    if ("roundAurora" in $$props)
      $$invalidate(15, roundAurora = $$new_props.roundAurora);
    if ("strong" in $$props)
      $$invalidate(0, strong = $$new_props.strong);
    if ("strongIos" in $$props)
      $$invalidate(1, strongIos = $$new_props.strongIos);
    if ("strongMd" in $$props)
      $$invalidate(2, strongMd = $$new_props.strongMd);
    if ("strongAurora" in $$props)
      $$invalidate(3, strongAurora = $$new_props.strongAurora);
    if ("tag" in $$props)
      $$invalidate(4, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classes = classNames(
        className,
        {
          segmented: true,
          "segmented-raised": raised,
          "segmented-raised-ios": raisedIos,
          "segmented-raised-aurora": raisedAurora,
          "segmented-raised-md": raisedMd,
          "segmented-round": round,
          "segmented-round-ios": roundIos,
          "segmented-round-aurora": roundAurora,
          "segmented-round-md": roundMd,
          "segmented-strong": strong,
          "segmented-strong-ios": strongIos,
          "segmented-strong-md": strongMd,
          "segmented-strong-aurora": strongAurora
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    strong,
    strongIos,
    strongMd,
    strongAurora,
    tag,
    classes,
    $$restProps,
    className,
    raised,
    raisedIos,
    raisedMd,
    raisedAurora,
    round,
    roundIos,
    roundMd,
    roundAurora,
    $$scope,
    slots
  ];
}
var Segmented = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment86, safe_not_equal, {
      class: 7,
      raised: 8,
      raisedIos: 9,
      raisedMd: 10,
      raisedAurora: 11,
      round: 12,
      roundIos: 13,
      roundMd: 14,
      roundAurora: 15,
      strong: 0,
      strongIos: 1,
      strongMd: 2,
      strongAurora: 3,
      tag: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Segmented",
      options,
      id: create_fragment86.name
    });
  }
  get class() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMd() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMd(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedAurora() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedAurora(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundIos() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundIos(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundMd() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundMd(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundAurora() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundAurora(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strong() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strong(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongIos() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongIos(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongMd() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongMd(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strongAurora() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strongAurora(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var segmented_default = Segmented;

// node_modules/skeleton-elements/svelte/SkeletonBlock.svelte
var file83 = "node_modules/skeleton-elements/svelte/SkeletonBlock.svelte";
function create_else_block13(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let span_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file83, 15, 2, 719);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_612(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let h5_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h5_data = {};
  for (let i = 0; i < h5_levels.length; i += 1) {
    h5_data = assign(h5_data, h5_levels[i]);
  }
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      set_attributes(h5, h5_data);
      add_location(h5, file83, 13, 2, 633);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h5, h5_data = get_spread_update(h5_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_612.name,
    type: "if",
    source: "(13:23) ",
    ctx
  });
  return block;
}
function create_if_block_511(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let h4_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h4_data = {};
  for (let i = 0; i < h4_levels.length; i += 1) {
    h4_data = assign(h4_data, h4_levels[i]);
  }
  const block = {
    c: function create() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      set_attributes(h4, h4_data);
      add_location(h4, file83, 11, 2, 531);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h4, h4_data = get_spread_update(h4_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_511.name,
    type: "if",
    source: "(11:23) ",
    ctx
  });
  return block;
}
function create_if_block_413(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let h3_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3, h3_data);
      add_location(h3, file83, 9, 2, 429);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_413.name,
    type: "if",
    source: "(9:23) ",
    ctx
  });
  return block;
}
function create_if_block_318(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let h2_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      set_attributes(h2, h2_data);
      add_location(h2, file83, 7, 2, 327);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_318.name,
    type: "if",
    source: "(7:23) ",
    ctx
  });
  return block;
}
function create_if_block_224(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let h1_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h1_data = {};
  for (let i = 0; i < h1_levels.length; i += 1) {
    h1_data = assign(h1_data, h1_levels[i]);
  }
  const block = {
    c: function create() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      set_attributes(h1, h1_data);
      add_location(h1, file83, 5, 2, 225);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h1, h1_data = get_spread_update(h1_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_224.name,
    type: "if",
    source: "(5:23) ",
    ctx
  });
  return block;
}
function create_if_block_145(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let p_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      set_attributes(p, p_data);
      add_location(p, file83, 3, 2, 125);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_145.name,
    type: "if",
    source: "(3:22) ",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    /*rest*/
    ctx[1],
    { style: (
      /*skeletonStyle*/
      ctx[3]
    ) },
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file83, 1, 2, 22);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonStyle*/
        8) && { style: (
          /*skeletonStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(1:0) {#if tag === 'div'}",
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block34,
    create_if_block_145,
    create_if_block_224,
    create_if_block_318,
    create_if_block_413,
    create_if_block_511,
    create_if_block_612,
    create_else_block13
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "div"
    )
      return 0;
    if (
      /*tag*/
      ctx2[0] === "p"
    )
      return 1;
    if (
      /*tag*/
      ctx2[0] === "h1"
    )
      return 2;
    if (
      /*tag*/
      ctx2[0] === "h2"
    )
      return 3;
    if (
      /*tag*/
      ctx2[0] === "h3"
    )
      return 4;
    if (
      /*tag*/
      ctx2[0] === "h4"
    )
      return 5;
    if (
      /*tag*/
      ctx2[0] === "h5"
    )
      return 6;
    return 7;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let skeletonStyle;
  let skeletonClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonBlock", slots, ["default"]);
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { tag = "div" } = $$props;
  let { effect = void 0 } = $$props;
  let { borderRadius = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let rest = {};
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("width" in $$new_props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(5, height = $$new_props.height);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("effect" in $$new_props)
      $$invalidate(6, effect = $$new_props.effect);
    if ("borderRadius" in $$new_props)
      $$invalidate(7, borderRadius = $$new_props.borderRadius);
    if ("style" in $$new_props)
      $$invalidate(8, style = $$new_props.style);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    width,
    height,
    tag,
    effect,
    borderRadius,
    style,
    className,
    rest,
    skeletonClassName,
    skeletonStyle
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("width" in $$props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(5, height = $$new_props.height);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("effect" in $$props)
      $$invalidate(6, effect = $$new_props.effect);
    if ("borderRadius" in $$props)
      $$invalidate(7, borderRadius = $$new_props.borderRadius);
    if ("style" in $$props)
      $$invalidate(8, style = $$new_props.style);
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("rest" in $$props)
      $$invalidate(1, rest = $$new_props.rest);
    if ("skeletonClassName" in $$props)
      $$invalidate(2, skeletonClassName = $$new_props.skeletonClassName);
    if ("skeletonStyle" in $$props)
      $$invalidate(3, skeletonStyle = $$new_props.skeletonStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      Object.keys($$props).forEach((prop) => {
        if (prop !== "width" && prop !== "height" && prop !== "tag" && prop !== "effect" && prop !== "style" && prop !== "class") {
          $$invalidate(1, rest[prop] = $$props[prop], rest);
        }
      });
    if ($$self.$$.dirty & /*style*/
    256) {
      $:
        $$invalidate(3, skeletonStyle = style || "");
    }
    if ($$self.$$.dirty & /*width, skeletonStyle*/
    24) {
      $:
        if (width)
          $$invalidate(3, skeletonStyle += `;width: ${width}`);
    }
    if ($$self.$$.dirty & /*height, skeletonStyle*/
    40) {
      $:
        if (height)
          $$invalidate(3, skeletonStyle += `;height: ${height}`);
    }
    if ($$self.$$.dirty & /*borderRadius, skeletonStyle*/
    136) {
      $:
        if (borderRadius)
          $$invalidate(3, skeletonStyle += `;border-radius: ${borderRadius}`);
    }
    if ($$self.$$.dirty & /*effect, className*/
    576) {
      $:
        $$invalidate(2, skeletonClassName = ["skeleton-block", effect && `skeleton-effect-${effect}`, className].filter((c) => !!c).join(" "));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    tag,
    rest,
    skeletonClassName,
    skeletonStyle,
    width,
    height,
    effect,
    borderRadius,
    style,
    className,
    $$scope,
    slots
  ];
}
var SkeletonBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment87, safe_not_equal, {
      width: 4,
      height: 5,
      tag: 0,
      effect: 6,
      borderRadius: 7,
      style: 8,
      class: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonBlock",
      options,
      id: create_fragment87.name
    });
  }
  get width() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkeletonBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkeletonBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonBlock_default = SkeletonBlock;

// node_modules/skeleton-elements/svelte/SkeletonText.svelte
var file84 = "node_modules/skeleton-elements/svelte/SkeletonText.svelte";
function create_else_block14(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file84, 15, 2, 565);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_613(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let h5_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h5_data = {};
  for (let i = 0; i < h5_levels.length; i += 1) {
    h5_data = assign(h5_data, h5_levels[i]);
  }
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      set_attributes(h5, h5_data);
      add_location(h5, file84, 13, 2, 501);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h5, h5_data = get_spread_update(h5_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_613.name,
    type: "if",
    source: "(13:23) ",
    ctx
  });
  return block;
}
function create_if_block_512(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let h4_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h4_data = {};
  for (let i = 0; i < h4_levels.length; i += 1) {
    h4_data = assign(h4_data, h4_levels[i]);
  }
  const block = {
    c: function create() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      set_attributes(h4, h4_data);
      add_location(h4, file84, 11, 2, 421);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h4, h4_data = get_spread_update(h4_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_512.name,
    type: "if",
    source: "(11:23) ",
    ctx
  });
  return block;
}
function create_if_block_414(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let h3_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3, h3_data);
      add_location(h3, file84, 9, 2, 341);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_414.name,
    type: "if",
    source: "(9:23) ",
    ctx
  });
  return block;
}
function create_if_block_319(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let h2_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      set_attributes(h2, h2_data);
      add_location(h2, file84, 7, 2, 261);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_319.name,
    type: "if",
    source: "(7:23) ",
    ctx
  });
  return block;
}
function create_if_block_225(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let h1_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let h1_data = {};
  for (let i = 0; i < h1_levels.length; i += 1) {
    h1_data = assign(h1_data, h1_levels[i]);
  }
  const block = {
    c: function create() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      set_attributes(h1, h1_data);
      add_location(h1, file84, 5, 2, 181);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h1, h1_data = get_spread_update(h1_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_225.name,
    type: "if",
    source: "(5:23) ",
    ctx
  });
  return block;
}
function create_if_block_146(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let p_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      set_attributes(p, p_data);
      add_location(p, file84, 3, 2, 103);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_146.name,
    type: "if",
    source: "(3:22) ",
    ctx
  });
  return block;
}
function create_if_block35(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*rest*/
    ctx[1],
    { class: (
      /*skeletonClassName*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file84, 1, 2, 22);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*rest*/
        2 && /*rest*/
        ctx2[1],
        (!current || dirty & /*skeletonClassName*/
        4) && { class: (
          /*skeletonClassName*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(1:0) {#if tag === 'div'}",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block35,
    create_if_block_146,
    create_if_block_225,
    create_if_block_319,
    create_if_block_414,
    create_if_block_512,
    create_if_block_613,
    create_else_block14
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "div"
    )
      return 0;
    if (
      /*tag*/
      ctx2[0] === "p"
    )
      return 1;
    if (
      /*tag*/
      ctx2[0] === "h1"
    )
      return 2;
    if (
      /*tag*/
      ctx2[0] === "h2"
    )
      return 3;
    if (
      /*tag*/
      ctx2[0] === "h3"
    )
      return 4;
    if (
      /*tag*/
      ctx2[0] === "h4"
    )
      return 5;
    if (
      /*tag*/
      ctx2[0] === "h5"
    )
      return 6;
    return 7;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let skeletonClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonText", slots, ["default"]);
  let { tag = "span" } = $$props;
  let { effect = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const rest = {};
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("effect" in $$new_props)
      $$invalidate(3, effect = $$new_props.effect);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tag,
    effect,
    className,
    rest,
    skeletonClassName
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("effect" in $$props)
      $$invalidate(3, effect = $$new_props.effect);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("skeletonClassName" in $$props)
      $$invalidate(2, skeletonClassName = $$new_props.skeletonClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      Object.keys($$props).forEach((prop) => {
        if (prop !== "tag" && prop !== "effect" && prop !== "class") {
          $$invalidate(1, rest[prop] = $$props[prop], rest);
        }
      });
    if ($$self.$$.dirty & /*effect, className*/
    24) {
      $:
        $$invalidate(2, skeletonClassName = ["skeleton-text", effect && `skeleton-effect-${effect}`, className].filter((c) => !!c).join(" "));
    }
  };
  $$props = exclude_internal_props($$props);
  return [tag, rest, skeletonClassName, effect, className, $$scope, slots];
}
var SkeletonText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment88, safe_not_equal, { tag: 0, effect: 3, class: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonText",
      options,
      id: create_fragment88.name
    });
  }
  get tag() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonText_default = SkeletonText;

// node_modules/skeleton-elements/utils/multiply-svg-points.js
function multiplySvgPoints(pointsString, iconSize, width, height) {
  const iconMaxSize = Math.min(width, height) * 0.5;
  const scale = iconMaxSize / iconSize;
  return pointsString.replace(/([0-9,\.]{1,})/g, (coords) => {
    coords = coords.split(",").map((p) => parseFloat(p));
    const x = coords[0] * scale + width / 2 - iconSize * scale / 2;
    const y = coords[1] * scale + height / 2 - iconSize * scale / 2;
    if (iconMaxSize >= 100) {
      return `${Math.round(x)},${Math.round(y)}`;
    }
    return `${x},${y}`;
  });
}
var multiply_svg_points_default = multiplySvgPoints;

// node_modules/skeleton-elements/svelte/SkeletonImage.svelte
var file85 = "node_modules/skeleton-elements/svelte/SkeletonImage.svelte";
function create_if_block36(ctx) {
  let path;
  let path_style_value;
  let path_d_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "style", path_style_value = /*iconColor*/
      ctx[3] ? `fill: ${/*iconColor*/
      ctx[3]}` : "");
      attr_dev(path, "d", path_d_value = /*multiplyPoints*/
      ctx[8]("M7.7148,49.5742 L48.2852,49.5742 C53.1836,49.5742 55.6446,47.1367 55.6446,42.3086 L55.6446,13.6914 C55.6446,8.8633 53.1836,6.4258 48.2852,6.4258 L7.7148,6.4258 C2.8398,6.4258 0.3554,8.8398 0.3554,13.6914 L0.3554,42.3086 C0.3554,47.1602 2.8398,49.5742 7.7148,49.5742 Z M39.2851,27.9414 C38.2304,27.0039 37.0351,26.5118 35.7695,26.5118 C34.457,26.5118 33.3085,26.9571 32.2304,27.918 L21.6366,37.3867 L17.3007,33.4492 C16.3163,32.582 15.2617,32.1133 14.1366,32.1133 C13.1054,32.1133 12.0976,32.5586 11.1366,33.4258 L4.1288,39.7305 L4.1288,13.8789 C4.1288,11.4414 5.4413,10.1992 7.7851,10.1992 L48.2147,10.1992 C50.535,10.1992 51.8708,11.4414 51.8708,13.8789 L51.8708,39.7539 L39.2851,27.9414 Z M17.8163,28.1992 C20.8398,28.1992 23.3241,25.7149 23.3241,22.668 C23.3241,19.6445 20.8398,17.1367 17.8163,17.1367 C14.7695,17.1367 12.2851,19.6445 12.2851,22.668 C12.2851,25.7149 14.7695,28.1992 17.8163,28.1992 Z"));
      add_location(path, file85, 18, 6, 448);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*iconColor*/
      8 && path_style_value !== (path_style_value = /*iconColor*/
      ctx2[3] ? `fill: ${/*iconColor*/
      ctx2[3]}` : "")) {
        attr_dev(path, "style", path_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(18:4) {#if showIcon}",
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let span;
  let svg;
  let polygon;
  let polygon_style_value;
  let polygon_points_value;
  let svg_viewBox_value;
  let svg_style_value;
  let t;
  let current;
  let if_block = (
    /*showIcon*/
    ctx[4] && create_if_block36(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let span_levels = [
    /*rest*/
    ctx[6],
    { class: (
      /*skeletonClassName*/
      ctx[7]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(polygon, "style", polygon_style_value = /*color*/
      ctx[2] ? `fill: ${/*color*/
      ctx[2]}` : "");
      attr_dev(polygon, "fillrule", "evenodd");
      attr_dev(polygon, "points", polygon_points_value = `0 0 ${/*width*/
      ctx[0]} 0 ${/*width*/
      ctx[0]} ${/*height*/
      ctx[1]} 0 ${/*height*/
      ctx[1]}`);
      add_location(polygon, file85, 12, 4, 275);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*height*/
        ctx[1]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*width*/
      ctx[0]} ${/*height*/
      ctx[1]}`);
      attr_dev(svg, "preserveAspectRatio", "none");
      attr_dev(svg, "style", svg_style_value = /*borderRadius*/
      ctx[5] ? `border-radius: ${/*borderRadius*/
      ctx[5]}` : "");
      add_location(svg, file85, 4, 2, 50);
      set_attributes(span, span_data);
      add_location(span, file85, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, svg);
      append_dev(svg, polygon);
      if (if_block)
        if_block.m(svg, null);
      append_dev(span, t);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*color*/
      4 && polygon_style_value !== (polygon_style_value = /*color*/
      ctx2[2] ? `fill: ${/*color*/
      ctx2[2]}` : "")) {
        attr_dev(polygon, "style", polygon_style_value);
      }
      if (!current || dirty & /*width, height*/
      3 && polygon_points_value !== (polygon_points_value = `0 0 ${/*width*/
      ctx2[0]} 0 ${/*width*/
      ctx2[0]} ${/*height*/
      ctx2[1]} 0 ${/*height*/
      ctx2[1]}`)) {
        attr_dev(polygon, "points", polygon_points_value);
      }
      if (
        /*showIcon*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block36(ctx2);
          if_block.c();
          if_block.m(svg, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*width*/
      1) {
        attr_dev(
          svg,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*height*/
      2) {
        attr_dev(
          svg,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*width, height*/
      3 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*width*/
      ctx2[0]} ${/*height*/
      ctx2[1]}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (!current || dirty & /*borderRadius*/
      32 && svg_style_value !== (svg_style_value = /*borderRadius*/
      ctx2[5] ? `border-radius: ${/*borderRadius*/
      ctx2[5]}` : "")) {
        attr_dev(svg, "style", svg_style_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*rest*/
        64 && /*rest*/
        ctx2[6],
        (!current || dirty & /*skeletonClassName*/
        128) && { class: (
          /*skeletonClassName*/
          ctx2[7]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let skeletonClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonImage", slots, ["default"]);
  let { width = 1200 } = $$props;
  let { height = 600 } = $$props;
  let { color = void 0 } = $$props;
  let { iconColor = void 0 } = $$props;
  let { showIcon = true } = $$props;
  let { effect = void 0 } = $$props;
  let { borderRadius = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let rest = {};
  function multiplyPoints(pointsString) {
    return multiply_svg_points_default(pointsString, 56, width, height);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("width" in $$new_props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(1, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(2, color = $$new_props.color);
    if ("iconColor" in $$new_props)
      $$invalidate(3, iconColor = $$new_props.iconColor);
    if ("showIcon" in $$new_props)
      $$invalidate(4, showIcon = $$new_props.showIcon);
    if ("effect" in $$new_props)
      $$invalidate(9, effect = $$new_props.effect);
    if ("borderRadius" in $$new_props)
      $$invalidate(5, borderRadius = $$new_props.borderRadius);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    multiplySvgPoints: multiply_svg_points_default,
    width,
    height,
    color,
    iconColor,
    showIcon,
    effect,
    borderRadius,
    className,
    rest,
    multiplyPoints,
    skeletonClassName
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("width" in $$props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("color" in $$props)
      $$invalidate(2, color = $$new_props.color);
    if ("iconColor" in $$props)
      $$invalidate(3, iconColor = $$new_props.iconColor);
    if ("showIcon" in $$props)
      $$invalidate(4, showIcon = $$new_props.showIcon);
    if ("effect" in $$props)
      $$invalidate(9, effect = $$new_props.effect);
    if ("borderRadius" in $$props)
      $$invalidate(5, borderRadius = $$new_props.borderRadius);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("rest" in $$props)
      $$invalidate(6, rest = $$new_props.rest);
    if ("skeletonClassName" in $$props)
      $$invalidate(7, skeletonClassName = $$new_props.skeletonClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      Object.keys($$props).forEach((prop) => {
        if (prop !== "width" && prop !== "height" && prop !== "color" && prop !== "iconColor" && prop !== "showIcon" && prop !== "effect" && prop !== "class") {
          $$invalidate(6, rest[prop] = $$props[prop], rest);
        }
      });
    if ($$self.$$.dirty & /*effect, className*/
    1536) {
      $:
        $$invalidate(7, skeletonClassName = ["skeleton-image", effect && `skeleton-effect-${effect}`, className].filter((c) => !!c).join(" "));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    width,
    height,
    color,
    iconColor,
    showIcon,
    borderRadius,
    rest,
    skeletonClassName,
    multiplyPoints,
    effect,
    className,
    $$scope,
    slots
  ];
}
var SkeletonImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment89, safe_not_equal, {
      width: 0,
      height: 1,
      color: 2,
      iconColor: 3,
      showIcon: 4,
      effect: 9,
      borderRadius: 5,
      class: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonImage",
      options,
      id: create_fragment89.name
    });
  }
  get width() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconColor() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconColor(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showIcon() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showIcon(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkeletonImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkeletonImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonImage_default = SkeletonImage;

// node_modules/skeleton-elements/svelte/SkeletonAvatar.svelte
var file86 = "node_modules/skeleton-elements/svelte/SkeletonAvatar.svelte";
function create_if_block37(ctx) {
  let path;
  let path_style_value;
  let path_d_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "style", path_style_value = /*color*/
      ctx[1] ? `fill: ${/*iconColor*/
      ctx[2]}` : "");
      attr_dev(path, "d", path_d_value = /*multiplyPoints*/
      ctx[7]("M28.22461,27.1590817 C34.9209931,27.1590817 40.6829044,21.1791004 40.6829044,13.3926332 C40.6829044,5.69958662 34.8898972,0 28.22461,0 C21.5594557,0 15.7663156,5.82423601 15.7663156,13.4549579 C15.7663156,21.1791004 21.5594557,27.1590817 28.22461,27.1590817 Z M8.66515427,56 L47.7841986,56 C52.6739629,56 54.4181241,54.5984253 54.4181241,51.8576005 C54.4181241,43.8219674 44.358068,32.7341519 28.22461,32.7341519 C12.0600561,32.7341519 2,43.8219674 2,51.8576005 C2,54.5984253 3.74402832,56 8.66515427,56 Z"));
      add_location(path, file86, 19, 6, 374);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color, iconColor*/
      6 && path_style_value !== (path_style_value = /*color*/
      ctx2[1] ? `fill: ${/*iconColor*/
      ctx2[2]}` : "")) {
        attr_dev(path, "style", path_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(19:4) {#if showIcon}",
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let span;
  let svg;
  let rect;
  let rect_style_value;
  let svg_viewBox_value;
  let t;
  let current;
  let if_block = (
    /*showIcon*/
    ctx[3] && create_if_block37(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let span_levels = [
    /*rest*/
    ctx[5],
    { class: (
      /*skeletonClassName*/
      ctx[6]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      rect = svg_element("rect");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(
        rect,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        rect,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(rect, "fillrule", "evenodd");
      attr_dev(rect, "style", rect_style_value = /*color*/
      ctx[1] ? `fill: ${/*color*/
      ctx[1]}` : "");
      attr_dev(
        rect,
        "rx",
        /*borderRadius*/
        ctx[4]
      );
      add_location(rect, file86, 11, 4, 204);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*size*/
      ctx[0]} ${/*size*/
      ctx[0]}`);
      attr_dev(svg, "preserveAspectRatio", "none");
      add_location(svg, file86, 4, 2, 50);
      set_attributes(span, span_data);
      add_location(span, file86, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, svg);
      append_dev(svg, rect);
      if (if_block)
        if_block.m(svg, null);
      append_dev(span, t);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          rect,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          rect,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*color*/
      2 && rect_style_value !== (rect_style_value = /*color*/
      ctx2[1] ? `fill: ${/*color*/
      ctx2[1]}` : "")) {
        attr_dev(rect, "style", rect_style_value);
      }
      if (!current || dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "rx",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (
        /*showIcon*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block37(ctx2);
          if_block.c();
          if_block.m(svg, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*size*/
      ctx2[0]} ${/*size*/
      ctx2[0]}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*rest*/
        32 && /*rest*/
        ctx2[5],
        (!current || dirty & /*skeletonClassName*/
        64) && { class: (
          /*skeletonClassName*/
          ctx2[6]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let skeletonClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonAvatar", slots, ["default"]);
  let { size = 48 } = $$props;
  let { color = void 0 } = $$props;
  let { iconColor = void 0 } = $$props;
  let { showIcon = true } = $$props;
  let { borderRadius = "50%" } = $$props;
  let { effect = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let rest = {};
  function multiplyPoints(pointsString) {
    return multiply_svg_points_default(pointsString, 56, size, size);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("iconColor" in $$new_props)
      $$invalidate(2, iconColor = $$new_props.iconColor);
    if ("showIcon" in $$new_props)
      $$invalidate(3, showIcon = $$new_props.showIcon);
    if ("borderRadius" in $$new_props)
      $$invalidate(4, borderRadius = $$new_props.borderRadius);
    if ("effect" in $$new_props)
      $$invalidate(8, effect = $$new_props.effect);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    multiplySvgPoints: multiply_svg_points_default,
    size,
    color,
    iconColor,
    showIcon,
    borderRadius,
    effect,
    className,
    rest,
    multiplyPoints,
    skeletonClassName
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
    if ("iconColor" in $$props)
      $$invalidate(2, iconColor = $$new_props.iconColor);
    if ("showIcon" in $$props)
      $$invalidate(3, showIcon = $$new_props.showIcon);
    if ("borderRadius" in $$props)
      $$invalidate(4, borderRadius = $$new_props.borderRadius);
    if ("effect" in $$props)
      $$invalidate(8, effect = $$new_props.effect);
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("rest" in $$props)
      $$invalidate(5, rest = $$new_props.rest);
    if ("skeletonClassName" in $$props)
      $$invalidate(6, skeletonClassName = $$new_props.skeletonClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      Object.keys($$props).forEach((prop) => {
        if (prop !== "size" && prop !== "color" && prop !== "iconColor" && prop !== "showIcon" && prop !== "effect" && prop !== "borderRadius" && prop !== "class") {
          $$invalidate(5, rest[prop] = $$props[prop], rest);
        }
      });
    if ($$self.$$.dirty & /*effect, className*/
    768) {
      $:
        $$invalidate(6, skeletonClassName = ["skeleton-avatar", effect && `skeleton-effect-${effect}`, className].filter((c) => !!c).join(" "));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    size,
    color,
    iconColor,
    showIcon,
    borderRadius,
    rest,
    skeletonClassName,
    multiplyPoints,
    effect,
    className,
    $$scope,
    slots
  ];
}
var SkeletonAvatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment90, safe_not_equal, {
      size: 0,
      color: 1,
      iconColor: 2,
      showIcon: 3,
      borderRadius: 4,
      effect: 8,
      class: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonAvatar",
      options,
      id: create_fragment90.name
    });
  }
  get size() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconColor() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconColor(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showIcon() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showIcon(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get effect() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set effect(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkeletonAvatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkeletonAvatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonAvatar_default = SkeletonAvatar;

// node_modules/framework7-svelte/components/skeleton-avatar.js
var skeleton_avatar_default = SkeletonAvatar_default;

// node_modules/framework7-svelte/components/skeleton-block.js
var skeleton_block_default = SkeletonBlock_default;

// node_modules/framework7-svelte/components/skeleton-image.js
var skeleton_image_default = SkeletonImage_default;

// node_modules/framework7-svelte/components/skeleton-text.js
var skeleton_text_default = SkeletonText_default;

// node_modules/framework7-svelte/components/stepper.svelte
var file87 = "node_modules/framework7-svelte/components/stepper.svelte";
function create_if_block_147(ctx) {
  let div;
  let input_1;
  let input_1_min_value;
  let input_1_max_value;
  let input_1_step_value;
  let input_1_value_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      input_1 = element("input");
      attr_dev(
        input_1,
        "name",
        /*name*/
        ctx[4]
      );
      attr_dev(
        input_1,
        "id",
        /*inputId*/
        ctx[5]
      );
      attr_dev(
        input_1,
        "type",
        /*inputType*/
        ctx[7]
      );
      attr_dev(input_1, "min", input_1_min_value = /*inputType*/
      ctx[7] === "number" ? (
        /*min*/
        ctx[1]
      ) : void 0);
      attr_dev(input_1, "max", input_1_max_value = /*inputType*/
      ctx[7] === "number" ? (
        /*max*/
        ctx[2]
      ) : void 0);
      attr_dev(input_1, "step", input_1_step_value = /*inputType*/
      ctx[7] === "number" ? (
        /*step*/
        ctx[3]
      ) : void 0);
      input_1.value = input_1_value_value = typeof /*value*/
      ctx[0] === "undefined" ? "" : (
        /*value*/
        ctx[0]
      );
      input_1.readOnly = /*inputReadonly*/
      ctx[8];
      add_location(input_1, file87, 152, 6, 3974);
      attr_dev(div, "class", "stepper-input-wrap");
      add_location(div, file87, 151, 4, 3935);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input_1);
      if (!mounted) {
        dispose = [
          listen_dev(
            input_1,
            "input",
            /*onInput*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "change",
            /*onChange*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      16) {
        attr_dev(
          input_1,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*inputId*/
      32) {
        attr_dev(
          input_1,
          "id",
          /*inputId*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*inputType*/
      128) {
        attr_dev(
          input_1,
          "type",
          /*inputType*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*inputType, min*/
      130 && input_1_min_value !== (input_1_min_value = /*inputType*/
      ctx2[7] === "number" ? (
        /*min*/
        ctx2[1]
      ) : void 0)) {
        attr_dev(input_1, "min", input_1_min_value);
      }
      if (dirty[0] & /*inputType, max*/
      132 && input_1_max_value !== (input_1_max_value = /*inputType*/
      ctx2[7] === "number" ? (
        /*max*/
        ctx2[2]
      ) : void 0)) {
        attr_dev(input_1, "max", input_1_max_value);
      }
      if (dirty[0] & /*inputType, step*/
      136 && input_1_step_value !== (input_1_step_value = /*inputType*/
      ctx2[7] === "number" ? (
        /*step*/
        ctx2[3]
      ) : void 0)) {
        attr_dev(input_1, "step", input_1_step_value);
      }
      if (dirty[0] & /*value*/
      1 && input_1_value_value !== (input_1_value_value = typeof /*value*/
      ctx2[0] === "undefined" ? "" : (
        /*value*/
        ctx2[0]
      )) && input_1.value !== input_1_value_value) {
        prop_dev(input_1, "value", input_1_value_value);
      }
      if (dirty[0] & /*inputReadonly*/
      256) {
        prop_dev(
          input_1,
          "readOnly",
          /*inputReadonly*/
          ctx2[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_147.name,
    type: "if",
    source: "(151:2) {#if input && !buttonsOnly}",
    ctx
  });
  return block;
}
function create_if_block38(ctx) {
  let div;
  let t_value = plainText(
    /*value*/
    ctx[0]
  ) + "";
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      attr_dev(div, "class", "stepper-value");
      add_location(div, file87, 167, 4, 4419);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1 && t_value !== (t_value = plainText(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(167:2) {#if !input && !buttonsOnly}",
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let t2;
  let div1;
  let mounted;
  let dispose;
  let if_block0 = (
    /*input*/
    ctx[6] && !/*buttonsOnly*/
    ctx[9] && create_if_block_147(ctx)
  );
  let if_block1 = !/*input*/
  ctx[6] && !/*buttonsOnly*/
  ctx[9] && create_if_block38(ctx);
  let div2_levels = [{ class: (
    /*classes*/
    ctx[11]
  ) }, restProps(
    /*$$restProps*/
    ctx[16]
  )];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      attr_dev(div0, "class", "stepper-button-minus");
      add_location(div0, file87, 149, 2, 3840);
      attr_dev(div1, "class", "stepper-button-plus");
      add_location(div1, file87, 169, 2, 4481);
      set_attributes(div2, div2_data);
      add_location(div2, file87, 148, 0, 3773);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append_dev(div2, t2);
      append_dev(div2, div1);
      ctx[48](div2);
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "click",
            /*onMinusClick*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*onPlusClick*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*input*/
        ctx2[6] && !/*buttonsOnly*/
        ctx2[9]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_147(ctx2);
          if_block0.c();
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*input*/
      ctx2[6] && !/*buttonsOnly*/
      ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block38(ctx2);
          if_block1.c();
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        dirty[0] & /*classes*/
        2048 && { class: (
          /*classes*/
          ctx2[11]
        ) },
        dirty[0] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[16]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[48](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_116($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "init",
    "value",
    "min",
    "max",
    "step",
    "formatValue",
    "name",
    "inputId",
    "input",
    "inputType",
    "inputReadonly",
    "autorepeat",
    "autorepeatDynamic",
    "wraps",
    "manualInputMode",
    "decimalPoint",
    "buttonsEndInputMode",
    "disabled",
    "buttonsOnly",
    "round",
    "roundMd",
    "roundIos",
    "roundAurora",
    "fill",
    "fillMd",
    "fillIos",
    "fillAurora",
    "large",
    "largeMd",
    "largeIos",
    "largeAurora",
    "small",
    "smallMd",
    "smallIos",
    "smallAurora",
    "raised",
    "raisedMd",
    "raisedIos",
    "raisedAurora",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, []);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { formatValue = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { inputId = void 0 } = $$props;
  let { input = true } = $$props;
  let { inputType = "text" } = $$props;
  let { inputReadonly = false } = $$props;
  let { autorepeat = false } = $$props;
  let { autorepeatDynamic = false } = $$props;
  let { wraps = false } = $$props;
  let { manualInputMode = false } = $$props;
  let { decimalPoint = 4 } = $$props;
  let { buttonsEndInputMode = true } = $$props;
  let { disabled = void 0 } = $$props;
  let { buttonsOnly = void 0 } = $$props;
  let { round = false } = $$props;
  let { roundMd = false } = $$props;
  let { roundIos = false } = $$props;
  let { roundAurora = false } = $$props;
  let { fill = false } = $$props;
  let { fillMd = false } = $$props;
  let { fillIos = false } = $$props;
  let { fillAurora = false } = $$props;
  let { large = false } = $$props;
  let { largeMd = false } = $$props;
  let { largeIos = false } = $$props;
  let { largeAurora = false } = $$props;
  let { small = false } = $$props;
  let { smallMd = false } = $$props;
  let { smallIos = false } = $$props;
  let { smallAurora = false } = $$props;
  let { raised = false } = $$props;
  let { raisedMd = false } = $$props;
  let { raisedIos = false } = $$props;
  let { raisedAurora = false } = $$props;
  let el;
  let f7Stepper;
  function instance87() {
    return f7Stepper;
  }
  function watchValue(newValue) {
    if (!f7Stepper)
      return;
    f7Stepper.setValue(newValue);
  }
  function onInput(event) {
    emit("input", [event, f7Stepper]);
  }
  function onChange(event) {
    emit("change", [event, f7Stepper]);
  }
  function onMinusClick(event) {
    emit("stepperMinusClick", [event, f7Stepper]);
  }
  function onPlusClick(event) {
    emit("stepperPlusClick", [event, f7Stepper]);
  }
  onMount(() => {
    if (!init2)
      return;
    f7ready(() => {
      f7Stepper = app.f7.stepper.create(noUndefinedProps({
        el,
        min,
        max,
        value,
        step,
        formatValue,
        autorepeat,
        autorepeatDynamic,
        wraps,
        manualInputMode,
        decimalPoint,
        buttonsEndInputMode,
        on: {
          change(stepper, newValue) {
            emit("stepperChange", [newValue]);
            $$invalidate(0, value = newValue);
          }
        }
      }));
    });
  });
  onDestroy(() => {
    if (f7Stepper && f7Stepper.destroy) {
      f7Stepper.destroy();
      f7Stepper = null;
    }
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(10, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(17, className = $$new_props.class);
    if ("init" in $$new_props)
      $$invalidate(18, init2 = $$new_props.init);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("formatValue" in $$new_props)
      $$invalidate(19, formatValue = $$new_props.formatValue);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("inputId" in $$new_props)
      $$invalidate(5, inputId = $$new_props.inputId);
    if ("input" in $$new_props)
      $$invalidate(6, input = $$new_props.input);
    if ("inputType" in $$new_props)
      $$invalidate(7, inputType = $$new_props.inputType);
    if ("inputReadonly" in $$new_props)
      $$invalidate(8, inputReadonly = $$new_props.inputReadonly);
    if ("autorepeat" in $$new_props)
      $$invalidate(20, autorepeat = $$new_props.autorepeat);
    if ("autorepeatDynamic" in $$new_props)
      $$invalidate(21, autorepeatDynamic = $$new_props.autorepeatDynamic);
    if ("wraps" in $$new_props)
      $$invalidate(22, wraps = $$new_props.wraps);
    if ("manualInputMode" in $$new_props)
      $$invalidate(23, manualInputMode = $$new_props.manualInputMode);
    if ("decimalPoint" in $$new_props)
      $$invalidate(24, decimalPoint = $$new_props.decimalPoint);
    if ("buttonsEndInputMode" in $$new_props)
      $$invalidate(25, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
    if ("disabled" in $$new_props)
      $$invalidate(26, disabled = $$new_props.disabled);
    if ("buttonsOnly" in $$new_props)
      $$invalidate(9, buttonsOnly = $$new_props.buttonsOnly);
    if ("round" in $$new_props)
      $$invalidate(27, round = $$new_props.round);
    if ("roundMd" in $$new_props)
      $$invalidate(28, roundMd = $$new_props.roundMd);
    if ("roundIos" in $$new_props)
      $$invalidate(29, roundIos = $$new_props.roundIos);
    if ("roundAurora" in $$new_props)
      $$invalidate(30, roundAurora = $$new_props.roundAurora);
    if ("fill" in $$new_props)
      $$invalidate(31, fill = $$new_props.fill);
    if ("fillMd" in $$new_props)
      $$invalidate(32, fillMd = $$new_props.fillMd);
    if ("fillIos" in $$new_props)
      $$invalidate(33, fillIos = $$new_props.fillIos);
    if ("fillAurora" in $$new_props)
      $$invalidate(34, fillAurora = $$new_props.fillAurora);
    if ("large" in $$new_props)
      $$invalidate(35, large = $$new_props.large);
    if ("largeMd" in $$new_props)
      $$invalidate(36, largeMd = $$new_props.largeMd);
    if ("largeIos" in $$new_props)
      $$invalidate(37, largeIos = $$new_props.largeIos);
    if ("largeAurora" in $$new_props)
      $$invalidate(38, largeAurora = $$new_props.largeAurora);
    if ("small" in $$new_props)
      $$invalidate(39, small = $$new_props.small);
    if ("smallMd" in $$new_props)
      $$invalidate(40, smallMd = $$new_props.smallMd);
    if ("smallIos" in $$new_props)
      $$invalidate(41, smallIos = $$new_props.smallIos);
    if ("smallAurora" in $$new_props)
      $$invalidate(42, smallAurora = $$new_props.smallAurora);
    if ("raised" in $$new_props)
      $$invalidate(43, raised = $$new_props.raised);
    if ("raisedMd" in $$new_props)
      $$invalidate(44, raisedMd = $$new_props.raisedMd);
    if ("raisedIos" in $$new_props)
      $$invalidate(45, raisedIos = $$new_props.raisedIos);
    if ("raisedAurora" in $$new_props)
      $$invalidate(46, raisedAurora = $$new_props.raisedAurora);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    classNames,
    noUndefinedProps,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    emit,
    className,
    init: init2,
    value,
    min,
    max,
    step,
    formatValue,
    name,
    inputId,
    input,
    inputType,
    inputReadonly,
    autorepeat,
    autorepeatDynamic,
    wraps,
    manualInputMode,
    decimalPoint,
    buttonsEndInputMode,
    disabled,
    buttonsOnly,
    round,
    roundMd,
    roundIos,
    roundAurora,
    fill,
    fillMd,
    fillIos,
    fillAurora,
    large,
    largeMd,
    largeIos,
    largeAurora,
    small,
    smallMd,
    smallIos,
    smallAurora,
    raised,
    raisedMd,
    raisedIos,
    raisedAurora,
    el,
    f7Stepper,
    instance: instance87,
    watchValue,
    onInput,
    onChange,
    onMinusClick,
    onPlusClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(17, className = $$new_props.className);
    if ("init" in $$props)
      $$invalidate(18, init2 = $$new_props.init);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(3, step = $$new_props.step);
    if ("formatValue" in $$props)
      $$invalidate(19, formatValue = $$new_props.formatValue);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
    if ("inputId" in $$props)
      $$invalidate(5, inputId = $$new_props.inputId);
    if ("input" in $$props)
      $$invalidate(6, input = $$new_props.input);
    if ("inputType" in $$props)
      $$invalidate(7, inputType = $$new_props.inputType);
    if ("inputReadonly" in $$props)
      $$invalidate(8, inputReadonly = $$new_props.inputReadonly);
    if ("autorepeat" in $$props)
      $$invalidate(20, autorepeat = $$new_props.autorepeat);
    if ("autorepeatDynamic" in $$props)
      $$invalidate(21, autorepeatDynamic = $$new_props.autorepeatDynamic);
    if ("wraps" in $$props)
      $$invalidate(22, wraps = $$new_props.wraps);
    if ("manualInputMode" in $$props)
      $$invalidate(23, manualInputMode = $$new_props.manualInputMode);
    if ("decimalPoint" in $$props)
      $$invalidate(24, decimalPoint = $$new_props.decimalPoint);
    if ("buttonsEndInputMode" in $$props)
      $$invalidate(25, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
    if ("disabled" in $$props)
      $$invalidate(26, disabled = $$new_props.disabled);
    if ("buttonsOnly" in $$props)
      $$invalidate(9, buttonsOnly = $$new_props.buttonsOnly);
    if ("round" in $$props)
      $$invalidate(27, round = $$new_props.round);
    if ("roundMd" in $$props)
      $$invalidate(28, roundMd = $$new_props.roundMd);
    if ("roundIos" in $$props)
      $$invalidate(29, roundIos = $$new_props.roundIos);
    if ("roundAurora" in $$props)
      $$invalidate(30, roundAurora = $$new_props.roundAurora);
    if ("fill" in $$props)
      $$invalidate(31, fill = $$new_props.fill);
    if ("fillMd" in $$props)
      $$invalidate(32, fillMd = $$new_props.fillMd);
    if ("fillIos" in $$props)
      $$invalidate(33, fillIos = $$new_props.fillIos);
    if ("fillAurora" in $$props)
      $$invalidate(34, fillAurora = $$new_props.fillAurora);
    if ("large" in $$props)
      $$invalidate(35, large = $$new_props.large);
    if ("largeMd" in $$props)
      $$invalidate(36, largeMd = $$new_props.largeMd);
    if ("largeIos" in $$props)
      $$invalidate(37, largeIos = $$new_props.largeIos);
    if ("largeAurora" in $$props)
      $$invalidate(38, largeAurora = $$new_props.largeAurora);
    if ("small" in $$props)
      $$invalidate(39, small = $$new_props.small);
    if ("smallMd" in $$props)
      $$invalidate(40, smallMd = $$new_props.smallMd);
    if ("smallIos" in $$props)
      $$invalidate(41, smallIos = $$new_props.smallIos);
    if ("smallAurora" in $$props)
      $$invalidate(42, smallAurora = $$new_props.smallAurora);
    if ("raised" in $$props)
      $$invalidate(43, raised = $$new_props.raised);
    if ("raisedMd" in $$props)
      $$invalidate(44, raisedMd = $$new_props.raisedMd);
    if ("raisedIos" in $$props)
      $$invalidate(45, raisedIos = $$new_props.raisedIos);
    if ("raisedAurora" in $$props)
      $$invalidate(46, raisedAurora = $$new_props.raisedAurora);
    if ("el" in $$props)
      $$invalidate(10, el = $$new_props.el);
    if ("f7Stepper" in $$props)
      f7Stepper = $$new_props.f7Stepper;
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(11, classes = classNames(
        className,
        "stepper",
        {
          disabled,
          "stepper-round": round,
          "stepper-round-ios": roundIos,
          "stepper-round-md": roundMd,
          "stepper-round-aurora": roundAurora,
          "stepper-fill": fill,
          "stepper-fill-ios": fillIos,
          "stepper-fill-md": fillMd,
          "stepper-fill-aurora": fillAurora,
          "stepper-large": large,
          "stepper-large-ios": largeIos,
          "stepper-large-md": largeMd,
          "stepper-large-aurora": largeAurora,
          "stepper-small": small,
          "stepper-small-ios": smallIos,
          "stepper-small-md": smallMd,
          "stepper-small-aurora": smallAurora,
          "stepper-raised": raised,
          "stepper-raised-ios": raisedIos,
          "stepper-raised-md": raisedMd,
          "stepper-raised-aurora": raisedAurora
        },
        colorClasses($$props)
      ));
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        watchValue(value);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min,
    max,
    step,
    name,
    inputId,
    input,
    inputType,
    inputReadonly,
    buttonsOnly,
    el,
    classes,
    onInput,
    onChange,
    onMinusClick,
    onPlusClick,
    $$restProps,
    className,
    init2,
    formatValue,
    autorepeat,
    autorepeatDynamic,
    wraps,
    manualInputMode,
    decimalPoint,
    buttonsEndInputMode,
    disabled,
    round,
    roundMd,
    roundIos,
    roundAurora,
    fill,
    fillMd,
    fillIos,
    fillAurora,
    large,
    largeMd,
    largeIos,
    largeAurora,
    small,
    smallMd,
    smallIos,
    smallAurora,
    raised,
    raisedMd,
    raisedIos,
    raisedAurora,
    instance87,
    div2_binding
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_116,
      create_fragment91,
      safe_not_equal,
      {
        class: 17,
        init: 18,
        value: 0,
        min: 1,
        max: 2,
        step: 3,
        formatValue: 19,
        name: 4,
        inputId: 5,
        input: 6,
        inputType: 7,
        inputReadonly: 8,
        autorepeat: 20,
        autorepeatDynamic: 21,
        wraps: 22,
        manualInputMode: 23,
        decimalPoint: 24,
        buttonsEndInputMode: 25,
        disabled: 26,
        buttonsOnly: 9,
        round: 27,
        roundMd: 28,
        roundIos: 29,
        roundAurora: 30,
        fill: 31,
        fillMd: 32,
        fillIos: 33,
        fillAurora: 34,
        large: 35,
        largeMd: 36,
        largeIos: 37,
        largeAurora: 38,
        small: 39,
        smallMd: 40,
        smallIos: 41,
        smallAurora: 42,
        raised: 43,
        raisedMd: 44,
        raisedIos: 45,
        raisedAurora: 46,
        instance: 47
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment91.name
    });
  }
  get class() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get init() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set init(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatValue() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatValue(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputReadonly() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputReadonly(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autorepeat() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autorepeat(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autorepeatDynamic() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autorepeatDynamic(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wraps() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wraps(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get manualInputMode() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set manualInputMode(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decimalPoint() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decimalPoint(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsEndInputMode() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsEndInputMode(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonsOnly() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonsOnly(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundMd() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundMd(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundAurora() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundAurora(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillMd() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillMd(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillAurora() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillAurora(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeMd() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeMd(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largeAurora() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largeAurora(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallMd() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallMd(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallAurora() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallAurora(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raised() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raised(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedMd() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedMd(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedIos() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedIos(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get raisedAurora() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set raisedAurora(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    return this.$$.ctx[47];
  }
  set instance(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var stepper_default = Stepper;

// node_modules/framework7-svelte/components/subnavbar.svelte
var file88 = "node_modules/framework7-svelte/components/subnavbar.svelte";
function create_else_block15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(32:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block39(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*title*/
    ctx[0] && create_if_block_148(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "subnavbar-inner");
      add_location(div, file88, 25, 4, 578);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_148(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(25:2) {#if inner}",
    ctx
  });
  return block;
}
function create_if_block_148(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*title*/
        ctx[0]
      );
      attr_dev(div, "class", "subnavbar-title");
      add_location(div, file88, 27, 8, 634);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      1)
        set_data_dev(
          t,
          /*title*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_148.name,
    type: "if",
    source: "(27:6) {#if title}",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block39, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inner*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[2]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file88, 23, 0, 488);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*f7Slot*/
        4) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sliding", "title", "inner", "f7Slot"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Subnavbar", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { inner = true } = $$props;
  let { f7Slot = "fixed" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("sliding" in $$new_props)
      $$invalidate(6, sliding = $$new_props.sliding);
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("inner" in $$new_props)
      $$invalidate(1, inner = $$new_props.inner);
    if ("f7Slot" in $$new_props)
      $$invalidate(2, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    sliding,
    title,
    inner,
    f7Slot,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("sliding" in $$props)
      $$invalidate(6, sliding = $$new_props.sliding);
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("inner" in $$props)
      $$invalidate(1, inner = $$new_props.inner);
    if ("f7Slot" in $$props)
      $$invalidate(2, f7Slot = $$new_props.f7Slot);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "subnavbar", { sliding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [title, inner, f7Slot, classes, $$restProps, className, sliding, $$scope, slots];
}
var Subnavbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment92, safe_not_equal, {
      class: 5,
      sliding: 6,
      title: 0,
      inner: 1,
      f7Slot: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Subnavbar",
      options,
      id: create_fragment92.name
    });
  }
  get class() {
    throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sliding() {
    throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sliding(value) {
    throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var subnavbar_default = Subnavbar;

// node_modules/framework7-svelte/components/swipeout-actions.svelte
var file89 = "node_modules/framework7-svelte/components/swipeout-actions.svelte";
function create_fragment93(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file89, 18, 0, 539);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let classes;
  let sideComputed;
  const omit_props_names = ["class", "left", "right", "side"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swipeout_actions", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { left = void 0 } = $$props;
  let { right = void 0 } = $$props;
  let { side = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("left" in $$new_props)
      $$invalidate(3, left = $$new_props.left);
    if ("right" in $$new_props)
      $$invalidate(4, right = $$new_props.right);
    if ("side" in $$new_props)
      $$invalidate(5, side = $$new_props.side);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    left,
    right,
    side,
    sideComputed,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("left" in $$props)
      $$invalidate(3, left = $$new_props.left);
    if ("right" in $$props)
      $$invalidate(4, right = $$new_props.right);
    if ("side" in $$props)
      $$invalidate(5, side = $$new_props.side);
    if ("sideComputed" in $$props)
      $$invalidate(6, sideComputed = $$new_props.sideComputed);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*side, left, right*/
    56) {
      $:
        $$invalidate(6, sideComputed = side || (left ? "left" : right ? "right" : "left"));
    }
    $:
      $$invalidate(0, classes = classNames(className, `swipeout-actions-${sideComputed}`, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    classes,
    $$restProps,
    className,
    left,
    right,
    side,
    sideComputed,
    $$scope,
    slots
  ];
}
var Swipeout_actions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment93, safe_not_equal, { class: 2, left: 3, right: 4, side: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swipeout_actions",
      options,
      id: create_fragment93.name
    });
  }
  get class() {
    throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swipeout_actions_default = Swipeout_actions;

// node_modules/framework7-svelte/components/swipeout-button.svelte
var file90 = "node_modules/framework7-svelte/components/swipeout-button.svelte";
function create_fragment94(ctx) {
  let a;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let a_href_value;
  let a_data_confirm_value;
  let a_data_confirm_title_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let a_levels = [
    {
      href: a_href_value = /*href*/
      ctx[3] || "#"
    },
    {
      "data-confirm": a_data_confirm_value = /*confirmText*/
      ctx[2] || void 0
    },
    {
      "data-confirm-title": a_data_confirm_title_value = /*confirmTitle*/
      ctx[1] || void 0
    },
    { class: (
      /*classes*/
      ctx[4]
    ) },
    restProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file90, 36, 0, 898);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, t0);
      append_dev(a, t1);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*onClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if ((!current || dirty & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        8 && a_href_value !== (a_href_value = /*href*/
        ctx2[3] || "#")) && { href: a_href_value },
        (!current || dirty & /*confirmText*/
        4 && a_data_confirm_value !== (a_data_confirm_value = /*confirmText*/
        ctx2[2] || void 0)) && { "data-confirm": a_data_confirm_value },
        (!current || dirty & /*confirmTitle*/
        2 && a_data_confirm_title_value !== (a_data_confirm_title_value = /*confirmTitle*/
        ctx2[1] || void 0)) && {
          "data-confirm-title": a_data_confirm_title_value
        },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "text",
    "confirmTitle",
    "confirmText",
    "overswipe",
    "close",
    "delete",
    "href"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swipeout_button", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { confirmTitle = void 0 } = $$props;
  let { confirmText = void 0 } = $$props;
  let { overswipe = void 0 } = $$props;
  let { close = void 0 } = $$props;
  let { delete: deleteProp = void 0 } = $$props;
  let { href = void 0 } = $$props;
  function onClick() {
    emit("click");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("text" in $$new_props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("confirmTitle" in $$new_props)
      $$invalidate(1, confirmTitle = $$new_props.confirmTitle);
    if ("confirmText" in $$new_props)
      $$invalidate(2, confirmText = $$new_props.confirmText);
    if ("overswipe" in $$new_props)
      $$invalidate(8, overswipe = $$new_props.overswipe);
    if ("close" in $$new_props)
      $$invalidate(9, close = $$new_props.close);
    if ("delete" in $$new_props)
      $$invalidate(10, deleteProp = $$new_props.delete);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    colorClasses,
    classNames,
    plainText,
    createEmitter,
    restProps,
    emit,
    className,
    text: text2,
    confirmTitle,
    confirmText,
    overswipe,
    close,
    deleteProp,
    href,
    onClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("text" in $$props)
      $$invalidate(0, text2 = $$new_props.text);
    if ("confirmTitle" in $$props)
      $$invalidate(1, confirmTitle = $$new_props.confirmTitle);
    if ("confirmText" in $$props)
      $$invalidate(2, confirmText = $$new_props.confirmText);
    if ("overswipe" in $$props)
      $$invalidate(8, overswipe = $$new_props.overswipe);
    if ("close" in $$props)
      $$invalidate(9, close = $$new_props.close);
    if ("deleteProp" in $$props)
      $$invalidate(10, deleteProp = $$new_props.deleteProp);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classes = classNames(
        className,
        {
          "swipeout-overswipe": overswipe,
          "swipeout-delete": deleteProp,
          "swipeout-close": close
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    text2,
    confirmTitle,
    confirmText,
    href,
    classes,
    onClick,
    $$restProps,
    className,
    overswipe,
    close,
    deleteProp,
    $$scope,
    slots
  ];
}
var Swipeout_button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment94, safe_not_equal, {
      class: 7,
      text: 0,
      confirmTitle: 1,
      confirmText: 2,
      overswipe: 8,
      close: 9,
      delete: 10,
      href: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swipeout_button",
      options,
      id: create_fragment94.name
    });
  }
  get class() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get confirmTitle() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set confirmTitle(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get confirmText() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set confirmText(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overswipe() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overswipe(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set close(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delete() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delete(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swipeout_button_default = Swipeout_button;

// node_modules/swiper/components-shared/utils.js
function isObject2(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function extend2(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject2(src[key]) && isObject2(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__)
        target[key] = src[key];
      else
        extend2(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames2 = "") {
  const classes = classNames2.split(" ").map((c) => c.trim()).filter((c) => !!c);
  const unique = [];
  classes.forEach((c) => {
    if (unique.indexOf(c) < 0)
      unique.push(c);
  });
  return unique.join(" ");
}

// node_modules/swiper/components-shared/params-list.js
var paramsList = [
  "modules",
  "init",
  "_direction",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_preloadImages",
  "updateOnImagesReady",
  "_loop",
  "_loopAdditionalSlides",
  "_loopedSlides",
  "_loopedSlidesLimit",
  "_loopFillGroupWithBlank",
  "loopPreventsSlide",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideBlankClass",
  "slideActiveClass",
  "slideDuplicateActiveClass",
  "slideVisibleClass",
  "slideDuplicateClass",
  "slideNextClass",
  "slideDuplicateNextClass",
  "slidePrevClass",
  "slideDuplicatePrevClass",
  "wrapperClass",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "lazy",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom"
];

// node_modules/swiper/components-shared/get-params.js
function getParams(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  extend2(params, core_default.defaults);
  extend2(params, core_default.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined")
      return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject2(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend2(params[key], obj[key]);
        extend2(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true)
      params[key] = {};
    if (params[key] === false)
      delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}

// node_modules/swiper/components-shared/mount-swiper.js
function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}

// node_modules/swiper/components-shared/get-changed-params.js
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys = [];
  if (!oldParams)
    return keys;
  const addKey = (key) => {
    if (keys.indexOf(key) < 0)
      keys.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join(""))
      addKey("children");
    if (oldChildren.length !== children.length)
      addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject2(swiperParams[key]) && isObject2(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
              addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}

// node_modules/swiper/components-shared/update-swiper.js
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper[mod])
      return;
    swiper[mod].destroy();
    if (mod === "navigation") {
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper[mod].prevEl = void 0;
      swiper[mod].nextEl = void 0;
    } else {
      currentParams[mod].el = void 0;
      swiper[mod].el = void 0;
    }
  };
  updateParams.forEach((key) => {
    if (isObject2(currentParams[key]) && isObject2(passedParams[key])) {
      extend2(currentParams[key], passedParams[key]);
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes("children") && swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper.changeDirection(passedParams.direction, false);
  }
  swiper.update();
}

// node_modules/swiper/svelte/swiper.svelte
var file91 = "node_modules/swiper/svelte/swiper.svelte";
var get_container_end_slot_changes = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_container_end_slot_context = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
var get_wrapper_end_slot_changes = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_wrapper_end_slot_context = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
var get_default_slot_changes14 = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_default_slot_context14 = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
var get_wrapper_start_slot_changes = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_wrapper_start_slot_context = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
var get_container_start_slot_changes = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_container_start_slot_context = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
function create_if_block_226(ctx) {
  let div0;
  let t;
  let div1;
  const block = {
    c: function create() {
      div0 = element("div");
      t = space();
      div1 = element("div");
      attr_dev(div0, "class", "swiper-button-prev");
      add_location(div0, file91, 166, 4, 4388);
      attr_dev(div1, "class", "swiper-button-next");
      add_location(div1, file91, 167, 4, 4446);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      ctx[15](div0);
      insert_dev(target, t, anchor);
      insert_dev(target, div1, anchor);
      ctx[16](div1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      ctx[15](null);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      ctx[16](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_226.name,
    type: "if",
    source: "(166:2) {#if needsNavigation(swiperParams)}",
    ctx
  });
  return block;
}
function create_if_block_149(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "swiper-scrollbar");
      add_location(div, file91, 170, 4, 4549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[17](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_149.name,
    type: "if",
    source: "(170:2) {#if needsScrollbar(swiperParams)}",
    ctx
  });
  return block;
}
function create_if_block40(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "swiper-pagination");
      add_location(div, file91, 173, 4, 4656);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[18](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(173:2) {#if needsPagination(swiperParams)}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element1;
  let t0;
  let svelte_element0;
  let t1;
  let t2;
  let t3;
  let show_if_2 = needsNavigation(
    /*swiperParams*/
    ctx[4]
  );
  let t4;
  let show_if_1 = needsScrollbar(
    /*swiperParams*/
    ctx[4]
  );
  let t5;
  let show_if = needsPagination(
    /*swiperParams*/
    ctx[4]
  );
  let t6;
  let svelte_element1_class_value;
  let current;
  const container_start_slot_template = (
    /*#slots*/
    ctx[14]["container-start"]
  );
  const container_start_slot = create_slot(
    container_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_container_start_slot_context
  );
  const wrapper_start_slot_template = (
    /*#slots*/
    ctx[14]["wrapper-start"]
  );
  const wrapper_start_slot = create_slot(
    wrapper_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_wrapper_start_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context14
  );
  const wrapper_end_slot_template = (
    /*#slots*/
    ctx[14]["wrapper-end"]
  );
  const wrapper_end_slot = create_slot(
    wrapper_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_wrapper_end_slot_context
  );
  let if_block0 = show_if_2 && create_if_block_226(ctx);
  let if_block1 = show_if_1 && create_if_block_149(ctx);
  let if_block2 = show_if && create_if_block40(ctx);
  const container_end_slot_template = (
    /*#slots*/
    ctx[14]["container-end"]
  );
  const container_end_slot = create_slot(
    container_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_container_end_slot_context
  );
  let svelte_element1_levels = [
    {
      class: svelte_element1_class_value = uniqueClasses(`${/*containerClasses*/
      ctx[3]}${/*className*/
      ctx[0] ? ` ${/*className*/
      ctx[0]}` : ""}`)
    },
    /*restProps*/
    ctx[5]
  ];
  let svelte_element1_data = {};
  for (let i = 0; i < svelte_element1_levels.length; i += 1) {
    svelte_element1_data = assign(svelte_element1_data, svelte_element1_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element1 = element(
        /*tag*/
        ctx[1]
      );
      if (container_start_slot)
        container_start_slot.c();
      t0 = space();
      svelte_element0 = element(
        /*wrapperTag*/
        ctx[2]
      );
      if (wrapper_start_slot)
        wrapper_start_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (wrapper_end_slot)
        wrapper_end_slot.c();
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      if (if_block2)
        if_block2.c();
      t6 = space();
      if (container_end_slot)
        container_end_slot.c();
      set_dynamic_element_data(
        /*wrapperTag*/
        ctx[2]
      )(svelte_element0, { class: "swiper-wrapper" });
      add_location(svelte_element0, file91, 160, 2, 4175);
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element1, svelte_element1_data);
      add_location(svelte_element1, file91, 153, 0, 3986);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svelte_element1, anchor);
      if (container_start_slot) {
        container_start_slot.m(svelte_element1, null);
      }
      append_dev(svelte_element1, t0);
      append_dev(svelte_element1, svelte_element0);
      if (wrapper_start_slot) {
        wrapper_start_slot.m(svelte_element0, null);
      }
      append_dev(svelte_element0, t1);
      if (default_slot) {
        default_slot.m(svelte_element0, null);
      }
      append_dev(svelte_element0, t2);
      if (wrapper_end_slot) {
        wrapper_end_slot.m(svelte_element0, null);
      }
      append_dev(svelte_element1, t3);
      if (if_block0)
        if_block0.m(svelte_element1, null);
      append_dev(svelte_element1, t4);
      if (if_block1)
        if_block1.m(svelte_element1, null);
      append_dev(svelte_element1, t5);
      if (if_block2)
        if_block2.m(svelte_element1, null);
      append_dev(svelte_element1, t6);
      if (container_end_slot) {
        container_end_slot.m(svelte_element1, null);
      }
      ctx[19](svelte_element1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (container_start_slot) {
        if (container_start_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            container_start_slot,
            container_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              container_start_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_container_start_slot_changes
            ),
            get_container_start_slot_context
          );
        }
      }
      if (wrapper_start_slot) {
        if (wrapper_start_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            wrapper_start_slot,
            wrapper_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              wrapper_start_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_wrapper_start_slot_changes
            ),
            get_wrapper_start_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
      if (wrapper_end_slot) {
        if (wrapper_end_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            wrapper_end_slot,
            wrapper_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              wrapper_end_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_wrapper_end_slot_changes
            ),
            get_wrapper_end_slot_context
          );
        }
      }
      if (dirty & /*swiperParams*/
      16)
        show_if_2 = needsNavigation(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if_2) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_226(ctx2);
          if_block0.c();
          if_block0.m(svelte_element1, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*swiperParams*/
      16)
        show_if_1 = needsScrollbar(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if_1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_149(ctx2);
          if_block1.c();
          if_block1.m(svelte_element1, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*swiperParams*/
      16)
        show_if = needsPagination(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block40(ctx2);
          if_block2.c();
          if_block2.m(svelte_element1, t6);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (container_end_slot) {
        if (container_end_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            container_end_slot,
            container_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              container_end_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_container_end_slot_changes
            ),
            get_container_end_slot_context
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element1, svelte_element1_data = get_spread_update(svelte_element1_levels, [
        (!current || dirty & /*containerClasses, className*/
        9 && svelte_element1_class_value !== (svelte_element1_class_value = uniqueClasses(`${/*containerClasses*/
        ctx2[3]}${/*className*/
        ctx2[0] ? ` ${/*className*/
        ctx2[0]}` : ""}`))) && { class: svelte_element1_class_value },
        dirty & /*restProps*/
        32 && /*restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container_start_slot, local);
      transition_in(wrapper_start_slot, local);
      transition_in(default_slot, local);
      transition_in(wrapper_end_slot, local);
      transition_in(container_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container_start_slot, local);
      transition_out(wrapper_start_slot, local);
      transition_out(default_slot, local);
      transition_out(wrapper_end_slot, local);
      transition_out(container_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element1);
      if (container_start_slot)
        container_start_slot.d(detaching);
      if (wrapper_start_slot)
        wrapper_start_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (wrapper_end_slot)
        wrapper_end_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (container_end_slot)
        container_end_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(154:0) <svelte:element   this={tag}   bind:this={swiperEl}   class={uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)}   {...restProps} >",
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[1]
  );
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "tag", "wrapperTag", "swiper"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swiper", slots, ["container-start", "wrapper-start", "default", "wrapper-end", "container-end"]);
  const dispatch = createEventDispatcher();
  let { class: className = void 0 } = $$props;
  let { tag = "div" } = $$props;
  let { wrapperTag = "div" } = $$props;
  let containerClasses = "swiper";
  let breakpointChanged = false;
  let swiperInstance = null;
  let oldPassedParams = null;
  let paramsData;
  let swiperParams;
  let passedParams;
  let restProps2;
  let swiperEl = null;
  let prevEl = null;
  let nextEl = null;
  let scrollbarEl = null;
  let paginationEl = null;
  let virtualData = { slides: [] };
  function swiper() {
    return swiperInstance;
  }
  const setVirtualData = (data) => {
    $$invalidate(11, virtualData = data);
    tick().then(() => {
      swiperInstance.$wrapperEl.children(".swiper-slide").each((el) => {
        if (el.onSwiper)
          el.onSwiper(swiperInstance);
      });
      swiperInstance.updateSlides();
      swiperInstance.updateProgress();
      swiperInstance.updateSlidesClasses();
      if (swiperInstance.lazy && swiperInstance.params.lazy.enabled) {
        swiperInstance.lazy.load();
      }
    });
  };
  const calcParams = () => {
    paramsData = getParams($$restProps);
    $$invalidate(4, swiperParams = paramsData.params);
    passedParams = paramsData.passedParams;
    $$invalidate(5, restProps2 = paramsData.rest);
  };
  calcParams();
  oldPassedParams = passedParams;
  const onBeforeBreakpoint = () => {
    breakpointChanged = true;
  };
  swiperParams.onAny = (event, ...args) => {
    dispatch(event, args);
  };
  Object.assign(swiperParams.on, {
    _beforeBreakpoint: onBeforeBreakpoint,
    _containerClasses(_swiper, classes) {
      $$invalidate(3, containerClasses = classes);
    }
  });
  swiperInstance = new core_default(swiperParams);
  setContext("swiper", swiperInstance);
  if (swiperInstance.virtual && swiperInstance.params.virtual.enabled) {
    const extendWith = {
      cache: false,
      renderExternal: (data) => {
        setVirtualData(data);
        if (swiperParams.virtual && swiperParams.virtual.renderExternal) {
          swiperParams.virtual.renderExternal(data);
        }
      },
      renderExternalUpdate: false
    };
    extend2(swiperInstance.params.virtual, extendWith);
    extend2(swiperInstance.originalParams.virtual, extendWith);
  }
  onMount(() => {
    if (!swiperEl)
      return;
    mountSwiper(
      {
        el: swiperEl,
        nextEl,
        prevEl,
        paginationEl,
        scrollbarEl,
        swiper: swiperInstance
      },
      swiperParams
    );
    dispatch("swiper", [swiperInstance]);
    if (swiperParams.virtual)
      return;
    swiperInstance.slides.each((el) => {
      if (el.onSwiper)
        el.onSwiper(swiperInstance);
    });
  });
  afterUpdate(() => {
    if (!swiperInstance)
      return;
    calcParams();
    const changedParams = getChangedParams(passedParams, oldPassedParams);
    if ((changedParams.length || breakpointChanged) && swiperInstance && !swiperInstance.destroyed) {
      updateSwiper({
        swiper: swiperInstance,
        passedParams,
        changedParams,
        nextEl,
        prevEl,
        scrollbarEl,
        paginationEl
      });
    }
    breakpointChanged = false;
    oldPassedParams = passedParams;
  });
  onDestroy(() => {
    if (typeof window !== "undefined" && swiperInstance && !swiperInstance.destroyed) {
      swiperInstance.destroy(true, false);
    }
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      prevEl = $$value;
      $$invalidate(7, prevEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nextEl = $$value;
      $$invalidate(8, nextEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollbarEl = $$value;
      $$invalidate(9, scrollbarEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      paginationEl = $$value;
      $$invalidate(10, paginationEl);
    });
  }
  function svelte_element1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      swiperEl = $$value;
      $$invalidate(6, swiperEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("wrapperTag" in $$new_props)
      $$invalidate(2, wrapperTag = $$new_props.wrapperTag);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    createEventDispatcher,
    tick,
    setContext,
    Swiper: core_default,
    getParams,
    mountSwiper,
    needsScrollbar,
    needsNavigation,
    needsPagination,
    uniqueClasses,
    extend: extend2,
    getChangedParams,
    updateSwiper,
    dispatch,
    className,
    tag,
    wrapperTag,
    containerClasses,
    breakpointChanged,
    swiperInstance,
    oldPassedParams,
    paramsData,
    swiperParams,
    passedParams,
    restProps: restProps2,
    swiperEl,
    prevEl,
    nextEl,
    scrollbarEl,
    paginationEl,
    virtualData,
    swiper,
    setVirtualData,
    calcParams,
    onBeforeBreakpoint
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("wrapperTag" in $$props)
      $$invalidate(2, wrapperTag = $$new_props.wrapperTag);
    if ("containerClasses" in $$props)
      $$invalidate(3, containerClasses = $$new_props.containerClasses);
    if ("breakpointChanged" in $$props)
      breakpointChanged = $$new_props.breakpointChanged;
    if ("swiperInstance" in $$props)
      swiperInstance = $$new_props.swiperInstance;
    if ("oldPassedParams" in $$props)
      oldPassedParams = $$new_props.oldPassedParams;
    if ("paramsData" in $$props)
      paramsData = $$new_props.paramsData;
    if ("swiperParams" in $$props)
      $$invalidate(4, swiperParams = $$new_props.swiperParams);
    if ("passedParams" in $$props)
      passedParams = $$new_props.passedParams;
    if ("restProps" in $$props)
      $$invalidate(5, restProps2 = $$new_props.restProps);
    if ("swiperEl" in $$props)
      $$invalidate(6, swiperEl = $$new_props.swiperEl);
    if ("prevEl" in $$props)
      $$invalidate(7, prevEl = $$new_props.prevEl);
    if ("nextEl" in $$props)
      $$invalidate(8, nextEl = $$new_props.nextEl);
    if ("scrollbarEl" in $$props)
      $$invalidate(9, scrollbarEl = $$new_props.scrollbarEl);
    if ("paginationEl" in $$props)
      $$invalidate(10, paginationEl = $$new_props.paginationEl);
    if ("virtualData" in $$props)
      $$invalidate(11, virtualData = $$new_props.virtualData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    tag,
    wrapperTag,
    containerClasses,
    swiperParams,
    restProps2,
    swiperEl,
    prevEl,
    nextEl,
    scrollbarEl,
    paginationEl,
    virtualData,
    swiper,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div_binding,
    div_binding_1,
    svelte_element1_binding
  ];
}
var Swiper_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment95, safe_not_equal, {
      class: 0,
      tag: 1,
      wrapperTag: 2,
      swiper: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swiper_1",
      options,
      id: create_fragment95.name
    });
  }
  get class() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperTag() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperTag(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swiper() {
    return this.$$.ctx[12];
  }
  set swiper(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swiper_default = Swiper_1;

// node_modules/swiper/svelte/swiper-slide.svelte
var file92 = "node_modules/swiper/svelte/swiper-slide.svelte";
var get_default_slot_changes_12 = (dirty) => ({ data: dirty & /*slideData*/
32 });
var get_default_slot_context_12 = (ctx) => ({ data: (
  /*slideData*/
  ctx[5]
) });
var get_default_slot_changes15 = (dirty) => ({ data: dirty & /*slideData*/
32 });
var get_default_slot_context15 = (ctx) => ({ data: (
  /*slideData*/
  ctx[5]
) });
function create_else_block16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_12
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slideData*/
        160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_12
            ),
            get_default_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(92:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block41(ctx) {
  let div;
  let div_data_swiper_zoom_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context15
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "swiper-zoom-container");
      attr_dev(div, "data-swiper-zoom", div_data_swiper_zoom_value = typeof /*zoom*/
      ctx[0] === "number" ? (
        /*zoom*/
        ctx[0]
      ) : void 0);
      add_location(div, file92, 85, 4, 2126);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slideData*/
        160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      }
      if (!current || dirty & /*zoom*/
      1 && div_data_swiper_zoom_value !== (div_data_swiper_zoom_value = typeof /*zoom*/
      ctx2[0] === "number" ? (
        /*zoom*/
        ctx2[0]
      ) : void 0)) {
        attr_dev(div, "data-swiper-zoom", div_data_swiper_zoom_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(85:2) {#if zoom}",
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block41, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*zoom*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = uniqueClasses(`${/*slideClasses*/
      ctx[3]}${/*className*/
      ctx[2] ? ` ${/*className*/
      ctx[2]}` : ""}`)
    },
    {
      "data-swiper-slide-index": (
        /*virtualIndex*/
        ctx[1]
      )
    },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file92, 78, 0, 1942);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*slideClasses, className*/
        12 && div_class_value !== (div_class_value = uniqueClasses(`${/*slideClasses*/
        ctx2[3]}${/*className*/
        ctx2[2] ? ` ${/*className*/
        ctx2[2]}` : ""}`))) && { class: div_class_value },
        (!current || dirty & /*virtualIndex*/
        2) && {
          "data-swiper-slide-index": (
            /*virtualIndex*/
            ctx2[1]
          )
        },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let slideData;
  const omit_props_names = ["zoom", "virtualIndex", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swiper_slide", slots, ["default"]);
  let { zoom = void 0 } = $$props;
  let { virtualIndex = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let slideEl = null;
  let slideClasses = "swiper-slide";
  let swiper = getContext("swiper");
  let eventAttached = false;
  const updateClasses = (_, el, classNames2) => {
    if (el === slideEl) {
      $$invalidate(3, slideClasses = classNames2);
    }
  };
  const attachEvent = () => {
    if (!swiper || eventAttached)
      return;
    swiper.on("_slideClass", updateClasses);
    eventAttached = true;
  };
  const detachEvent = () => {
    if (!swiper)
      return;
    swiper.off("_slideClass", updateClasses);
    eventAttached = false;
  };
  onMount(() => {
    if (typeof virtualIndex === "undefined")
      return;
    $$invalidate(
      4,
      slideEl.onSwiper = (_swiper) => {
        swiper = _swiper;
        attachEvent();
      },
      slideEl
    );
    attachEvent();
  });
  afterUpdate(() => {
    if (!slideEl || !swiper)
      return;
    if (swiper.destroyed) {
      if (slideClasses !== "swiper-slide") {
        $$invalidate(3, slideClasses = "swiper-slide");
      }
      return;
    }
    attachEvent();
  });
  beforeUpdate(() => {
    attachEvent();
  });
  onDestroy(() => {
    if (!swiper)
      return;
    detachEvent();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slideEl = $$value;
      $$invalidate(4, slideEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("zoom" in $$new_props)
      $$invalidate(0, zoom = $$new_props.zoom);
    if ("virtualIndex" in $$new_props)
      $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    beforeUpdate,
    afterUpdate,
    setContext,
    getContext,
    uniqueClasses,
    zoom,
    virtualIndex,
    className,
    slideEl,
    slideClasses,
    swiper,
    eventAttached,
    updateClasses,
    attachEvent,
    detachEvent,
    slideData
  });
  $$self.$inject_state = ($$new_props) => {
    if ("zoom" in $$props)
      $$invalidate(0, zoom = $$new_props.zoom);
    if ("virtualIndex" in $$props)
      $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("slideEl" in $$props)
      $$invalidate(4, slideEl = $$new_props.slideEl);
    if ("slideClasses" in $$props)
      $$invalidate(3, slideClasses = $$new_props.slideClasses);
    if ("swiper" in $$props)
      swiper = $$new_props.swiper;
    if ("eventAttached" in $$props)
      eventAttached = $$new_props.eventAttached;
    if ("slideData" in $$props)
      $$invalidate(5, slideData = $$new_props.slideData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*slideClasses*/
    8) {
      $:
        $$invalidate(5, slideData = {
          isActive: slideClasses.indexOf("swiper-slide-active") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-active") >= 0,
          isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
          isDuplicate: slideClasses.indexOf("swiper-slide-duplicate") >= 0,
          isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-prev") >= 0,
          isNext: slideClasses.indexOf("swiper-slide-next") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-next") >= 0
        });
    }
  };
  return [
    zoom,
    virtualIndex,
    className,
    slideClasses,
    slideEl,
    slideData,
    $$restProps,
    $$scope,
    slots,
    div_binding
  ];
}
var Swiper_slide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment96, safe_not_equal, { zoom: 0, virtualIndex: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swiper_slide",
      options,
      id: create_fragment96.name
    });
  }
  get zoom() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualIndex() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualIndex(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swiper_slide_default = Swiper_slide;

// node_modules/framework7-svelte/components/swiper-slide.js
var swiper_slide_default2 = swiper_slide_default;

// node_modules/framework7-svelte/components/swiper.js
var swiper_default2 = swiper_default;

// node_modules/framework7-svelte/components/tab.svelte
var file93 = "node_modules/framework7-svelte/components/tab.svelte";
function create_if_block42(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*tabContent*/
    ctx[2].props
  ];
  var switch_value = (
    /*tabContent*/
    ctx[2].component
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*tabContent*/
      4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*tabContent*/
        ctx2[2].props
      )]) : {};
      if (dirty & /*tabContent*/
      4 && switch_value !== (switch_value = /*tabContent*/
      ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block42.name,
    type: "if",
    source: "(87:2) {#if tabContent}",
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*tabContent*/
    ctx[2] && create_if_block42(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { id: (
      /*id*/
      ctx[0]
    ) },
    { class: (
      /*classes*/
      ctx[3]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file93, 85, 0, 2437);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tabContent*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tabContent*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block42(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*id*/
        1) && { id: (
          /*id*/
          ctx2[0]
        ) },
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tabActive", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { tabActive = false } = $$props;
  let { id = void 0 } = $$props;
  const RouterContext = getContext("RouterContext") || {};
  let el;
  let routerData = null;
  let initialTabContent = null;
  if (!routerData && RouterContext && RouterContext.route && RouterContext.route.route && RouterContext.route.route.tab && RouterContext.route.route.tab.id === id) {
    const { component, asyncComponent, options: tabRouteOptions } = RouterContext.route.route.tab;
    if (component || asyncComponent) {
      const parentProps = RouterContext.route.route.options && RouterContext.route.route.options.props;
      initialTabContent = {
        id: getComponentId(),
        component: component || asyncComponent,
        isAsync: !!asyncComponent,
        props: {
          ...parentProps || {},
          ...tabRouteOptions && tabRouteOptions.props || {},
          f7router: RouterContext.router,
          f7route: RouterContext.route,
          ...RouterContext.route.params
        }
      };
    }
  }
  let tabContent = initialTabContent || null;
  useTab(() => el, emit);
  onMount(() => {
    if (el && initialTabContent) {
      $$invalidate(1, el.f7RouterTabLoaded = true, el);
    }
    f7ready(() => {
      if (!routerData) {
        routerData = {
          el,
          setTabContent(tc) {
            tick().then(() => {
              $$invalidate(2, tabContent = tc);
            });
          }
        };
        app.f7routers.tabs.push(routerData);
      } else {
        routerData.el = el;
      }
    });
  });
  afterUpdate(() => {
    if (!routerData)
      return;
    app.f7events.emit("tabRouterDidUpdate", routerData);
  });
  onDestroy(() => {
    if (!routerData)
      return;
    app.f7routers.tabs.splice(app.f7routers.tabs.indexOf(routerData), 1);
    routerData = null;
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("tabActive" in $$new_props)
      $$invalidate(6, tabActive = $$new_props.tabActive);
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    createEventDispatcher,
    tick,
    getContext,
    restProps,
    colorClasses,
    classNames,
    createEmitter,
    getComponentId,
    f7ready,
    app,
    useTab,
    emit,
    className,
    tabActive,
    id,
    RouterContext,
    el,
    routerData,
    initialTabContent,
    tabContent,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("tabActive" in $$props)
      $$invalidate(6, tabActive = $$new_props.tabActive);
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("el" in $$props)
      $$invalidate(1, el = $$new_props.el);
    if ("routerData" in $$props)
      routerData = $$new_props.routerData;
    if ("initialTabContent" in $$props)
      initialTabContent = $$new_props.initialTabContent;
    if ("tabContent" in $$props)
      $$invalidate(2, tabContent = $$new_props.tabContent);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(className, "tab", tabActive && "tab-active", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    el,
    tabContent,
    classes,
    $$restProps,
    className,
    tabActive,
    $$scope,
    slots,
    div_binding
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment97, safe_not_equal, { class: 5, tabActive: 6, id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment97.name
    });
  }
  get class() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabActive() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabActive(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var tab_default = Tab;

// node_modules/framework7-svelte/components/tabs.svelte
var file94 = "node_modules/framework7-svelte/components/tabs.svelte";
function create_else_block17(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    {
      class: div_class_value = classNames(
        /*tabsClasses*/
        ctx[3],
        /*classes*/
        ctx[5]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file94, 40, 2, 1008);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*tabsClasses, classes*/
        40 && div_class_value !== (div_class_value = classNames(
          /*tabsClasses*/
          ctx2[3],
          /*classes*/
          ctx2[5]
        ))) && { class: div_class_value },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(40:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block43(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div1_levels = [
    {
      class: div1_class_value = classNames(
        /*wrapClasses*/
        ctx[4],
        /*classes*/
        ctx[5]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div0,
        "class",
        /*tabsClasses*/
        ctx[3]
      );
      add_location(div0, file94, 35, 4, 937);
      set_attributes(div1, div1_data);
      add_location(div1, file94, 34, 2, 839);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[12](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tabsClasses*/
      8) {
        attr_dev(
          div0,
          "class",
          /*tabsClasses*/
          ctx2[3]
        );
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & /*wrapClasses, classes*/
        48 && div1_class_value !== (div1_class_value = classNames(
          /*wrapClasses*/
          ctx2[4],
          /*classes*/
          ctx2[5]
        ))) && { class: div1_class_value },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block43.name,
    type: "if",
    source: "(34:0) {#if animated || swipeable}",
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block43, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*animated*/
      ctx2[0] || /*swipeable*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let classes;
  let wrapClasses;
  let tabsClasses;
  const omit_props_names = ["class", "animated", "swipeable", "routable", "swiperParams"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { animated = false } = $$props;
  let { swipeable = false } = $$props;
  let { routable = false } = $$props;
  let { swiperParams = void 0 } = $$props;
  let wrapEl;
  onMount(() => {
    if (swipeable && swiperParams && wrapEl) {
      $$invalidate(2, wrapEl.f7SwiperParams = swiperParams, wrapEl);
    }
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapEl = $$value;
      $$invalidate(2, wrapEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("animated" in $$new_props)
      $$invalidate(0, animated = $$new_props.animated);
    if ("swipeable" in $$new_props)
      $$invalidate(1, swipeable = $$new_props.swipeable);
    if ("routable" in $$new_props)
      $$invalidate(8, routable = $$new_props.routable);
    if ("swiperParams" in $$new_props)
      $$invalidate(9, swiperParams = $$new_props.swiperParams);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    restProps,
    colorClasses,
    classNames,
    className,
    animated,
    swipeable,
    routable,
    swiperParams,
    wrapEl,
    tabsClasses,
    wrapClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("animated" in $$props)
      $$invalidate(0, animated = $$new_props.animated);
    if ("swipeable" in $$props)
      $$invalidate(1, swipeable = $$new_props.swipeable);
    if ("routable" in $$props)
      $$invalidate(8, routable = $$new_props.routable);
    if ("swiperParams" in $$props)
      $$invalidate(9, swiperParams = $$new_props.swiperParams);
    if ("wrapEl" in $$props)
      $$invalidate(2, wrapEl = $$new_props.wrapEl);
    if ("tabsClasses" in $$props)
      $$invalidate(3, tabsClasses = $$new_props.tabsClasses);
    if ("wrapClasses" in $$props)
      $$invalidate(4, wrapClasses = $$new_props.wrapClasses);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classes = classNames(className, colorClasses($$props)));
    if ($$self.$$.dirty & /*animated, swipeable*/
    3) {
      $:
        $$invalidate(4, wrapClasses = classNames({
          "tabs-animated-wrap": animated,
          "tabs-swipeable-wrap": swipeable
        }));
    }
    if ($$self.$$.dirty & /*routable*/
    256) {
      $:
        $$invalidate(3, tabsClasses = classNames({ tabs: true, "tabs-routable": routable }));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    animated,
    swipeable,
    wrapEl,
    tabsClasses,
    wrapClasses,
    classes,
    $$restProps,
    className,
    routable,
    swiperParams,
    $$scope,
    slots,
    div1_binding
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment98, safe_not_equal, {
      class: 7,
      animated: 0,
      swipeable: 1,
      routable: 8,
      swiperParams: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment98.name
    });
  }
  get class() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeable() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeable(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routable() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routable(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swiperParams() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swiperParams(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var tabs_default = Tabs;

// node_modules/framework7-svelte/components/toolbar.svelte
var file95 = "node_modules/framework7-svelte/components/toolbar.svelte";
var get_after_inner_slot_changes5 = (dirty) => ({});
var get_after_inner_slot_context5 = (ctx) => ({});
var get_before_inner_slot_changes5 = (dirty) => ({});
var get_before_inner_slot_context5 = (ctx) => ({});
function create_else_block18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(106:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block44(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "toolbar-inner");
      add_location(div, file95, 102, 4, 2759);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block44.name,
    type: "if",
    source: "(102:2) {#if inner}",
    ctx
  });
  return block;
}
function create_fragment99(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let current;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[24]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_before_inner_slot_context5
  );
  const if_block_creators = [create_if_block44, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inner*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_inner_slot_template = (
    /*#slots*/
    ctx[24]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_after_inner_slot_context5
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (before_inner_slot)
        before_inner_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_inner_slot)
        after_inner_slot.c();
      set_attributes(div, div_data);
      add_location(div, file95, 99, 0, 2623);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (before_inner_slot) {
        before_inner_slot.m(div, null);
      }
      append_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t1);
      if (after_inner_slot) {
        after_inner_slot.m(div, null);
      }
      ctx[25](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_before_inner_slot_changes5
            ),
            get_before_inner_slot_context5
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t1);
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_after_inner_slot_changes5
            ),
            get_after_inner_slot_context5
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*f7Slot*/
        2) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(before_inner_slot, local);
      transition_in(if_block);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(before_inner_slot, local);
      transition_out(if_block);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (before_inner_slot)
        before_inner_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_inner_slot)
        after_inner_slot.d(detaching);
      ctx[25](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "tabbar",
    "labels",
    "scrollable",
    "hidden",
    "noShadow",
    "noHairline",
    "noBorder",
    "position",
    "topMd",
    "topIos",
    "topAurora",
    "top",
    "bottomMd",
    "bottomIos",
    "bottomAurora",
    "bottom",
    "inner",
    "f7Slot"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, ["before-inner", "default", "after-inner"]);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { tabbar = false } = $$props;
  let { labels = false } = $$props;
  let { scrollable = false } = $$props;
  let { hidden = false } = $$props;
  let { noShadow = false } = $$props;
  let { noHairline = false } = $$props;
  let { noBorder = false } = $$props;
  let { position = void 0 } = $$props;
  let { topMd = void 0 } = $$props;
  let { topIos = void 0 } = $$props;
  let { topAurora = void 0 } = $$props;
  let { top = void 0 } = $$props;
  let { bottomMd = void 0 } = $$props;
  let { bottomIos = void 0 } = $$props;
  let { bottomAurora = void 0 } = $$props;
  let { bottom = void 0 } = $$props;
  let { inner = true } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let theme2 = useTheme((t) => {
    $$invalidate(22, theme2 = t);
  });
  setReactiveContext("TabbarContext", () => ({ tabbarHasLabels: labels }));
  function onShow(toolbarEl) {
    if (el !== toolbarEl)
      return;
    emit("toolbarShow");
  }
  function onHide(toolbarEl) {
    if (el !== toolbarEl)
      return;
    emit("toolbarHide");
  }
  onMount(() => {
    f7ready(() => {
      if (tabbar)
        app.f7.toolbar.setHighlight(el);
      app.f7.on("toolbarShow", onShow);
      app.f7.on("toolbarHide", onHide);
    });
  });
  afterUpdate(() => {
    if (tabbar && app.f7 && el) {
      app.f7.toolbar.setHighlight(el);
    }
  });
  onDestroy(() => {
    if (!app.f7)
      return;
    app.f7.off("toolbarShow", onShow);
    app.f7.off("toolbarHide", onHide);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("tabbar" in $$new_props)
      $$invalidate(6, tabbar = $$new_props.tabbar);
    if ("labels" in $$new_props)
      $$invalidate(7, labels = $$new_props.labels);
    if ("scrollable" in $$new_props)
      $$invalidate(8, scrollable = $$new_props.scrollable);
    if ("hidden" in $$new_props)
      $$invalidate(9, hidden = $$new_props.hidden);
    if ("noShadow" in $$new_props)
      $$invalidate(10, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$new_props)
      $$invalidate(11, noHairline = $$new_props.noHairline);
    if ("noBorder" in $$new_props)
      $$invalidate(12, noBorder = $$new_props.noBorder);
    if ("position" in $$new_props)
      $$invalidate(13, position = $$new_props.position);
    if ("topMd" in $$new_props)
      $$invalidate(14, topMd = $$new_props.topMd);
    if ("topIos" in $$new_props)
      $$invalidate(15, topIos = $$new_props.topIos);
    if ("topAurora" in $$new_props)
      $$invalidate(16, topAurora = $$new_props.topAurora);
    if ("top" in $$new_props)
      $$invalidate(17, top = $$new_props.top);
    if ("bottomMd" in $$new_props)
      $$invalidate(18, bottomMd = $$new_props.bottomMd);
    if ("bottomIos" in $$new_props)
      $$invalidate(19, bottomIos = $$new_props.bottomIos);
    if ("bottomAurora" in $$new_props)
      $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    if ("bottom" in $$new_props)
      $$invalidate(21, bottom = $$new_props.bottom);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("f7Slot" in $$new_props)
      $$invalidate(1, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    afterUpdate,
    colorClasses,
    classNames,
    createEmitter,
    restProps,
    app,
    f7ready,
    useTheme,
    setReactiveContext,
    emit,
    className,
    tabbar,
    labels,
    scrollable,
    hidden,
    noShadow,
    noHairline,
    noBorder,
    position,
    topMd,
    topIos,
    topAurora,
    top,
    bottomMd,
    bottomIos,
    bottomAurora,
    bottom,
    inner,
    f7Slot,
    el,
    theme: theme2,
    onShow,
    onHide,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("tabbar" in $$props)
      $$invalidate(6, tabbar = $$new_props.tabbar);
    if ("labels" in $$props)
      $$invalidate(7, labels = $$new_props.labels);
    if ("scrollable" in $$props)
      $$invalidate(8, scrollable = $$new_props.scrollable);
    if ("hidden" in $$props)
      $$invalidate(9, hidden = $$new_props.hidden);
    if ("noShadow" in $$props)
      $$invalidate(10, noShadow = $$new_props.noShadow);
    if ("noHairline" in $$props)
      $$invalidate(11, noHairline = $$new_props.noHairline);
    if ("noBorder" in $$props)
      $$invalidate(12, noBorder = $$new_props.noBorder);
    if ("position" in $$props)
      $$invalidate(13, position = $$new_props.position);
    if ("topMd" in $$props)
      $$invalidate(14, topMd = $$new_props.topMd);
    if ("topIos" in $$props)
      $$invalidate(15, topIos = $$new_props.topIos);
    if ("topAurora" in $$props)
      $$invalidate(16, topAurora = $$new_props.topAurora);
    if ("top" in $$props)
      $$invalidate(17, top = $$new_props.top);
    if ("bottomMd" in $$props)
      $$invalidate(18, bottomMd = $$new_props.bottomMd);
    if ("bottomIos" in $$props)
      $$invalidate(19, bottomIos = $$new_props.bottomIos);
    if ("bottomAurora" in $$props)
      $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    if ("bottom" in $$props)
      $$invalidate(21, bottom = $$new_props.bottom);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("f7Slot" in $$props)
      $$invalidate(1, f7Slot = $$new_props.f7Slot);
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("theme" in $$props)
      $$invalidate(22, theme2 = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classes = classNames(
        className,
        "toolbar",
        {
          tabbar,
          "toolbar-bottom": theme2 && theme2.md && bottomMd || theme2 && theme2.ios && bottomIos || theme2 && theme2.aurora && bottomAurora || bottom || position === "bottom",
          "toolbar-top": theme2 && theme2.md && topMd || theme2 && theme2.ios && topIos || theme2 && theme2.aurora && topAurora || top || position === "top",
          "tabbar-labels": labels,
          "tabbar-scrollable": scrollable,
          "toolbar-hidden": hidden,
          "no-shadow": noShadow,
          "no-hairline": noHairline || noBorder
        },
        colorClasses($$props)
      ));
  };
  $$props = exclude_internal_props($$props);
  return [
    inner,
    f7Slot,
    el,
    classes,
    $$restProps,
    className,
    tabbar,
    labels,
    scrollable,
    hidden,
    noShadow,
    noHairline,
    noBorder,
    position,
    topMd,
    topIos,
    topAurora,
    top,
    bottomMd,
    bottomIos,
    bottomAurora,
    bottom,
    theme2,
    $$scope,
    slots,
    div_binding
  ];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment99, safe_not_equal, {
      class: 5,
      tabbar: 6,
      labels: 7,
      scrollable: 8,
      hidden: 9,
      noShadow: 10,
      noHairline: 11,
      noBorder: 12,
      position: 13,
      topMd: 14,
      topIos: 15,
      topAurora: 16,
      top: 17,
      bottomMd: 18,
      bottomIos: 19,
      bottomAurora: 20,
      bottom: 21,
      inner: 0,
      f7Slot: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment99.name
    });
  }
  get class() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabbar() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabbar(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollable() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollable(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noShadow() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noShadow(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noHairline() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noHairline(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noBorder() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noBorder(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMd() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMd(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topIos() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topIos(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topAurora() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topAurora(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottomMd() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottomMd(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottomIos() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottomIos(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottomAurora() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottomAurora(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get f7Slot() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set f7Slot(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var toolbar_default = Toolbar;

// node_modules/framework7-svelte/components/treeview-item.svelte
var file96 = "node_modules/framework7-svelte/components/treeview-item.svelte";
var get_children_slot_changes = (dirty) => ({});
var get_children_slot_context = (ctx) => ({});
var get_children_start_slot_changes = (dirty) => ({});
var get_children_start_slot_context = (ctx) => ({});
var get_root_end_slot_changes_1 = (dirty) => ({});
var get_root_end_slot_context_1 = (ctx) => ({});
var get_root_slot_changes_1 = (dirty) => ({});
var get_root_slot_context_1 = (ctx) => ({});
var get_content_end_slot_changes_13 = (dirty) => ({});
var get_content_end_slot_context_13 = (ctx) => ({});
var get_content_slot_changes_13 = (dirty) => ({});
var get_content_slot_context_13 = (ctx) => ({});
var get_label_slot_changes_12 = (dirty) => ({});
var get_label_slot_context_12 = (ctx) => ({});
var get_label_start_slot_changes_1 = (dirty) => ({});
var get_label_start_slot_context_1 = (ctx) => ({});
var get_media_slot_changes_13 = (dirty) => ({});
var get_media_slot_context_13 = (ctx) => ({});
var get_content_start_slot_changes_13 = (dirty) => ({});
var get_content_start_slot_context_13 = (ctx) => ({});
var get_root_start_slot_changes_1 = (dirty) => ({});
var get_root_start_slot_context_1 = (ctx) => ({});
var get_root_end_slot_changes4 = (dirty) => ({});
var get_root_end_slot_context4 = (ctx) => ({});
var get_root_slot_changes5 = (dirty) => ({});
var get_root_slot_context5 = (ctx) => ({});
var get_content_end_slot_changes4 = (dirty) => ({});
var get_content_end_slot_context4 = (ctx) => ({});
var get_content_slot_changes4 = (dirty) => ({});
var get_content_slot_context4 = (ctx) => ({});
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
var get_label_start_slot_changes = (dirty) => ({});
var get_label_start_slot_context = (ctx) => ({});
var get_media_slot_changes5 = (dirty) => ({});
var get_media_slot_context5 = (ctx) => ({});
var get_content_start_slot_changes4 = (dirty) => ({});
var get_content_start_slot_context4 = (ctx) => ({});
var get_root_start_slot_changes4 = (dirty) => ({});
var get_root_start_slot_context4 = (ctx) => ({});
function create_else_block19(ctx) {
  let a;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let div0;
  let t5;
  let t6_value = plainText(
    /*label*/
    ctx[0]
  ) + "";
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let current;
  let mounted;
  let dispose;
  const root_start_slot_template = (
    /*#slots*/
    ctx[20]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_start_slot_context_1
  );
  let if_block0 = (
    /*needToggle*/
    ctx[5] && create_if_block_513(ctx)
  );
  const content_start_slot_template = (
    /*#slots*/
    ctx[20]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_start_slot_context_13
  );
  let if_block1 = (
    /*icon*/
    ctx[4] && create_if_block_415(ctx)
  );
  const media_slot_template = (
    /*#slots*/
    ctx[20].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_media_slot_context_13
  );
  const label_start_slot_template = (
    /*#slots*/
    ctx[20]["label-start"]
  );
  const label_start_slot = create_slot(
    label_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_start_slot_context_1
  );
  const label_slot_template = (
    /*#slots*/
    ctx[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_slot_context_12
  );
  const content_slot_template = (
    /*#slots*/
    ctx[20].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_slot_context_13
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[20]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_end_slot_context_13
  );
  const root_slot_template = (
    /*#slots*/
    ctx[20].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_slot_context_1
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[20]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_end_slot_context_1
  );
  let a_levels = [
    { class: (
      /*itemRootClasses*/
      ctx[7]
    ) },
    /*itemRootAttrs*/
    ctx[6]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (root_start_slot)
        root_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (media_slot)
        media_slot.c();
      t4 = space();
      div0 = element("div");
      if (label_start_slot)
        label_start_slot.c();
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      if (label_slot)
        label_slot.c();
      t8 = space();
      if (content_slot)
        content_slot.c();
      t9 = space();
      if (content_end_slot)
        content_end_slot.c();
      t10 = space();
      if (root_slot)
        root_slot.c();
      t11 = space();
      if (root_end_slot)
        root_end_slot.c();
      attr_dev(div0, "class", "treeview-item-label");
      add_location(div0, file96, 141, 8, 3782);
      attr_dev(div1, "class", "treeview-item-content");
      add_location(div1, file96, 135, 6, 3608);
      set_attributes(a, a_data);
      add_location(a, file96, 130, 4, 3428);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (root_start_slot) {
        root_start_slot.m(a, null);
      }
      append_dev(a, t0);
      if (if_block0)
        if_block0.m(a, null);
      append_dev(a, t1);
      append_dev(a, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t3);
      if (media_slot) {
        media_slot.m(div1, null);
      }
      append_dev(div1, t4);
      append_dev(div1, div0);
      if (label_start_slot) {
        label_start_slot.m(div0, null);
      }
      append_dev(div0, t5);
      append_dev(div0, t6);
      append_dev(div0, t7);
      if (label_slot) {
        label_slot.m(div0, null);
      }
      append_dev(div1, t8);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t9);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      append_dev(a, t10);
      if (root_slot) {
        root_slot.m(a, null);
      }
      append_dev(a, t11);
      if (root_end_slot) {
        root_end_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*onClick*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_start_slot_changes_1
            ),
            get_root_start_slot_context_1
          );
        }
      }
      if (
        /*needToggle*/
        ctx2[5]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_513(ctx2);
          if_block0.c();
          if_block0.m(a, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_start_slot_changes_13
            ),
            get_content_start_slot_context_13
          );
        }
      }
      if (
        /*icon*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*icon*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_415(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_media_slot_changes_13
            ),
            get_media_slot_context_13
          );
        }
      }
      if (label_start_slot) {
        if (label_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            label_start_slot,
            label_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_start_slot_changes_1
            ),
            get_label_start_slot_context_1
          );
        }
      }
      if ((!current || dirty & /*label*/
      1) && t6_value !== (t6_value = plainText(
        /*label*/
        ctx2[0]
      ) + ""))
        set_data_dev(t6, t6_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_slot_changes_12
            ),
            get_label_slot_context_12
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_slot_changes_13
            ),
            get_content_slot_context_13
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_end_slot_changes_13
            ),
            get_content_end_slot_context_13
          );
        }
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_slot_changes_1
            ),
            get_root_slot_context_1
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_end_slot_changes_1
            ),
            get_root_end_slot_context_1
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*itemRootClasses*/
        128) && { class: (
          /*itemRootClasses*/
          ctx2[7]
        ) },
        dirty & /*itemRootAttrs*/
        64 && /*itemRootAttrs*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(root_start_slot, local);
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(media_slot, local);
      transition_in(label_start_slot, local);
      transition_in(label_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      transition_in(root_slot, local);
      transition_in(root_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(root_start_slot, local);
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(media_slot, local);
      transition_out(label_start_slot, local);
      transition_out(label_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      transition_out(root_slot, local);
      transition_out(root_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (root_start_slot)
        root_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (media_slot)
        media_slot.d(detaching);
      if (label_start_slot)
        label_start_slot.d(detaching);
      if (label_slot)
        label_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      if (root_slot)
        root_slot.d(detaching);
      if (root_end_slot)
        root_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(130:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_150(ctx) {
  let div2;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let div0;
  let t5;
  let t6_value = plainText(
    /*label*/
    ctx[0]
  ) + "";
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let current;
  let mounted;
  let dispose;
  const root_start_slot_template = (
    /*#slots*/
    ctx[20]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_start_slot_context4
  );
  let if_block0 = (
    /*needToggle*/
    ctx[5] && create_if_block_320(ctx)
  );
  const content_start_slot_template = (
    /*#slots*/
    ctx[20]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_start_slot_context4
  );
  let if_block1 = (
    /*icon*/
    ctx[4] && create_if_block_227(ctx)
  );
  const media_slot_template = (
    /*#slots*/
    ctx[20].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_media_slot_context5
  );
  const label_start_slot_template = (
    /*#slots*/
    ctx[20]["label-start"]
  );
  const label_start_slot = create_slot(
    label_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_start_slot_context
  );
  const label_slot_template = (
    /*#slots*/
    ctx[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_slot_context2
  );
  const content_slot_template = (
    /*#slots*/
    ctx[20].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_slot_context4
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[20]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_content_end_slot_context4
  );
  const root_slot_template = (
    /*#slots*/
    ctx[20].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_slot_context5
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[20]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_root_end_slot_context4
  );
  let div2_levels = [
    { class: (
      /*itemRootClasses*/
      ctx[7]
    ) },
    /*itemRootAttrs*/
    ctx[6]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (root_start_slot)
        root_start_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div1 = element("div");
      if (content_start_slot)
        content_start_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (media_slot)
        media_slot.c();
      t4 = space();
      div0 = element("div");
      if (label_start_slot)
        label_start_slot.c();
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      if (label_slot)
        label_slot.c();
      t8 = space();
      if (content_slot)
        content_slot.c();
      t9 = space();
      if (content_end_slot)
        content_end_slot.c();
      t10 = space();
      if (root_slot)
        root_slot.c();
      t11 = space();
      if (root_end_slot)
        root_end_slot.c();
      attr_dev(div0, "class", "treeview-item-label");
      add_location(div0, file96, 118, 8, 3116);
      attr_dev(div1, "class", "treeview-item-content");
      add_location(div1, file96, 112, 6, 2942);
      set_attributes(div2, div2_data);
      add_location(div2, file96, 107, 4, 2760);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (root_start_slot) {
        root_start_slot.m(div2, null);
      }
      append_dev(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t3);
      if (media_slot) {
        media_slot.m(div1, null);
      }
      append_dev(div1, t4);
      append_dev(div1, div0);
      if (label_start_slot) {
        label_start_slot.m(div0, null);
      }
      append_dev(div0, t5);
      append_dev(div0, t6);
      append_dev(div0, t7);
      if (label_slot) {
        label_slot.m(div0, null);
      }
      append_dev(div1, t8);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append_dev(div1, t9);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      append_dev(div2, t10);
      if (root_slot) {
        root_slot.m(div2, null);
      }
      append_dev(div2, t11);
      if (root_end_slot) {
        root_end_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div2,
          "click",
          /*onClick*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_start_slot_changes4
            ),
            get_root_start_slot_context4
          );
        }
      }
      if (
        /*needToggle*/
        ctx2[5]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_320(ctx2);
          if_block0.c();
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_start_slot_changes4
            ),
            get_content_start_slot_context4
          );
        }
      }
      if (
        /*icon*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*icon*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_227(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_media_slot_changes5
            ),
            get_media_slot_context5
          );
        }
      }
      if (label_start_slot) {
        if (label_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            label_start_slot,
            label_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_start_slot_changes
            ),
            get_label_start_slot_context
          );
        }
      }
      if ((!current || dirty & /*label*/
      1) && t6_value !== (t6_value = plainText(
        /*label*/
        ctx2[0]
      ) + ""))
        set_data_dev(t6, t6_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_slot_changes4
            ),
            get_content_slot_context4
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_content_end_slot_changes4
            ),
            get_content_end_slot_context4
          );
        }
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_slot_changes5
            ),
            get_root_slot_context5
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_root_end_slot_changes4
            ),
            get_root_end_slot_context4
          );
        }
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & /*itemRootClasses*/
        128) && { class: (
          /*itemRootClasses*/
          ctx2[7]
        ) },
        dirty & /*itemRootAttrs*/
        64 && /*itemRootAttrs*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(root_start_slot, local);
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(media_slot, local);
      transition_in(label_start_slot, local);
      transition_in(label_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      transition_in(root_slot, local);
      transition_in(root_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(root_start_slot, local);
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(media_slot, local);
      transition_out(label_start_slot, local);
      transition_out(label_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      transition_out(root_slot, local);
      transition_out(root_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (root_start_slot)
        root_start_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (content_start_slot)
        content_start_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (media_slot)
        media_slot.d(detaching);
      if (label_start_slot)
        label_start_slot.d(detaching);
      if (label_slot)
        label_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (content_end_slot)
        content_end_slot.d(detaching);
      if (root_slot)
        root_slot.d(detaching);
      if (root_end_slot)
        root_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_150.name,
    type: "if",
    source: "(107:2) {#if treeviewRootTag === 'div'}",
    ctx
  });
  return block;
}
function create_if_block_513(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "treeview-toggle");
      add_location(div, file96, 133, 8, 3558);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_513.name,
    type: "if",
    source: "(133:6) {#if needToggle}",
    ctx
  });
  return block;
}
function create_if_block_415(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty & /*icon*/
      16)
        useicon_changes.icon = /*icon*/
        ctx2[4];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_415.name,
    type: "if",
    source: "(138:8) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block_320(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "treeview-toggle");
      add_location(div, file96, 110, 8, 2892);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_320.name,
    type: "if",
    source: "(110:6) {#if needToggle}",
    ctx
  });
  return block;
}
function create_if_block_227(ctx) {
  let useicon;
  let current;
  useicon = new use_icon_default({
    props: { icon: (
      /*icon*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty & /*icon*/
      16)
        useicon_changes.icon = /*icon*/
        ctx2[4];
      useicon.$set(useicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_227.name,
    type: "if",
    source: "(115:8) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block45(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const children_start_slot_template = (
    /*#slots*/
    ctx[20]["children-start"]
  );
  const children_start_slot = create_slot(
    children_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_children_start_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const children_slot_template = (
    /*#slots*/
    ctx[20].children
  );
  const children_slot = create_slot(
    children_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_children_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (children_start_slot)
        children_start_slot.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (children_slot)
        children_slot.c();
      attr_dev(div, "class", "treeview-item-children");
      add_location(div, file96, 154, 4, 4110);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (children_start_slot) {
        children_start_slot.m(div, null);
      }
      append_dev(div, t0);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t1);
      if (children_slot) {
        children_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (children_start_slot) {
        if (children_start_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            children_start_slot,
            children_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              children_start_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_children_start_slot_changes
            ),
            get_children_start_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (children_slot) {
        if (children_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            children_slot,
            children_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              children_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_children_slot_changes
            ),
            get_children_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(children_start_slot, local);
      transition_in(default_slot, local);
      transition_in(children_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(children_start_slot, local);
      transition_out(default_slot, local);
      transition_out(children_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (children_start_slot)
        children_start_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (children_slot)
        children_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block45.name,
    type: "if",
    source: "(154:2) {#if hasChildren}",
    ctx
  });
  return block;
}
function create_fragment100(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_150, create_else_block19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*treeviewRootTag*/
      ctx2[3] === "div"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*hasChildren*/
    ctx[1] && create_if_block45(ctx)
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[8]
  ) }, restProps(
    /*$$restProps*/
    ctx[10]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      set_attributes(div, div_data);
      add_location(div, file96, 105, 0, 2657);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[21](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (
        /*hasChildren*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*hasChildren*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block45(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        1024 && restProps(
          /*$$restProps*/
          ctx2[10]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  let classes;
  let itemRootClasses;
  let itemRootAttrs;
  let hasChildren;
  let needToggle;
  let icon;
  let treeviewRootTag;
  const omit_props_names = [
    "class",
    "toggle",
    "itemToggle",
    "selectable",
    "selected",
    "opened",
    "label",
    "loadChildren",
    "link"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Treeview_item", slots, [
    "root-start",
    "content-start",
    "media",
    "label-start",
    "label",
    "content",
    "content-end",
    "root",
    "root-end",
    "children-start",
    "default",
    "children"
  ]);
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { toggle = void 0 } = $$props;
  let { itemToggle = false } = $$props;
  let { selectable = false } = $$props;
  let { selected = false } = $$props;
  let { opened = false } = $$props;
  let { label = void 0 } = $$props;
  let { loadChildren = false } = $$props;
  let { link = void 0 } = $$props;
  let el;
  function onClick(e) {
    emit("click", [e]);
  }
  function onOpen(itemEl) {
    if (itemEl !== el)
      return;
    emit("treeviewOpen", [el]);
  }
  function onClose(itemEl) {
    if (itemEl !== el)
      return;
    emit("treeviewClose", [el]);
  }
  function onLoadChildren(itemEl, done) {
    if (itemEl !== el)
      return;
    emit("treeviewLoadChildren", [el, done]);
  }
  onMount(() => {
    if (!el)
      return;
    f7ready(() => {
      app.f7.on("treeviewOpen", onOpen);
      app.f7.on("treeviewClose", onClose);
      app.f7.on("treeviewLoadChildren", onLoadChildren);
    });
  });
  onDestroy(() => {
    if (!el || !app.f7)
      return;
    app.f7.off("treeviewOpen", onOpen);
    app.f7.off("treeviewClose", onClose);
    app.f7.off("treeviewLoadChildren", onLoadChildren);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("toggle" in $$new_props)
      $$invalidate(12, toggle = $$new_props.toggle);
    if ("itemToggle" in $$new_props)
      $$invalidate(13, itemToggle = $$new_props.itemToggle);
    if ("selectable" in $$new_props)
      $$invalidate(14, selectable = $$new_props.selectable);
    if ("selected" in $$new_props)
      $$invalidate(15, selected = $$new_props.selected);
    if ("opened" in $$new_props)
      $$invalidate(16, opened = $$new_props.opened);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("loadChildren" in $$new_props)
      $$invalidate(17, loadChildren = $$new_props.loadChildren);
    if ("link" in $$new_props)
      $$invalidate(18, link = $$new_props.link);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    onDestroy,
    colorClasses,
    routerAttrs,
    routerClasses,
    actionsClasses,
    actionsAttrs,
    classNames,
    extend,
    plainText,
    createEmitter,
    restProps,
    app,
    f7ready,
    useIcon,
    UseIcon: use_icon_default,
    emit,
    className,
    toggle,
    itemToggle,
    selectable,
    selected,
    opened,
    label,
    loadChildren,
    link,
    el,
    onClick,
    onOpen,
    onClose,
    onLoadChildren,
    treeviewRootTag,
    icon,
    hasChildren,
    needToggle,
    itemRootAttrs,
    itemRootClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("toggle" in $$props)
      $$invalidate(12, toggle = $$new_props.toggle);
    if ("itemToggle" in $$props)
      $$invalidate(13, itemToggle = $$new_props.itemToggle);
    if ("selectable" in $$props)
      $$invalidate(14, selectable = $$new_props.selectable);
    if ("selected" in $$props)
      $$invalidate(15, selected = $$new_props.selected);
    if ("opened" in $$props)
      $$invalidate(16, opened = $$new_props.opened);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("loadChildren" in $$props)
      $$invalidate(17, loadChildren = $$new_props.loadChildren);
    if ("link" in $$props)
      $$invalidate(18, link = $$new_props.link);
    if ("el" in $$props)
      $$invalidate(2, el = $$new_props.el);
    if ("treeviewRootTag" in $$props)
      $$invalidate(3, treeviewRootTag = $$new_props.treeviewRootTag);
    if ("icon" in $$props)
      $$invalidate(4, icon = $$new_props.icon);
    if ("hasChildren" in $$props)
      $$invalidate(1, hasChildren = $$new_props.hasChildren);
    if ("needToggle" in $$props)
      $$invalidate(5, needToggle = $$new_props.needToggle);
    if ("itemRootAttrs" in $$props)
      $$invalidate(6, itemRootAttrs = $$new_props.itemRootAttrs);
    if ("itemRootClasses" in $$props)
      $$invalidate(7, itemRootClasses = $$new_props.itemRootClasses);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(8, classes = classNames(
        className,
        "treeview-item",
        {
          "treeview-item-opened": opened,
          "treeview-load-children": loadChildren
        },
        colorClasses($$props)
      ));
    $:
      $$invalidate(7, itemRootClasses = classNames(
        "treeview-item-root",
        {
          "treeview-item-selectable": selectable,
          "treeview-item-selected": selected,
          "treeview-item-toggle": itemToggle
        },
        routerClasses($$props),
        actionsClasses($$props)
      ));
    $:
      $$invalidate(6, itemRootAttrs = extend(
        {
          href: link === true ? "#" : link || void 0
        },
        routerAttrs($$props),
        actionsAttrs($$props)
      ));
    if ($$self.$$.dirty & /*toggle, hasChildren*/
    4098) {
      $:
        $$invalidate(5, needToggle = typeof toggle === "undefined" ? hasChildren : toggle);
    }
    $:
      $$invalidate(4, icon = useIcon($$props));
    if ($$self.$$.dirty & /*link*/
    262144) {
      $:
        $$invalidate(3, treeviewRootTag = link || link === "" ? "a" : "div");
    }
  };
  $:
    $$invalidate(1, hasChildren = $$slots.default || $$slots.children || $$slots["children-start"]);
  $$props = exclude_internal_props($$props);
  return [
    label,
    hasChildren,
    el,
    treeviewRootTag,
    icon,
    needToggle,
    itemRootAttrs,
    itemRootClasses,
    classes,
    onClick,
    $$restProps,
    className,
    toggle,
    itemToggle,
    selectable,
    selected,
    opened,
    loadChildren,
    link,
    $$scope,
    slots,
    div_binding
  ];
}
var Treeview_item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment100, safe_not_equal, {
      class: 11,
      toggle: 12,
      itemToggle: 13,
      selectable: 14,
      selected: 15,
      opened: 16,
      label: 0,
      loadChildren: 17,
      link: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Treeview_item",
      options,
      id: create_fragment100.name
    });
  }
  get class() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToggle() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToggle(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadChildren() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadChildren(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var treeview_item_default = Treeview_item;

// node_modules/framework7-svelte/components/treeview.svelte
var file97 = "node_modules/framework7-svelte/components/treeview.svelte";
function create_fragment101(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file97, 11, 0, 317);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Treeview", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    colorClasses,
    classNames,
    restProps,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "treeview", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, $$scope, slots];
}
var Treeview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment101, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Treeview",
      options,
      id: create_fragment101.name
    });
  }
  get class() {
    throw new Error("<Treeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Treeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var treeview_default = Treeview;

// node_modules/framework7-svelte/components/views.svelte
var file98 = "node_modules/framework7-svelte/components/views.svelte";
function create_fragment102(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file98, 20, 0, 384);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["tabs", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Views", slots, ["default"]);
  let { tabs = false } = $$props;
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tabs" in $$new_props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    restProps,
    colorClasses,
    classNames,
    tabs,
    className,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("tabs" in $$props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classes = classNames(className, "views", { tabs }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, tabs, className, $$scope, slots];
}
var Views = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment102, safe_not_equal, { tabs: 2, class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Views",
      options,
      id: create_fragment102.name
    });
  }
  get tabs() {
    throw new Error("<Views>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Views>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Views>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Views>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var views_default = Views;

// node_modules/framework7-svelte/framework7-svelte.js
var framework7_svelte_default = plugin_default;
export {
  accordion_default as Accordion,
  accordion_content_default as AccordionContent,
  accordion_item_default as AccordionItem,
  accordion_toggle_default as AccordionToggle,
  actions_default as Actions,
  actions_button_default as ActionsButton,
  actions_group_default as ActionsGroup,
  actions_label_default as ActionsLabel,
  app_default as App,
  appbar_default as Appbar,
  area_chart_default as AreaChart,
  badge_default as Badge,
  block_default as Block,
  block_footer_default as BlockFooter,
  block_header_default as BlockHeader,
  block_title_default as BlockTitle,
  breadcrumbs_default as Breadcrumbs,
  breadcrumbs_collapsed_default as BreadcrumbsCollapsed,
  breadcrumbs_item_default as BreadcrumbsItem,
  breadcrumbs_separator_default as BreadcrumbsSeparator,
  button_default as Button,
  card_default as Card,
  card_content_default as CardContent,
  card_footer_default as CardFooter,
  card_header_default as CardHeader,
  checkbox_default as Checkbox,
  chip_default as Chip,
  col_default as Col,
  fab_default as Fab,
  fab_backdrop_default as FabBackdrop,
  fab_button_default as FabButton,
  fab_buttons_default as FabButtons,
  gauge_default as Gauge,
  icon_default as Icon,
  input_default as Input,
  link_default as Link,
  list_default as List,
  list_button_default as ListButton,
  list_group_default as ListGroup,
  list_index_default as ListIndex,
  list_input_default as ListInput,
  list_item_default as ListItem,
  list_item_cell_default as ListItemCell,
  list_item_row_default as ListItemRow,
  login_screen_default as LoginScreen,
  login_screen_title_default as LoginScreenTitle,
  menu_default as Menu,
  menu_dropdown_default as MenuDropdown,
  menu_dropdown_item_default as MenuDropdownItem,
  menu_item_default as MenuItem,
  message_default as Message,
  messagebar_default as Messagebar,
  messagebar_attachment_default as MessagebarAttachment,
  messagebar_attachments_default as MessagebarAttachments,
  messagebar_sheet_default as MessagebarSheet,
  messagebar_sheet_image_default as MessagebarSheetImage,
  messagebar_sheet_item_default as MessagebarSheetItem,
  messages_default as Messages,
  messages_title_default as MessagesTitle,
  nav_left_default as NavLeft,
  nav_right_default as NavRight,
  nav_title_default as NavTitle,
  nav_title_large_default as NavTitleLarge,
  navbar_default as Navbar,
  page_default as Page,
  page_content_default as PageContent,
  panel_default as Panel,
  photo_browser_default as PhotoBrowser,
  pie_chart_default as PieChart,
  popover_default as Popover,
  popup_default as Popup,
  preloader_default as Preloader,
  progressbar_default as Progressbar,
  radio_default as Radio,
  range_default as Range,
  routable_modals_default as RoutableModals,
  router_context_provider_default as RouterContextProvider,
  row_default as Row,
  searchbar_default as Searchbar,
  segmented_default as Segmented,
  sheet_default as Sheet,
  skeleton_avatar_default as SkeletonAvatar,
  skeleton_block_default as SkeletonBlock,
  skeleton_image_default as SkeletonImage,
  skeleton_text_default as SkeletonText,
  stepper_default as Stepper,
  subnavbar_default as Subnavbar,
  swipeout_actions_default as SwipeoutActions,
  swipeout_button_default as SwipeoutButton,
  swiper_default2 as Swiper,
  swiper_slide_default2 as SwiperSlide,
  tab_default as Tab,
  tabs_default as Tabs,
  text_editor_default as TextEditor,
  toggle_default as Toggle,
  toolbar_default as Toolbar,
  treeview_default as Treeview,
  treeview_item_default as TreeviewItem,
  use_icon_default as UseIcon,
  view_default as View,
  views_default as Views,
  app,
  framework7_svelte_default as default,
  f7,
  f7ready,
  theme,
  useStore
};
//# sourceMappingURL=framework7-svelte.js.map
