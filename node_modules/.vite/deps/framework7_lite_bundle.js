import {
  ConstructorMethods,
  ModalMethods,
  app_class_default,
  auroraPreloaderContent,
  bindMethods,
  class_default,
  clicks_default,
  colorHexToRgb,
  colorHsbToHsl,
  colorHslToHsb,
  colorHslToRgb,
  colorRgbToHex,
  colorRgbToHsl,
  create_store_default,
  deleteProps,
  device_default,
  dom7_default,
  extend,
  getDevice,
  getSupport,
  getTranslate,
  history_default,
  id,
  iosPreloaderContent,
  jsx_default,
  mdPreloaderContent,
  modal_class_default,
  modal_default,
  navbar_default,
  nextFrame,
  nextTick,
  now,
  request_default,
  request_default2,
  resize_default,
  router_default,
  serializeObject,
  service_worker_default,
  statusbar_default,
  store_default,
  subnavbar_default,
  support_default,
  toolbar_default,
  touch_default,
  touch_ripple_default,
  utils_default,
  utils_exports,
  view_default
} from "./chunk-EFBM5GME.js";
import {
  A11y,
  Autoplay,
  Controller,
  EffectCards,
  EffectCoverflow,
  EffectCreative,
  EffectCube,
  EffectFade,
  EffectFlip,
  Grid,
  HashNavigation,
  History,
  Keyboard,
  Lazy,
  Manipulation,
  Mousewheel,
  Navigation,
  Pagination,
  Parallax,
  Scrollbar,
  Thumb,
  Virtual,
  Zoom,
  core_default,
  freeMode
} from "./chunk-67RK4OXE.js";
import {
  getDocument,
  getWindow
} from "./chunk-LESNZ6JR.js";
import "./chunk-JC4IRQUL.js";

// node_modules/framework7/components/appbar/appbar.js
var appbar_default = {
  name: "appbar"
};

// node_modules/framework7/components/dialog/dialog-class.js
var Dialog = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      title: app.params.dialog.title,
      text: void 0,
      content: "",
      buttons: [],
      verticalButtons: false,
      onClick: void 0,
      cssClass: void 0,
      destroyOnClose: false,
      on: {}
    }, params);
    if (typeof extendedParams.closeByBackdropClick === "undefined") {
      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
    }
    if (typeof extendedParams.backdrop === "undefined") {
      extendedParams.backdrop = app.params.dialog.backdrop;
    }
    super(app, extendedParams);
    const dialog = this;
    const device = getDevice();
    const document = getDocument();
    const {
      title,
      text,
      content,
      buttons,
      verticalButtons,
      cssClass,
      backdrop
    } = extendedParams;
    dialog.params = extendedParams;
    let $el;
    if (!dialog.params.el) {
      const dialogClasses = ["dialog"];
      if (buttons.length === 0)
        dialogClasses.push("dialog-no-buttons");
      if (buttons.length > 0)
        dialogClasses.push(`dialog-buttons-${buttons.length}`);
      if (verticalButtons)
        dialogClasses.push("dialog-buttons-vertical");
      if (cssClass)
        dialogClasses.push(cssClass);
      let buttonsHTML = "";
      if (buttons.length > 0) {
        buttonsHTML = jsx_default("div", {
          class: "dialog-buttons"
        }, buttons.map((button) => jsx_default("span", {
          class: `dialog-button${button.bold ? " dialog-button-bold" : ""}${button.color ? ` color-${button.color}` : ""}${button.cssClass ? ` ${button.cssClass}` : ""}`
        }, button.text)));
      }
      const dialogHtml = jsx_default("div", {
        class: dialogClasses.join(" ")
      }, jsx_default("div", {
        class: "dialog-inner"
      }, title && jsx_default("div", {
        class: "dialog-title"
      }, title), text && jsx_default("div", {
        class: "dialog-text"
      }, text), content), buttonsHTML);
      $el = dom7_default(dialogHtml);
    } else {
      $el = dom7_default(dialog.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return dialog.destroy();
    }
    let $backdropEl;
    if (backdrop) {
      $backdropEl = app.$el.children(".dialog-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="dialog-backdrop"></div>');
        app.$el.append($backdropEl);
      }
    }
    function buttonOnClick(e) {
      const buttonEl = this;
      const index = dom7_default(buttonEl).index();
      const button = buttons[index];
      if (button.onClick)
        button.onClick(dialog, e);
      if (dialog.params.onClick)
        dialog.params.onClick(dialog, index);
      if (button.close !== false)
        dialog.close();
    }
    let addKeyboardHander;
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      buttons.forEach((button, index) => {
        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
          if (document.activeElement)
            document.activeElement.blur();
          if (button.onClick)
            button.onClick(dialog, e);
          if (dialog.params.onClick)
            dialog.params.onClick(dialog, index);
          if (button.close !== false)
            dialog.close();
        }
      });
    }
    if (buttons && buttons.length > 0) {
      dialog.on("open", () => {
        $el.find(".dialog-button").each((buttonEl, index) => {
          const button = buttons[index];
          if (button.keyCodes)
            addKeyboardHander = true;
          dom7_default(buttonEl).on("click", buttonOnClick);
        });
        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          dom7_default(document).on("keydown", onKeyDown);
        }
      });
      dialog.on("close", () => {
        $el.find(".dialog-button").each((buttonEl) => {
          dom7_default(buttonEl).off("click", buttonOnClick);
        });
        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          dom7_default(document).off("keydown", onKeyDown);
        }
        addKeyboardHander = false;
      });
    }
    extend(dialog, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "dialog",
      setProgress(progress, duration) {
        app.progressbar.set($el.find(".progressbar"), progress, duration);
        return dialog;
      },
      setText(newText) {
        let $textEl = $el.find(".dialog-text");
        if ($textEl.length === 0) {
          $textEl = dom7_default('<div class="dialog-text"></div>');
          if (typeof title !== "undefined") {
            $textEl.insertAfter($el.find(".dialog-title"));
          } else {
            $el.find(".dialog-inner").prepend($textEl);
          }
        }
        $textEl.html(newText);
        dialog.params.text = newText;
        return dialog;
      },
      setTitle(newTitle) {
        let $titleEl = $el.find(".dialog-title");
        if ($titleEl.length === 0) {
          $titleEl = dom7_default('<div class="dialog-title"></div>');
          $el.find(".dialog-inner").prepend($titleEl);
        }
        $titleEl.html(newTitle);
        dialog.params.title = newTitle;
        return dialog;
      }
    });
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      if ($target.closest(dialog.el).length === 0) {
        if (dialog.params.closeByBackdropClick && dialog.backdropEl && dialog.backdropEl === target) {
          dialog.close();
        }
      }
    }
    dialog.on("opened", () => {
      if (dialog.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    dialog.on("close", () => {
      if (dialog.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
    });
    $el[0].f7Modal = dialog;
    if (dialog.params.destroyOnClose) {
      dialog.once("closed", () => {
        setTimeout(() => {
          dialog.destroy();
        }, 0);
      });
    }
    return dialog;
  }
};
var dialog_class_default = Dialog;

// node_modules/framework7/components/dialog/dialog.js
var dialog_default = {
  name: "dialog",
  params: {
    dialog: {
      title: void 0,
      buttonOk: "OK",
      buttonCancel: "Cancel",
      usernamePlaceholder: "Username",
      passwordPlaceholder: "Password",
      preloaderTitle: "Loading... ",
      progressTitle: "Loading... ",
      backdrop: true,
      closeByBackdropClick: false,
      destroyPredefinedDialogs: true,
      keyboardActions: true,
      autoFocus: true
    }
  },
  static: {
    Dialog: dialog_class_default
  },
  create() {
    const app = this;
    function defaultDialogTitle() {
      return app.params.dialog.title || app.name;
    }
    const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
    const keyboardActions = app.params.dialog.keyboardActions;
    const autoFocus = app.params.dialog.autoFocus;
    const autoFocusHandler = autoFocus ? {
      on: {
        opened(dialog) {
          dialog.$el.find("input").eq(0).focus();
        }
      }
    } : {};
    app.dialog = extend(ModalMethods({
      app,
      constructor: dialog_class_default,
      defaultSelector: ".dialog.modal-in"
    }), {
      // Shortcuts
      alert() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let [text, title, callbackOk] = args;
        if (args.length === 2 && typeof args[1] === "function") {
          [text, callbackOk, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text,
          buttons: [{
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13, 27] : null
          }],
          destroyOnClose
        }).open();
      },
      prompt() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        let [text, title, callbackOk, callbackCancel, defaultValue] = args;
        if (typeof args[1] === "function") {
          [text, callbackOk, callbackCancel, defaultValue, title] = args;
        }
        defaultValue = typeof defaultValue === "undefined" || defaultValue === null ? "" : defaultValue;
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text,
          content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${defaultValue}"></div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index) {
            const inputValue = dialog.$el.find(".dialog-input").val();
            if (index === 0 && callbackCancel)
              callbackCancel(inputValue);
            if (index === 1 && callbackOk)
              callbackOk(inputValue);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      confirm() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        let [text, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            onClick: callbackCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13] : null
          }],
          destroyOnClose
        }).open();
      },
      login() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        let [text, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text,
          // prettier-ignore
          content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index) {
            const username = dialog.$el.find('[name="dialog-username"]').val();
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index === 0 && callbackCancel)
              callbackCancel(username, password);
            if (index === 1 && callbackOk)
              callbackOk(username, password);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      password() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        let [text, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text,
          // prettier-ignore
          content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index) {
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index === 0 && callbackCancel)
              callbackCancel(password);
            if (index === 1 && callbackOk)
              callbackOk(password);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      preloader(title, color) {
        const preloaders = {
          iosPreloaderContent,
          mdPreloaderContent,
          auroraPreloaderContent
        };
        const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
        return new dialog_class_default(app, {
          title: typeof title === "undefined" || title === null ? app.params.dialog.preloaderTitle : title,
          // prettier-ignore
          content: `<div class="preloader${color ? ` color-${color}` : ""}">${preloaderInner}</div>`,
          cssClass: "dialog-preloader",
          destroyOnClose
        }).open();
      },
      progress() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        let [title, progress, color] = args;
        if (args.length === 2) {
          if (typeof args[0] === "number") {
            [progress, color, title] = args;
          } else if (typeof args[0] === "string" && typeof args[1] === "string") {
            [title, color, progress] = args;
          }
        } else if (args.length === 1) {
          if (typeof args[0] === "number") {
            [progress, title, color] = args;
          }
        }
        const infinite = typeof progress === "undefined";
        const dialog = new dialog_class_default(app, {
          title: typeof title === "undefined" ? app.params.dialog.progressTitle : title,
          cssClass: "dialog-progress",
          // prettier-ignore
          content: `
              <div class="progressbar${infinite ? "-infinite" : ""}${color ? ` color-${color}` : ""}">
                ${!infinite ? "<span></span>" : ""}
              </div>
            `,
          destroyOnClose
        });
        if (!infinite)
          dialog.setProgress(progress);
        return dialog.open();
      }
    });
  }
};

// node_modules/framework7/components/popup/popup-class.js
var Popup = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.popup, params);
    super(app, extendedParams);
    const popup = this;
    const window = getWindow();
    const document = getDocument();
    const support = getSupport();
    const device = getDevice();
    popup.params = extendedParams;
    let $el;
    if (!popup.params.el) {
      $el = dom7_default(popup.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(popup.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return popup.destroy();
    }
    let $backdropEl;
    if (popup.params.backdrop && popup.params.backdropEl) {
      $backdropEl = dom7_default(popup.params.backdropEl);
    } else if (popup.params.backdrop) {
      if (popup.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="popup-backdrop popup-backdrop-unique"></div>');
        popup.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popup.$containerEl.children(".popup-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="popup-backdrop"></div>');
        popup.$containerEl.append($backdropEl);
      }
    }
    extend(popup, {
      app,
      push: $el.hasClass("popup-push") || popup.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popup",
      $htmlEl: dom7_default("html")
    });
    if (popup.params.push) {
      $el.addClass("popup-push");
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(popup.el).length === 0) {
        if (popup.params && popup.params.closeByBackdropClick && popup.params.backdrop && popup.backdropEl && popup.backdropEl === target) {
          let needToClose = true;
          popup.$el.nextAll(".popup.modal-in").each((popupEl) => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance)
              return;
            if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === popup.backdropEl) {
              needToClose = false;
            }
          });
          if (needToClose) {
            popup.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popup.params.closeOnEscape) {
        popup.close();
      }
    }
    let pushOffset;
    let isPush;
    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }
    let allowSwipeToClose = true;
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let pageContentEl;
    let pageContentScrollTop;
    let pageContentOffsetHeight;
    let pageContentScrollHeight;
    let popupHeight;
    let $pushEl;
    function handleTouchStart(e) {
      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose)
        return;
      if (popup.params.swipeHandler && dom7_default(e.target).closest(popup.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = now();
      isScrolling = void 0;
      if (!popup.params.swipeHandler && e.type === "touchstart") {
        pageContentEl = dom7_default(e.target).closest(".page-content")[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      currentTouch = {
        x: e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY
      };
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      touchesDiff = startTouch.y - currentTouch.y;
      if (isPush && pushOffset && touchesDiff > 0) {
        touchesDiff = 0;
      }
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      $el.transition(0);
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        $el.transition("");
        return;
      }
      if (!isMoved) {
        if (isPush && pushOffset) {
          popupHeight = $el[0].offsetHeight;
          $pushEl = $el.prevAll(".popup.modal-in").eq(0);
          if ($pushEl.length === 0) {
            $pushEl = app.$el.children(".view, .views");
          }
        }
        if (pageContentEl) {
          pageContentScrollTop = pageContentEl.scrollTop;
          pageContentScrollHeight = pageContentEl.scrollHeight;
          pageContentOffsetHeight = pageContentEl.offsetHeight;
          if (!(pageContentScrollHeight === pageContentOffsetHeight) && !(direction === "to-bottom" && pageContentScrollTop === 0) && !(direction === "to-top" && pageContentScrollTop === pageContentScrollHeight - pageContentOffsetHeight)) {
            $el.transform("");
            $el.transition("");
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        isMoved = true;
        popup.emit("local::swipeStart popupSwipeStart", popup);
        popup.$el.trigger("popup:swipestart");
      } else {
        popup.emit("local::swipeMove popupSwipeMove", popup);
        popup.$el.trigger("popup:swipemove");
      }
      e.preventDefault();
      if (isPush && pushOffset) {
        const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        if ($pushEl.hasClass("popup")) {
          if ($pushEl.hasClass("popup-push")) {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`, "important");
            });
          } else {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, 0px , 0px) scale(${scale})`, "important");
            });
          }
        } else {
          $pushEl.transition(0).forEach((el) => {
            el.style.setProperty("transform", `translate3d(0,0,0) scale(${scale})`, "important");
          });
        }
      }
      $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      popup.emit("local::swipeEnd popupSwipeEnd", popup);
      popup.$el.trigger("popup:swipeend");
      isMoved = false;
      allowSwipeToClose = false;
      $el.transition("");
      if (isPush && pushOffset) {
        $pushEl.transition("").transform("");
      }
      const direction = touchesDiff <= 0 ? "to-bottom" : "to-top";
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        allowSwipeToClose = true;
        return;
      }
      const diff = Math.abs(touchesDiff);
      const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
      if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
        nextTick(() => {
          if (direction === "to-bottom") {
            $el.addClass("swipe-close-to-bottom");
          } else {
            $el.addClass("swipe-close-to-top");
          }
          $el.transform("");
          popup.emit("local::swipeclose popupSwipeClose", popup);
          popup.$el.trigger("popup:swipeclose");
          popup.close();
          allowSwipeToClose = true;
        });
        return;
      }
      allowSwipeToClose = true;
      $el.transform("");
    }
    const passive = support.passiveListener ? {
      passive: true
    } : false;
    if (popup.params.swipeToClose) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      popup.once("popupDestroy", () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      });
    }
    let hasPreviousPushPopup;
    const updatePushOffset = () => {
      const wasPush = isPush;
      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush && !wasPush) {
        setPushOffset();
      } else if (isPush && wasPush) {
        popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
      } else if (!isPush && wasPush) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
      }
    };
    const setPushOffset = () => {
      app.off("resize", updatePushOffset);
      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush) {
        pushOffset = parseInt($el.css("--f7-popup-push-offset"), 10);
        if (Number.isNaN(pushOffset))
          pushOffset = 0;
        if (pushOffset) {
          $el.addClass("popup-push");
          popup.$htmlEl.addClass("with-modal-popup-push");
          popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
        }
      }
      app.on("resize", updatePushOffset);
    };
    popup.on("open", () => {
      hasPreviousPushPopup = false;
      if (popup.params.closeOnEscape) {
        dom7_default(document).on("keydown", onKeyDown);
      }
      $el.prevAll(".popup.modal-in").addClass("popup-behind");
      setPushOffset();
    });
    popup.on("opened", () => {
      $el.removeClass("swipe-close-to-bottom swipe-close-to-top");
      if (popup.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    popup.on("close", () => {
      hasPreviousPushPopup = popup.$el.prevAll(".popup-push.modal-in").length > 0;
      if (popup.params.closeOnEscape) {
        dom7_default(document).off("keydown", onKeyDown);
      }
      if (popup.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
      $el.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl.addClass("with-modal-popup-push-closing");
      }
      app.off("resize", updatePushOffset);
    });
    popup.on("closed", () => {
      $el.removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push-closing");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
      }
    });
    $el[0].f7Modal = popup;
    return popup;
  }
};
var popup_class_default = Popup;

// node_modules/framework7/components/popup/popup.js
var popup_default = {
  name: "popup",
  params: {
    popup: {
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeOnEscape: false,
      swipeToClose: false,
      swipeHandler: null,
      push: false,
      containerEl: null
    }
  },
  static: {
    Popup: popup_class_default
  },
  create() {
    const app = this;
    app.popup = ModalMethods({
      app,
      constructor: popup_class_default,
      defaultSelector: ".popup.modal-in",
      parentSelector: ".popup"
    });
  },
  clicks: {
    ".popup-open": function openPopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popup.open(data.popup, data.animate, $clickedEl);
    },
    ".popup-close": function closePopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popup.close(data.popup, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/login-screen/login-screen-class.js
var LoginScreen = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, params);
    super(app, extendedParams);
    const loginScreen = this;
    loginScreen.params = extendedParams;
    let $el;
    if (!loginScreen.params.el) {
      $el = dom7_default(loginScreen.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(loginScreen.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return loginScreen.destroy();
    }
    extend(loginScreen, {
      app,
      $el,
      el: $el[0],
      type: "loginScreen"
    });
    $el[0].f7Modal = loginScreen;
    return loginScreen;
  }
};
var login_screen_class_default = LoginScreen;

// node_modules/framework7/components/login-screen/login-screen.js
var login_screen_default = {
  name: "loginScreen",
  static: {
    LoginScreen: login_screen_class_default
  },
  create() {
    const app = this;
    app.loginScreen = ModalMethods({
      app,
      constructor: login_screen_class_default,
      defaultSelector: ".login-screen.modal-in"
    });
  },
  clicks: {
    ".login-screen-open": function openLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
    },
    ".login-screen-close": function closeLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/popover/popover-class.js
var Popover = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.popover, params);
    super(app, extendedParams);
    const popover = this;
    const device = getDevice();
    const window = getWindow();
    const document = getDocument();
    popover.params = extendedParams;
    let $el;
    if (!popover.params.el) {
      $el = dom7_default(popover.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(popover.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    const $targetEl = dom7_default(popover.params.targetEl).eq(0);
    if ($el.length === 0) {
      return popover.destroy();
    }
    let $backdropEl;
    const forceBackdropUnique = popover.params.backdrop && app.$el.find(".popover.modal-in").filter((anotherPopoverEl) => anotherPopoverEl !== $el[0]).length > 0;
    if (popover.params.backdrop && popover.params.backdropEl) {
      $backdropEl = dom7_default(popover.params.backdropEl);
    } else if (popover.params.backdrop) {
      if (popover.params.backdropUnique || forceBackdropUnique) {
        $backdropEl = dom7_default('<div class="popover-backdrop popover-backdrop-unique"></div>');
        $backdropEl[0].f7PopoverRef = popover;
        popover.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popover.$containerEl.children(".popover-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="popover-backdrop"></div>');
        popover.$containerEl.append($backdropEl);
      }
    }
    let $angleEl;
    if ($el.find(".popover-angle").length === 0) {
      $angleEl = dom7_default('<div class="popover-angle"></div>');
      $el.prepend($angleEl);
    } else {
      $angleEl = $el.find(".popover-angle");
    }
    const originalOpen = popover.open;
    extend(popover, {
      app,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $angleEl,
      angleEl: $angleEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popover",
      forceBackdropUnique,
      open() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let [targetEl, animate] = args;
        if (typeof args[0] === "boolean")
          [animate, targetEl] = args;
        if (targetEl) {
          popover.$targetEl = dom7_default(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }
        return originalOpen.call(popover, animate);
      }
    });
    function handleResize() {
      popover.resize();
    }
    popover.on("popoverOpen", () => {
      popover.resize();
      app.on("resize", handleResize);
      dom7_default(window).on("keyboardDidShow keyboardDidHide", handleResize);
      popover.on("popoverClose popoverBeforeDestroy", () => {
        app.off("resize", handleResize);
        dom7_default(window).off("keyboardDidShow keyboardDidHide", handleResize);
      });
    });
    let touchStartTarget = null;
    function handleTouchStart(e) {
      touchStartTarget = e.target;
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(popover.el).length === 0) {
        if (popover.params.closeByBackdropClick && popover.params.backdrop && popover.backdropEl && popover.backdropEl === target && touchStartTarget === target) {
          popover.close();
        } else if (popover.params.closeByOutsideClick && touchStartTarget === target) {
          const isAnotherPopoverBackdrop = $target.hasClass("popover-backdrop-unique") && target.f7PopoverRef !== popover || $target.hasClass("popover-backdrop") && target !== popover.backdropEl;
          const isAnotherPopoverTarget = target.closest(".popover") && target.closest(".popover") !== popover.$el[0];
          if (!isAnotherPopoverBackdrop && !isAnotherPopoverTarget) {
            popover.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popover.params.closeOnEscape) {
        popover.close();
      }
    }
    if (popover.params.closeOnEscape) {
      popover.on("popoverOpen", () => {
        dom7_default(document).on("keydown", onKeyDown);
      });
      popover.on("popoverClose", () => {
        dom7_default(document).off("keydown", onKeyDown);
      });
    }
    popover.on("popoverOpened", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.on("touchstart", handleTouchStart);
        app.on("click", handleClick);
      }
    });
    popover.on("popoverClose", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.off("touchstart", handleTouchStart);
        app.off("click", handleClick);
      }
    });
    $el[0].f7Modal = popover;
    return popover;
  }
  resize() {
    const popover = this;
    const {
      app,
      $el,
      $targetEl,
      $angleEl
    } = popover;
    const {
      targetX,
      targetY,
      verticalPosition
    } = popover.params;
    $el.css({
      left: "",
      top: ""
    });
    const [width, height] = [$el.width(), $el.height()];
    let angleSize = 0;
    let angleLeft;
    let angleTop;
    if (app.theme === "ios" || app.theme === "aurora") {
      $angleEl.removeClass("on-left on-right on-top on-bottom").css({
        left: "",
        top: ""
      });
      angleSize = $angleEl.width() / 2;
    } else {
      $el.removeClass("popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle").css({
        left: "",
        top: ""
      });
    }
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    let safeAreaTop = parseInt(dom7_default("html").css("--f7-safe-area-top"), 10);
    let safeAreaLeft = parseInt(dom7_default("html").css("--f7-safe-area-left"), 10);
    let safeAreaRight = parseInt(dom7_default("html").css("--f7-safe-area-right"), 10);
    if (Number.isNaN(safeAreaTop))
      safeAreaTop = 0;
    if (Number.isNaN(safeAreaLeft))
      safeAreaLeft = 0;
    if (Number.isNaN(safeAreaRight))
      safeAreaRight = 0;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;
      const targetParentPage = $targetEl.parents(".page");
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== "undefined" && targetY !== "undefined") {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }
    let [left, top, diff] = [0, 0, 0];
    const forcedPosition = verticalPosition === "auto" ? false : verticalPosition;
    let position = forcedPosition || (app.theme === "md" ? "bottom" : "top");
    if (app.theme === "md") {
      if (forcedPosition === "bottom" || !forcedPosition && height < app.height - targetOffsetTop - targetHeight) {
        position = "bottom";
        top = targetOffsetTop + targetHeight;
      } else if (forcedPosition === "top" || !forcedPosition && height < targetOffsetTop - safeAreaTop) {
        top = targetOffsetTop - height;
        position = "top";
      } else {
        position = "middle";
        top = targetHeight / 2 + targetOffsetTop - height / 2;
      }
      top = Math.max(8, Math.min(top, app.height - height - 8));
      let hPosition;
      if (targetOffsetLeft < app.width / 2) {
        hPosition = "right";
        left = position === "middle" ? targetOffsetLeft + targetWidth : targetOffsetLeft;
      } else {
        hPosition = "left";
        left = position === "middle" ? targetOffsetLeft - width : targetOffsetLeft + targetWidth - width;
      }
      left = Math.max(8, Math.min(left, app.width - width - 8 - safeAreaRight), safeAreaLeft);
      $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
    } else {
      if (forcedPosition === "top" || !forcedPosition && height + angleSize < targetOffsetTop - safeAreaTop) {
        top = targetOffsetTop - height - angleSize;
      } else if (forcedPosition === "bottom" || !forcedPosition && height + angleSize < app.height - targetOffsetTop - targetHeight) {
        position = "bottom";
        top = targetOffsetTop + targetHeight + angleSize;
      } else {
        position = "middle";
        top = targetHeight / 2 + targetOffsetTop - height / 2;
        diff = top;
        top = Math.max(5, Math.min(top, app.height - height - 5));
        diff -= top;
      }
      if (position === "top" || position === "bottom") {
        left = targetWidth / 2 + targetOffsetLeft - width / 2;
        diff = left;
        left = Math.max(5, Math.min(left, app.width - width - 5));
        if (safeAreaLeft) {
          left = Math.max(left, safeAreaLeft);
        }
        if (safeAreaRight && left + width > app.width - 5 - safeAreaRight) {
          left = app.width - 5 - safeAreaRight - width;
        }
        if (position === "top") {
          $angleEl.addClass("on-bottom");
        }
        if (position === "bottom") {
          $angleEl.addClass("on-top");
        }
        diff -= left;
        angleLeft = width / 2 - angleSize + diff;
        angleLeft = Math.max(Math.min(angleLeft, width - angleSize * 2 - 13), 13);
        $angleEl.css({
          left: `${angleLeft}px`
        });
      } else if (position === "middle") {
        left = targetOffsetLeft - width - angleSize;
        $angleEl.addClass("on-right");
        if (left < 5 || left + width + safeAreaRight > app.width || left < safeAreaLeft) {
          if (left < 5)
            left = targetOffsetLeft + targetWidth + angleSize;
          if (left + width + safeAreaRight > app.width)
            left = app.width - width - 5 - safeAreaRight;
          if (left < safeAreaLeft)
            left = safeAreaLeft;
          $angleEl.removeClass("on-right").addClass("on-left");
        }
        angleTop = height / 2 - angleSize + diff;
        angleTop = Math.max(Math.min(angleTop, height - angleSize * 2 - 13), 13);
        $angleEl.css({
          top: `${angleTop}px`
        });
      }
    }
    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }
};
var popover_class_default = Popover;

// node_modules/framework7/components/popover/popover.js
var popover_default = {
  name: "popover",
  params: {
    popover: {
      verticalPosition: "auto",
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: true,
      closeOnEscape: false,
      containerEl: null
    }
  },
  static: {
    Popover: popover_class_default
  },
  create() {
    const app = this;
    app.popover = extend(ModalMethods({
      app,
      constructor: popover_class_default,
      defaultSelector: ".popover.modal-in"
    }), {
      open(popoverEl, targetEl, animate) {
        let $popoverEl = dom7_default(popoverEl);
        if ($popoverEl.length > 1) {
          const $targetPage = dom7_default(targetEl).parents(".page");
          if ($targetPage.length) {
            $popoverEl.each((el) => {
              const $el = dom7_default(el);
              if ($el.parents($targetPage)[0] === $targetPage[0]) {
                $popoverEl = $el;
              }
            });
          }
        }
        if ($popoverEl.length > 1) {
          $popoverEl = $popoverEl.eq($popoverEl.length - 1);
        }
        let popover = $popoverEl[0].f7Modal;
        const data = $popoverEl.dataset();
        if (!popover) {
          popover = new popover_class_default(app, Object.assign({
            el: $popoverEl,
            targetEl
          }, data));
        }
        return popover.open(targetEl, animate);
      }
    });
  },
  clicks: {
    ".popover-open": function openPopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popover.open(data.popover, $clickedEl, data.animate);
    },
    ".popover-close": function closePopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popover.close(data.popover, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/actions/actions-class.js
var Actions = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.actions, params);
    super(app, extendedParams);
    const actions = this;
    const device = getDevice();
    const window = getWindow();
    const document = getDocument();
    actions.params = extendedParams;
    let groups;
    if (actions.params.buttons) {
      groups = actions.params.buttons;
      if (!Array.isArray(groups[0]))
        groups = [groups];
    }
    actions.groups = groups;
    let $el;
    if (actions.params.el) {
      $el = dom7_default(actions.params.el).eq(0);
    } else if (actions.params.content) {
      $el = dom7_default(actions.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else if (actions.params.buttons) {
      if (actions.params.convertToPopover) {
        actions.popoverHtml = actions.renderPopover();
      }
      actions.actionsHtml = actions.render();
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
      return actions.destroy();
    }
    let $backdropEl;
    if (actions.params.backdrop && actions.params.backdropEl) {
      $backdropEl = dom7_default(actions.params.backdropEl);
    } else if (actions.params.backdrop) {
      if (actions.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="popup-backdrop popup-backdrop-unique"></div>');
        actions.$containerEl.append($backdropEl);
      } else {
        $backdropEl = actions.$containerEl.children(".actions-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="actions-backdrop"></div>');
        actions.$containerEl.append($backdropEl);
      }
    }
    const originalOpen = actions.open;
    const originalClose = actions.close;
    let popover;
    function buttonOnClick(e) {
      const $buttonEl = dom7_default(this);
      let buttonIndex;
      let groupIndex;
      if ($buttonEl.hasClass("list-button") || $buttonEl.hasClass("item-link")) {
        buttonIndex = $buttonEl.parents("li").index();
        groupIndex = $buttonEl.parents(".list").index();
      } else {
        buttonIndex = $buttonEl.index();
        groupIndex = $buttonEl.parents(".actions-group").index();
      }
      if (typeof groups !== "undefined") {
        const button = groups[groupIndex][buttonIndex];
        if (button.onClick)
          button.onClick(actions, e);
        if (actions.params.onClick)
          actions.params.onClick(actions, e);
        if (button.close !== false)
          actions.close();
      }
    }
    actions.open = function open6(animate) {
      let convertToPopover = false;
      const {
        targetEl,
        targetX,
        targetY,
        targetWidth,
        targetHeight
      } = actions.params;
      if (actions.params.convertToPopover && (targetEl || targetX !== void 0 && targetY !== void 0)) {
        if (actions.params.forceToPopover || device.ios && device.ipad || app.width >= 768 || device.desktop && app.theme === "aurora") {
          convertToPopover = true;
        }
      }
      if (convertToPopover && actions.popoverHtml) {
        popover = app.popover.create({
          containerEl: actions.params.containerEl,
          content: actions.popoverHtml,
          backdrop: actions.params.backdrop,
          targetEl,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
          on: {
            open() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:open ${actions.type.toLowerCase()}:open`);
              actions.emit(`local::open modalOpen ${actions.type}Open`, actions);
            },
            opened() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:opened ${actions.type.toLowerCase()}:opened`);
              actions.emit(`local::opened modalOpened ${actions.type}Opened`, actions);
            },
            close() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:close ${actions.type.toLowerCase()}:close`);
              actions.emit(`local::close modalClose ${actions.type}Close`, actions);
            },
            closed() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:closed ${actions.type.toLowerCase()}:closed`);
              actions.emit(`local::closed modalClosed ${actions.type}Closed`, actions);
            }
          }
        });
        popover.open(animate);
        popover.once("popoverOpened", () => {
          popover.$el.find(".list-button, .item-link").each((buttonEl) => {
            dom7_default(buttonEl).on("click", buttonOnClick);
          });
        });
        popover.once("popoverClosed", () => {
          popover.$el.find(".list-button, .item-link").each((buttonEl) => {
            dom7_default(buttonEl).off("click", buttonOnClick);
          });
          nextTick(() => {
            popover.destroy();
            popover = void 0;
          });
        });
      } else {
        actions.$el = actions.actionsHtml ? dom7_default(actions.actionsHtml) : actions.$el;
        actions.$el[0].f7Modal = actions;
        if (actions.groups) {
          actions.$el.find(".actions-button").each((buttonEl) => {
            dom7_default(buttonEl).on("click", buttonOnClick);
          });
          actions.once("actionsClosed", () => {
            actions.$el.find(".actions-button").each((buttonEl) => {
              dom7_default(buttonEl).off("click", buttonOnClick);
            });
          });
        }
        actions.el = actions.$el[0];
        originalOpen.call(actions, animate);
      }
      return actions;
    };
    actions.close = function close6(animate) {
      if (popover) {
        popover.close(animate);
      } else {
        originalClose.call(actions, animate);
      }
      return actions;
    };
    extend(actions, {
      app,
      $el,
      el: $el ? $el[0] : void 0,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "actions"
    });
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(actions.el).length === 0) {
        if (actions.params.closeByBackdropClick && actions.params.backdrop && actions.backdropEl && actions.backdropEl === target) {
          actions.close();
        } else if (actions.params.closeByOutsideClick) {
          actions.close();
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && actions.params.closeOnEscape) {
        actions.close();
      }
    }
    if (actions.params.closeOnEscape) {
      actions.on("open", () => {
        dom7_default(document).on("keydown", onKeyDown);
      });
      actions.on("close", () => {
        dom7_default(document).off("keydown", onKeyDown);
      });
    }
    actions.on("opened", () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.on("click", handleClick);
      }
    });
    actions.on("close", () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.off("click", handleClick);
      }
    });
    if ($el) {
      $el[0].f7Modal = actions;
    }
    return actions;
  }
  render() {
    const actions = this;
    if (actions.params.render)
      return actions.params.render.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return jsx_default("div", {
      class: `actions-modal${actions.params.grid ? " actions-grid" : ""} ${cssClass || ""}`
    }, groups.map((group) => jsx_default("div", {
      class: "actions-group"
    }, group.map((button) => {
      const buttonClasses = [`actions-${button.label ? "label" : "button"}`];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text,
        icon
      } = button;
      if (color)
        buttonClasses.push(`color-${color}`);
      if (bg)
        buttonClasses.push(`bg-color-${bg}`);
      if (bold)
        buttonClasses.push("actions-button-bold");
      if (disabled)
        buttonClasses.push("disabled");
      if (label) {
        return jsx_default("div", {
          class: buttonClasses.join(" ")
        }, text);
      }
      return jsx_default("div", {
        class: buttonClasses.join(" ")
      }, icon && jsx_default("div", {
        class: "actions-button-media"
      }, icon), jsx_default("div", {
        class: "actions-button-text"
      }, text));
    }))));
  }
  renderPopover() {
    const actions = this;
    if (actions.params.renderPopover)
      return actions.params.renderPopover.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return jsx_default("div", {
      class: `popover popover-from-actions ${cssClass || ""}`
    }, jsx_default("div", {
      class: "popover-inner"
    }, groups.map((group) => jsx_default("div", {
      class: "list"
    }, jsx_default("ul", null, group.map((button) => {
      const itemClasses = [];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text,
        icon
      } = button;
      if (color)
        itemClasses.push(`color-${color}`);
      if (bg)
        itemClasses.push(`bg-color-${bg}`);
      if (bold)
        itemClasses.push("popover-from-actions-bold");
      if (disabled)
        itemClasses.push("disabled");
      if (label) {
        itemClasses.push("popover-from-actions-label");
        return `<li class="${itemClasses.join(" ")}">${text}</li>`;
      }
      if (icon) {
        itemClasses.push("item-link item-content");
        return jsx_default("li", null, jsx_default("a", {
          class: itemClasses.join(" ")
        }, jsx_default("div", {
          class: "item-media"
        }, icon), jsx_default("div", {
          class: "item-inner"
        }, jsx_default("div", {
          class: "item-title"
        }, text))));
      }
      itemClasses.push("list-button");
      return jsx_default("li", null, jsx_default("a", {
        class: itemClasses.join(" ")
      }, text));
    }))))));
  }
};
var actions_class_default = Actions;

// node_modules/framework7/components/actions/actions.js
var actions_default = {
  name: "actions",
  params: {
    actions: {
      convertToPopover: true,
      forceToPopover: false,
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      cssClass: null,
      closeByBackdropClick: true,
      closeOnEscape: false,
      render: null,
      renderPopover: null,
      containerEl: null
    }
  },
  static: {
    Actions: actions_class_default
  },
  create() {
    const app = this;
    app.actions = ModalMethods({
      app,
      constructor: actions_class_default,
      defaultSelector: ".actions-modal.modal-in"
    });
  },
  clicks: {
    ".actions-open": function openActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.actions.open(data.actions, data.animate, $clickedEl);
    },
    ".actions-close": function closeActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.actions.close(data.actions, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/sheet/sheet-class.js
var Sheet = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.sheet, params);
    super(app, extendedParams);
    const sheet = this;
    const window = getWindow();
    const document = getDocument();
    const support = getSupport();
    const device = getDevice();
    sheet.params = extendedParams;
    if (typeof sheet.params.backdrop === "undefined") {
      sheet.params.backdrop = app.theme !== "ios";
    }
    let $el;
    if (!sheet.params.el) {
      $el = dom7_default(sheet.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(sheet.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return sheet.destroy();
    }
    let $backdropEl;
    if (sheet.params.backdrop && sheet.params.backdropEl) {
      $backdropEl = dom7_default(sheet.params.backdropEl);
    } else if (sheet.params.backdrop) {
      if (sheet.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="sheet-backdrop sheet-backdrop-unique"></div>');
        sheet.$containerEl.append($backdropEl);
      } else {
        $backdropEl = sheet.$containerEl.children(".sheet-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="sheet-backdrop"></div>');
        sheet.$containerEl.append($backdropEl);
      }
    }
    extend(sheet, {
      app,
      push: $el.hasClass("sheet-modal-push") || sheet.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "sheet",
      $htmlEl: dom7_default("html")
    });
    if (sheet.params.push) {
      $el.addClass("sheet-modal-push");
    }
    let $pageContentEl;
    function scrollToElementOnOpen() {
      const $scrollEl = dom7_default(sheet.params.scrollToEl).eq(0);
      if ($scrollEl.length === 0)
        return;
      $pageContentEl = $scrollEl.parents(".page-content");
      if ($pageContentEl.length === 0)
        return;
      const paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
      const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
      const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
      const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
      const pageScroll = $pageContentEl.scrollTop();
      let newPaddingBottom;
      const scrollElTop = $scrollEl.offset().top - paddingTop + $scrollEl[0].offsetHeight;
      if (scrollElTop > pageHeight) {
        const scrollTop = pageScroll + scrollElTop - pageHeight;
        if (scrollTop + pageHeight > pageScrollHeight) {
          newPaddingBottom = scrollTop + pageHeight - pageScrollHeight + paddingBottom;
          if (pageHeight === pageScrollHeight) {
            newPaddingBottom = $el.height();
          }
          $pageContentEl.css({
            "padding-bottom": `${newPaddingBottom}px`
          });
        }
        $pageContentEl.scrollTop(scrollTop, 300);
      }
    }
    function scrollToElementOnClose() {
      if ($pageContentEl && $pageContentEl.length > 0) {
        $pageContentEl.css({
          "padding-bottom": ""
        });
      }
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(sheet.el).length === 0) {
        if (sheet.params.closeByBackdropClick && sheet.params.backdrop && sheet.backdropEl && sheet.backdropEl === target) {
          sheet.close();
        } else if (sheet.params.closeByOutsideClick) {
          sheet.close();
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && sheet.params.closeOnEscape) {
        sheet.close();
      }
    }
    let pushOffset;
    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let isTopSheetModal;
    let swipeStepTranslate;
    let startTranslate;
    let currentTranslate;
    let sheetElOffsetHeight;
    let minTranslate;
    let maxTranslate;
    let $pushViewEl;
    let pushBorderRadius;
    let sheetPageContentEl;
    let sheetPageContentScrollTop;
    let sheetPageContentScrollHeight;
    let sheetPageContentOffsetHeight;
    function handleTouchStart(e) {
      if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep))
        return;
      if (sheet.params.swipeHandler && dom7_default(e.target).closest(sheet.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = now();
      isScrolling = void 0;
      isTopSheetModal = $el.hasClass("sheet-modal-top");
      if (!sheet.params.swipeHandler && e.type === "touchstart") {
        sheetPageContentEl = dom7_default(e.target).closest(".page-content")[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      currentTouch = {
        x: e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY
      };
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      touchesDiff = startTouch.y - currentTouch.y;
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      if (!isMoved) {
        if (sheetPageContentEl && !$el.hasClass("modal-in-swipe-step")) {
          sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
          sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
          sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;
          if (!(sheetPageContentScrollHeight === sheetPageContentOffsetHeight) && !(direction === "to-bottom" && sheetPageContentScrollTop === 0) && !(direction === "to-top" && sheetPageContentScrollTop === sheetPageContentScrollHeight - sheetPageContentOffsetHeight)) {
            $el.transform("");
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        if (sheet.push && pushOffset) {
          $pushViewEl = app.$el.children(".view, .views");
        }
        sheetElOffsetHeight = $el[0].offsetHeight;
        startTranslate = getTranslate($el[0], "y");
        if (isTopSheetModal) {
          minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
          maxTranslate = 0;
        } else {
          minTranslate = 0;
          maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
        }
        isMoved = true;
      }
      currentTranslate = startTranslate - touchesDiff;
      currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
      e.preventDefault();
      if (sheet.push && pushOffset) {
        let progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;
        if (sheet.params.swipeToStep) {
          if (isTopSheetModal) {
            progress = currentTranslate / swipeStepTranslate;
          } else {
            progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
          }
        }
        progress = Math.abs(progress);
        progress = Math.min(Math.max(progress, 0), 1);
        const pushProgress = 1 - progress;
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        $pushViewEl.transition(0).forEach((el) => {
          el.style.setProperty("transform", `translate3d(0,0,0) scale(${scale})`, "important");
        });
        if (sheet.params.swipeToStep) {
          $pushViewEl.css("border-radius", `${pushBorderRadius * pushProgress}px`);
        }
      }
      $el.transition(0).transform(`translate3d(0,${currentTranslate}px,0)`);
      if (sheet.params.swipeToStep) {
        let progress;
        if (isTopSheetModal) {
          progress = 1 - currentTranslate / swipeStepTranslate;
        } else {
          progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        $el.trigger("sheet:stepprogress", progress);
        sheet.emit("local::stepProgress sheetStepProgress", sheet, progress);
      }
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      isMoved = false;
      $el.transform("").transition("");
      if (sheet.push && pushOffset) {
        $pushViewEl.transition("").transform("");
        $pushViewEl.css("border-radius", "");
      }
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      const diff = Math.abs(touchesDiff);
      if (diff === 0 || currentTranslate === startTranslate)
        return;
      const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
      if (!sheet.params.swipeToStep) {
        if (direction !== (isTopSheetModal ? "to-top" : "to-bottom")) {
          return;
        }
        if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > sheetElOffsetHeight / 2) {
          sheet.close();
        }
        return;
      }
      const openDirection = isTopSheetModal ? "to-bottom" : "to-top";
      const closeDirection = isTopSheetModal ? "to-top" : "to-bottom";
      const absCurrentTranslate = Math.abs(currentTranslate);
      const absSwipeStepTranslate = Math.abs(swipeStepTranslate);
      if (timeDiff < 300 && diff > 10) {
        if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
          $el.removeClass("modal-in-swipe-step");
          $el.trigger("sheet:stepprogress", 1);
          sheet.emit("local::stepProgress sheetStepProgress", sheet, 1);
          sheet.emit("local::_swipeStep", false);
          $el.trigger("sheet:stepopen");
          sheet.emit("local::stepOpen sheetStepOpen", sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
            $pushViewEl.css("border-radius", "");
          }
        }
        if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
          if (sheet.params.swipeToClose) {
            sheet.close();
          } else {
            $el.addClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 0);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
            sheet.emit("local::_swipeStep", true);
            $el.trigger("sheet:stepclose");
            sheet.emit("local::stepClose sheetStepClose", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
              $pushViewEl.css("border-radius", "0px");
            }
          }
        }
        if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
          $el.addClass("modal-in-swipe-step");
          $el.trigger("sheet:stepprogress", 0);
          sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
          sheet.emit("local::_swipeStep", true);
          $el.trigger("sheet:stepclose");
          sheet.emit("local::stepClose sheetStepClose", sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
            $pushViewEl.css("border-radius", "0px");
          }
        }
        return;
      }
      if (timeDiff >= 300) {
        const stepOpened = !$el.hasClass("modal-in-swipe-step");
        if (!stepOpened) {
          if (absCurrentTranslate < absSwipeStepTranslate / 2) {
            $el.removeClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 1);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 1);
            sheet.emit("local::_swipeStep", false);
            $el.trigger("sheet:stepopen");
            sheet.emit("local::stepOpen sheetStepOpen", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
              $pushViewEl.css("border-radius", "");
            }
          } else if (absCurrentTranslate - absSwipeStepTranslate > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            if (sheet.params.swipeToClose)
              sheet.close();
          }
        } else if (stepOpened) {
          if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            if (sheet.params.swipeToClose)
              sheet.close();
          } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
            $el.addClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 0);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
            sheet.emit("local::_swipeStep", true);
            $el.trigger("sheet:stepclose");
            sheet.emit("local::stepClose sheetStepClose", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
              $pushViewEl.css("border-radius", "0px");
            }
          }
        }
      }
    }
    sheet.setSwipeStep = function setSwipeStep(byResize) {
      if (byResize === void 0) {
        byResize = true;
      }
      const $swipeStepEl = $el.find(".sheet-modal-swipe-step").eq(0);
      if (!$swipeStepEl.length)
        return;
      if ($el.hasClass("sheet-modal-top")) {
        swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      } else {
        swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      }
      $el[0].style.setProperty("--f7-sheet-swipe-step", `${swipeStepTranslate}px`);
      if (!byResize) {
        $el.addClass("modal-in-swipe-step");
        sheet.emit("local::_swipeStep", true);
      }
    };
    function onResize() {
      sheet.setSwipeStep(true);
    }
    const passive = support.passiveListener ? {
      passive: true
    } : false;
    if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      sheet.once("sheetDestroy", () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      });
    }
    sheet.on("open", () => {
      if (sheet.params.closeOnEscape) {
        dom7_default(document).on("keydown", onKeyDown);
      }
      $el.prevAll(".popup.modal-in").addClass("popup-behind");
      if (sheet.params.swipeToStep) {
        sheet.setSwipeStep(false);
        app.on("resize", onResize);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnOpen();
      }
      if (sheet.push) {
        pushOffset = parseInt($el.css("--f7-sheet-push-offset"), 10);
        if (Number.isNaN(pushOffset))
          pushOffset = 0;
        if (pushOffset) {
          $el.addClass("sheet-modal-push");
          sheet.$htmlEl.addClass("with-modal-sheet-push");
          if (!sheet.params.swipeToStep) {
            sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
          } else {
            $pushViewEl = app.$el.children(".view, .views");
            pushBorderRadius = parseFloat($el.css(`border-${isTopSheetModal ? "bottom" : "top"}-left-radius`));
            $pushViewEl.css("border-radius", "0px");
          }
        }
      }
    });
    sheet.on("opened", () => {
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    sheet.on("close", () => {
      if (sheet.params.swipeToStep) {
        $el.removeClass("modal-in-swipe-step");
        sheet.emit("local::_swipeStep", false);
        app.off("resize", onResize);
      }
      if (sheet.params.closeOnEscape) {
        dom7_default(document).off("keydown", onKeyDown);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnClose();
      }
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
      $el.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind");
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass("with-modal-sheet-push");
        sheet.$htmlEl.addClass("with-modal-sheet-push-closing");
      }
    });
    sheet.on("closed", () => {
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass("with-modal-sheet-push-closing");
        sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
      }
    });
    sheet.stepOpen = function stepOpen() {
      $el.removeClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", false);
      if (sheet.push) {
        if (!pushOffset) {
          pushOffset = parseInt($el.css("--f7-sheet-push-offset"), 10);
          if (Number.isNaN(pushOffset))
            pushOffset = 0;
        }
        if (pushOffset) {
          sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
        }
      }
    };
    sheet.stepClose = function stepClose() {
      $el.addClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", true);
      if (sheet.push) {
        sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
      }
    };
    sheet.stepToggle = function stepToggle() {
      $el.toggleClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", $el.hasClass("modal-in-swipe-step"));
    };
    $el[0].f7Modal = sheet;
    return sheet;
  }
};
var sheet_class_default = Sheet;

// node_modules/framework7/components/sheet/sheet.js
var sheet_default = {
  name: "sheet",
  params: {
    sheet: {
      push: false,
      backdrop: void 0,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: false,
      closeOnEscape: false,
      swipeToClose: false,
      swipeToStep: false,
      swipeHandler: null,
      containerEl: null
    }
  },
  static: {
    Sheet: sheet_class_default
  },
  create() {
    const app = this;
    app.sheet = extend({}, ModalMethods({
      app,
      constructor: sheet_class_default,
      defaultSelector: ".sheet-modal.modal-in"
    }), {
      stepOpen(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepOpen)
          return sheetInstance.stepOpen();
        return void 0;
      },
      stepClose(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepClose)
          return sheetInstance.stepClose();
        return void 0;
      },
      stepToggle(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepToggle)
          return sheetInstance.stepToggle();
        return void 0;
      }
    });
  },
  clicks: {
    ".sheet-open": function openSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      if (dom7_default(".sheet-modal.modal-in").length > 0 && data.sheet && dom7_default(data.sheet)[0] !== dom7_default(".sheet-modal.modal-in")[0]) {
        app.sheet.close(".sheet-modal.modal-in");
      }
      app.sheet.open(data.sheet, data.animate, $clickedEl);
    },
    ".sheet-close": function closeSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sheet.close(data.sheet, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/toast/toast-class.js
var Toast = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.toast, params);
    super(app, extendedParams);
    const toast = this;
    const window = getWindow();
    toast.app = app;
    toast.params = extendedParams;
    const {
      closeButton,
      closeTimeout
    } = toast.params;
    let $el;
    if (!toast.params.el) {
      const toastHtml = toast.render();
      $el = dom7_default(toastHtml);
    } else {
      $el = dom7_default(toast.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return toast.destroy();
    }
    extend(toast, {
      $el,
      el: $el[0],
      type: "toast"
    });
    $el[0].f7Modal = toast;
    if (closeButton) {
      $el.find(".toast-button").on("click", () => {
        toast.emit("local::closeButtonClick toastCloseButtonClick", toast);
        toast.close();
      });
      toast.on("beforeDestroy", () => {
        $el.find(".toast-button").off("click");
      });
    }
    let timeoutId;
    toast.on("open", () => {
      dom7_default(".toast.modal-in").each((openedEl) => {
        const toastInstance = app.toast.get(openedEl);
        if (openedEl !== toast.el && toastInstance) {
          toastInstance.close();
        }
      });
      if (closeTimeout) {
        timeoutId = nextTick(() => {
          toast.close();
        }, closeTimeout);
      }
    });
    toast.on("close", () => {
      window.clearTimeout(timeoutId);
    });
    if (toast.params.destroyOnClose) {
      toast.once("closed", () => {
        setTimeout(() => {
          toast.destroy();
        }, 0);
      });
    }
    return toast;
  }
  render() {
    const toast = this;
    if (toast.params.render)
      return toast.params.render.call(toast, toast);
    const {
      position,
      horizontalPosition,
      cssClass,
      icon,
      text,
      closeButton,
      closeButtonColor,
      closeButtonText
    } = toast.params;
    const horizontalClass = position === "top" || position === "bottom" ? `toast-horizontal-${horizontalPosition}` : "";
    return jsx_default("div", {
      class: `toast toast-${position} ${horizontalClass} ${cssClass || ""} ${icon ? "toast-with-icon" : ""}`
    }, jsx_default("div", {
      class: "toast-content"
    }, icon && jsx_default("div", {
      class: "toast-icon"
    }, icon), jsx_default("div", {
      class: "toast-text"
    }, text), closeButton && !icon && jsx_default("a", {
      class: `toast-button button ${closeButtonColor ? `color-${closeButtonColor}` : ""}`
    }, closeButtonText)));
  }
};
var toast_class_default = Toast;

// node_modules/framework7/components/toast/toast.js
var toast_default = {
  name: "toast",
  static: {
    Toast: toast_class_default
  },
  create() {
    const app = this;
    app.toast = extend({}, ModalMethods({
      app,
      constructor: toast_class_default,
      defaultSelector: ".toast.modal-in"
    }), {
      // Shortcuts
      show(params) {
        extend(params, {
          destroyOnClose: true
        });
        return new toast_class_default(app, params).open();
      }
    });
  },
  params: {
    toast: {
      icon: null,
      text: null,
      position: "bottom",
      horizontalPosition: "left",
      closeButton: false,
      closeButtonColor: null,
      closeButtonText: "Ok",
      closeTimeout: null,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
};

// node_modules/framework7/components/preloader/preloader.js
var Preloader = {
  init(el) {
    const app = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const $el = dom7_default(el);
    if ($el.length === 0 || $el.children(".preloader-inner").length > 0 || $el.children(".preloader-inner-line").length > 0)
      return;
    $el.append(preloaders[`${app.theme}PreloaderContent`]);
  },
  // Modal
  visible: false,
  show(color) {
    if (color === void 0) {
      color = "white";
    }
    const app = this;
    if (Preloader.visible)
      return;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
    dom7_default("html").addClass("with-modal-preloader");
    app.$el.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    Preloader.visible = true;
  },
  showIn(el, color) {
    if (color === void 0) {
      color = "white";
    }
    const app = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
    dom7_default(el || "html").addClass("with-modal-preloader");
    dom7_default(el || app.$el).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
  },
  hide() {
    const app = this;
    if (!Preloader.visible)
      return;
    dom7_default("html").removeClass("with-modal-preloader");
    app.$el.find(".preloader-backdrop, .preloader-modal").remove();
    Preloader.visible = false;
  },
  hideIn(el) {
    const app = this;
    dom7_default(el || "html").removeClass("with-modal-preloader");
    dom7_default(el || app.$el).find(".preloader-backdrop, .preloader-modal").remove();
  }
};
var preloader_default = {
  name: "preloader",
  create() {
    const app = this;
    bindMethods(app, {
      preloader: Preloader
    });
  },
  on: {
    photoBrowserOpen(pb) {
      const app = this;
      pb.$el.find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    }
  },
  vnode: {
    preloader: {
      insert(vnode) {
        const app = this;
        const preloaderEl = vnode.elm;
        app.preloader.init(preloaderEl);
      }
    }
  }
};

// node_modules/framework7/components/progressbar/progressbar.js
var Progressbar = {
  set() {
    const app = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let [el, progress, duration] = args;
    if (typeof args[0] === "number") {
      [progress, duration] = args;
      el = app.$el;
    }
    if (typeof progress === "undefined" || progress === null)
      return el;
    if (!progress)
      progress = 0;
    const $el = dom7_default(el || app.$el);
    if ($el.length === 0) {
      return el;
    }
    const progressNormalized = Math.min(Math.max(progress, 0), 100);
    let $progressbarEl;
    if ($el.hasClass("progressbar"))
      $progressbarEl = $el.eq(0);
    else {
      $progressbarEl = $el.children(".progressbar");
    }
    if ($progressbarEl.length === 0 || $progressbarEl.hasClass("progressbar-infinite")) {
      return $progressbarEl;
    }
    let $progressbarLine = $progressbarEl.children("span");
    if ($progressbarLine.length === 0) {
      $progressbarLine = dom7_default("<span></span>");
      $progressbarEl.append($progressbarLine);
    }
    $progressbarLine.transition(typeof duration !== "undefined" ? duration : "").transform(`translate3d(${(-100 + progressNormalized) * (app.rtl ? -1 : 1)}%,0,0)`);
    return $progressbarEl[0];
  },
  show() {
    const app = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    let [el, progress, color] = args;
    let type = "determined";
    if (args.length === 2) {
      if ((typeof args[0] === "string" || typeof args[0] === "object") && typeof args[1] === "string") {
        [el, color, progress] = args;
        type = "infinite";
      } else if (typeof args[0] === "number" && typeof args[1] === "string") {
        [progress, color] = args;
        el = app.$el;
      }
    } else if (args.length === 1) {
      if (typeof args[0] === "number") {
        el = app.$el;
        progress = args[0];
      } else if (typeof args[0] === "string") {
        type = "infinite";
        el = app.$el;
        color = args[0];
      }
    } else if (args.length === 0) {
      type = "infinite";
      el = app.$el;
    }
    const $el = dom7_default(el);
    if ($el.length === 0)
      return void 0;
    let $progressbarEl;
    if ($el.hasClass("progressbar") || $el.hasClass("progressbar-infinite")) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children(".progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)");
      if ($progressbarEl.length === 0) {
        $progressbarEl = dom7_default(`
          <span class="progressbar${type === "infinite" ? "-infinite" : ""}${color ? ` color-${color}` : ""} progressbar-in">
            ${type === "infinite" ? "" : "<span></span>"}
          </span>`);
        $el.append($progressbarEl);
      }
    }
    if (typeof progress !== "undefined") {
      app.progressbar.set($progressbarEl, progress);
    }
    return $progressbarEl[0];
  },
  hide(el, removeAfterHide) {
    if (removeAfterHide === void 0) {
      removeAfterHide = true;
    }
    const app = this;
    const $el = dom7_default(el || app.$el);
    if ($el.length === 0)
      return void 0;
    let $progressbarEl;
    if ($el.hasClass("progressbar") || $el.hasClass("progressbar-infinite")) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children(".progressbar, .progressbar-infinite");
    }
    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass("progressbar-in") || $progressbarEl.hasClass("progressbar-out")) {
      return $progressbarEl;
    }
    $progressbarEl.removeClass("progressbar-in").addClass("progressbar-out").animationEnd(() => {
      if (removeAfterHide) {
        $progressbarEl.remove();
      }
    });
    return $progressbarEl;
  }
};
var progressbar_default = {
  name: "progressbar",
  create() {
    const app = this;
    bindMethods(app, {
      progressbar: Progressbar
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".progressbar").each((progressbarEl) => {
        const $progressbarEl = dom7_default(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr("data-progress"));
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".progressbar").each((progressbarEl) => {
        const $progressbarEl = dom7_default(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr("data-progress"));
      });
    }
  },
  vnode: {
    progressbar: {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute("data-progress"));
      },
      update(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute("data-progress"));
      }
    }
  }
};

// node_modules/framework7/components/sortable/sortable.js
var Sortable = {
  init() {
    const app = this;
    const document = getDocument();
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchesDiff;
    let $sortingEl;
    let $sortingItems;
    let $sortableContainer;
    let sortingElHeight;
    let minTop;
    let maxTop;
    let $insertAfterEl;
    let $insertBeforeEl;
    let indexFrom;
    let $pageEl;
    let $pageContentEl;
    let pageHeight;
    let pageOffset;
    let sortingElOffsetLocal;
    let sortingElOffsetTop;
    let initialScrollTop;
    let wasTapHold;
    function handleTouchStart(e, isTapHold) {
      isMoved = false;
      isTouched = true;
      wasTapHold = false;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      $sortingEl = dom7_default(e.target).closest("li").eq(0);
      indexFrom = $sortingEl.index();
      $sortableContainer = $sortingEl.parents(".sortable");
      const $listGroup = $sortingEl.parents(".list-group");
      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
        $sortableContainer = $listGroup;
      }
      $sortingItems = $sortableContainer.children("ul").children("li:not(.disallow-sorting):not(.no-sorting)");
      if (app.panel)
        app.panel.allowOpen = false;
      if (app.swipeout)
        app.swipeout.allow = false;
      if (isTapHold) {
        $sortingEl.addClass("sorting");
        $sortableContainer.addClass("sortable-sorting");
        wasTapHold = true;
      }
    }
    function handleTouchMove(e) {
      if (!isTouched || !$sortingEl)
        return;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (!isMoved) {
        $pageEl = $sortingEl.parents(".page");
        $pageContentEl = $sortingEl.parents(".page-content");
        const paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
        const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
        initialScrollTop = $pageContentEl[0].scrollTop;
        pageOffset = $pageEl.offset().top + paddingTop;
        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
        $sortingEl.addClass("sorting");
        $sortableContainer.addClass("sortable-sorting");
        sortingElOffsetLocal = $sortingEl[0].offsetTop;
        minTop = $sortingEl[0].offsetTop;
        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
        sortingElHeight = $sortingEl[0].offsetHeight;
        sortingElOffsetTop = $sortingEl.offset().top;
      }
      isMoved = true;
      e.preventDefault();
      e.f7PreventSwipePanel = true;
      touchesDiff = pageY - touchStartY;
      const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
      const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
      $sortingEl.transform(`translate3d(0,${translate}px,0)`);
      const scrollAddition = 44;
      let allowScroll = true;
      if (touchesDiff + translateScrollOffset + scrollAddition < -minTop) {
        allowScroll = false;
      }
      if (touchesDiff + translateScrollOffset - scrollAddition > maxTop) {
        allowScroll = false;
      }
      $insertBeforeEl = void 0;
      $insertAfterEl = void 0;
      let scrollDiff;
      if (allowScroll) {
        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
          scrollDiff = sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition - (pageOffset + pageHeight);
        }
        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
          scrollDiff = sortingElOffsetTop + touchesDiff - pageOffset - scrollAddition;
        }
        if (scrollDiff) {
          $pageContentEl[0].scrollTop += scrollDiff;
        }
      }
      $sortingItems.each((el) => {
        const $currentEl = dom7_default(el);
        if ($currentEl[0] === $sortingEl[0])
          return;
        const currentElOffset = $currentEl[0].offsetTop;
        const currentElHeight = $currentEl.height();
        const sortingElOffset = sortingElOffsetLocal + translate;
        let currentTranslate;
        const prevTranslate = $currentEl[0].f7Translate;
        if (sortingElOffset >= currentElOffset - currentElHeight / 2 && $sortingEl.index() < $currentEl.index()) {
          currentTranslate = -sortingElHeight;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = $currentEl;
          $insertBeforeEl = void 0;
        } else if (sortingElOffset <= currentElOffset + currentElHeight / 2 && $sortingEl.index() > $currentEl.index()) {
          currentTranslate = sortingElHeight;
          $currentEl[0].f7Translate = currentTranslate;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = void 0;
          if (!$insertBeforeEl)
            $insertBeforeEl = $currentEl;
        } else {
          currentTranslate = void 0;
          $currentEl.transform("translate3d(0, 0%,0)");
        }
        if (prevTranslate !== currentTranslate) {
          $currentEl.trigger("sortable:move");
          app.emit("sortableMove", $currentEl[0], $sortableContainer[0]);
        }
        $currentEl[0].f7Translate = currentTranslate;
      });
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        if (isTouched && !isMoved) {
          if (app.panel)
            app.panel.allowOpen = true;
          if (app.swipeout)
            app.swipeout.allow = true;
          if (wasTapHold) {
            $sortingEl.removeClass("sorting");
            $sortableContainer.removeClass("sortable-sorting");
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      if (app.panel)
        app.panel.allowOpen = true;
      if (app.swipeout)
        app.swipeout.allow = true;
      $sortingItems.transform("");
      $sortingEl.removeClass("sorting");
      $sortableContainer.removeClass("sortable-sorting");
      let indexTo;
      if ($insertAfterEl)
        indexTo = $insertAfterEl.index();
      else if ($insertBeforeEl)
        indexTo = $insertBeforeEl.index();
      let moveElements = $sortableContainer.dataset().sortableMoveElements;
      if (typeof moveElements === "undefined") {
        moveElements = app.params.sortable.moveElements;
      }
      if (moveElements) {
        if ($insertAfterEl) {
          $sortingEl.insertAfter($insertAfterEl);
        }
        if ($insertBeforeEl) {
          $sortingEl.insertBefore($insertBeforeEl);
        }
      }
      if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass("virtual-list")) {
        indexFrom = $sortingEl[0].f7VirtualListIndex;
        if (typeof indexFrom === "undefined")
          indexFrom = $sortingEl.attr("data-virtual-list-index");
        if ($insertBeforeEl) {
          indexTo = $insertBeforeEl[0].f7VirtualListIndex;
          if (typeof indexTo === "undefined")
            indexTo = $insertBeforeEl.attr("data-virtual-list-index");
        } else {
          indexTo = $insertAfterEl[0].f7VirtualListIndex;
          if (typeof indexTo === "undefined")
            indexTo = $insertAfterEl.attr("data-virtual-list-index");
        }
        if (indexTo !== null)
          indexTo = parseInt(indexTo, 10);
        else
          indexTo = void 0;
        const virtualList = $sortableContainer[0].f7VirtualList;
        if (indexFrom)
          indexFrom = parseInt(indexFrom, 10);
        if (indexTo)
          indexTo = parseInt(indexTo, 10);
        if (virtualList)
          virtualList.moveItem(indexFrom, indexTo);
      }
      if (typeof indexTo !== "undefined" && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
        $sortingEl.trigger("sortable:sort", {
          from: indexFrom,
          to: indexTo
        });
        app.emit("sortableSort", $sortingEl[0], {
          from: indexFrom,
          to: indexTo,
          el: $sortingEl[0]
        }, $sortableContainer[0]);
      }
      $insertBeforeEl = void 0;
      $insertAfterEl = void 0;
      isTouched = false;
      isMoved = false;
    }
    const activeListener = getSupport().passiveListener ? {
      passive: false,
      capture: false
    } : false;
    dom7_default(document).on(app.touchEvents.start, ".list.sortable .sortable-handler", handleTouchStart, activeListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    dom7_default(document).on("taphold", ".sortable-tap-hold", (e, pointerEvent) => {
      handleTouchStart(pointerEvent, true);
    });
  },
  enable(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    $el.addClass("sortable-enabled");
    $el.trigger("sortable:enable");
    app.emit("sortableEnable", $el[0]);
  },
  disable(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    $el.removeClass("sortable-enabled");
    $el.trigger("sortable:disable");
    app.emit("sortableDisable", $el[0]);
  },
  toggle(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    if ($el.hasClass("sortable-enabled")) {
      app.sortable.disable($el);
    } else {
      app.sortable.enable($el);
    }
  }
};
var sortable_default = {
  name: "sortable",
  params: {
    sortable: {
      moveElements: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      sortable: Sortable
    });
  },
  on: {
    init() {
      const app = this;
      if (!app.params.sortable)
        return;
      app.sortable.init();
    }
  },
  clicks: {
    ".sortable-enable": function enable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.enable(data.sortable);
    },
    ".sortable-disable": function disable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.disable(data.sortable);
    },
    ".sortable-toggle": function toggle($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.toggle(data.sortable);
    }
  }
};

// node_modules/framework7/components/swipeout/swipeout.js
var Swipeout = {
  init() {
    const app = this;
    const document = getDocument();
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let $swipeoutEl;
    let $swipeoutContent;
    let $actionsRight;
    let $actionsLeft;
    let actionsLeftWidth;
    let actionsRightWidth;
    let translate;
    let opened;
    let openedActionsSide;
    let $leftButtons;
    let $rightButtons;
    let direction;
    let $overswipeLeftButton;
    let $overswipeRightButton;
    let overswipeLeft;
    let overswipeRight;
    function handleTouchStart(e) {
      if (!app.swipeout.allow)
        return;
      isMoved = false;
      isTouched = true;
      isScrolling = void 0;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = (/* @__PURE__ */ new Date()).getTime();
      $swipeoutEl = dom7_default(this);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      if (!isMoved) {
        if (dom7_default(".list.sortable-opened").length > 0)
          return;
        $swipeoutContent = $swipeoutEl.find(".swipeout-content");
        $actionsRight = $swipeoutEl.find(".swipeout-actions-right");
        $actionsLeft = $swipeoutEl.find(".swipeout-actions-left");
        actionsLeftWidth = null;
        actionsRightWidth = null;
        $leftButtons = null;
        $rightButtons = null;
        $overswipeRightButton = null;
        $overswipeLeftButton = null;
        if ($actionsLeft.length > 0) {
          actionsLeftWidth = $actionsLeft.outerWidth();
          $leftButtons = $actionsLeft.children("a");
          $overswipeLeftButton = $actionsLeft.find(".swipeout-overswipe");
        }
        if ($actionsRight.length > 0) {
          actionsRightWidth = $actionsRight.outerWidth();
          $rightButtons = $actionsRight.children("a");
          $overswipeRightButton = $actionsRight.find(".swipeout-overswipe");
        }
        opened = $swipeoutEl.hasClass("swipeout-opened");
        if (opened) {
          openedActionsSide = $swipeoutEl.find(".swipeout-actions-left.swipeout-actions-opened").length > 0 ? "left" : "right";
        }
        $swipeoutEl.removeClass("swipeout-transitioning");
        if (!app.params.swipeout.noFollow) {
          $swipeoutEl.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened");
          $swipeoutEl.removeClass("swipeout-opened");
        }
      }
      isMoved = true;
      if (e.cancelable) {
        e.preventDefault();
      }
      touchesDiff = pageX - touchesStart.x;
      translate = touchesDiff;
      if (opened) {
        if (openedActionsSide === "right")
          translate -= actionsRightWidth;
        else
          translate += actionsLeftWidth;
      }
      if (translate > 0 && $actionsLeft.length === 0 || translate < 0 && $actionsRight.length === 0) {
        if (!opened) {
          isTouched = false;
          isMoved = false;
          $swipeoutContent.transform("");
          if ($rightButtons && $rightButtons.length > 0) {
            $rightButtons.transform("");
          }
          if ($leftButtons && $leftButtons.length > 0) {
            $leftButtons.transform("");
          }
          return;
        }
        translate = 0;
      }
      if (translate < 0)
        direction = "to-left";
      else if (translate > 0)
        direction = "to-right";
      else if (!direction)
        direction = "to-left";
      let buttonOffset;
      let progress;
      e.f7PreventSwipePanel = true;
      if (app.params.swipeout.noFollow) {
        if (opened) {
          if (openedActionsSide === "right" && touchesDiff > 0) {
            app.swipeout.close($swipeoutEl);
          }
          if (openedActionsSide === "left" && touchesDiff < 0) {
            app.swipeout.close($swipeoutEl);
          }
        } else {
          if (touchesDiff < 0 && $actionsRight.length > 0) {
            app.swipeout.open($swipeoutEl, "right");
          }
          if (touchesDiff > 0 && $actionsLeft.length > 0) {
            app.swipeout.open($swipeoutEl, "left");
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      overswipeLeft = false;
      overswipeRight = false;
      if ($actionsRight.length > 0) {
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsRightWidth;
        if (buttonTranslate < -actionsRightWidth) {
          const ratio = buttonTranslate / -actionsRightWidth;
          buttonTranslate = -actionsRightWidth - (-buttonTranslate - actionsRightWidth) ** 0.8;
          translate = buttonTranslate;
          if ($overswipeRightButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeRight = true;
          }
        }
        if (direction !== "to-left") {
          progress = 0;
          buttonTranslate = 0;
        }
        $rightButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass("swipeout-overswipe") && direction === "to-left") {
            $buttonEl.css({
              left: `${overswipeRight ? -buttonOffset : 0}px`
            });
            if (overswipeRight) {
              if (!$buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeenter");
                app.emit("swipeoutOverswipeEnter", $swipeoutEl[0]);
              }
              $buttonEl.addClass("swipeout-overswipe-active");
            } else {
              if ($buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeexit");
                app.emit("swipeoutOverswipeExit", $swipeoutEl[0]);
              }
              $buttonEl.removeClass("swipeout-overswipe-active");
            }
          }
          $buttonEl.transform(`translate3d(${buttonTranslate - buttonOffset * (1 + Math.max(progress, -1))}px,0,0)`);
        });
      }
      if ($actionsLeft.length > 0) {
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsLeftWidth;
        if (buttonTranslate > actionsLeftWidth) {
          const ratio = buttonTranslate / actionsRightWidth;
          buttonTranslate = actionsLeftWidth + (buttonTranslate - actionsLeftWidth) ** 0.8;
          translate = buttonTranslate;
          if ($overswipeLeftButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeLeft = true;
          }
        }
        if (direction !== "to-right") {
          buttonTranslate = 0;
          progress = 0;
        }
        $leftButtons.each((buttonEl, index) => {
          const $buttonEl = dom7_default(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass("swipeout-overswipe") && direction === "to-right") {
            $buttonEl.css({
              left: `${overswipeLeft ? buttonOffset : 0}px`
            });
            if (overswipeLeft) {
              if (!$buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeenter");
                app.emit("swipeoutOverswipeEnter", $swipeoutEl[0]);
              }
              $buttonEl.addClass("swipeout-overswipe-active");
            } else {
              if ($buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeexit");
                app.emit("swipeoutOverswipeExit", $swipeoutEl[0]);
              }
              $buttonEl.removeClass("swipeout-overswipe-active");
            }
          }
          if ($leftButtons.length > 1) {
            $buttonEl.css("z-index", $leftButtons.length - index);
          }
          $buttonEl.transform(`translate3d(${buttonTranslate + buttonOffset * (1 - Math.min(progress, 1))}px,0,0)`);
        });
      }
      $swipeoutEl.trigger("swipeout", progress);
      app.emit("swipeout", $swipeoutEl[0], progress);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
      const $actions = direction === "to-left" ? $actionsRight : $actionsLeft;
      const actionsWidth = direction === "to-left" ? actionsRightWidth : actionsLeftWidth;
      let action;
      let $buttons;
      let i;
      if (timeDiff < 300 && (touchesDiff < -10 && direction === "to-left" || touchesDiff > 10 && direction === "to-right") || timeDiff >= 300 && Math.abs(translate) > actionsWidth / 2) {
        action = "open";
      } else {
        action = "close";
      }
      if (timeDiff < 300) {
        if (Math.abs(translate) === 0)
          action = "close";
        if (Math.abs(translate) === actionsWidth)
          action = "open";
      }
      if (action === "open") {
        Swipeout.el = $swipeoutEl[0];
        $swipeoutEl.trigger("swipeout:open");
        app.emit("swipeoutOpen", $swipeoutEl[0]);
        $swipeoutEl.addClass("swipeout-opened swipeout-transitioning");
        const newTranslate = direction === "to-left" ? -actionsWidth : actionsWidth;
        $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
        $actions.addClass("swipeout-actions-opened");
        $buttons = direction === "to-left" ? $rightButtons : $leftButtons;
        if ($buttons) {
          for (i = 0; i < $buttons.length; i += 1) {
            dom7_default($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
          }
        }
        if (overswipeRight) {
          $actionsRight.find(".swipeout-overswipe").trigger("click", "f7Overswipe");
        }
        if (overswipeLeft) {
          $actionsLeft.find(".swipeout-overswipe").trigger("click", "f7Overswipe");
        }
      } else {
        $swipeoutEl.trigger("swipeout:close");
        app.emit("swipeoutClose", $swipeoutEl[0]);
        Swipeout.el = void 0;
        $swipeoutEl.addClass("swipeout-transitioning").removeClass("swipeout-opened");
        $swipeoutContent.transform("");
        $actions.removeClass("swipeout-actions-opened");
      }
      let buttonOffset;
      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
        $leftButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
        });
      }
      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
        $rightButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
        });
      }
      $swipeoutContent.transitionEnd(() => {
        if (opened && action === "open" || !opened && action === "close")
          return;
        $swipeoutEl.trigger(action === "open" ? "swipeout:opened" : "swipeout:closed");
        app.emit(action === "open" ? "swipeoutOpened" : "swipeoutClosed", $swipeoutEl[0]);
        $swipeoutEl.removeClass("swipeout-transitioning");
        if (opened && action === "close") {
          if ($actionsRight.length > 0) {
            $rightButtons.transform("");
          }
          if ($actionsLeft.length > 0) {
            $leftButtons.transform("");
          }
        }
      });
    }
    const passiveListener = getSupport().passiveListener ? {
      passive: true
    } : false;
    app.on("touchstart", (e) => {
      if (Swipeout.el) {
        const $targetEl = dom7_default(e.target);
        if (!(dom7_default(Swipeout.el).is($targetEl[0]) || $targetEl.parents(".swipeout").is(Swipeout.el) || $targetEl.hasClass("modal-in") || ($targetEl.attr("class") || "").indexOf("-backdrop") > 0 || $targetEl.hasClass("actions-modal") || $targetEl.parents(".actions-modal.modal-in, .dialog.modal-in").length > 0)) {
          app.swipeout.close(Swipeout.el);
        }
      }
    });
    dom7_default(document).on(app.touchEvents.start, "li.swipeout", handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
  },
  allow: true,
  el: void 0,
  open() {
    const app = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let [el, side, callback] = args;
    if (typeof args[1] === "function") {
      [el, callback, side] = args;
    }
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    if (!$el.hasClass("swipeout") || $el.hasClass("swipeout-opened"))
      return;
    if (!side) {
      if ($el.find(".swipeout-actions-right").length > 0)
        side = "right";
      else
        side = "left";
    }
    const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
    const $swipeoutContent = $el.find(".swipeout-content");
    if ($swipeoutActions.length === 0)
      return;
    $el.trigger("swipeout:open").addClass("swipeout-opened").removeClass("swipeout-transitioning");
    app.emit("swipeoutOpen", $el[0]);
    $swipeoutActions.addClass("swipeout-actions-opened");
    const $buttons = $swipeoutActions.children("a");
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    const translate = side === "right" ? -swipeoutActionsWidth : swipeoutActionsWidth;
    if ($buttons.length > 1) {
      $buttons.each((buttonEl, buttonIndex) => {
        const $buttonEl = dom7_default(buttonEl);
        if (side === "right") {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.css("z-index", $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
      });
    }
    $el.addClass("swipeout-transitioning");
    $swipeoutContent.transitionEnd(() => {
      $el.trigger("swipeout:opened");
      app.emit("swipeoutOpened", $el[0]);
      if (callback)
        callback.call($el[0]);
    });
    nextFrame(() => {
      $buttons.transform(`translate3d(${translate}px,0,0)`);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    });
    Swipeout.el = $el[0];
  },
  close(el, callback) {
    const app = this;
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    if (!$el.hasClass("swipeout-opened"))
      return;
    const side = $el.find(".swipeout-actions-opened").hasClass("swipeout-actions-right") ? "right" : "left";
    const $swipeoutActions = $el.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened");
    const $buttons = $swipeoutActions.children("a");
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    app.swipeout.allow = false;
    $el.trigger("swipeout:close");
    app.emit("swipeoutClose", $el[0]);
    $el.removeClass("swipeout-opened").addClass("swipeout-transitioning");
    let closeTimeout;
    function onSwipeoutClose() {
      app.swipeout.allow = true;
      if ($el.hasClass("swipeout-opened"))
        return;
      $el.removeClass("swipeout-transitioning");
      $buttons.transform("");
      $el.trigger("swipeout:closed");
      app.emit("swipeoutClosed", $el[0]);
      if (callback)
        callback.call($el[0]);
      if (closeTimeout)
        clearTimeout(closeTimeout);
    }
    $el.find(".swipeout-content").transform("").transitionEnd(onSwipeoutClose);
    closeTimeout = setTimeout(onSwipeoutClose, 500);
    $buttons.each((buttonEl) => {
      const $buttonEl = dom7_default(buttonEl);
      if (side === "right") {
        $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
      } else {
        $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
      }
      $buttonEl.css({
        left: "0px"
      }).removeClass("swipeout-overswipe-active");
    });
    if (Swipeout.el && Swipeout.el === $el[0])
      Swipeout.el = void 0;
  },
  delete(el, callback) {
    const app = this;
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    Swipeout.el = void 0;
    $el.trigger("swipeout:delete");
    app.emit("swipeoutDelete", $el[0]);
    $el.css({
      height: `${$el.outerHeight()}px`
    });
    $el.transitionEnd(() => {
      $el.trigger("swipeout:deleted");
      app.emit("swipeoutDeleted", $el[0]);
      if (callback)
        callback.call($el[0]);
      if ($el.parents(".virtual-list").length > 0) {
        const virtualList = $el.parents(".virtual-list")[0].f7VirtualList;
        const virtualIndex = $el[0].f7VirtualListIndex;
        if (virtualList && typeof virtualIndex !== "undefined")
          virtualList.deleteItem(virtualIndex);
      } else if (app.params.swipeout.removeElements) {
        if (app.params.swipeout.removeElementsWithTimeout) {
          setTimeout(() => {
            $el.remove();
          }, app.params.swipeout.removeElementsTimeout);
        } else {
          $el.remove();
        }
      } else {
        $el.removeClass("swipeout-deleting swipeout-transitioning");
      }
    });
    nextFrame(() => {
      $el.addClass("swipeout-deleting swipeout-transitioning").css({
        height: "0px"
      }).find(".swipeout-content").transform("translate3d(-100%,0,0)");
    });
  }
};
var swipeout_default = {
  name: "swipeout",
  params: {
    swipeout: {
      actionsNoFold: false,
      noFollow: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      overswipeRatio: 1.2
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      swipeout: Swipeout
    });
  },
  clicks: {
    ".swipeout-open": function openSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.swipeout.open(data.swipeout, data.side);
    },
    ".swipeout-close": function closeSwipeout($clickedEl) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest(".swipeout");
      if ($swipeoutEl.length === 0)
        return;
      app.swipeout.close($swipeoutEl);
    },
    ".swipeout-delete": function deleteSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const $swipeoutEl = $clickedEl.closest(".swipeout");
      if ($swipeoutEl.length === 0)
        return;
      const {
        confirm,
        confirmTitle
      } = data;
      if (data.confirm) {
        app.dialog.confirm(confirm, confirmTitle, () => {
          app.swipeout.delete($swipeoutEl);
        });
      } else {
        app.swipeout.delete($swipeoutEl);
      }
    }
  },
  on: {
    init() {
      const app = this;
      if (!app.params.swipeout)
        return;
      app.swipeout.init();
    }
  }
};

// node_modules/framework7/components/accordion/accordion.js
var Accordion = {
  toggleClicked($clickedEl) {
    const app = this;
    let $accordionItemEl = $clickedEl.closest(".accordion-item").eq(0);
    if (!$accordionItemEl.length)
      $accordionItemEl = $clickedEl.parents("li").eq(0);
    const $accordionContent = $clickedEl.parents(".accordion-item-content").eq(0);
    if ($accordionContent.length) {
      if ($accordionContent.parents($accordionItemEl).length)
        return;
    }
    if ($clickedEl.parents("li").length > 1 && $clickedEl.parents("li")[0] !== $accordionItemEl[0])
      return;
    app.accordion.toggle($accordionItemEl);
  },
  open(el) {
    const app = this;
    const $el = dom7_default(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger("accordion:beforeopen", {
      prevent
    }, prevent);
    app.emit("accordionBeforeOpen", $el[0], prevent);
    if (prevented)
      return;
    const $list = $el.parents(".accordion-list").eq(0);
    let $contentEl = $el.children(".accordion-item-content");
    $contentEl.removeAttr("aria-hidden");
    if ($contentEl.length === 0)
      $contentEl = $el.find(".accordion-item-content");
    if ($contentEl.length === 0)
      return;
    const $openedItem = $list.length > 0 && $el.parent().children(".accordion-item-opened");
    if ($openedItem.length > 0) {
      app.accordion.close($openedItem);
    }
    $contentEl.transitionEnd(() => {
      if ($el.hasClass("accordion-item-opened")) {
        $contentEl.transition(0);
        $contentEl.css("height", "auto");
        nextFrame(() => {
          $contentEl.transition("");
          $el.trigger("accordion:opened");
          app.emit("accordionOpened", $el[0]);
        });
      } else {
        $contentEl.css("height", "");
        $el.trigger("accordion:closed");
        app.emit("accordionClosed", $el[0]);
      }
    });
    $contentEl.css("height", `${$contentEl[0].scrollHeight}px`);
    $el.trigger("accordion:open");
    $el.addClass("accordion-item-opened");
    app.emit("accordionOpen", $el[0]);
  },
  close(el) {
    const app = this;
    const $el = dom7_default(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger("accordion:beforeclose", {
      prevent
    }, prevent);
    app.emit("accordionBeforeClose", $el[0], prevent);
    if (prevented)
      return;
    let $contentEl = $el.children(".accordion-item-content");
    if ($contentEl.length === 0)
      $contentEl = $el.find(".accordion-item-content");
    $el.removeClass("accordion-item-opened");
    $contentEl.attr("aria-hidden", true);
    $contentEl.transition(0);
    $contentEl.css("height", `${$contentEl[0].scrollHeight}px`);
    $contentEl.transitionEnd(() => {
      if ($el.hasClass("accordion-item-opened")) {
        $contentEl.transition(0);
        $contentEl.css("height", "auto");
        nextFrame(() => {
          $contentEl.transition("");
          $el.trigger("accordion:opened");
          app.emit("accordionOpened", $el[0]);
        });
      } else {
        $contentEl.css("height", "");
        $el.trigger("accordion:closed");
        app.emit("accordionClosed", $el[0]);
      }
    });
    nextFrame(() => {
      $contentEl.transition("");
      $contentEl.css("height", "");
      $el.trigger("accordion:close");
      app.emit("accordionClose", $el[0]);
    });
  },
  toggle(el) {
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    if ($el.hasClass("accordion-item-opened"))
      app.accordion.close(el);
    else
      app.accordion.open(el);
  }
};
var accordion_default = {
  name: "accordion",
  create() {
    const app = this;
    bindMethods(app, {
      accordion: Accordion
    });
  },
  clicks: {
    ".accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a": function open($clickedEl) {
      const app = this;
      Accordion.toggleClicked.call(app, $clickedEl);
    }
  }
};

// node_modules/framework7/components/contacts-list/contacts-list.js
var contacts_list_default = {
  name: "contactsList"
};

// node_modules/framework7/components/virtual-list/virtual-list-class.js
var VirtualList = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const vl = this;
    const device = getDevice();
    const document = getDocument();
    let defaultHeight;
    if (app.theme === "md") {
      defaultHeight = 48;
    } else if (app.theme === "ios") {
      defaultHeight = 44;
    } else if (app.theme === "aurora") {
      defaultHeight = 38;
    }
    const defaults = {
      cols: 1,
      height: defaultHeight,
      cache: true,
      dynamicHeightBufferSize: 1,
      showFilteredItemsOnly: false,
      renderExternal: void 0,
      setListHeight: true,
      searchByItem: void 0,
      searchAll: void 0,
      ul: null,
      createUl: true,
      scrollableParentEl: void 0,
      renderItem(item) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
      },
      on: {}
    };
    vl.useModulesParams(defaults);
    vl.params = extend(defaults, params);
    if (vl.params.height === void 0 || !vl.params.height) {
      vl.params.height = defaultHeight;
    }
    vl.$el = dom7_default(params.el);
    vl.el = vl.$el[0];
    if (vl.$el.length === 0)
      return void 0;
    vl.$el[0].f7VirtualList = vl;
    vl.items = vl.params.items;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    }
    if (vl.params.renderItem) {
      vl.renderItem = vl.params.renderItem;
    }
    vl.$pageContentEl = vl.$el.parents(".page-content");
    vl.pageContentEl = vl.$pageContentEl[0];
    vl.$scrollableParentEl = vl.params.scrollableParentEl ? dom7_default(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;
    if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
      vl.$scrollableParentEl = vl.$pageContentEl;
    }
    vl.scrollableParentEl = vl.$scrollableParentEl[0];
    if (typeof vl.params.updatableScroll !== "undefined") {
      vl.updatableScroll = vl.params.updatableScroll;
    } else {
      vl.updatableScroll = true;
      if (device.ios && device.osVersion.split(".")[0] < 8) {
        vl.updatableScroll = false;
      }
    }
    const ul = vl.params.ul;
    vl.$ul = ul ? dom7_default(vl.params.ul) : vl.$el.children("ul");
    if (vl.$ul.length === 0 && vl.params.createUl) {
      vl.$el.append("<ul></ul>");
      vl.$ul = vl.$el.children("ul");
    }
    vl.ul = vl.$ul[0];
    let $itemsWrapEl;
    if (!vl.ul && !vl.params.createUl)
      $itemsWrapEl = vl.$el;
    else
      $itemsWrapEl = vl.$ul;
    extend(vl, {
      $itemsWrapEl,
      itemsWrapEl: $itemsWrapEl[0],
      // DOM cached items
      domCache: {},
      displayDomCache: {},
      // Temporary DOM Element
      tempDomElement: document.createElement("ul"),
      // Last repain position
      lastRepaintY: null,
      // Fragment
      fragment: document.createDocumentFragment(),
      // Props
      pageHeight: void 0,
      rowsPerScreen: void 0,
      rowsBefore: void 0,
      rowsAfter: void 0,
      rowsToRender: void 0,
      maxBufferHeight: 0,
      listHeight: void 0,
      dynamicHeight: typeof vl.params.height === "function",
      autoHeight: vl.params.height === "auto"
    });
    vl.useModules();
    const handleScrollBound = vl.handleScroll.bind(vl);
    const handleResizeBound = vl.handleResize.bind(vl);
    let $pageEl;
    let $tabEl;
    let $panelEl;
    let $popupEl;
    vl.attachEvents = function attachEvents() {
      $pageEl = vl.$el.parents(".page").eq(0);
      $tabEl = vl.$el.parents(".tab").filter((tabEl) => {
        return dom7_default(tabEl).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0;
      }).eq(0);
      $panelEl = vl.$el.parents(".panel").eq(0);
      $popupEl = vl.$el.parents(".popup").eq(0);
      vl.$scrollableParentEl.on("scroll", handleScrollBound);
      if ($pageEl.length)
        $pageEl.on("page:reinit", handleResizeBound);
      if ($tabEl.length)
        $tabEl.on("tab:show", handleResizeBound);
      if ($panelEl.length)
        $panelEl.on("panel:open", handleResizeBound);
      if ($popupEl.length)
        $popupEl.on("popup:open", handleResizeBound);
      app.on("resize", handleResizeBound);
    };
    vl.detachEvents = function attachEvents() {
      vl.$scrollableParentEl.off("scroll", handleScrollBound);
      if ($pageEl.length)
        $pageEl.off("page:reinit", handleResizeBound);
      if ($tabEl.length)
        $tabEl.off("tab:show", handleResizeBound);
      if ($panelEl.length)
        $panelEl.off("panel:open", handleResizeBound);
      if ($popupEl.length)
        $popupEl.off("popup:open", handleResizeBound);
      app.off("resize", handleResizeBound);
    };
    vl.init();
    return vl;
  }
  setListSize(autoHeightRerender) {
    const vl = this;
    const items = vl.filteredItems || vl.items;
    if (!autoHeightRerender) {
      vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;
    }
    if (vl.dynamicHeight) {
      vl.listHeight = 0;
      vl.heights = [];
      for (let i = 0; i < items.length; i += 1) {
        const itemHeight = vl.params.height(items[i]);
        vl.listHeight += itemHeight;
        vl.heights.push(itemHeight);
      }
    } else if (vl.autoHeight) {
      vl.listHeight = 0;
      if (!vl.heights)
        vl.heights = [];
      if (!vl.heightsCalculated)
        vl.heightsCalculated = [];
      const renderedItems = {};
      vl.$itemsWrapEl.find(`[data-virtual-list-index]`).forEach((el) => {
        renderedItems[parseInt(el.getAttribute("data-virtual-list-index"), 10)] = el;
      });
      for (let i = 0; i < items.length; i += 1) {
        const renderedItem = renderedItems[i];
        if (renderedItem) {
          if (!vl.heightsCalculated.includes(i)) {
            vl.heights[i] = renderedItem.offsetHeight;
            vl.heightsCalculated.push(i);
          }
        }
        if (typeof vl.heights[i] === "undefined") {
          vl.heights[i] = 40;
        }
        vl.listHeight += vl.heights[i];
      }
    } else {
      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
      vl.rowsToRender = vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter;
      vl.maxBufferHeight = vl.rowsBefore / 2 * vl.params.height;
    }
    if (vl.updatableScroll || vl.params.setListHeight) {
      vl.$itemsWrapEl.css({
        height: `${vl.listHeight}px`
      });
    }
  }
  render(force, forceScrollTop) {
    const vl = this;
    if (force)
      vl.lastRepaintY = null;
    let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);
    if (typeof forceScrollTop !== "undefined")
      scrollTop = forceScrollTop;
    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || !vl.updatableScroll && vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight) {
      vl.lastRepaintY = scrollTop;
    } else {
      return;
    }
    const items = vl.filteredItems || vl.items;
    let fromIndex;
    let toIndex;
    let heightBeforeFirstItem = 0;
    let heightBeforeLastItem = 0;
    if (vl.dynamicHeight || vl.autoHeight) {
      let itemTop = 0;
      let itemHeight;
      vl.maxBufferHeight = vl.pageHeight;
      for (let j = 0; j < vl.heights.length; j += 1) {
        itemHeight = vl.heights[j];
        if (typeof fromIndex === "undefined") {
          if (itemTop + itemHeight >= scrollTop - vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)
            fromIndex = j;
          else
            heightBeforeFirstItem += itemHeight;
        }
        if (typeof toIndex === "undefined") {
          if (itemTop + itemHeight >= scrollTop + vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize || j === vl.heights.length - 1)
            toIndex = j + 1;
          heightBeforeLastItem += itemHeight;
        }
        itemTop += itemHeight;
      }
      toIndex = Math.min(toIndex, items.length);
    } else {
      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
      toIndex = Math.min(fromIndex + vl.rowsToRender * vl.params.cols, items.length);
    }
    let topPosition;
    const renderExternalItems = [];
    vl.reachEnd = false;
    let i;
    for (i = fromIndex; i < toIndex; i += 1) {
      let itemEl;
      const index = vl.items.indexOf(items[i]);
      if (i === fromIndex)
        vl.currentFromIndex = index;
      if (i === toIndex - 1)
        vl.currentToIndex = index;
      if (vl.filteredItems) {
        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1])
          vl.reachEnd = true;
      } else if (index === vl.items.length - 1)
        vl.reachEnd = true;
      if (vl.params.renderExternal) {
        renderExternalItems.push(items[i]);
      } else if (vl.domCache[index]) {
        itemEl = vl.domCache[index];
        itemEl.f7VirtualListIndex = index;
      } else {
        if (vl.renderItem) {
          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
        } else {
          vl.tempDomElement.innerHTML = items[i].toString().trim();
        }
        itemEl = vl.tempDomElement.childNodes[0];
        if (vl.params.cache)
          vl.domCache[index] = itemEl;
        itemEl.f7VirtualListIndex = index;
      }
      if (i === fromIndex) {
        if (vl.dynamicHeight || vl.autoHeight) {
          topPosition = heightBeforeFirstItem;
        } else {
          topPosition = i * vl.params.height / vl.params.cols;
        }
      }
      if (!vl.params.renderExternal) {
        itemEl.style.top = `${topPosition}px`;
        vl.emit("local::itemBeforeInsert vlItemBeforeInsert", vl, itemEl, items[i]);
        vl.fragment.appendChild(itemEl);
      }
    }
    if (!vl.updatableScroll) {
      if (vl.dynamicHeight || vl.autoHeight) {
        vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
      } else {
        vl.itemsWrapEl.style.height = `${i * vl.params.height / vl.params.cols}px`;
      }
    }
    if (vl.params.renderExternal) {
      if (items && items.length === 0) {
        vl.reachEnd = true;
      }
    } else {
      vl.emit("local::beforeClear vlBeforeClear", vl, vl.fragment);
      vl.itemsWrapEl.innerHTML = "";
      vl.emit("local::itemsBeforeInsert vlItemsBeforeInsert", vl, vl.fragment);
      if (items && items.length === 0) {
        vl.reachEnd = true;
        if (vl.params.emptyTemplate)
          vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
      } else {
        vl.itemsWrapEl.appendChild(vl.fragment);
      }
      vl.emit("local::itemsAfterInsert vlItemsAfterInsert", vl, vl.fragment);
    }
    if (typeof forceScrollTop !== "undefined" && force) {
      vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
    }
    if (vl.params.renderExternal) {
      vl.params.renderExternal(vl, {
        fromIndex,
        toIndex,
        listHeight: vl.listHeight,
        topPosition,
        items: renderExternalItems
      });
    }
    if (vl.autoHeight) {
      requestAnimationFrame(() => {
        vl.setListSize(true);
      });
    }
  }
  // Filter
  filterItems(indexes, resetScrollTop) {
    if (resetScrollTop === void 0) {
      resetScrollTop = true;
    }
    const vl = this;
    vl.filteredItems = [];
    for (let i = 0; i < indexes.length; i += 1) {
      vl.filteredItems.push(vl.items[indexes[i]]);
    }
    if (resetScrollTop) {
      vl.$scrollableParentEl[0].scrollTop = 0;
    }
    vl.update();
  }
  resetFilter() {
    const vl = this;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    } else {
      vl.filteredItems = null;
      delete vl.filteredItems;
    }
    vl.update();
  }
  scrollToItem(index) {
    const vl = this;
    if (index > vl.items.length)
      return false;
    let itemTop = 0;
    if (vl.dynamicHeight || vl.autoHeight) {
      for (let i = 0; i < index; i += 1) {
        itemTop += vl.heights[i];
      }
    } else {
      itemTop = index * vl.params.height;
    }
    const listTop = vl.$el[0].offsetTop;
    vl.render(true, listTop + itemTop - parseInt(vl.$scrollableParentEl.css("padding-top"), 10));
    return true;
  }
  handleScroll() {
    const vl = this;
    vl.render();
  }
  // Handle resize event
  isVisible() {
    const vl = this;
    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
  }
  handleResize() {
    const vl = this;
    if (vl.isVisible()) {
      vl.heightsCalculated = [];
      vl.setListSize();
      vl.render(true);
    }
  }
  // Append
  appendItems(items) {
    const vl = this;
    for (let i = 0; i < items.length; i += 1) {
      vl.items.push(items[i]);
    }
    vl.update();
  }
  appendItem(item) {
    const vl = this;
    vl.appendItems([item]);
  }
  // Replace
  replaceAllItems(items) {
    const vl = this;
    vl.items = items;
    delete vl.filteredItems;
    vl.domCache = {};
    vl.update();
  }
  replaceItem(index, item) {
    const vl = this;
    vl.items[index] = item;
    if (vl.params.cache)
      delete vl.domCache[index];
    vl.update();
  }
  // Prepend
  prependItems(items) {
    const vl = this;
    for (let i = items.length - 1; i >= 0; i -= 1) {
      vl.items.unshift(items[i]);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  prependItem(item) {
    const vl = this;
    vl.prependItems([item]);
  }
  // Move
  moveItem(from, to) {
    const vl = this;
    const fromIndex = from;
    let toIndex = to;
    if (fromIndex === toIndex)
      return;
    const item = vl.items.splice(fromIndex, 1)[0];
    if (toIndex >= vl.items.length) {
      vl.items.push(item);
      toIndex = vl.items.length - 1;
    } else {
      vl.items.splice(toIndex, 0, item);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
        const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
        const indexShift = fromIndex < toIndex ? -1 : 1;
        if (cachedIndex < leftIndex || cachedIndex > rightIndex)
          newCache[cachedIndex] = vl.domCache[cachedIndex];
        if (cachedIndex === leftIndex)
          newCache[rightIndex] = vl.domCache[cachedIndex];
        if (cachedIndex > leftIndex && cachedIndex <= rightIndex)
          newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  // Insert before
  insertItemBefore(index, item) {
    const vl = this;
    if (index === 0) {
      vl.prependItem(item);
      return;
    }
    if (index >= vl.items.length) {
      vl.appendItem(item);
      return;
    }
    vl.items.splice(index, 0, item);
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        if (cachedIndex >= index) {
          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
        }
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  // Delete
  deleteItems(indexes) {
    const vl = this;
    let prevIndex;
    let indexShift = 0;
    for (let i = 0; i < indexes.length; i += 1) {
      let index = indexes[i];
      if (typeof prevIndex !== "undefined") {
        if (index > prevIndex) {
          indexShift = -i;
        }
      }
      index += indexShift;
      prevIndex = indexes[i];
      const deletedItem = vl.items.splice(index, 1)[0];
      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
      }
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          if (cachedIndex === index) {
            delete vl.domCache[index];
          } else if (parseInt(cached, 10) > index) {
            newCache[cachedIndex - 1] = vl.domCache[cached];
          } else {
            newCache[cachedIndex] = vl.domCache[cached];
          }
        });
        vl.domCache = newCache;
      }
    }
    vl.update();
  }
  deleteAllItems() {
    const vl = this;
    vl.items = [];
    delete vl.filteredItems;
    if (vl.params.cache)
      vl.domCache = {};
    vl.update();
  }
  deleteItem(index) {
    const vl = this;
    vl.deleteItems([index]);
  }
  // Clear cache
  clearCache() {
    const vl = this;
    vl.domCache = {};
  }
  // Update Virtual List
  update(deleteCache) {
    const vl = this;
    if (deleteCache && vl.params.cache) {
      vl.domCache = {};
    }
    vl.heightsCalculated = [];
    vl.setListSize();
    vl.render(true);
  }
  init() {
    const vl = this;
    vl.attachEvents();
    vl.setListSize();
    vl.render();
  }
  destroy() {
    let vl = this;
    vl.detachEvents();
    vl.$el[0].f7VirtualList = null;
    delete vl.$el[0].f7VirtualList;
    deleteProps(vl);
    vl = null;
  }
};
var virtual_list_class_default = VirtualList;

// node_modules/framework7/components/virtual-list/virtual-list.js
var virtual_list_default = {
  name: "virtualList",
  static: {
    VirtualList: virtual_list_class_default
  },
  create() {
    const app = this;
    app.virtualList = ConstructorMethods({
      defaultSelector: ".virtual-list",
      constructor: virtual_list_class_default,
      app,
      domProp: "f7VirtualList"
    });
  }
};

// node_modules/framework7/components/list-index/list-index-class.js
var ListIndex = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const index = this;
    const defaults = {
      el: null,
      // where to render indexes
      listEl: null,
      // list el to generate indexes
      indexes: "auto",
      // or array of indexes
      iosItemHeight: 14,
      mdItemHeight: 14,
      auroraItemHeight: 14,
      scrollList: true,
      label: false,
      // eslint-disable-next-line
      renderItem(itemContent, itemIndex) {
        return `
          <li>${itemContent}</li>
        `.trim();
      },
      renderSkipPlaceholder() {
        return '<li class="list-index-skip-placeholder"></li>';
      },
      on: {}
    };
    index.useModulesParams(defaults);
    index.params = extend(defaults, params);
    let $el;
    let $listEl;
    let $pageContentEl;
    let $ul;
    if (index.params.el) {
      $el = dom7_default(index.params.el);
    } else {
      return index;
    }
    if ($el[0].f7ListIndex) {
      return $el[0].f7ListIndex;
    }
    $ul = $el.find("ul");
    if ($ul.length === 0) {
      $ul = dom7_default("<ul></ul>");
      $el.append($ul);
    }
    if (index.params.listEl) {
      $listEl = dom7_default(index.params.listEl);
    }
    if (index.params.indexes === "auto" && !$listEl) {
      return index;
    }
    if ($listEl) {
      $pageContentEl = $listEl.parents(".page-content").eq(0);
    } else {
      $pageContentEl = $el.siblings(".page-content").eq(0);
      if ($pageContentEl.length === 0) {
        $pageContentEl = $el.parents(".page").eq(0).find(".page-content").eq(0);
      }
    }
    $el[0].f7ListIndex = index;
    extend(index, {
      app,
      $el,
      el: $el && $el[0],
      $ul,
      ul: $ul && $ul[0],
      $listEl,
      listEl: $listEl && $listEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl && $pageContentEl[0],
      indexes: params.indexes,
      height: 0,
      skipRate: 0
    });
    index.useModules();
    function handleResize() {
      const height = {
        index
      };
      index.calcSize();
      if (height !== index.height) {
        index.render();
      }
    }
    function handleClick(e) {
      const $clickedLi = dom7_default(e.target).closest("li");
      if (!$clickedLi.length)
        return;
      let itemIndex = $clickedLi.index();
      if (index.skipRate > 0) {
        const percentage = itemIndex / ($clickedLi.siblings("li").length - 1);
        itemIndex = Math.round((index.indexes.length - 1) * percentage);
      }
      const itemContent = index.indexes[itemIndex];
      index.$el.trigger("listindex:click", {
        content: itemContent,
        index: itemIndex
      });
      index.emit("local::click listIndexClick", index, itemContent, itemIndex);
      index.$el.trigger("listindex:select", {
        content: itemContent,
        index: itemIndex
      });
      index.emit("local::select listIndexSelect", index, itemContent, itemIndex);
      if (index.$listEl && index.params.scrollList) {
        index.scrollListToIndex(itemContent, itemIndex);
      }
    }
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let topPoint;
    let bottomPoint;
    let $labelEl;
    let previousIndex = null;
    function handleTouchStart(e) {
      const $children = $ul.children();
      if (!$children.length)
        return;
      topPoint = $children[0].getBoundingClientRect().top;
      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isMoved = false;
      previousIndex = null;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      if (!isMoved && index.params.label) {
        $labelEl = dom7_default('<span class="list-index-label"></span>');
        $el.append($labelEl);
      }
      isMoved = true;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
      percentage = Math.min(Math.max(percentage, 0), 1);
      const itemIndex = Math.round((index.indexes.length - 1) * percentage);
      const itemContent = index.indexes[itemIndex];
      const ulHeight = bottomPoint - topPoint;
      const bubbleBottom = (index.height - ulHeight) / 2 + (1 - percentage) * ulHeight;
      if (itemIndex !== previousIndex) {
        if (index.params.label) {
          $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
        }
        if (index.$listEl && index.params.scrollList) {
          index.scrollListToIndex(itemContent, itemIndex);
        }
      }
      previousIndex = itemIndex;
      index.$el.trigger("listindex:select");
      index.emit("local::select listIndexSelect", index, itemContent, itemIndex);
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      isTouched = false;
      isMoved = false;
      if (index.params.label) {
        if ($labelEl)
          $labelEl.remove();
        $labelEl = void 0;
      }
    }
    const passiveListener = getSupport().passiveListener ? {
      passive: true
    } : false;
    index.attachEvents = function attachEvents() {
      $el.parents(".tab").on("tab:show", handleResize);
      $el.parents(".page").on("page:reinit", handleResize);
      $el.parents(".panel").on("panel:open", handleResize);
      $el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").on("modal:open", handleResize);
      app.on("resize", handleResize);
      $el.on("click", handleClick);
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
    };
    index.detachEvents = function attachEvents() {
      $el.parents(".tab").off("tab:show", handleResize);
      $el.parents(".page").off("page:reinit", handleResize);
      $el.parents(".panel").off("panel:open", handleResize);
      $el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").off("modal:open", handleResize);
      app.off("resize", handleResize);
      $el.off("click", handleClick);
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
    };
    index.init();
    return index;
  }
  // eslint-disable-next-line
  scrollListToIndex(itemContent, itemIndex) {
    const index = this;
    const {
      $listEl,
      $pageContentEl,
      app
    } = index;
    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0)
      return index;
    let $scrollToEl;
    $listEl.find(".list-group-title, .item-divider").each((el) => {
      if ($scrollToEl)
        return;
      const $el = dom7_default(el);
      if ($el.text() === itemContent) {
        $scrollToEl = $el;
      }
    });
    if (!$scrollToEl || $scrollToEl.length === 0)
      return index;
    const parentTop = $scrollToEl.parent().offset().top;
    let paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
    const scrollTop = $pageContentEl[0].scrollTop;
    const scrollToElTop = $scrollToEl.offset().top;
    if ($pageContentEl.parents(".page-with-navbar-large").length) {
      const navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents(".page-with-navbar-large").eq(0));
      const $titleLargeEl = dom7_default(navbarInnerEl).find(".title-large");
      if ($titleLargeEl.length) {
        paddingTop -= $titleLargeEl[0].offsetHeight || 0;
      }
    }
    if (parentTop <= paddingTop) {
      $pageContentEl.scrollTop(parentTop + scrollTop - paddingTop);
    } else {
      $pageContentEl.scrollTop(scrollToElTop + scrollTop - paddingTop);
    }
    return index;
  }
  renderSkipPlaceholder() {
    const index = this;
    return index.params.renderSkipPlaceholder.call(index);
  }
  renderItem(itemContent, itemIndex) {
    const index = this;
    return index.params.renderItem.call(index, itemContent, itemIndex);
  }
  render() {
    const index = this;
    const {
      $ul,
      indexes,
      skipRate
    } = index;
    let wasSkipped;
    const html = indexes.map((itemContent, itemIndex) => {
      if (itemIndex % skipRate !== 0 && skipRate > 0) {
        wasSkipped = true;
        return "";
      }
      let itemHtml = index.renderItem(itemContent, itemIndex);
      if (wasSkipped) {
        itemHtml = index.renderSkipPlaceholder() + itemHtml;
      }
      wasSkipped = false;
      return itemHtml;
    }).join("");
    $ul.html(html);
    return index;
  }
  calcSize() {
    const index = this;
    const {
      app,
      params,
      el,
      indexes
    } = index;
    const height = el.offsetHeight;
    const itemHeight = params[`${app.theme}ItemHeight`];
    const maxItems = Math.floor(height / itemHeight);
    const items = indexes.length;
    let skipRate = 0;
    if (items > maxItems) {
      skipRate = Math.ceil((items * 2 - 1) / maxItems);
    }
    index.height = height;
    index.skipRate = skipRate;
    return index;
  }
  calcIndexes() {
    const index = this;
    if (index.params.indexes === "auto") {
      index.indexes = [];
      index.$listEl.find(".list-group-title, .item-divider").each((el) => {
        const elContent = dom7_default(el).text();
        if (index.indexes.indexOf(elContent) < 0) {
          index.indexes.push(elContent);
        }
      });
    } else {
      index.indexes = index.params.indexes;
    }
    return index;
  }
  update() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    return index;
  }
  init() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    index.attachEvents();
  }
  destroy() {
    let index = this;
    index.$el.trigger("listindex:beforedestroy", index);
    index.emit("local::beforeDestroy listIndexBeforeDestroy");
    index.detachEvents();
    if (index.$el[0]) {
      index.$el[0].f7ListIndex = null;
      delete index.$el[0].f7ListIndex;
    }
    deleteProps(index);
    index = null;
  }
};
var list_index_class_default = ListIndex;

// node_modules/framework7/components/list-index/list-index.js
var list_index_default = {
  name: "listIndex",
  static: {
    ListIndex: list_index_class_default
  },
  create() {
    const app = this;
    app.listIndex = ConstructorMethods({
      defaultSelector: ".list-index",
      constructor: list_index_class_default,
      app,
      domProp: "f7ListIndex"
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".list-index-init").each((listIndexEl) => {
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".list-index-init").each((listIndexEl) => {
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".list-index-init").each((listIndexEl) => {
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".list-index-init").each((listIndexEl) => {
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      });
    }
  },
  vnode: {
    "list-index-init": {
      insert(vnode) {
        const app = this;
        const listIndexEl = vnode.elm;
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      },
      destroy(vnode) {
        const listIndexEl = vnode.elm;
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      }
    }
  }
};

// node_modules/framework7/components/timeline/timeline.js
var timeline_default = {
  name: "timeline"
};

// node_modules/framework7/components/tabs/tabs.js
var Tab = {
  show() {
    const app = this;
    let tabEl;
    let tabLinkEl;
    let animate;
    let tabRoute;
    let animatedInit;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0] && args[0].constructor === Object) {
      tabEl = args[0].tabEl;
      tabLinkEl = args[0].tabLinkEl;
      animate = args[0].animate;
      tabRoute = args[0].tabRoute;
      animatedInit = args[0].animatedInit;
    } else {
      [tabEl, tabLinkEl, animate, tabRoute] = args;
      if (typeof args[1] === "boolean") {
        [tabEl, animate, tabLinkEl, tabRoute] = args;
        if (args.length > 2 && tabLinkEl.constructor === Object) {
          [tabEl, animate, tabRoute, tabLinkEl] = args;
        }
      }
    }
    if (typeof animate === "undefined")
      animate = true;
    const $newTabEl = dom7_default(tabEl);
    if (tabRoute && $newTabEl[0]) {
      $newTabEl[0].f7TabRoute = tabRoute;
    }
    if (!animatedInit && ($newTabEl.length === 0 || $newTabEl.hasClass("tab-active"))) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    }
    let $tabLinkEl;
    if (tabLinkEl)
      $tabLinkEl = dom7_default(tabLinkEl);
    const $tabsEl = $newTabEl.parent(".tabs");
    if ($tabsEl.length === 0) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    }
    if (app.swipeout)
      app.swipeout.allowOpen = true;
    const tabsChangedCallbacks = [];
    function onTabsChanged(callback) {
      tabsChangedCallbacks.push(callback);
    }
    function tabsChanged() {
      tabsChangedCallbacks.forEach((callback) => {
        callback();
      });
    }
    let animated = false;
    if ($tabsEl.parent().hasClass("tabs-animated-wrap")) {
      $tabsEl.parent()[animate ? "removeClass" : "addClass"]("not-animated");
      const transitionDuration = parseFloat($tabsEl.css("transition-duration").replace(",", "."));
      if (animate && transitionDuration) {
        $tabsEl.transitionEnd(tabsChanged);
        animated = true;
      }
      const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
      $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
    }
    let swiper;
    if ($tabsEl.parent().hasClass("tabs-swipeable-wrap") && app.swiper) {
      swiper = $tabsEl.parent()[0].swiper;
      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
        animated = true;
        swiper.once("slideChangeTransitionEnd", () => {
          tabsChanged();
        }).slideTo($newTabEl.index(), animate ? void 0 : 0);
      } else if (swiper && swiper.animating) {
        animated = true;
        swiper.once("slideChangeTransitionEnd", () => {
          tabsChanged();
        });
      }
    }
    const $oldTabEl = $tabsEl.children(".tab-active");
    $oldTabEl.removeClass("tab-active");
    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($oldTabEl.hasClass("view") && $oldTabEl.children(".page").length) {
        $oldTabEl.children(".page").each((pageEl) => {
          dom7_default(pageEl).trigger("page:tabhide");
          app.emit("pageTabHide", pageEl);
        });
      }
      $oldTabEl.trigger("tab:hide");
      app.emit("tabHide", $oldTabEl[0]);
    }
    $newTabEl.addClass("tab-active");
    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($newTabEl.hasClass("view") && $newTabEl.children(".page").length) {
        $newTabEl.children(".page").each((pageEl) => {
          dom7_default(pageEl).trigger("page:tabshow");
          app.emit("pageTabShow", pageEl);
        });
      }
      $newTabEl.trigger("tab:show");
      app.emit("tabShow", $newTabEl[0]);
    }
    if (!$tabLinkEl) {
      if (typeof tabEl === "string")
        $tabLinkEl = dom7_default(`.tab-link[href="${tabEl}"]`);
      else
        $tabLinkEl = dom7_default(`.tab-link[href="#${$newTabEl.attr("id")}"]`);
      if (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0) {
        dom7_default("[data-tab]").each((el) => {
          if ($newTabEl.is(dom7_default(el).attr("data-tab")))
            $tabLinkEl = dom7_default(el);
        });
      }
      if (tabRoute && (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0)) {
        $tabLinkEl = dom7_default(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
        if ($tabLinkEl.length === 0) {
          $tabLinkEl = dom7_default(`.tab-link[href="${tabRoute.url}"]`);
        }
      }
      if ($tabLinkEl.length > 1 && $newTabEl.parents(".page").length) {
        $tabLinkEl = $tabLinkEl.filter((tabLinkElement) => {
          return dom7_default(tabLinkElement).parents(".page")[0] === $newTabEl.parents(".page")[0];
        });
        if (app.theme === "ios" && $tabLinkEl.length === 0 && tabRoute) {
          const $pageEl = $newTabEl.parents(".page");
          const $navbarEl = dom7_default(app.navbar.getElByPage($pageEl));
          $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
      }
    }
    if ($tabLinkEl.length > 0) {
      let $oldTabLinkEl;
      if ($oldTabEl && $oldTabEl.length > 0) {
        const oldTabId = $oldTabEl.attr("id");
        if (oldTabId) {
          $oldTabLinkEl = dom7_default(`.tab-link[href="#${oldTabId}"]`);
          if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
            $oldTabLinkEl = dom7_default(`.tab-link[data-route-tab-id="${oldTabId}"]`);
          }
        }
        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          dom7_default("[data-tab]").each((tabLinkElement) => {
            if ($oldTabEl.is(dom7_default(tabLinkElement).attr("data-tab")))
              $oldTabLinkEl = dom7_default(tabLinkElement);
          });
        }
        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          $oldTabLinkEl = $tabLinkEl.siblings(".tab-link-active");
        }
      } else if (tabRoute) {
        $oldTabLinkEl = $tabLinkEl.siblings(".tab-link-active");
      }
      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents(".page").length) {
        $oldTabLinkEl = $oldTabLinkEl.filter((tabLinkElement) => {
          return dom7_default(tabLinkElement).parents(".page")[0] === $oldTabEl.parents(".page")[0];
        });
      }
      if ($oldTabLinkEl && $oldTabLinkEl.length > 0)
        $oldTabLinkEl.removeClass("tab-link-active");
      if ($tabLinkEl && $tabLinkEl.length > 0) {
        $tabLinkEl.addClass("tab-link-active");
        const $tabbarEl = $tabLinkEl.parents(".tabbar, .tabbar-labels");
        const hasHighlight = app.toolbar && $tabbarEl.length > 0 && ($tabbarEl.hasClass("tabbar-highlight") || app.theme !== "ios");
        if (hasHighlight) {
          app.toolbar.setHighlight($tabbarEl);
        }
      }
    }
    return {
      $newTabEl,
      newTabEl: $newTabEl[0],
      $oldTabEl,
      oldTabEl: $oldTabEl[0],
      onTabsChanged,
      animated
    };
  }
};
var tabs_default = {
  name: "tabs",
  create() {
    const app = this;
    extend(app, {
      tab: {
        show: Tab.show.bind(app)
      }
    });
  },
  on: {
    "pageInit tabMounted": function onInit(pageOrTabEl) {
      const $el = dom7_default(pageOrTabEl.el || pageOrTabEl);
      const animatedTabEl = $el.find(".tabs-animated-wrap > .tabs > .tab-active")[0];
      if (!animatedTabEl)
        return;
      const app = this;
      app.tab.show({
        tabEl: animatedTabEl,
        animatedInit: true,
        animate: false
      });
    }
  },
  clicks: {
    ".tab-link": function tabLinkClick($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      if ($clickedEl.attr("href") && $clickedEl.attr("href").indexOf("#") === 0 || $clickedEl.attr("data-tab")) {
        const app = this;
        app.tab.show({
          tabEl: data.tab || $clickedEl.attr("href"),
          tabLinkEl: $clickedEl,
          animate: data.animate
        });
      }
    }
  }
};

// node_modules/framework7/components/panel/swipe-panel.js
function swipePanel(panel) {
  const app = panel.app;
  if (panel.swipeInitialized) {
    return;
  }
  extend(panel, {
    swipeable: true,
    swipeInitialized: true
  });
  const params = panel.params;
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  let otherPanel;
  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;
  let $viewEl;
  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted)
      return;
    if (!app.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched)
      return;
    if (dom7_default(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0)
      return;
    otherPanel = app.panel.get(side === "left" ? "right" : "left") || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass("panel-in-breakpoint");
    if (!panel.opened && otherPanelOpened) {
      return;
    }
    if (!params.swipeOnlyClose) {
      if (otherPanelOpened)
        return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === "input" && e.target.type === "range")
      return;
    if (dom7_default(e.target).closest(".range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened").length > 0)
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === "left") {
        if (touchesStart.x > params.swipeActiveArea)
          return;
      }
      if (side === "right") {
        if (touchesStart.x < app.width - params.swipeActiveArea)
          return;
      }
    }
    touchMoves = 0;
    $viewEl = dom7_default(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    isInterrupted = false;
    touchStartTime = now();
    direction = void 0;
  }
  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted)
      return;
    touchMoves += 1;
    if (touchMoves < 2)
      return;
    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = "to-right";
      } else {
        direction = "to-left";
      }
      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === "left" && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }
        if (side === "right" && touchesStart.x < app.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }
      if ($el.hasClass("panel-in-breakpoint")) {
        isTouched = false;
        return;
      }
      if (side === "left" && direction === "to-left" && !$el.hasClass("panel-in") || side === "right" && direction === "to-right" && !$el.hasClass("panel-in")) {
        isTouched = false;
        return;
      }
    }
    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === "right")
      threshold = -threshold;
    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass("panel-in-swipe");
        if ($backdropEl)
          $backdropEl.css("visibility", "visible");
        $el.trigger("panel:swipeopen");
        panel.emit("local::swipeOpen panelSwipeOpen", panel);
      }
      panelWidth = $el[0].offsetWidth;
      if (effect === "reveal" && $el.hasClass("panel-in-collapsed")) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }
      $el.transition(0);
    }
    isMoved = true;
    if (e.cancelable) {
      e.preventDefault();
    }
    touchesDiff = pageX - touchesStart.x + threshold;
    if (side === "right") {
      if (effect === "cover" || effect === "push") {
        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
        if (translate < 0)
          translate = 0;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0)
          translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : 0);
      if (translate < 0)
        translate = 0;
      if (translate > panelWidth) {
        translate = panelWidth;
      }
    }
    const noFollowProgress = Math.abs(translate / panelWidth);
    if (effect === "reveal") {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if ($backdropEl)
          $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    } else {
      if (side === "left")
        translate -= panelWidth;
      if (!params.swipeNoFollow) {
        backdropOpacity = 1 - Math.abs(translate / panelWidth);
        if ($backdropEl) {
          $backdropEl.transition(0);
          $backdropEl.css({
            opacity: backdropOpacity
          });
        }
        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if (effect === "push") {
          const viewTranslate = side === "left" ? translate + panelWidth : translate - panelWidth;
          $viewEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          if ($backdropEl) {
            $backdropEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          }
        }
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    }
    if (params.swipeNoFollow) {
      const stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;
      if (stateChanged) {
        isInterrupted = true;
        handleTouchEnd(e);
      }
    }
  }
  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    const isGesture = e.type === "gesturestart" || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
    let action;
    const edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
    const threshold = params.swipeThreshold || 0;
    if (isGesture) {
      action = "reset";
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = "reset";
      } else if (effect === "cover" || effect === "push") {
        if (translate === 0) {
          action = "swap";
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = "swap";
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = "swap";
        } else {
          action = "reset";
        }
      } else if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
        action = "swap";
      } else {
        action = "reset";
      }
    } else if (effect === "cover" || effect === "push") {
      if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = "swap";
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = "reset";
      } else {
        action = "swap";
      }
    } else if (translate === -panelWidth) {
      action = "reset";
    } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
      if (side === "left" && translate === panelWidth)
        action = "reset";
      else
        action = "swap";
    } else {
      action = "reset";
    }
    if (action === "swap") {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    let removePanelInClass = true;
    if (action === "reset") {
      if (!panel.opened) {
        if (edge) {
          $el.removeClass("panel-in-swipe");
        } else {
          removePanelInClass = false;
          const target = effect === "reveal" ? $viewEl : $el;
          panel.setStateClasses("before-closing");
          target.transitionEnd(() => {
            if ($el.hasClass("panel-in"))
              return;
            $el.removeClass("panel-in-swipe");
            panel.setStateClasses("after-closing");
          });
        }
      }
    }
    if (effect === "reveal" || effect === "push") {
      nextFrame(() => {
        $viewEl.transition("");
        $viewEl.transform("");
      });
    }
    if (removePanelInClass) {
      $el.removeClass("panel-in-swipe");
    }
    $el.transition("").transform("");
    if ($backdropEl) {
      $backdropEl.transform("").transition("").css({
        opacity: "",
        visibility: ""
      });
    }
  }
  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }
  function handleGestureEnd() {
    isGestureStarted = false;
  }
  app.on("touchstart:passive", handleTouchStart);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("gesturestart", handleGestureStart);
  app.on("gestureend", handleGestureEnd);
  panel.on("panelDestroy", () => {
    app.off("touchstart:passive", handleTouchStart);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("gesturestart", handleGestureStart);
    app.off("gestureend", handleGestureEnd);
  });
}
var swipe_panel_default = swipePanel;

// node_modules/framework7/components/panel/resizable-panel.js
function resizablePanel(panel) {
  const app = panel.app;
  const support = getSupport();
  if (panel.resizableInitialized)
    return;
  extend(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = dom7_default("html");
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  if (!$el)
    return;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;
  let $viewEl;
  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;
  function transformCSSWidth(v) {
    if (!v)
      return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV))
      return null;
    return newV;
  }
  function isResizable() {
    return panel.resizable && $el.hasClass("panel-resizable");
  }
  function handleTouchStart(e) {
    if (!isResizable())
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    visibleByBreakpoint = $el.hasClass("panel-in-breakpoint");
  }
  function handleTouchMove(e) {
    if (!isTouched)
      return;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass("panel-resizing");
      $htmlEl.css("cursor", "col-resize");
      if (effect !== "cover" || visibleByBreakpoint) {
        $viewEl = dom7_default(panel.getViewEl());
        if (panel.$containerEl && panel.$containerEl.hasClass("page")) {
          $viewEl.add(panel.$containerEl.children(".page-content, .tabs, .fab"));
        }
      }
      if (effect !== "cover" && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newPanelWidth = side === "left" ? panelWidth + touchesDiff : panelWidth - touchesDiff;
    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }
    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);
    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;
    if (effect !== "cover" && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }
    $el.trigger("panel:resize", newPanelWidth);
    panel.emit("local::resize panelResize", panel, newPanelWidth);
  }
  function handleTouchEnd() {
    dom7_default("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = "";
    if (effect !== "cover" && !visibleByBreakpoint) {
      $viewEl.transform("");
      $backdropEl.transform("");
    }
    $el.removeClass("panel-resizing");
    nextFrame(() => {
      $el.transition("");
      if (effect !== "cover") {
        $backdropEl.transition("");
        if ($viewEl)
          $viewEl.transition("");
      }
    });
  }
  function handleResize() {
    if (!panel.opened || !panel.resizableWidth)
      return;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }
    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }
  if (panel.$el.find(".panel-resize-handler").length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }
  panel.$resizeHandlerEl = panel.$el.children(".panel-resize-handler");
  $el.addClass("panel-resizable");
  const passive = support.passiveListener ? {
    passive: true
  } : false;
  panel.$el.on(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("resize", handleResize);
  panel.on("beforeOpen", handleResize);
  panel.once("panelDestroy", () => {
    $el.removeClass("panel-resizable");
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("resize", handleResize);
    panel.off("beforeOpen", handleResize);
  });
}
var resizable_panel_default = resizablePanel;

// node_modules/framework7/components/panel/panel-class.js
var Panel = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    const extendedParams = extend({
      on: {}
    }, app.params.panel, params);
    super(extendedParams, [app]);
    const panel = this;
    panel.params = extendedParams;
    panel.$containerEl = panel.params.containerEl ? dom7_default(panel.params.containerEl).eq(0) : app.$el;
    panel.containerEl = panel.$containerEl[0];
    if (!panel.containerEl) {
      panel.$containerEl = app.$el;
      panel.containerEl = app.$el[0];
    }
    let $el;
    if (panel.params.el) {
      $el = dom7_default(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = dom7_default(panel.params.content).filter((node) => node.nodeType === 1).eq(0);
    }
    if ($el.length === 0)
      return panel;
    if ($el[0].f7Panel)
      return $el[0].f7Panel;
    $el[0].f7Panel = panel;
    let {
      side,
      effect,
      resizable
    } = panel.params;
    if (typeof side === "undefined")
      side = $el.hasClass("panel-left") ? "left" : "right";
    if (typeof effect === "undefined")
      effect = $el.hasClass("panel-cover") ? "cover" : $el.hasClass("panel-push") ? "push" : "reveal";
    if (typeof resizable === "undefined")
      resizable = $el.hasClass("panel-resizable");
    let $backdropEl;
    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = dom7_default(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = panel.$containerEl.children(".panel-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="panel-backdrop"></div>');
        panel.$containerEl.prepend($backdropEl);
      }
    }
    extend(panel, {
      app,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0]
    });
    panel.useModules();
    panel.init();
    return panel;
  }
  getViewEl() {
    const panel = this;
    let viewEl;
    if (panel.$containerEl.children(".views").length > 0) {
      viewEl = panel.$containerEl.children(".views")[0];
    } else {
      viewEl = panel.$containerEl.children(".view")[0];
    }
    return viewEl;
  }
  setStateClasses(state) {
    const panel = this;
    const {
      side,
      el
    } = panel;
    const viewEl = panel.getViewEl();
    const panelInView = viewEl && viewEl.contains(el);
    const $targetEl = !viewEl || panelInView ? panel.$containerEl : dom7_default("html");
    if (state === "open") {
      $targetEl.addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "before-closing") {
      $targetEl.addClass("with-panel-closing");
    }
    if (state === "closing") {
      $targetEl.addClass("with-panel-closing");
      $targetEl.removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "after-closing") {
      $targetEl.removeClass("with-panel-closing");
    }
    if (state === "closed") {
      $targetEl.removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel-${side}-push with-panel`);
    }
  }
  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }
  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }
  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }
  setVisibleBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };
      app.on("resize", panel.visibleBreakpointResizeHandler);
    }
    const {
      side,
      $el,
      $containerEl,
      params,
      visibleBreakpointDisabled
    } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = dom7_default(panel.getViewEl());
    const wasVisible = $el.hasClass("panel-in-breakpoint");
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs, .fab"));
    }
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed");
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::breakpoint panelBreakpoint", panel);
          panel.$el.trigger("panel:breakpoint");
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-breakpoint panel-in");
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: ""
      });
      if (emitEvents) {
        panel.emit("local::breakpoint panelBreakpoint", panel);
        panel.$el.trigger("panel:breakpoint");
      }
    }
  }
  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  setCollapsedBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };
      app.on("resize", panel.collapsedBreakpointResizeHandler);
    }
    const {
      $el,
      params,
      collapsedBreakpointDisabled
    } = panel;
    if ($el.hasClass("panel-in-breakpoint"))
      return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass("panel-in-collapsed");
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-collapsed").removeClass("panel-in");
        panel.collapsed = true;
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
          panel.$el.trigger("panel:collapsedbreakpoint");
        }
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-collapsed panel-in");
      panel.collapsed = false;
      if (emitEvents) {
        panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
        panel.$el.trigger("panel:collapsedbreakpoint");
      }
    }
  }
  enableResizable() {
    const panel = this;
    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass("panel-resizable");
    } else {
      resizable_panel_default(panel);
    }
    return panel;
  }
  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass("panel-resizable");
    return panel;
  }
  enableSwipe() {
    const panel = this;
    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      swipe_panel_default(panel);
    }
    return panel;
  }
  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }
  onOpen(modifyHtmlClasses) {
    if (modifyHtmlClasses === void 0) {
      modifyHtmlClasses = true;
    }
    const panel = this;
    panel._openTransitionStarted = false;
    const app = panel.app;
    panel.opened = true;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeopen");
    panel.emit("local::beforeOpen panelBeforeOpen", panel);
    if (modifyHtmlClasses) {
      panel.setStateClasses("open");
    }
    panel.$el.trigger("panel:open");
    panel.emit("local::open panelOpen", panel);
  }
  onOpened() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.$el.trigger("panel:opened");
    panel.emit("local::opened panelOpened", panel);
  }
  onClose() {
    const panel = this;
    const app = panel.app;
    panel.opened = false;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeclose");
    panel.emit("local::beforeClose panelBeforeClose", panel);
    panel.setStateClasses("closing");
    panel.$el.trigger("panel:close");
    panel.emit("local::close panelClose", panel);
  }
  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.setStateClasses("after-closing");
    panel.$el.removeClass("panel-out");
    if (panel.$backdropEl) {
      const otherPanel = app.panel.get(".panel-in");
      const shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;
      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass("panel-backdrop-in");
      }
    }
    panel.$el.trigger("panel:closed");
    panel.emit("local::closed panelClosed", panel);
  }
  toggle(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app = panel.app;
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }
    if (panel.opened)
      panel.close(animate);
    else
      panel.open(animate);
    return panel;
  }
  insertToRoot() {
    const panel = this;
    const document = getDocument();
    const {
      $el,
      $backdropEl,
      $containerEl
    } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;
    if (!$panelParentEl.is($containerEl) || $el.prevAll(".views, .view").length) {
      const $insertBeforeEl = $containerEl.children(".panel, .views, .view").eq(0);
      const $insertAfterEl = $containerEl.children(".panel-backdrop").eq(0);
      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        $containerEl.prepend($el);
      }
      if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0)) {
        $backdropEl.insertBefore($el);
      }
      panel.once("panelClosed", () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }
  open(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const app = panel.app;
    if (!app.panel.allowOpen)
      return false;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!$el || $el.hasClass("panel-in")) {
      return panel;
    }
    panel.insertToRoot();
    if (opened || $el.hasClass("panel-in-breakpoint") || $el.hasClass("panel-in"))
      return false;
    const otherOpenedPanel = app.panel.get(".panel-in");
    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate);
    }
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    $el.addClass("panel-in");
    if ($backdropEl) {
      $backdropEl.addClass("panel-backdrop-in");
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    if (panel.effect === "cover" || panel.effect === "push") {
      panel._clientLeft = $el[0].clientLeft;
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    function panelTransitionStart() {
      transitionEndTarget.transitionStart(() => {
        panel._openTransitionStarted = true;
      });
    }
    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if (dom7_default(e.target).is(transitionEndTarget)) {
          if ($el.hasClass("panel-out")) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else
          panelTransitionEnd();
      });
    }
    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
      }
      panelTransitionStart();
      panelTransitionEnd();
      $el.removeClass("panel-out not-animated").addClass("panel-in");
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("not-animated");
      }
      $el.removeClass("panel-out").addClass("panel-in not-animated");
      panel.onOpen();
      panel.onOpened();
    }
    return true;
  }
  close(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!opened || $el.hasClass("panel-in-breakpoint") || !$el.hasClass("panel-in"))
      return panel;
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    if ($backdropEl) {
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    if (!panel._openTransitionStarted) {
      animate = false;
    }
    function transitionEnd() {
      if ($el.hasClass("panel-out")) {
        panel.onClosed();
      } else if ($el.hasClass("panel-in")) {
        panel.onOpened();
      }
      panel.setStateClasses("after-closing");
    }
    if (animate) {
      transitionEndTarget.transitionEnd(() => {
        transitionEnd();
      });
      $el.removeClass("panel-in").addClass("panel-out");
      panel.onClose();
    } else {
      $el.addClass("not-animated").removeClass("panel-in").addClass("panel-out");
      panel.onClose();
      panel.onClosed();
    }
    return panel;
  }
  init() {
    const panel = this;
    if (typeof panel.params.visibleBreakpoint !== "undefined") {
      panel.setVisibleBreakpoint();
    }
    if (typeof panel.params.collapsedBreakpoint !== "undefined") {
      panel.setCollapsedBreakpoint();
    }
    if (panel.params.swipe) {
      panel.enableSwipe();
    }
    if (panel.resizable) {
      panel.enableResizable();
    }
  }
  destroy() {
    let panel = this;
    const app = panel.app;
    const {
      $containerEl
    } = panel;
    if (!panel.$el) {
      return;
    }
    panel.emit("local::beforeDestroy panelBeforeDestroy", panel);
    panel.$el.trigger("panel:beforedestroy");
    if (panel.visibleBreakpointResizeHandler) {
      app.off("resize", panel.visibleBreakpointResizeHandler);
    }
    if (panel.collapsedBreakpointResizeHandler) {
      app.off("resize", panel.collapsedBreakpointResizeHandler);
    }
    if (panel.$el.hasClass("panel-in-breakpoint") || panel.$el.hasClass("panel-in-collapsed")) {
      const $viewEl = dom7_default(panel.getViewEl());
      if ($containerEl && $containerEl.hasClass("page")) {
        $viewEl.add($containerEl.children(".page-content, .tabs"));
      }
      panel.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in");
      $viewEl.css({
        [`margin-${panel.side}`]: ""
      });
      panel.emit("local::breakpoint panelBreakpoint", panel);
      panel.$el.trigger("panel:breakpoint");
    }
    panel.$el.trigger("panel:destroy");
    panel.emit("local::destroy panelDestroy", panel);
    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }
    deleteProps(panel);
    panel = null;
  }
};
var panel_class_default = Panel;

// node_modules/framework7/components/panel/panel.js
var panel_default = {
  name: "panel",
  params: {
    panel: {
      opened: void 0,
      // default based on panel-in class
      side: void 0,
      // default based on panel class
      effect: void 0,
      // default based on panel class
      resizable: void 0,
      // default based on panel-resizable class
      backdrop: true,
      backdropEl: void 0,
      visibleBreakpoint: void 0,
      collapsedBreakpoint: void 0,
      swipe: false,
      // or true
      swipeNoFollow: false,
      // or true
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
      containerEl: void 0
    }
  },
  static: {
    Panel: panel_class_default
  },
  create() {
    const app = this;
    extend(app, {
      panel: {
        allowOpen: true,
        create(params) {
          return new panel_class_default(app, params);
        },
        get(el) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el instanceof panel_class_default)
            return el;
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          const $el = dom7_default(el);
          if ($el.length === 0 || $el.length > 1)
            return void 0;
          return $el[0].f7Panel;
        },
        destroy(el) {
          if (el === void 0) {
            el = ".panel";
          }
          const panel = app.panel.get(el);
          if (panel && panel.destroy)
            return panel.destroy();
          return void 0;
        },
        open(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.open(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.open(animate);
          }
          return void 0;
        },
        close(el, animate) {
          if (el === void 0) {
            el = ".panel-in";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.close(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.close(animate);
          }
          return void 0;
        },
        toggle(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.toggle)
            return panel.toggle(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.toggle(animate);
          }
          return void 0;
        }
      }
    });
  },
  on: {
    init() {
      const app = this;
      dom7_default(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      });
    }
  },
  vnode: {
    "panel-init": {
      insert(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      },
      destroy(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      }
    }
  },
  clicks: {
    ".panel-open": function open2(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.open(data.panel, data.animate);
    },
    ".panel-close": function close(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.close(data.panel, data.animate);
    },
    ".panel-toggle": function close2(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.toggle(data.panel, data.animate);
    },
    ".panel-backdrop": function close3() {
      const app = this;
      const $panelEl = dom7_default(".panel-in:not(.panel-out)");
      if (!$panelEl.length)
        return;
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger("panel:backdrop-click");
      if (instance) {
        instance.emit("backdropClick", instance);
      }
      app.emit("panelBackdropClick", instance || $panelEl[0]);
      if (instance && instance.params.closeByBackdropClick === false)
        return;
      if (app.params.panel.closeByBackdropClick)
        app.panel.close();
    }
  }
};

// node_modules/framework7/components/card/card.js
var CardExpandable = {
  open(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable";
    }
    if (animate === void 0) {
      animate = true;
    }
    const app = this;
    const device = getDevice();
    const document = getDocument();
    const support = getSupport();
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length)
      return;
    if ($cardEl.hasClass("card-opened") || $cardEl.hasClass("card-opening") || $cardEl.hasClass("card-closing"))
      return;
    const $pageEl = $cardEl.parents(".page").eq(0);
    if (!$pageEl.length)
      return;
    if ($pageEl.find(".card-opened").length) {
      return;
    }
    let prevented;
    function prevent() {
      prevented = true;
    }
    $cardEl.trigger("card:beforeopen", {
      prevent
    });
    app.emit("cardBeforeOpen", $cardEl[0], prevent);
    if (prevented)
      return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $pageContentEl = $cardEl.parents(".page-content");
    let $backdropEl;
    if ($cardEl.attr("data-backdrop-el")) {
      $backdropEl = dom7_default($cardEl.attr("data-backdrop-el"));
    }
    if (!$backdropEl && cardParams.backdrop) {
      $backdropEl = $pageContentEl.find(".card-backdrop");
      if (!$backdropEl.length) {
        $backdropEl = dom7_default('<div class="card-backdrop"></div>');
        $pageContentEl.append($backdropEl);
      }
    }
    let $navbarEl;
    let $toolbarEl;
    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children(".navbar");
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page)
          $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children(".toolbar");
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".view").children(".toolbar");
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".views").children(".toolbar");
      }
    }
    const currTransform = $cardEl.css("transform");
    let hasTransform;
    if (currTransform && currTransform.match(/[2-9]/)) {
      hasTransform = true;
    }
    const $cardContentEl = $cardEl.children(".card-content");
    const $cardSizeEl = dom7_default(document.createElement("div")).addClass("card-expandable-size");
    $cardEl.append($cardSizeEl);
    let cardWidth = $cardEl[0].offsetWidth;
    let cardHeight = $cardEl[0].offsetHeight;
    let pageWidth = $pageEl[0].offsetWidth;
    let pageHeight = $pageEl[0].offsetHeight;
    let maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
    let maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
    let statusbarHeight;
    if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
      statusbarHeight = parseInt($navbarEl.css("--f7-safe-area-top"), 10);
      if (Number.isNaN(statusbarHeight))
        statusbarHeight = 0;
    }
    if (statusbarHeight) {
      maxHeight -= statusbarHeight;
    }
    let scaleX = maxWidth / cardWidth;
    let scaleY = maxHeight / cardHeight;
    let offset = $cardEl.offset();
    let pageOffset = $pageEl.offset();
    if (statusbarHeight) {
      pageOffset.top += statusbarHeight / 2;
    }
    offset.left -= pageOffset.left;
    let cardLeftOffset;
    let cardTopOffset;
    if (hasTransform) {
      const transformValues = currTransform.replace(/matrix\(|\)/g, "").split(",").map((el) => el.trim());
      if (transformValues && transformValues.length > 1) {
        const scale = parseFloat(transformValues[0]);
        cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
        cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
        if (app.rtl)
          cardLeftOffset -= $cardEl[0].scrollLeft;
      } else {
        cardLeftOffset = $cardEl[0].offsetLeft;
        cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
      }
    } else {
      cardLeftOffset = offset.left;
      cardTopOffset = offset.top - pageOffset.top;
      if (app.rtl)
        cardLeftOffset -= $cardEl[0].scrollLeft;
    }
    cardLeftOffset -= (pageWidth - maxWidth) / 2;
    cardTopOffset -= (pageHeight - maxHeight) / 2;
    let cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
    if (app.rtl) {
      [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
    }
    let cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
    let translateX = (cardRightOffset - cardLeftOffset) / 2;
    let translateY = (cardBottomOffset - cardTopOffset) / 2;
    if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
      if ($navbarEl.closest(".navbar-hidden").length) {
        $cardEl[0].f7KeepNavbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepNavbarOnClose;
        app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen, true);
      }
    }
    if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
      if ($toolbarEl.closest(".toolbar-hidden").length) {
        $cardEl[0].f7KeepToolbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepToolbarOnClose;
        app.toolbar.hide($toolbarEl, cardParams.animate);
      }
    }
    if ($backdropEl) {
      $backdropEl.removeClass("card-backdrop-out").addClass("card-backdrop-in");
    }
    $cardEl.removeClass("card-transitioning");
    if (cardParams.animate) {
      $cardEl.addClass("card-opening");
    }
    $cardEl.trigger("card:open");
    app.emit("cardOpen", $cardEl[0]);
    function transitionEnd() {
      $pageEl.addClass("page-with-card-opened");
      if (device.ios && $pageContentEl.length) {
        $pageContentEl.css("height", `${$pageContentEl[0].offsetHeight + 1}px`);
        setTimeout(() => {
          $pageContentEl.css("height", "");
        });
      }
      $cardEl.addClass("card-opened");
      $cardEl.removeClass("card-opening");
      $cardEl.trigger("card:opened");
      app.emit("cardOpened", $cardEl[0], $pageEl[0]);
    }
    $cardContentEl.css({
      width: `${maxWidth}px`,
      height: `${maxHeight}px`
    }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
    if (cardParams.animate) {
      $cardEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }
    function onResize() {
      $cardEl.removeClass("card-transitioning");
      cardWidth = $cardEl[0].offsetWidth;
      cardHeight = $cardEl[0].offsetHeight;
      pageWidth = $pageEl[0].offsetWidth;
      pageHeight = $pageEl[0].offsetHeight;
      maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
      maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
      statusbarHeight = 0;
      if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
        statusbarHeight = parseInt($navbarEl.css("--f7-safe-area-top"), 10);
        if (Number.isNaN(statusbarHeight))
          statusbarHeight = 0;
      }
      if (statusbarHeight) {
        maxHeight -= statusbarHeight;
      }
      scaleX = maxWidth / cardWidth;
      scaleY = maxHeight / cardHeight;
      $cardEl.transform("translate3d(0px, 0px, 0) scale(1)");
      offset = $cardEl.offset();
      pageOffset = $pageEl.offset();
      if (statusbarHeight) {
        pageOffset.top += statusbarHeight / 2;
      }
      offset.left -= pageOffset.left;
      offset.top -= pageOffset.top;
      cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
      if (app.rtl)
        cardLeftOffset -= $cardEl[0].scrollLeft;
      cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;
      cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
      cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
      if (app.rtl) {
        [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
      }
      translateX = (cardRightOffset - cardLeftOffset) / 2;
      translateY = (cardBottomOffset - cardTopOffset) / 2;
      $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      $cardContentEl.css({
        width: `${maxWidth}px`,
        height: `${maxHeight}px`
      }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    }
    let cardScrollTop;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchEndX;
    let touchEndY;
    let isScrolling;
    let progress;
    let isV;
    let isH;
    let $cardScrollableEl;
    function onTouchStart(e) {
      if (!dom7_default(e.target).closest($cardEl).length)
        return;
      if (!$cardEl.hasClass("card-opened"))
        return;
      $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
      if ($cardScrollableEl[0] && $cardScrollableEl[0] !== $cardContentEl[0] && !$cardScrollableEl[0].contains(e.target)) {
        cardScrollTop = 0;
      } else {
        cardScrollTop = $cardScrollableEl.scrollTop();
      }
      isTouched = true;
      touchStartX = e.targetTouches[0].pageX;
      touchStartY = e.targetTouches[0].pageY;
      isScrolling = void 0;
      isV = false;
      isH = false;
    }
    function onTouchMove(e) {
      if (!isTouched)
        return;
      touchEndX = e.targetTouches[0].pageX;
      touchEndY = e.targetTouches[0].pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
      }
      if (!isH && !isV) {
        if (!isScrolling && e.targetTouches[0].clientX <= 50) {
          isH = true;
        } else {
          isV = true;
        }
      }
      if (!(isH || isV) || isV && cardScrollTop !== 0) {
        isTouched = true;
        isMoved = true;
        return;
      }
      if (!isMoved) {
        $cardEl.removeClass("card-transitioning");
      }
      isMoved = true;
      progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);
      if (progress > 0 && isV || isH) {
        if (isV && device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
          $cardScrollableEl.css("-webkit-overflow-scrolling", "auto");
          $cardScrollableEl.scrollTop(0);
        }
        e.preventDefault();
      }
      if (progress > 1)
        progress **= 0.3;
      if (progress > (isV ? 1.3 : 1.1)) {
        isTouched = false;
        isMoved = false;
        app.card.close($cardEl);
      } else {
        $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX * (1 - progress * 0.2)}, ${scaleY * (1 - progress * 0.2)})`);
      }
    }
    function onTouchEnd() {
      if (!isTouched || !isMoved)
        return;
      isTouched = false;
      isMoved = false;
      if (device.ios) {
        $cardScrollableEl.css("-webkit-overflow-scrolling", "");
      }
      if (progress >= 0.8) {
        app.card.close($cardEl);
      } else {
        $cardEl.addClass("card-transitioning").transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      }
    }
    $cardEl[0].detachEventHandlers = function detachEventHandlers() {
      app.off("resize", onResize);
      if (support.touch && cardParams.swipeToClose) {
        app.off("touchstart:passive", onTouchStart);
        app.off("touchmove:active", onTouchMove);
        app.off("touchend:passive", onTouchEnd);
      }
    };
    app.on("resize", onResize);
    if (support.touch && cardParams.swipeToClose) {
      app.on("touchstart:passive", onTouchStart);
      app.on("touchmove:active", onTouchMove);
      app.on("touchend:passive", onTouchEnd);
    }
  },
  close(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable.card-opened";
    }
    if (animate === void 0) {
      animate = true;
    }
    const app = this;
    const device = getDevice();
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length)
      return;
    if (!$cardEl.hasClass("card-opened") || $cardEl.hasClass("card-opening") || $cardEl.hasClass("card-closing"))
      return;
    const $cardContentEl = $cardEl.children(".card-content");
    const $pageContentEl = $cardEl.parents(".page-content");
    const $pageEl = $cardEl.parents(".page").eq(0);
    if (!$pageEl.length)
      return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
    let $navbarEl;
    let $toolbarEl;
    let $backdropEl;
    if ($cardEl.attr("data-backdrop-el")) {
      $backdropEl = dom7_default($cardEl.attr("data-backdrop-el"));
    }
    if (cardParams.backdrop) {
      $backdropEl = $cardEl.parents(".page-content").find(".card-backdrop");
    }
    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children(".navbar");
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page)
          $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
      if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
        app.navbar.show($navbarEl, cardParams.animate, true);
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children(".toolbar");
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".view").children(".toolbar");
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".views").children(".toolbar");
      }
      if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
        app.toolbar.show($toolbarEl, cardParams.animate);
      }
    }
    $pageEl.removeClass("page-with-card-opened");
    if (device.ios && $pageContentEl.length) {
      $pageContentEl.css("height", `${$pageContentEl[0].offsetHeight + 1}px`);
      setTimeout(() => {
        $pageContentEl.css("height", "");
      });
    }
    if ($backdropEl && $backdropEl.length) {
      $backdropEl.removeClass("card-backdrop-in").addClass("card-backdrop-out");
    }
    $cardEl.removeClass("card-opened card-transitioning");
    if (cardParams.animate) {
      $cardEl.addClass("card-closing");
    } else {
      $cardEl.addClass("card-no-transition");
    }
    $cardEl.transform("");
    $cardEl.trigger("card:close");
    app.emit("cardClose", $cardEl[0], $pageEl[0]);
    const animateWidth = $cardEl.hasClass("card-expandable-animate-width");
    function transitionEnd() {
      if (!animateWidth) {
        $cardContentEl.css({
          width: "",
          height: ""
        });
      }
      if ($backdropEl && $backdropEl.length) {
        $backdropEl.removeClass("card-backdrop-in card-backdrop-out");
      }
      $cardEl.removeClass("card-closing card-no-transition");
      $cardEl.trigger("card:closed");
      $cardEl.find(".card-expandable-size").remove();
      app.emit("cardClosed", $cardEl[0], $pageEl[0]);
    }
    if (animateWidth) {
      $cardContentEl.css({
        width: "",
        height: ""
      });
    }
    $cardContentEl.transform("").scrollTop(0, animate ? 300 : 0);
    if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
      $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
    }
    if (animate) {
      $cardContentEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }
    if ($cardEl[0].detachEventHandlers) {
      $cardEl[0].detachEventHandlers();
      delete $cardEl[0].detachEventHandlers;
    }
  },
  toggle(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable";
    }
    const app = this;
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl.length)
      return;
    if ($cardEl.hasClass("card-opened")) {
      app.card.close($cardEl, animate);
    } else {
      app.card.open($cardEl, animate);
    }
  }
};
var card_default = {
  name: "card",
  params: {
    card: {
      hideNavbarOnOpen: true,
      hideStatusbarOnOpen: true,
      hideToolbarOnOpen: true,
      scrollableEl: ".card-content",
      swipeToClose: true,
      closeByBackdropClick: true,
      backdrop: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      card: CardExpandable
    });
  },
  on: {
    pageBeforeIn(page) {
      const app = this;
      if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find(".card-opened.card-expandable").length) {
        app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen, true);
      }
      if (app.params.card.hideToolbarOnOpen && page.$el.find(".card-opened.card-expandable").length) {
        let $toolbarEl = page.$el.children(".toolbar");
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents(".view").children(".toolbar");
        }
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents(".views").children(".toolbar");
        }
        if ($toolbarEl && $toolbarEl.length) {
          app.toolbar.hide($toolbarEl);
        }
      }
    }
  },
  clicks: {
    ".card-close": function closeCard($clickedEl, data) {
      const app = this;
      app.card.close(data.card, data.animate);
    },
    ".card-open": function closeCard2($clickedEl, data) {
      const app = this;
      app.card.open(data.card, data.animate);
    },
    ".card-expandable": function toggleExpandableCard($clickedEl, data, e) {
      const app = this;
      if ($clickedEl.hasClass("card-opened") || $clickedEl.hasClass("card-opening") || $clickedEl.hasClass("card-closing"))
        return;
      if (dom7_default(e.target).closest(".card-prevent-open, .card-close").length)
        return;
      app.card.open($clickedEl);
    },
    ".card-backdrop-in": function onBackdropClick() {
      const app = this;
      let needToClose = false;
      if (app.params.card.closeByBackdropClick)
        needToClose = true;
      const $openedCardEl = dom7_default(".card-opened");
      if (!$openedCardEl.length)
        return;
      if ($openedCardEl.attr("data-close-by-backdrop-click") === "true") {
        needToClose = true;
      } else if ($openedCardEl.attr("data-close-by-backdrop-click") === "false") {
        needToClose = false;
      }
      if (needToClose)
        app.card.close($openedCardEl);
    }
  }
};

// node_modules/framework7/components/chip/chip.js
var chip_default = {
  name: "chip"
};

// node_modules/framework7/components/form/form.js
var FormData = {
  store(form, data) {
    const app = this;
    const window = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    app.form.data[`form-${formId}`] = data;
    window.localStorage[`f7form-${formId}`] = JSON.stringify(data);
  },
  get(form) {
    const app = this;
    const window = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    if (window.localStorage[`f7form-${formId}`]) {
      return JSON.parse(window.localStorage[`f7form-${formId}`]);
    }
    if (app.form.data[`form-${formId}`]) {
      return app.form.data[`form-${formId}`];
    }
    return void 0;
  },
  remove(form) {
    const app = this;
    const window = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    if (app.form.data[`form-${formId}`]) {
      app.form.data[`form-${formId}`] = "";
      delete app.form.data[`form-${formId}`];
    }
    if (window.localStorage[`f7form-${formId}`]) {
      window.localStorage[`f7form-${formId}`] = "";
      window.localStorage.removeItem(`f7form-${formId}`);
    }
  }
};
var FormStorage = {
  init(formEl) {
    const app = this;
    const $formEl = dom7_default(formEl);
    const formId = $formEl.attr("id");
    if (!formId)
      return;
    const initialData = app.form.getFormData(formId);
    if (initialData) {
      app.form.fillFromData($formEl, initialData);
    }
    function store() {
      const data = app.form.convertToData($formEl);
      if (!data)
        return;
      app.form.storeFormData(formId, data);
      $formEl.trigger("form:storedata", data);
      app.emit("formStoreData", $formEl[0], data);
    }
    $formEl.on("change submit", store);
  },
  destroy(formEl) {
    const $formEl = dom7_default(formEl);
    $formEl.off("change submit");
  }
};
function formToData(formEl) {
  const app = this;
  const $formEl = dom7_default(formEl).eq(0);
  if ($formEl.length === 0)
    return void 0;
  const data = {};
  const skipTypes = ["submit", "image", "button", "file"];
  const skipNames = [];
  $formEl.find("input, select, textarea").each((inputEl) => {
    const $inputEl = dom7_default(inputEl);
    if ($inputEl.hasClass("ignore-store-data") || $inputEl.hasClass("no-store-data")) {
      return;
    }
    const name = $inputEl.attr("name");
    const type = $inputEl.attr("type");
    const tag = inputEl.nodeName.toLowerCase();
    if (skipTypes.indexOf(type) >= 0)
      return;
    if (skipNames.indexOf(name) >= 0 || !name)
      return;
    if (tag === "select" && $inputEl.prop("multiple")) {
      skipNames.push(name);
      data[name] = [];
      $formEl.find(`select[name="${name}"] option`).each((el) => {
        if (el.selected)
          data[name].push(el.value);
      });
    } else {
      switch (type) {
        case "checkbox":
          skipNames.push(name);
          data[name] = [];
          $formEl.find(`input[name="${name}"]`).each((el) => {
            if (el.checked)
              data[name].push(el.value);
          });
          break;
        case "radio":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            if (el.checked)
              data[name] = el.value;
          });
          break;
        default:
          data[name] = $inputEl.val();
          break;
      }
    }
  });
  $formEl.trigger("form:todata", data);
  app.emit("formToData", $formEl[0], data);
  return data;
}
function formFromData(formEl, formData) {
  const app = this;
  const $formEl = dom7_default(formEl).eq(0);
  if (!$formEl.length)
    return;
  let data = formData;
  const formId = $formEl.attr("id");
  if (!data && formId) {
    data = app.form.getFormData(formId);
  }
  if (!data)
    return;
  const skipTypes = ["submit", "image", "button", "file"];
  const skipNames = [];
  $formEl.find("input, select, textarea").each((inputEl) => {
    const $inputEl = dom7_default(inputEl);
    if ($inputEl.hasClass("ignore-store-data") || $inputEl.hasClass("no-store-data")) {
      return;
    }
    const name = $inputEl.attr("name");
    const type = $inputEl.attr("type");
    const tag = inputEl.nodeName.toLowerCase();
    if (typeof data[name] === "undefined" || data[name] === null)
      return;
    if (skipTypes.indexOf(type) >= 0)
      return;
    if (skipNames.indexOf(name) >= 0 || !name)
      return;
    if (tag === "select" && $inputEl.prop("multiple")) {
      skipNames.push(name);
      $formEl.find(`select[name="${name}"] option`).each((el) => {
        const selectEl = el;
        if (data[name].indexOf(el.value) >= 0)
          selectEl.selected = true;
        else
          selectEl.selected = false;
      });
    } else {
      switch (type) {
        case "checkbox":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            const checkboxEl = el;
            if (data[name].indexOf(el.value) >= 0)
              checkboxEl.checked = true;
            else
              checkboxEl.checked = false;
          });
          break;
        case "radio":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            const radioEl = el;
            if (data[name] === el.value)
              radioEl.checked = true;
            else
              radioEl.checked = false;
          });
          break;
        default:
          $inputEl.val(data[name]);
          break;
      }
    }
    if (tag === "select" || tag === "input" || tag === "textarea") {
      $inputEl.trigger("change", "fromdata");
    }
  });
  $formEl.trigger("form:fromdata", data);
  app.emit("formFromData", $formEl[0], data);
}
function initAjaxForm() {
  const app = this;
  const window = getWindow();
  const document = getDocument();
  function onSubmitChange(e, fromData) {
    const $formEl = dom7_default(this);
    if (e.type === "change" && !$formEl.hasClass("form-ajax-submit-onchange"))
      return;
    if (e.type === "submit")
      e.preventDefault();
    if (e.type === "change" && fromData === "fromdata")
      return;
    const method = ($formEl.attr("method") || "GET").toUpperCase();
    const contentType = $formEl.prop("enctype") || $formEl.attr("enctype");
    const url = $formEl.attr("action");
    if (!url)
      return;
    let data;
    if (method === "POST") {
      if (contentType === "application/x-www-form-urlencoded") {
        data = app.form.convertToData($formEl[0]);
      } else {
        data = new window.FormData($formEl[0]);
      }
    } else {
      data = serializeObject(app.form.convertToData($formEl[0]));
    }
    app.request({
      method,
      url,
      contentType,
      data,
      beforeSend(xhr) {
        $formEl.trigger("formajax:beforesend", {
          data,
          xhr
        });
        app.emit("formAjaxBeforeSend", $formEl[0], data, xhr);
      },
      error(xhr) {
        $formEl.trigger("formajax:error", {
          data,
          xhr
        });
        app.emit("formAjaxError", $formEl[0], data, xhr);
      },
      complete(xhr) {
        $formEl.trigger("formajax:complete", {
          data,
          xhr
        });
        app.emit("formAjaxComplete", $formEl[0], data, xhr);
      },
      success(response, status, xhr) {
        $formEl.trigger("formajax:success", {
          data,
          xhr
        });
        app.emit("formAjaxSuccess", $formEl[0], data, xhr);
      }
    });
  }
  dom7_default(document).on("submit change", "form.form-ajax-submit, form.form-ajax-submit-onchange", onSubmitChange);
}
var form_default = {
  name: "form",
  create() {
    const app = this;
    extend(app, {
      form: {
        data: {},
        storeFormData: FormData.store.bind(app),
        getFormData: FormData.get.bind(app),
        removeFormData: FormData.remove.bind(app),
        convertToData: formToData.bind(app),
        fillFromData: formFromData.bind(app),
        storage: {
          init: FormStorage.init.bind(app),
          destroy: FormStorage.destroy.bind(app)
        }
      }
    });
  },
  on: {
    init() {
      const app = this;
      initAjaxForm.call(app);
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".form-store-data").each((formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".form-store-data").each((formEl) => {
        app.form.storage.init(formEl);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".form-store-data").each((formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".form-store-data").each((formEl) => {
        app.form.storage.init(formEl);
      });
    }
  }
};

// node_modules/framework7/components/input/input.js
var Input = {
  ignoreTypes: ["checkbox", "button", "submit", "range", "radio", "image"],
  createTextareaResizableShadow() {
    const document = getDocument();
    const $shadowEl = dom7_default(document.createElement("textarea"));
    $shadowEl.addClass("textarea-resizable-shadow");
    $shadowEl.prop({
      disabled: true,
      readonly: true
    });
    Input.textareaResizableShadow = $shadowEl;
  },
  textareaResizableShadow: void 0,
  resizeTextarea(textareaEl) {
    const app = this;
    const window = getWindow();
    const $textareaEl = dom7_default(textareaEl);
    if (!Input.textareaResizableShadow) {
      Input.createTextareaResizableShadow();
    }
    const $shadowEl = Input.textareaResizableShadow;
    if (!$textareaEl.length)
      return;
    if (!$textareaEl.hasClass("resizable"))
      return;
    if (Input.textareaResizableShadow.parents().length === 0) {
      app.$el.append($shadowEl);
    }
    const styles = window.getComputedStyle($textareaEl[0]);
    "padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display".split(" ").forEach((style) => {
      let styleValue = styles[style];
      if ("font-size line-height letter-spacing width".split(" ").indexOf(style) >= 0) {
        styleValue = styleValue.replace(",", ".");
      }
      $shadowEl.css(style, styleValue);
    });
    const currentHeight = $textareaEl[0].clientHeight;
    $shadowEl.val("");
    const initialHeight = $shadowEl[0].scrollHeight;
    $shadowEl.val($textareaEl.val());
    $shadowEl.css("height", 0);
    const scrollHeight = $shadowEl[0].scrollHeight;
    if (currentHeight !== scrollHeight) {
      if (scrollHeight > initialHeight) {
        $textareaEl.css("height", `${scrollHeight}px`);
      } else if (scrollHeight < currentHeight) {
        $textareaEl.css("height", "");
      }
      if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
        $textareaEl.trigger("textarea:resize", {
          initialHeight,
          currentHeight,
          scrollHeight
        });
        app.emit("textareaResize", {
          initialHeight,
          currentHeight,
          scrollHeight
        });
      }
    }
  },
  validate(inputEl) {
    const $inputEl = dom7_default(inputEl);
    if (!$inputEl.length)
      return true;
    const $itemInputEl = $inputEl.parents(".item-input");
    const $inputWrapEl = $inputEl.parents(".input");
    function unsetReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = false;
      }
    }
    function setReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = true;
      }
    }
    unsetReadonly();
    const validity = $inputEl[0].validity;
    const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || "";
    if (!validity) {
      setReadonly();
      return true;
    }
    if (!validity.valid) {
      let $errorEl = $inputEl.nextAll(".item-input-error-message, .input-error-message");
      if (validationMessage) {
        if ($errorEl.length === 0) {
          $errorEl = dom7_default(`<div class="${$inputWrapEl.length ? "input-error-message" : "item-input-error-message"}"></div>`);
          $errorEl.insertAfter($inputEl);
        }
        $errorEl.text(validationMessage);
      }
      if ($errorEl.length > 0) {
        $itemInputEl.addClass("item-input-with-error-message");
        $inputWrapEl.addClass("input-with-error-message");
      }
      $itemInputEl.addClass("item-input-invalid");
      $inputWrapEl.addClass("input-invalid");
      $inputEl.addClass("input-invalid");
      setReadonly();
      return false;
    }
    $itemInputEl.removeClass("item-input-invalid item-input-with-error-message");
    $inputWrapEl.removeClass("input-invalid input-with-error-message");
    $inputEl.removeClass("input-invalid");
    setReadonly();
    return true;
  },
  validateInputs(el) {
    const app = this;
    const validates = dom7_default(el).find("input, textarea, select").map((inputEl) => app.input.validate(inputEl));
    return validates.indexOf(false) < 0;
  },
  focus(inputEl) {
    const $inputEl = dom7_default(inputEl);
    const type = $inputEl.attr("type");
    if (Input.ignoreTypes.indexOf(type) >= 0)
      return;
    $inputEl.parents(".item-input").addClass("item-input-focused");
    $inputEl.parents(".input").addClass("input-focused");
    $inputEl.addClass("input-focused");
  },
  blur(inputEl) {
    const $inputEl = dom7_default(inputEl);
    $inputEl.parents(".item-input").removeClass("item-input-focused");
    $inputEl.parents(".input").removeClass("input-focused");
    $inputEl.removeClass("input-focused");
  },
  checkEmptyState(inputEl) {
    const app = this;
    let $inputEl = dom7_default(inputEl);
    if (!$inputEl.is("input, select, textarea, .item-input [contenteditable]")) {
      $inputEl = $inputEl.find("input, select, textarea, .item-input [contenteditable]").eq(0);
    }
    if (!$inputEl.length)
      return;
    const isContentEditable = $inputEl[0].hasAttribute("contenteditable");
    let value;
    if (isContentEditable) {
      if ($inputEl.find(".text-editor-placeholder").length)
        value = "";
      else
        value = $inputEl.html();
    } else {
      value = $inputEl.val();
    }
    const $itemInputEl = $inputEl.parents(".item-input");
    const $inputWrapEl = $inputEl.parents(".input");
    if (value && typeof value === "string" && value.trim() !== "" || Array.isArray(value) && value.length > 0) {
      $itemInputEl.addClass("item-input-with-value");
      $inputWrapEl.addClass("input-with-value");
      $inputEl.addClass("input-with-value");
      $inputEl.trigger("input:notempty");
      app.emit("inputNotEmpty", $inputEl[0]);
    } else {
      $itemInputEl.removeClass("item-input-with-value");
      $inputWrapEl.removeClass("input-with-value");
      $inputEl.removeClass("input-with-value");
      $inputEl.trigger("input:empty");
      app.emit("inputEmpty", $inputEl[0]);
    }
  },
  scrollIntoView(inputEl, duration, centered, force) {
    if (duration === void 0) {
      duration = 0;
    }
    const $inputEl = dom7_default(inputEl);
    const $scrollableEl = $inputEl.parents(".page-content, .panel, .card-expandable .card-content").eq(0);
    if (!$scrollableEl.length) {
      return false;
    }
    const contentHeight = $scrollableEl[0].offsetHeight;
    const contentScrollTop = $scrollableEl[0].scrollTop;
    const contentPaddingTop = parseInt($scrollableEl.css("padding-top"), 10);
    const contentPaddingBottom = parseInt($scrollableEl.css("padding-bottom"), 10);
    const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;
    const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
    const inputHeight = $inputEl[0].offsetHeight;
    const min = inputOffsetTop + contentScrollTop - contentPaddingTop;
    const max = inputOffsetTop + contentScrollTop - contentHeight + contentPaddingBottom + inputHeight;
    const centeredPosition = min + (max - min) / 2;
    if (contentScrollTop > min) {
      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
      return true;
    }
    if (contentScrollTop < max) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      return true;
    }
    if (force) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
    }
    return false;
  },
  init() {
    const app = this;
    const device = getDevice();
    const window = getWindow();
    const document = getDocument();
    Input.createTextareaResizableShadow();
    function onFocus() {
      const inputEl = this;
      if (app.params.input.scrollIntoViewOnFocus) {
        if (device.android) {
          dom7_default(window).once("resize", () => {
            if (document && document.activeElement === inputEl) {
              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
            }
          });
        } else {
          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
        }
      }
      app.input.focus(inputEl);
    }
    function onBlur() {
      const $inputEl = dom7_default(this);
      const tag = $inputEl[0].nodeName.toLowerCase();
      app.input.blur($inputEl);
      if ($inputEl.dataset().validate || $inputEl.attr("validate") !== null || $inputEl.attr("data-validate-on-blur") !== null) {
        app.input.validate($inputEl);
      }
      if (tag === "textarea" && $inputEl.hasClass("resizable")) {
        if (Input.textareaResizableShadow)
          Input.textareaResizableShadow.remove();
      }
    }
    function onChange() {
      const $inputEl = dom7_default(this);
      const type = $inputEl.attr("type");
      const tag = $inputEl[0].nodeName.toLowerCase();
      const isContentEditable = $inputEl[0].hasAttribute("contenteditable");
      if (Input.ignoreTypes.indexOf(type) >= 0)
        return;
      app.input.checkEmptyState($inputEl);
      if (isContentEditable)
        return;
      if ($inputEl.attr("data-validate-on-blur") === null && ($inputEl.dataset().validate || $inputEl.attr("validate") !== null)) {
        app.input.validate($inputEl);
      }
      if (tag === "textarea" && $inputEl.hasClass("resizable")) {
        app.input.resizeTextarea($inputEl);
      }
    }
    function onInvalid(e) {
      const $inputEl = dom7_default(this);
      if ($inputEl.attr("data-validate-on-blur") === null && ($inputEl.dataset().validate || $inputEl.attr("validate") !== null)) {
        e.preventDefault();
        app.input.validate($inputEl);
      }
    }
    function clearInput() {
      const $clicked = dom7_default(this);
      const $inputEl = $clicked.siblings("input, textarea").eq(0);
      const previousValue = $inputEl.val();
      $inputEl.val("").trigger("input change").focus().trigger("input:clear", previousValue);
      app.emit("inputClear", previousValue);
    }
    function preventDefault(e) {
      e.preventDefault();
    }
    dom7_default(document).on("click", ".input-clear-button", clearInput);
    dom7_default(document).on("mousedown", ".input-clear-button", preventDefault);
    dom7_default(document).on("change input", "input, textarea, select, .item-input [contenteditable]", onChange, true);
    dom7_default(document).on("focus", "input, textarea, select, .item-input [contenteditable]", onFocus, true);
    dom7_default(document).on("blur", "input, textarea, select, .item-input [contenteditable]", onBlur, true);
    dom7_default(document).on("invalid", "input, textarea, select", onInvalid, true);
  }
};
var input_default = {
  name: "input",
  params: {
    input: {
      scrollIntoViewOnFocus: void 0,
      scrollIntoViewCentered: false,
      scrollIntoViewDuration: 0,
      scrollIntoViewAlways: false
    }
  },
  create() {
    const app = this;
    if (typeof app.params.input.scrollIntoViewOnFocus === "undefined") {
      app.params.input.scrollIntoViewOnFocus = getDevice().android;
    }
    bindMethods(app, {
      input: Input
    });
  },
  on: {
    init() {
      const app = this;
      app.input.init();
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      $tabEl.find(".item-input, .input").each((itemInputEl) => {
        const $itemInputEl = dom7_default(itemInputEl);
        $itemInputEl.find("input, select, textarea, [contenteditable]").each((inputEl) => {
          const $inputEl = dom7_default(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr("type")) >= 0)
            return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $tabEl.find("textarea.resizable").each((textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    pageInit(page) {
      const app = this;
      const $pageEl = page.$el;
      $pageEl.find(".item-input, .input").each((itemInputEl) => {
        const $itemInputEl = dom7_default(itemInputEl);
        $itemInputEl.find("input, select, textarea, [contenteditable]").each((inputEl) => {
          const $inputEl = dom7_default(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr("type")) >= 0)
            return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $pageEl.find("textarea.resizable").each((textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    "panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint": function onPanelOpen(instance) {
      const app = this;
      if (instance && instance.$el) {
        instance.$el.find("textarea.resizable").each((textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      } else {
        dom7_default("textarea.resizable").each((textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      }
    }
  }
};

// node_modules/framework7/components/checkbox/checkbox.js
var checkbox_default = {
  name: "checkbox"
};

// node_modules/framework7/components/radio/radio.js
var radio_default = {
  name: "radio"
};

// node_modules/framework7/components/toggle/toggle-class.js
var Toggle = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const toggle5 = this;
    const support = getSupport();
    const defaults = {};
    toggle5.useModulesParams(defaults);
    toggle5.params = extend(defaults, params);
    const el = toggle5.params.el;
    if (!el)
      return toggle5;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return toggle5;
    if ($el[0].f7Toggle)
      return $el[0].f7Toggle;
    const $inputEl = $el.children('input[type="checkbox"]');
    extend(toggle5, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl[0],
      disabled: $el.hasClass("disabled") || $inputEl.hasClass("disabled") || $inputEl.attr("disabled") || $inputEl[0].disabled
    });
    Object.defineProperty(toggle5, "checked", {
      enumerable: true,
      configurable: true,
      set(checked) {
        if (!toggle5 || typeof toggle5.$inputEl === "undefined")
          return;
        if (toggle5.checked === checked)
          return;
        $inputEl[0].checked = checked;
        toggle5.$inputEl.trigger("change");
      },
      get() {
        return $inputEl[0].checked;
      }
    });
    $el[0].f7Toggle = toggle5;
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let toggleWidth;
    let touchStartTime;
    let touchStartChecked;
    function handleTouchStart(e) {
      if (isTouched || toggle5.disabled)
        return;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchesDiff = 0;
      isTouched = true;
      isScrolling = void 0;
      touchStartTime = now();
      touchStartChecked = toggle5.checked;
      toggleWidth = $el[0].offsetWidth;
      nextTick(() => {
        if (isTouched) {
          $el.addClass("toggle-active-state");
        }
      });
    }
    function handleTouchMove(e) {
      if (!isTouched || toggle5.disabled)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      const inverter = app.rtl ? -1 : 1;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      touchesDiff = pageX - touchesStart.x;
      let changed;
      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
        changed = true;
      }
      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
        changed = true;
      }
      if (changed) {
        touchesStart.x = pageX;
        toggle5.checked = !touchStartChecked;
        touchStartChecked = !touchStartChecked;
      }
    }
    function handleTouchEnd() {
      if (!isTouched || toggle5.disabled) {
        if (isScrolling)
          $el.removeClass("toggle-active-state");
        isTouched = false;
        return;
      }
      const inverter = app.rtl ? -1 : 1;
      isTouched = false;
      $el.removeClass("toggle-active-state");
      let changed;
      if (now() - touchStartTime < 300) {
        if (touchesDiff * inverter < 0 && touchStartChecked) {
          changed = true;
        }
        if (touchesDiff * inverter > 0 && !touchStartChecked) {
          changed = true;
        }
        if (changed) {
          toggle5.checked = !touchStartChecked;
        }
      }
    }
    function handleInputChange() {
      toggle5.$el.trigger("toggle:change");
      toggle5.emit("local::change toggleChange", toggle5);
    }
    toggle5.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      toggle5.$inputEl.on("change", handleInputChange);
    };
    toggle5.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      toggle5.$inputEl.off("change", handleInputChange);
    };
    toggle5.useModules();
    toggle5.init();
  }
  toggle() {
    const toggle5 = this;
    toggle5.checked = !toggle5.checked;
  }
  init() {
    const toggle5 = this;
    toggle5.attachEvents();
  }
  destroy() {
    let toggle5 = this;
    toggle5.$el.trigger("toggle:beforedestroy");
    toggle5.emit("local::beforeDestroy toggleBeforeDestroy", toggle5);
    delete toggle5.$el[0].f7Toggle;
    toggle5.detachEvents();
    deleteProps(toggle5);
    toggle5 = null;
  }
};
var toggle_class_default = Toggle;

// node_modules/framework7/components/toggle/toggle.js
var toggle_default = {
  name: "toggle",
  create() {
    const app = this;
    app.toggle = ConstructorMethods({
      defaultSelector: ".toggle",
      constructor: toggle_class_default,
      app,
      domProp: "f7Toggle"
    });
  },
  static: {
    Toggle: toggle_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".toggle-init").each((toggleEl) => app.toggle.create({
        el: toggleEl
      }));
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".toggle-init").each((toggleEl) => {
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".toggle-init").each((toggleEl) => app.toggle.create({
        el: toggleEl
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find(".toggle-init").each((toggleEl) => {
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      });
    }
  },
  vnode: {
    "toggle-init": {
      insert(vnode) {
        const app = this;
        const toggleEl = vnode.elm;
        app.toggle.create({
          el: toggleEl
        });
      },
      destroy(vnode) {
        const toggleEl = vnode.elm;
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      }
    }
  }
};

// node_modules/framework7/components/range/range-class.js
var Range = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const range = this;
    const support = getSupport();
    const defaults = {
      el: null,
      inputEl: null,
      dual: false,
      step: 1,
      label: false,
      min: 0,
      max: 100,
      value: 0,
      draggableBar: true,
      vertical: false,
      verticalReversed: false,
      formatLabel: null,
      scale: false,
      scaleSteps: 5,
      scaleSubSteps: 0,
      formatScaleLabel: null,
      limitKnobPosition: app.theme === "ios"
    };
    range.useModulesParams(defaults);
    range.params = extend(defaults, params);
    const el = range.params.el;
    if (!el)
      return range;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return range;
    if ($el[0].f7Range)
      return $el[0].f7Range;
    const dataset = $el.dataset();
    "step min max value scaleSteps scaleSubSteps".split(" ").forEach((paramName) => {
      if (typeof params[paramName] === "undefined" && typeof dataset[paramName] !== "undefined") {
        range.params[paramName] = parseFloat(dataset[paramName]);
      }
    });
    "dual label vertical verticalReversed scale".split(" ").forEach((paramName) => {
      if (typeof params[paramName] === "undefined" && typeof dataset[paramName] !== "undefined") {
        range.params[paramName] = dataset[paramName];
      }
    });
    if (!range.params.value) {
      if (typeof dataset.value !== "undefined")
        range.params.value = dataset.value;
      if (typeof dataset.valueLeft !== "undefined" && typeof dataset.valueRight !== "undefined") {
        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
      }
    }
    let $inputEl;
    if (!range.params.dual) {
      if (range.params.inputEl) {
        $inputEl = dom7_default(range.params.inputEl);
      } else if ($el.find('input[type="range"]').length) {
        $inputEl = $el.find('input[type="range"]').eq(0);
      }
    }
    const {
      dual,
      step,
      label,
      min,
      max,
      value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    } = range.params;
    extend(range, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : void 0,
      dual,
      step,
      label,
      min,
      max,
      value,
      previousValue: value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    });
    if ($inputEl) {
      "step min max".split(" ").forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          range.params[paramName] = parseFloat($inputEl.attr(paramName));
          range[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      if (typeof $inputEl.val() !== "undefined") {
        range.params.value = parseFloat($inputEl.val());
        range.value = parseFloat($inputEl.val());
      }
    }
    if (range.dual) {
      $el.addClass("range-slider-dual");
    }
    if (range.label) {
      $el.addClass("range-slider-label");
    }
    if (range.vertical) {
      $el.addClass("range-slider-vertical");
      if (range.verticalReversed) {
        $el.addClass("range-slider-vertical-reversed");
      }
    } else {
      $el.addClass("range-slider-horizontal");
    }
    const $barEl = dom7_default('<div class="range-bar"></div>');
    const $barActiveEl = dom7_default('<div class="range-bar-active"></div>');
    $barEl.append($barActiveEl);
    const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ""}
      </div>
    `;
    const knobs = [dom7_default(knobHTML)];
    if (range.dual) {
      knobs.push(dom7_default(knobHTML));
    }
    $el.append($barEl);
    knobs.forEach(($knobEl) => {
      $el.append($knobEl);
    });
    const labels = [];
    if (range.label) {
      labels.push(knobs[0].find(".range-knob-label"));
      if (range.dual) {
        labels.push(knobs[1].find(".range-knob-label"));
      }
    }
    let $scaleEl;
    if (range.scale && range.scaleSteps >= 1) {
      $scaleEl = dom7_default(`
        <div class="range-scale">
          ${range.renderScale()}
        </div>
      `);
      $el.append($scaleEl);
    }
    extend(range, {
      knobs,
      labels,
      $barEl,
      $barActiveEl,
      $scaleEl
    });
    $el[0].f7Range = range;
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let rangeOffset;
    let rangeOffsetLeft;
    let rangeOffsetTop;
    let $touchedKnobEl;
    let dualValueIndex;
    let valueChangedByTouch;
    let targetTouchIdentifier;
    function onTouchChange() {
      valueChangedByTouch = true;
    }
    function handleTouchStart(e) {
      if (isTouched)
        return;
      if (!range.params.draggableBar) {
        if (dom7_default(e.target).closest(".range-knob").length === 0) {
          return;
        }
      }
      valueChangedByTouch = false;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      if (e.type === "touchstart") {
        targetTouchIdentifier = e.targetTouches[0].identifier;
      }
      isTouched = true;
      isScrolling = void 0;
      rangeOffset = $el.offset();
      rangeOffsetLeft = rangeOffset.left;
      rangeOffsetTop = rangeOffset.top;
      let progress;
      if (range.vertical) {
        progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed)
          progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - touchesStart.x) / range.rangeWidth;
      } else {
        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
      }
      let newValue = progress * (range.max - range.min) + range.min;
      if (range.dual) {
        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
          dualValueIndex = 0;
          $touchedKnobEl = range.knobs[0];
          newValue = [newValue, range.value[1]];
        } else {
          dualValueIndex = 1;
          $touchedKnobEl = range.knobs[1];
          newValue = [range.value[0], newValue];
        }
      } else {
        $touchedKnobEl = range.knobs[0];
        newValue = progress * (range.max - range.min) + range.min;
      }
      nextTick(() => {
        if (isTouched)
          $touchedKnobEl.addClass("range-knob-active-state");
      }, 70);
      range.on("change", onTouchChange);
      range.setValue(newValue, true);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      let pageX;
      let pageY;
      if (e.type === "touchmove") {
        for (let i = 0; i < e.targetTouches.length; i += 1) {
          if (e.targetTouches[i].identifier === targetTouchIdentifier) {
            pageX = e.targetTouches[i].pageX;
            pageY = e.targetTouches[i].pageY;
          }
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (typeof pageX === "undefined" && typeof pageY === "undefined")
        return;
      if (typeof isScrolling === "undefined" && !range.vertical) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      let progress;
      if (range.vertical) {
        progress = (pageY - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed)
          progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - pageX) / range.rangeWidth;
      } else {
        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
      }
      let newValue = progress * (range.max - range.min) + range.min;
      if (range.dual) {
        let leftValue;
        let rightValue;
        if (dualValueIndex === 0) {
          leftValue = newValue;
          rightValue = range.value[1];
          if (leftValue > rightValue) {
            rightValue = leftValue;
          }
        } else {
          leftValue = range.value[0];
          rightValue = newValue;
          if (rightValue < leftValue) {
            leftValue = rightValue;
          }
        }
        newValue = [leftValue, rightValue];
      }
      range.setValue(newValue, true);
    }
    function handleTouchEnd(e) {
      if (e.type === "touchend") {
        let touchEnded;
        for (let i = 0; i < e.changedTouches.length; i += 1) {
          if (e.changedTouches[i].identifier === targetTouchIdentifier)
            touchEnded = true;
        }
        if (!touchEnded)
          return;
      }
      if (!isTouched) {
        if (isScrolling)
          $touchedKnobEl.removeClass("range-knob-active-state");
        isTouched = false;
        return;
      }
      range.off("change", onTouchChange);
      isTouched = false;
      $touchedKnobEl.removeClass("range-knob-active-state");
      if (valueChangedByTouch && range.$inputEl && !range.dual) {
        range.$inputEl.trigger("change");
      }
      valueChangedByTouch = false;
      if (typeof range.previousValue !== "undefined") {
        if (range.dual && (range.previousValue[0] !== range.value[0] || range.previousValue[1] !== range.value[1]) || !range.dual && range.previousValue !== range.value) {
          range.$el.trigger("range:changed", range.value);
          range.emit("local::changed rangeChanged", range, range.value);
        }
      }
    }
    function handleResize() {
      range.calcSize();
      range.layout();
    }
    let parentModals;
    let parentPanel;
    let parentPage;
    range.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      app.on("tabShow", handleResize);
      app.on("resize", handleResize);
      parentModals = range.$el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast");
      parentModals.on("modal:open", handleResize);
      parentPanel = range.$el.parents(".panel");
      parentPanel.on("panel:open panel:resize", handleResize);
      parentPage = range.$el.parents(".page").eq(0);
      parentPage.on("page:reinit", handleResize);
    };
    range.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("tabShow", handleResize);
      app.off("resize", handleResize);
      if (parentModals) {
        parentModals.off("modal:open", handleResize);
      }
      if (parentPanel) {
        parentPanel.off("panel:open panel:resize", handleResize);
      }
      if (parentPage) {
        parentPage.off("page:reinit", handleResize);
      }
      parentModals = null;
      parentPanel = null;
      parentPage = null;
    };
    range.useModules();
    range.init();
    return range;
  }
  calcSize() {
    const range = this;
    if (range.vertical) {
      const height = range.$el.outerHeight();
      if (height === 0)
        return;
      range.rangeHeight = height;
      range.knobHeight = range.knobs[0].outerHeight();
    } else {
      const width = range.$el.outerWidth();
      if (width === 0)
        return;
      range.rangeWidth = width;
      range.knobWidth = range.knobs[0].outerWidth();
    }
  }
  layout() {
    const range = this;
    const {
      app,
      knobWidth,
      knobHeight,
      rangeWidth,
      rangeHeight,
      min,
      max,
      knobs,
      $barActiveEl,
      value,
      label,
      labels,
      vertical,
      verticalReversed,
      limitKnobPosition
    } = range;
    const knobSize = vertical ? knobHeight : knobWidth;
    const rangeSize = vertical ? rangeHeight : rangeWidth;
    const positionProperty = vertical ? verticalReversed ? "top" : "bottom" : app.rtl ? "right" : "left";
    if (range.dual) {
      const progress = [(value[0] - min) / (max - min), (value[1] - min) / (max - min)];
      $barActiveEl.css({
        [positionProperty]: `${progress[0] * 100}%`,
        [vertical ? "height" : "width"]: `${(progress[1] - progress[0]) * 100}%`
      });
      knobs.forEach(($knobEl, knobIndex) => {
        let startPos = rangeSize * progress[knobIndex];
        if (limitKnobPosition) {
          const realStartPos = rangeSize * progress[knobIndex] - knobSize / 2;
          if (realStartPos < 0)
            startPos = knobSize / 2;
          if (realStartPos + knobSize > rangeSize)
            startPos = rangeSize - knobSize / 2;
        }
        $knobEl.css(positionProperty, `${startPos}px`);
        if (label)
          labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
      });
    } else {
      const progress = (value - min) / (max - min);
      $barActiveEl.css(vertical ? "height" : "width", `${progress * 100}%`);
      let startPos = rangeSize * progress;
      if (limitKnobPosition) {
        const realStartPos = rangeSize * progress - knobSize / 2;
        if (realStartPos < 0)
          startPos = knobSize / 2;
        if (realStartPos + knobSize > rangeSize)
          startPos = rangeSize - knobSize / 2;
      }
      knobs[0].css(positionProperty, `${startPos}px`);
      if (label)
        labels[0].text(range.formatLabel(value, labels[0][0]));
    }
    if (range.dual && value.indexOf(min) >= 0 || !range.dual && value === min) {
      range.$el.addClass("range-slider-min");
    } else {
      range.$el.removeClass("range-slider-min");
    }
    if (range.dual && value.indexOf(max) >= 0 || !range.dual && value === max) {
      range.$el.addClass("range-slider-max");
    } else {
      range.$el.removeClass("range-slider-max");
    }
  }
  setValue(newValue, byTouchMove) {
    const range = this;
    const {
      step,
      min,
      max
    } = range;
    let valueChanged;
    let oldValue;
    if (range.dual) {
      oldValue = [range.value[0], range.value[1]];
      let newValues = newValue;
      if (!Array.isArray(newValues))
        newValues = [newValue, newValue];
      if (newValue[0] > newValue[1]) {
        newValues = [newValues[0], newValues[0]];
      }
      newValues = newValues.map((value) => Math.max(Math.min(Math.round(value / step) * step, max), min));
      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
        return range;
      }
      newValues.forEach((value, valueIndex) => {
        range.value[valueIndex] = value;
      });
      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
      range.layout();
    } else {
      oldValue = range.value;
      const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
      range.value = value;
      range.layout();
      valueChanged = oldValue !== value;
    }
    if (valueChanged) {
      range.previousValue = oldValue;
    }
    if (!valueChanged)
      return range;
    range.$el.trigger("range:change", range.value);
    if (range.$inputEl && !range.dual) {
      range.$inputEl.val(range.value);
      if (!byTouchMove) {
        range.$inputEl.trigger("input change");
      } else {
        range.$inputEl.trigger("input");
      }
    }
    if (!byTouchMove) {
      range.$el.trigger("range:changed", range.value);
      range.emit("local::changed rangeChanged", range, range.value);
    }
    range.emit("local::change rangeChange", range, range.value);
    return range;
  }
  getValue() {
    return this.value;
  }
  formatLabel(value, labelEl) {
    const range = this;
    if (range.params.formatLabel)
      return range.params.formatLabel.call(range, value, labelEl);
    return value;
  }
  formatScaleLabel(value) {
    const range = this;
    if (range.params.formatScaleLabel)
      return range.params.formatScaleLabel.call(range, value);
    return value;
  }
  renderScale() {
    const range = this;
    const {
      app,
      verticalReversed,
      vertical
    } = range;
    const positionProperty = vertical ? verticalReversed ? "top" : "bottom" : app.rtl ? "right" : "left";
    let html = "";
    Array.from({
      length: range.scaleSteps + 1
    }).forEach((scaleEl, index) => {
      const scaleStepValue = (range.max - range.min) / range.scaleSteps;
      const scaleValue = range.min + scaleStepValue * index;
      const progress = (scaleValue - range.min) / (range.max - range.min);
      html += `<div class="range-scale-step" style="${positionProperty}: ${progress * 100}%">${range.formatScaleLabel(scaleValue)}</div>`;
      if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
        Array.from({
          length: range.scaleSubSteps - 1
        }).forEach((subStepEl, subIndex) => {
          const subStep = scaleStepValue / range.scaleSubSteps;
          const scaleSubValue = scaleValue + subStep * (subIndex + 1);
          const subProgress = (scaleSubValue - range.min) / (range.max - range.min);
          html += `<div class="range-scale-step range-scale-substep" style="${positionProperty}: ${subProgress * 100}%"></div>`;
        });
      }
    });
    return html;
  }
  updateScale() {
    const range = this;
    if (!range.scale || range.scaleSteps < 1) {
      if (range.$scaleEl)
        range.$scaleEl.remove();
      delete range.$scaleEl;
      return;
    }
    if (!range.$scaleEl) {
      range.$scaleEl = dom7_default('<div class="range-scale"></div>');
      range.$el.append(range.$scaleEl);
    }
    range.$scaleEl.html(range.renderScale());
  }
  init() {
    const range = this;
    range.calcSize();
    range.layout();
    range.attachEvents();
    return range;
  }
  destroy() {
    let range = this;
    range.$el.trigger("range:beforedestroy");
    range.emit("local::beforeDestroy rangeBeforeDestroy", range);
    delete range.$el[0].f7Range;
    range.detachEvents();
    deleteProps(range);
    range = null;
  }
};
var range_class_default = Range;

// node_modules/framework7/components/range/range.js
var range_default = {
  name: "range",
  create() {
    const app = this;
    app.range = extend(ConstructorMethods({
      defaultSelector: ".range-slider",
      constructor: range_class_default,
      app,
      domProp: "f7Range"
    }), {
      getValue(el) {
        if (el === void 0) {
          el = ".range-slider";
        }
        const range = app.range.get(el);
        if (range)
          return range.getValue();
        return void 0;
      },
      setValue(el, value) {
        if (el === void 0) {
          el = ".range-slider";
        }
        const range = app.range.get(el);
        if (range)
          return range.setValue(value);
        return void 0;
      }
    });
  },
  static: {
    Range: range_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".range-slider-init").each((rangeEl) => new range_class_default(app, {
        el: rangeEl
      }));
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".range-slider-init").each((rangeEl) => {
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".range-slider-init").each((rangeEl) => new range_class_default(app, {
        el: rangeEl
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find(".range-slider-init").each((rangeEl) => {
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      });
    }
  },
  vnode: {
    "range-slider-init": {
      insert(vnode) {
        const rangeEl = vnode.elm;
        const app = this;
        app.range.create({
          el: rangeEl
        });
      },
      destroy(vnode) {
        const rangeEl = vnode.elm;
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      }
    }
  }
};

// node_modules/framework7/components/stepper/stepper-class.js
var Stepper = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const stepper = this;
    const defaults = {
      el: null,
      inputEl: null,
      valueEl: null,
      value: 0,
      formatValue: null,
      step: 1,
      min: 0,
      max: 100,
      watchInput: true,
      autorepeat: false,
      autorepeatDynamic: false,
      wraps: false,
      manualInputMode: false,
      decimalPoint: 4,
      buttonsEndInputMode: true
    };
    stepper.useModulesParams(defaults);
    stepper.params = extend(defaults, params);
    if (stepper.params.value < stepper.params.min) {
      stepper.params.value = stepper.params.min;
    }
    if (stepper.params.value > stepper.params.max) {
      stepper.params.value = stepper.params.max;
    }
    const el = stepper.params.el;
    if (!el)
      return stepper;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return stepper;
    if ($el[0].f7Stepper)
      return $el[0].f7Stepper;
    let $inputEl;
    if (stepper.params.inputEl) {
      $inputEl = dom7_default(stepper.params.inputEl);
    } else if ($el.find(".stepper-input-wrap").find("input, textarea").length) {
      $inputEl = $el.find(".stepper-input-wrap").find("input, textarea").eq(0);
    }
    if ($inputEl && $inputEl.length) {
      "step min max".split(" ").forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      const decimalPoint2 = parseInt(stepper.params.decimalPoint, 10);
      if (Number.isNaN(decimalPoint2)) {
        stepper.params.decimalPoint = 0;
      } else {
        stepper.params.decimalPoint = decimalPoint2;
      }
      const inputValue = parseFloat($inputEl.val());
      if (typeof params.value === "undefined" && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
        stepper.params.value = inputValue;
      }
    }
    let $valueEl;
    if (stepper.params.valueEl) {
      $valueEl = dom7_default(stepper.params.valueEl);
    } else if ($el.find(".stepper-value").length) {
      $valueEl = $el.find(".stepper-value").eq(0);
    }
    const $buttonPlusEl = $el.find(".stepper-button-plus");
    const $buttonMinusEl = $el.find(".stepper-button-minus");
    const {
      step,
      min,
      max,
      value,
      decimalPoint
    } = stepper.params;
    extend(stepper, {
      app,
      $el,
      el: $el[0],
      $buttonPlusEl,
      buttonPlusEl: $buttonPlusEl[0],
      $buttonMinusEl,
      buttonMinusEl: $buttonMinusEl[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : void 0,
      $valueEl,
      valueEl: $valueEl ? $valueEl[0] : void 0,
      step,
      min,
      max,
      value,
      decimalPoint,
      typeModeChanged: false
    });
    $el[0].f7Stepper = stepper;
    const touchesStart = {};
    let isTouched;
    let isScrolling;
    let preventButtonClick;
    let intervalId;
    let timeoutId;
    let autorepeatAction = null;
    let autorepeatInAction = false;
    let manualInput = false;
    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        if (current === 1) {
          preventButtonClick = true;
          autorepeatInAction = true;
        }
        clearInterval(intervalId);
        action();
        intervalId = setInterval(() => {
          action();
        }, repeatEvery);
        if (current < progressions) {
          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
        }
      }, current === 1 ? startsIn : progressionStep);
    }
    function onTouchStart(e) {
      if (isTouched)
        return;
      if (manualInput) {
        return;
      }
      if (dom7_default(e.target).closest($buttonPlusEl).length) {
        autorepeatAction = "increment";
      } else if (dom7_default(e.target).closest($buttonMinusEl).length) {
        autorepeatAction = "decrement";
      }
      if (!autorepeatAction)
        return;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = void 0;
      const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
      dynamicRepeat(1, progressions, 500, 1e3, 300, () => {
        stepper[autorepeatAction]();
      });
    }
    function onTouchMove(e) {
      if (!isTouched)
        return;
      if (manualInput) {
        return;
      }
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined" && !autorepeatInAction) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      const distance = ((pageX - touchesStart.x) ** 2 + (pageY - touchesStart.y) ** 2) ** 0.5;
      if (isScrolling || distance > 20) {
        isTouched = false;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      }
    }
    function onTouchEnd() {
      clearTimeout(timeoutId);
      clearInterval(intervalId);
      autorepeatAction = null;
      autorepeatInAction = false;
      isTouched = false;
    }
    function onMinusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.decrement(true);
    }
    function onPlusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.increment(true);
    }
    function onInputClick(e) {
      if (!e.target.readOnly && stepper.params.manualInputMode) {
        manualInput = true;
        if (typeof e.target.selectionStart === "number") {
          e.target.selectionStart = e.target.value.length;
          e.target.selectionEnd = e.target.value.length;
        }
      }
    }
    function onInputKey(e) {
      if (e.keyCode === 13 || e.which === 13) {
        e.preventDefault();
        manualInput = false;
        stepper.endTypeMode();
      }
    }
    function onInputBlur() {
      manualInput = false;
      stepper.endTypeMode(true);
    }
    function onInput(e) {
      if (manualInput) {
        stepper.typeValue(e.target.value);
        return;
      }
      if (e.detail && e.detail.sentByF7Stepper)
        return;
      stepper.setValue(e.target.value, true);
    }
    stepper.attachEvents = function attachEvents() {
      $buttonMinusEl.on("click", onMinusClick);
      $buttonPlusEl.on("click", onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.on("input", onInput);
        $inputEl.on("click", onInputClick);
        $inputEl.on("blur", onInputBlur);
        $inputEl.on("keyup", onInputKey);
      }
      if (stepper.params.autorepeat) {
        app.on("touchstart:passive", onTouchStart);
        app.on("touchmove:active", onTouchMove);
        app.on("touchend:passive", onTouchEnd);
      }
    };
    stepper.detachEvents = function detachEvents() {
      $buttonMinusEl.off("click", onMinusClick);
      $buttonPlusEl.off("click", onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.off("input", onInput);
        $inputEl.off("click", onInputClick);
        $inputEl.off("blur", onInputBlur);
        $inputEl.off("keyup", onInputKey);
      }
    };
    stepper.useModules();
    stepper.init();
    return stepper;
  }
  minus() {
    return this.decrement();
  }
  plus() {
    return this.increment();
  }
  decrement() {
    const stepper = this;
    return stepper.setValue(stepper.value - stepper.step, false, true);
  }
  increment() {
    const stepper = this;
    return stepper.setValue(stepper.value + stepper.step, false, true);
  }
  setValue(newValue, forceUpdate, withWraps) {
    const stepper = this;
    const {
      step,
      min,
      max
    } = stepper;
    const oldValue = stepper.value;
    let value = Math.round(newValue / step) * step;
    if (stepper.params.wraps && withWraps) {
      if (value > max)
        value = min;
      if (value < min)
        value = max;
    } else {
      value = Math.max(Math.min(value, max), min);
    }
    if (Number.isNaN(value)) {
      value = oldValue;
    }
    stepper.value = value;
    const valueChanged = oldValue !== value;
    if (!valueChanged && !forceUpdate)
      return stepper;
    stepper.$el.trigger("stepper:change", stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger("input change", {
        sentByF7Stepper: true
      });
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit("local::change stepperChange", stepper, stepper.value);
    return stepper;
  }
  endTypeMode(noBlur) {
    const stepper = this;
    const {
      min,
      max
    } = stepper;
    let value = parseFloat(stepper.value);
    if (Number.isNaN(value))
      value = 0;
    value = Math.max(Math.min(value, max), min);
    stepper.value = value;
    if (!stepper.typeModeChanged) {
      if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
        stepper.$inputEl.blur();
      }
      return stepper;
    }
    stepper.typeModeChanged = false;
    stepper.$el.trigger("stepper:change", stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger("input change", {
        sentByF7Stepper: true
      });
      if (!noBlur)
        stepper.$inputEl.blur();
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit("local::change stepperChange", stepper, stepper.value);
    return stepper;
  }
  typeValue(value) {
    const stepper = this;
    stepper.typeModeChanged = true;
    let inputTxt = String(value);
    if (inputTxt.length === 1 && inputTxt === "-")
      return stepper;
    if (inputTxt.lastIndexOf(".") + 1 === inputTxt.length || inputTxt.lastIndexOf(",") + 1 === inputTxt.length) {
      if (inputTxt.lastIndexOf(".") !== inputTxt.indexOf(".") || inputTxt.lastIndexOf(",") !== inputTxt.indexOf(",")) {
        inputTxt = inputTxt.slice(0, -1);
        stepper.value = inputTxt;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
    } else {
      let newValue = parseFloat(inputTxt.replace(",", "."));
      if (newValue === 0) {
        stepper.value = inputTxt.replace(",", ".");
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      if (Number.isNaN(newValue)) {
        stepper.value = 0;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      const powVal = 10 ** stepper.params.decimalPoint;
      newValue = Math.round(newValue * powVal).toFixed(stepper.params.decimalPoint + 1) / powVal;
      stepper.value = parseFloat(String(newValue).replace(",", "."));
      stepper.$inputEl.val(stepper.value);
      return stepper;
    }
    stepper.value = inputTxt;
    stepper.$inputEl.val(inputTxt);
    return stepper;
  }
  getValue() {
    return this.value;
  }
  formatValue(value) {
    const stepper = this;
    if (!stepper.params.formatValue)
      return value;
    return stepper.params.formatValue.call(stepper, value);
  }
  init() {
    const stepper = this;
    stepper.attachEvents();
    if (stepper.$valueEl && stepper.$valueEl.length) {
      const formattedValue = stepper.formatValue(stepper.value);
      stepper.$valueEl.html(formattedValue);
    }
    return stepper;
  }
  destroy() {
    let stepper = this;
    stepper.$el.trigger("stepper:beforedestroy");
    stepper.emit("local::beforeDestroy stepperBeforeDestroy", stepper);
    delete stepper.$el[0].f7Stepper;
    stepper.detachEvents();
    deleteProps(stepper);
    stepper = null;
  }
};
var stepper_class_default = Stepper;

// node_modules/framework7/components/stepper/stepper.js
var stepper_default = {
  name: "stepper",
  create() {
    const app = this;
    app.stepper = extend(ConstructorMethods({
      defaultSelector: ".stepper",
      constructor: stepper_class_default,
      app,
      domProp: "f7Stepper"
    }), {
      getValue(el) {
        if (el === void 0) {
          el = ".stepper";
        }
        const stepper = app.stepper.get(el);
        if (stepper)
          return stepper.getValue();
        return void 0;
      },
      setValue(el, value) {
        if (el === void 0) {
          el = ".stepper";
        }
        const stepper = app.stepper.get(el);
        if (stepper)
          return stepper.setValue(value);
        return void 0;
      }
    });
  },
  static: {
    Stepper: stepper_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".stepper-init").each((stepperEl) => {
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".stepper-init").each((stepperEl) => {
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".stepper-init").each((stepperEl) => {
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".stepper-init").each((stepperEl) => {
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      });
    }
  },
  vnode: {
    "stepper-init": {
      insert(vnode) {
        const app = this;
        const stepperEl = vnode.elm;
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      },
      destroy(vnode) {
        const stepperEl = vnode.elm;
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      }
    }
  }
};

// node_modules/framework7/components/searchbar/remove-diacritics.js
var defaultDiacriticsRemovalap = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "OE",
  letters: "Œ"
}, {
  base: "oe",
  letters: "œ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}];
var diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;
  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}
function removeDiacritics(str) {
  return str.replace(/[^\u0000-\u007E]/g, (a) => diacriticsMap[a] || a);
}
var remove_diacritics_default = removeDiacritics;

// node_modules/framework7/components/smart-select/smart-select-class.js
var SmartSelect = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const ss = this;
    const defaults = extend({
      on: {}
    }, app.params.smartSelect);
    if (typeof defaults.searchbarDisableButton === "undefined") {
      defaults.searchbarDisableButton = app.theme !== "aurora";
    }
    ss.useModulesParams(defaults);
    ss.params = extend({}, defaults, params);
    ss.app = app;
    const $el = dom7_default(ss.params.el).eq(0);
    if ($el.length === 0)
      return ss;
    if ($el[0].f7SmartSelect)
      return $el[0].f7SmartSelect;
    const $selectEl = $el.find("select").eq(0);
    if ($selectEl.length === 0)
      return ss;
    let $valueEl;
    if (ss.params.setValueText) {
      $valueEl = dom7_default(ss.params.valueEl);
      if ($valueEl.length === 0) {
        $valueEl = $el.find(".item-after");
      }
      if ($valueEl.length === 0) {
        $valueEl = dom7_default('<div class="item-after"></div>');
        $valueEl.insertAfter($el.find(".item-title"));
      }
    }
    let url = params.url;
    if (!url) {
      if ($el.attr("href") && $el.attr("href") !== "#")
        url = $el.attr("href");
      else if ($selectEl.attr("name"))
        url = `${$selectEl.attr("name").toLowerCase()}-select/`;
    }
    if (!url)
      url = ss.params.url;
    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? "checkbox" : "radio";
    const selectId = id();
    extend(ss, {
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl && $valueEl[0],
      url,
      multiple,
      inputType,
      id: selectId,
      inputName: `${inputType}-${selectId}`,
      selectName: $selectEl.attr("name"),
      maxLength: $selectEl.attr("maxlength") || params.maxLength
    });
    $el[0].f7SmartSelect = ss;
    function onClick3() {
      ss.open();
    }
    function onChange() {
      const value = ss.$selectEl.val();
      ss.$el.trigger("smartselect:change", value);
      ss.emit("local::change smartSelectChange", ss, value);
      if (ss.vl) {
        ss.vl.clearCache();
      }
      ss.setValueText();
    }
    ss.attachEvents = function attachEvents() {
      $el.on("click", onClick3);
      $el.on("change", "select", onChange);
    };
    ss.detachEvents = function detachEvents() {
      $el.off("click", onClick3);
      $el.off("change", "select", onChange);
    };
    function handleInputChange() {
      let optionEl;
      let text;
      const inputEl = this;
      const value = inputEl.value;
      let optionText = [];
      let displayAs;
      if (inputEl.type === "checkbox") {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (optionEl.value === value) {
            optionEl.selected = inputEl.checked;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-value-as");
            text = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
            optionText.push(text.trim());
          }
        }
        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];
        if (!optionEl) {
          optionEl = ss.$selectEl.find("option").filter((optEl) => optEl.value === value)[0];
        }
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-as");
        text = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text];
        ss.selectEl.value = value;
      }
      ss.$selectEl.trigger("change");
      if (ss.params.setValueText) {
        ss.formatValueTextContent(optionText);
      }
      if (ss.params.closeOnSelect && ss.inputType === "radio") {
        ss.close();
      }
    }
    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.useModules();
    ss.init();
    return ss;
  }
  setValue(value) {
    const ss = this;
    let newValue = value;
    let optionText = [];
    let optionEl;
    let displayAs;
    let text;
    if (ss.multiple) {
      if (!Array.isArray(newValue))
        newValue = [newValue];
      for (let i = 0; i < ss.selectEl.options.length; i += 1) {
        optionEl = ss.selectEl.options[i];
        if (newValue.indexOf(optionEl.value) >= 0) {
          optionEl.selected = true;
        } else {
          optionEl.selected = false;
        }
        if (optionEl.selected) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-value-as");
          text = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
          optionText.push(text.trim());
        }
      }
    } else {
      optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];
      if (optionEl) {
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-as");
        text = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text];
      }
      ss.selectEl.value = newValue;
    }
    if (ss.params.setValueText) {
      ss.formatValueTextContent(optionText);
    }
    ss.$selectEl.trigger("change");
    return ss;
  }
  unsetValue() {
    const ss = this;
    if (ss.params.setValueText) {
      ss.formatValueTextContent([]);
    }
    ss.$selectEl.find("option").each((optionEl) => {
      optionEl.selected = false;
      optionEl.checked = false;
    });
    ss.$selectEl[0].value = null;
    if (ss.$containerEl) {
      ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop("checked", false);
    }
    ss.$selectEl.trigger("change");
  }
  getValue() {
    const ss = this;
    return ss.$selectEl.val();
  }
  get view() {
    const {
      params,
      $el
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    }
    if (!view) {
      view = $el.parents(".view").length && $el.parents(".view")[0].f7View;
    }
    if (!view && params.openIn === "page") {
      throw Error("Smart Select requires initialized View");
    }
    return view;
  }
  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;
    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each((inputEl) => {
        if (!inputEl.checked) {
          dom7_default(inputEl).parents("li").addClass("disabled");
        } else {
          dom7_default(inputEl).parents("li").removeClass("disabled");
        }
      });
    } else {
      $containerEl.find(".disabled").removeClass("disabled");
    }
  }
  formatValueTextContent(values) {
    const ss = this;
    const valueFormatted = ss.formatValueText(values);
    if (valueFormatted.includes("<") && valueFormatted.includes(">")) {
      ss.$valueEl.html(valueFormatted);
    } else {
      ss.$valueEl.text(valueFormatted);
    }
  }
  formatValueText(values) {
    const ss = this;
    let textValue;
    if (ss.params.formatValueText) {
      textValue = ss.params.formatValueText.call(ss, values, ss);
    } else {
      textValue = values.join(", ");
    }
    return textValue;
  }
  setValueText(value) {
    const ss = this;
    let valueArray = [];
    if (typeof value !== "undefined") {
      if (Array.isArray(value)) {
        valueArray = value;
      } else {
        valueArray = [value];
      }
    } else {
      ss.$selectEl.find("option").each((optionEl) => {
        const $optionEl = dom7_default(optionEl);
        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data("display-value-as");
          if (displayAs && typeof displayAs !== "undefined") {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }
    if (ss.params.setValueText) {
      ss.formatValueTextContent(valueArray);
    }
  }
  getItemsData() {
    const ss = this;
    const theme = ss.app.theme;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find("option").each((optionEl) => {
      const $optionEl = dom7_default(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionIconIos = theme === "ios" && (optionData.optionIconIos || ss.params.optionIconIos);
      const optionIconMd = theme === "md" && (optionData.optionIconMd || ss.params.optionIconMd);
      const optionIconAurora = theme === "aurora" && (optionData.optionIconAurora || ss.params.optionIconAurora);
      const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
      const optionColor = optionData.optionColor;
      let optionClassName = optionData.optionClass || "";
      if ($optionEl[0].disabled)
        optionClassName += " disabled";
      const optionGroupEl = $optionEl.parent("optgroup")[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;
      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel
        });
      }
      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        iconIos: optionIconIos,
        iconMd: optionIconMd,
        iconAurora: optionIconAurora,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === "checkbox",
        radio: ss.inputType === "radio",
        inputName: ss.inputName,
        inputType: ss.inputType
      });
    });
    ss.items = items;
    return items;
  }
  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar)
      return ss.params.renderSearchbar.call(ss);
    return jsx_default("form", {
      class: "searchbar"
    }, jsx_default("div", {
      class: "searchbar-inner"
    }, jsx_default("div", {
      class: "searchbar-input-wrap"
    }, jsx_default("input", {
      type: "search",
      spellcheck: ss.params.searchbarSpellcheck || "false",
      placeholder: ss.params.searchbarPlaceholder
    }), jsx_default("i", {
      class: "searchbar-icon"
    }), jsx_default("span", {
      class: "input-clear-button"
    })), ss.params.searchbarDisableButton && jsx_default("span", {
      class: "searchbar-disable-button"
    }, ss.params.searchbarDisableText)));
  }
  renderItem(item, index) {
    const ss = this;
    if (ss.params.renderItem)
      return ss.params.renderItem.call(ss, item, index);
    function getIconContent(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        return iconValue.split(":")[1];
      }
      return "";
    }
    function getIconClass(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        let className = iconValue.split(":")[0];
        if (className === "f7")
          className = "f7-icons";
        if (className === "material")
          className = "material-icons";
        return className;
      }
      return iconValue;
    }
    let itemHtml;
    if (item.isLabel) {
      itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
    } else {
      let selected = item.selected;
      let disabled;
      if (ss.params.virtualList) {
        const ssValue = ss.getValue();
        selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;
        if (ss.multiple) {
          disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
        }
      }
      const {
        icon,
        iconIos,
        iconMd,
        iconAurora
      } = item;
      const hasIcon = icon || iconIos || iconMd || iconAurora;
      const iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || "");
      const iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || "");
      itemHtml = jsx_default("li", {
        class: `${item.className || ""}${disabled ? " disabled" : ""}`
      }, jsx_default("label", {
        class: `item-${item.inputType} item-content`
      }, jsx_default("input", {
        type: item.inputType,
        name: item.inputName,
        value: item.value,
        _checked: selected
      }), jsx_default("i", {
        class: `icon icon-${item.inputType}`
      }), item.hasMedia && jsx_default("div", {
        class: "item-media"
      }, hasIcon && jsx_default("i", {
        class: `icon ${iconClass}`
      }, iconContent), item.image && jsx_default("img", {
        src: item.image
      })), jsx_default("div", {
        class: "item-inner"
      }, jsx_default("div", {
        class: `item-title${item.color ? ` text-color-${item.color}` : ""}`
      }, item.text))));
    }
    return itemHtml;
  }
  renderItems() {
    const ss = this;
    if (ss.params.renderItems)
      return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index) => `${ss.renderItem(item, index)}`).join("")}
    `;
    return itemsHtml;
  }
  renderPage() {
    const ss = this;
    if (ss.params.renderPage)
      return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass;
    return jsx_default("div", {
      class: `page smart-select-page ${cssClass}`,
      "data-name": "smart-select-page",
      "data-select-name": ss.selectName
    }, jsx_default("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default("div", {
      class: "navbar-bg"
    }), jsx_default("div", {
      class: `navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default("div", {
      class: "left"
    }, jsx_default("a", {
      class: "link back"
    }, jsx_default("i", {
      class: "icon icon-back"
    }), jsx_default("span", {
      class: "if-not-md"
    }, ss.params.pageBackLinkText))), pageTitle && jsx_default("div", {
      class: "title"
    }, pageTitle), ss.params.searchbar && jsx_default("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && jsx_default("div", {
      class: "searchbar-backdrop"
    }), jsx_default("div", {
      class: "page-content"
    }, jsx_default("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup)
      return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass || "";
    return jsx_default("div", {
      class: `popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? "popup-tablet-fullscreen" : ""}`,
      "data-select-name": ss.selectName
    }, jsx_default("div", {
      class: "view"
    }, jsx_default("div", {
      class: `page smart-select-page ${ss.params.searchbar ? "page-with-subnavbar" : ""}`,
      "data-name": "smart-select-page"
    }, jsx_default("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default("div", {
      class: "navbar-bg"
    }), jsx_default("div", {
      class: "navbar-inner sliding"
    }, pageTitle && jsx_default("div", {
      class: "title"
    }, pageTitle), jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link popup-close",
      "data-popup": `.smart-select-popup[data-select-name='${ss.selectName}']`
    }, ss.params.popupCloseLinkText)), ss.params.searchbar && jsx_default("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && jsx_default("div", {
      class: "searchbar-backdrop"
    }), jsx_default("div", {
      class: "page-content"
    }, jsx_default("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))))));
  }
  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet)
      return ss.params.renderSheet.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return jsx_default("div", {
      class: `sheet-modal smart-select-sheet ${cssClass}`,
      "data-select-name": ss.selectName
    }, jsx_default("div", {
      class: `toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ""}`
    }, jsx_default("div", {
      class: "toolbar-inner"
    }, jsx_default("div", {
      class: "left"
    }), jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link sheet-close"
    }, ss.params.sheetCloseLinkText)))), jsx_default("div", {
      class: "sheet-modal-inner"
    }, jsx_default("div", {
      class: "page-content"
    }, jsx_default("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default("ul", null, !ss.params.virtualList && ss.renderItems(ss.items))))));
  }
  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover)
      return ss.params.renderPopover.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return jsx_default("div", {
      class: `popover smart-select-popover ${cssClass}`,
      "data-select-name": ss.selectName
    }, jsx_default("div", {
      class: "popover-inner"
    }, jsx_default("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  scrollToSelectedItem() {
    const ss = this;
    const {
      params,
      $containerEl
    } = ss;
    if (!ss.opened)
      return ss;
    if (params.virtualList) {
      let selectedIndex;
      ss.vl.items.forEach((item, index) => {
        if (typeof selectedIndex === "undefined" && item.selected) {
          selectedIndex = index;
        }
      });
      if (typeof selectedIndex !== "undefined") {
        ss.vl.scrollToItem(selectedIndex);
      }
    } else {
      const $selectedItemEl = $containerEl.find("input:checked").parents("li");
      if (!$selectedItemEl.length)
        return ss;
      const $scrollableEl = $containerEl.find(".page-content, .popover-inner");
      if (!$scrollableEl.length)
        return ss;
      $scrollableEl.scrollTop($selectedItemEl.offset().top - $scrollableEl.offset().top - parseInt($scrollableEl.css("padding-top"), 10));
    }
    return ss;
  }
  onOpen(type, containerEl) {
    const ss = this;
    const app = ss.app;
    const $containerEl = dom7_default(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true;
    if (ss.params.virtualList) {
      ss.vl = app.virtualList.create({
        el: $containerEl.find(".virtual-list"),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,
        searchByItem(query, item) {
          if (item.text && remove_diacritics_default(item.text).toLowerCase().indexOf(query.trim().toLowerCase()) >= 0)
            return true;
          return false;
        }
      });
    }
    if (ss.params.scrollToSelectedItem) {
      ss.scrollToSelectedItem();
    }
    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find(".searchbar");
      if (type === "page" && app.theme === "ios") {
        $searchbarEl = dom7_default(app.navbar.getElByPage($containerEl)).find(".searchbar");
      }
      if (ss.params.appendSearchbarNotFound && (type === "page" || type === "popup")) {
        let $notFoundEl = null;
        if (typeof ss.params.appendSearchbarNotFound === "string") {
          $notFoundEl = dom7_default(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
        } else if (typeof ss.params.appendSearchbarNotFound === "boolean") {
          $notFoundEl = dom7_default('<div class="block searchbar-not-found">Nothing found</div>');
        } else {
          $notFoundEl = ss.params.appendSearchbarNotFound;
        }
        if ($notFoundEl) {
          $containerEl.find(".page-content").append($notFoundEl[0]);
        }
      }
      const searchbarParams = extend({
        el: $searchbarEl,
        backdropEl: $containerEl.find(".searchbar-backdrop"),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: ".item-title"
      }, typeof ss.params.searchbar === "object" ? ss.params.searchbar : {});
      ss.searchbar = app.searchbar.create(searchbarParams);
    }
    if (ss.maxLength) {
      ss.checkMaxLength();
    }
    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents("label").once("click", () => {
        ss.close();
      });
    }
    ss.attachInputsEvents();
    ss.$el.trigger("smartselect:open");
    ss.emit("local::open smartSelectOpen", ss);
  }
  onOpened() {
    const ss = this;
    ss.$el.trigger("smartselect:opened");
    ss.emit("local::opened smartSelectOpened", ss);
  }
  onClose() {
    const ss = this;
    if (ss.destroyed)
      return;
    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    }
    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    }
    ss.detachInputsEvents();
    ss.$el.trigger("smartselect:close");
    ss.emit("local::close smartSelectClose", ss);
  }
  onClosed() {
    const ss = this;
    if (ss.destroyed)
      return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;
    ss.$el.trigger("smartselect:closed");
    ss.emit("local::closed smartSelectClosed", ss);
  }
  openPage() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);
    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            ss.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            ss.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            ss.onClosed("page", page.el);
          }
        }
      }
    });
    return ss;
  }
  openPopup() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);
    const popupParams = {
      content: popupHtml,
      push: ss.params.popupPush,
      swipeToClose: ss.params.popupSwipeToClose,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        popupOpen(popup) {
          ss.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          ss.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          ss.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          ss.onClosed("popup", popup.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams
        }
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }
    return ss;
  }
  openSheet() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);
    const sheetParams = {
      content: sheetHtml,
      backdrop: ss.params.sheetBackdrop,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      push: ss.params.sheetPush,
      swipeToClose: ss.params.sheetSwipeToClose,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        sheetOpen(sheet) {
          ss.onOpen("sheet", sheet.el);
        },
        sheetOpened(sheet) {
          ss.onOpened("sheet", sheet.el);
        },
        sheetClose(sheet) {
          ss.onClose("sheet", sheet.el);
        },
        sheetClosed(sheet) {
          ss.onClosed("sheet", sheet.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams
        }
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }
    return ss;
  }
  openPopover() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        popoverOpen(popover) {
          ss.onOpen("popover", popover.el);
        },
        popoverOpened(popover) {
          ss.onOpened("popover", popover.el);
        },
        popoverClose(popover) {
          ss.onClose("popover", popover.el);
        },
        popoverClosed(popover) {
          ss.onClosed("popover", popover.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams
        }
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }
    return ss;
  }
  open(type) {
    const ss = this;
    if (ss.opened)
      return ss;
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    if (ss.$el) {
      ss.$el.trigger("smartselect:beforeopen", {
        prevent
      });
    }
    ss.emit("local::beforeOpen smartSelectBeforeOpen", ss, prevent);
    if (prevented)
      return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split("").map((el, index) => {
      if (index === 0)
        return el.toUpperCase();
      return el;
    }).join("")}`]();
    return ss;
  }
  close() {
    const ss = this;
    if (!ss.opened)
      return ss;
    if (ss.params.routableModals && ss.view || ss.openedIn === "page") {
      ss.view.router.back();
    } else {
      ss.modal.once("modalClosed", () => {
        nextTick(() => {
          if (ss.destroyed)
            return;
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }
    return ss;
  }
  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValueText();
  }
  destroy() {
    const ss = this;
    ss.emit("local::beforeDestroy smartSelectBeforeDestroy", ss);
    ss.$el.trigger("smartselect:beforedestroy");
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    deleteProps(ss);
    ss.destroyed = true;
  }
};
var smart_select_class_default = SmartSelect;

// node_modules/framework7/components/smart-select/smart-select.js
var smart_select_default = {
  name: "smartSelect",
  params: {
    smartSelect: {
      el: void 0,
      valueEl: void 0,
      setValueText: true,
      formatValueText: null,
      openIn: "page",
      // or 'popup' or 'sheet' or 'popover'
      popupPush: false,
      popupSwipeToClose: void 0,
      // defaults to app
      sheetPush: false,
      sheetSwipeToClose: void 0,
      // defaults to app
      sheetBackdrop: false,
      pageTitle: void 0,
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      popupTabletFullscreen: false,
      closeByBackdropClick: true,
      sheetCloseLinkText: "Done",
      searchbar: false,
      searchbarPlaceholder: "Search",
      searchbarDisableText: "Cancel",
      searchbarDisableButton: void 0,
      searchbarSpellcheck: false,
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: void 0,
      scrollToSelectedItem: false,
      formColorTheme: void 0,
      navbarColorTheme: void 0,
      routableModals: false,
      url: "select/",
      cssClass: "",
      /*
        Custom render functions
      */
      renderPage: void 0,
      renderPopup: void 0,
      renderSheet: void 0,
      renderPopover: void 0,
      renderItems: void 0,
      renderItem: void 0,
      renderSearchbar: void 0
    }
  },
  static: {
    SmartSelect: smart_select_class_default
  },
  create() {
    const app = this;
    app.smartSelect = extend(ConstructorMethods({
      defaultSelector: ".smart-select",
      constructor: smart_select_class_default,
      app,
      domProp: "f7SmartSelect"
    }), {
      open(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.open)
          return ss.open();
        return void 0;
      },
      close(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.close)
          return ss.close();
        return void 0;
      }
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    }
  },
  clicks: {
    ".smart-select": function open3($clickedEl, data) {
      const app = this;
      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app.smartSelect.create(extend({
          el: $clickedEl
        }, data));
        ss.open();
      }
    }
  },
  vnode: {
    "smart-select-init": {
      insert(vnode) {
        const app = this;
        const smartSelectEl = vnode.elm;
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      },
      destroy(vnode) {
        const smartSelectEl = vnode.elm;
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      }
    }
  }
};

// node_modules/framework7/components/grid/grid.js
function getElMinSize(dimension, $el) {
  let minSize = $el.css(`min-${dimension}`);
  if (minSize === "auto" || minSize === "none") {
    minSize = 0;
  } else if (minSize.indexOf("px") >= 0) {
    minSize = parseFloat(minSize);
  } else if (minSize.indexOf("%") >= 0) {
    minSize = $el.parent()[0][dimension === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(minSize) / 100;
  }
  return minSize;
}
function getElMaxSize(dimension, $el) {
  let maxSize = $el.css(`max-${dimension}`);
  if (maxSize === "auto" || maxSize === "none") {
    maxSize = null;
  } else if (maxSize.indexOf("px") >= 0) {
    maxSize = parseFloat(maxSize);
  } else if (maxSize.indexOf("%") >= 0) {
    maxSize = $el.parent()[0][dimension === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(maxSize) / 100;
  }
  return maxSize;
}
var Grid2 = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let $resizeHandlerEl;
    let $prevResizableEl;
    let $nextResizableEl;
    let prevElSize;
    let prevElMinSize;
    let prevElMaxSize;
    let nextElSize;
    let nextElMinSize;
    let nextElMaxSize;
    let parentSize;
    let itemsInFlow;
    let gapSize;
    let isScrolling;
    function handleTouchStart(e) {
      if (isTouched || isMoved)
        return;
      $resizeHandlerEl = dom7_default(e.target).closest(".resize-handler");
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      $prevResizableEl = void 0;
      $nextResizableEl = void 0;
      isScrolling = void 0;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const isRow = $resizeHandlerEl.parent(".row").length === 1;
      const sizeProp = isRow ? "height" : "width";
      const getSizeProp = isRow ? "offsetHeight" : "offsetWidth";
      if (!isMoved) {
        $prevResizableEl = $resizeHandlerEl.parent(isRow ? ".row" : ".col");
        if ($prevResizableEl.length && (!$prevResizableEl.hasClass("resizable") || $prevResizableEl.hasClass("resizable-fixed"))) {
          $prevResizableEl = $prevResizableEl.prevAll(".resizable:not(.resizable-fixed)").eq(0);
        }
        $nextResizableEl = $prevResizableEl.next(isRow ? ".row" : ".col");
        if ($nextResizableEl.length && (!$nextResizableEl.hasClass("resizable") || $nextResizableEl.hasClass("resizable-fixed"))) {
          $nextResizableEl = $nextResizableEl.nextAll(".resizable:not(.resizable-fixed)").eq(0);
        }
        if ($prevResizableEl.length) {
          prevElSize = $prevResizableEl[0][getSizeProp];
          prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
          prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
          parentSize = $prevResizableEl.parent()[0][getSizeProp];
          itemsInFlow = $prevResizableEl.parent().children(isRow ? ".row" : '[class*="col-"], .col').length;
          gapSize = parseFloat($prevResizableEl.css(isRow ? "--f7-grid-row-gap" : "--f7-grid-gap"));
        }
        if ($nextResizableEl.length) {
          nextElSize = $nextResizableEl[0][getSizeProp];
          nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
          nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);
          if (!$prevResizableEl.length) {
            parentSize = $nextResizableEl.parent()[0][getSizeProp];
            itemsInFlow = $nextResizableEl.parent().children(isRow ? ".row" : '[class*="col-"], .col').length;
            gapSize = parseFloat($nextResizableEl.css(isRow ? "--f7-grid-row-gap" : "--f7-grid-gap"));
          }
        }
      }
      isMoved = true;
      const touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined" && !isRow) {
        isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      const isAbsolute = $prevResizableEl.hasClass("resizable-absolute") || $nextResizableEl.hasClass("resizable-absolute");
      const resizeNextEl = !isRow || isRow && !isAbsolute;
      if (resizeNextEl && !$nextResizableEl.length || !$prevResizableEl.length) {
        isTouched = false;
        isMoved = false;
        return;
      }
      e.preventDefault();
      let diff = isRow ? touchCurrentY - touchStartY : touchCurrentX - touchStartX;
      let prevElNewSize;
      let nextElNewSize;
      if ($prevResizableEl.length) {
        prevElNewSize = prevElSize + diff;
        if (prevElNewSize < prevElMinSize) {
          prevElNewSize = prevElMinSize;
          diff = prevElNewSize - prevElSize;
        }
        if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
          prevElNewSize = prevElMaxSize;
          diff = prevElNewSize - prevElSize;
        }
      }
      if ($nextResizableEl.length && resizeNextEl) {
        nextElNewSize = nextElSize - diff;
        if (nextElNewSize < nextElMinSize) {
          nextElNewSize = nextElMinSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
        if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
          nextElNewSize = nextElMaxSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
      }
      if (isAbsolute) {
        $prevResizableEl[0].style[sizeProp] = `${prevElNewSize}px`;
        if (resizeNextEl) {
          $nextResizableEl[0].style[sizeProp] = `${nextElNewSize}px`;
        }
        $prevResizableEl.trigger("grid:resize");
        $nextResizableEl.trigger("grid:resize");
        app.emit("gridResize", $prevResizableEl[0]);
        app.emit("gridResize", $nextResizableEl[0]);
        return;
      }
      const gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
      const gapAddSizeCSS = isRow ? `${itemsInFlow - 1} * var(--f7-grid-row-gap) / ${itemsInFlow}` : "(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)";
      const prevElNewSizeNormalized = prevElNewSize + gapAddSize;
      const nextElNewSizeNormalized = nextElNewSize + gapAddSize;
      $prevResizableEl[0].style[sizeProp] = `calc(${prevElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $nextResizableEl[0].style[sizeProp] = `calc(${nextElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $prevResizableEl.trigger("grid:resize");
      $nextResizableEl.trigger("grid:resize");
      app.emit("gridResize", $prevResizableEl[0]);
      app.emit("gridResize", $nextResizableEl[0]);
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      if (!isMoved) {
        isTouched = false;
      }
      isTouched = false;
      isMoved = false;
    }
    const document = getDocument();
    dom7_default(document).on(app.touchEvents.start, ".col > .resize-handler, .row > .resize-handler", handleTouchStart);
    app.on("touchmove", handleTouchMove);
    app.on("touchend", handleTouchEnd);
  }
};
var grid_default = {
  name: "grid",
  create() {
    const app = this;
    extend(app, {
      grid: {
        init: Grid2.init.bind(app)
      }
    });
  },
  on: {
    init() {
      const app = this;
      app.grid.init();
    }
  }
};

// node_modules/framework7/components/calendar/calendar-class.js
var Calendar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const calendar = this;
    calendar.params = extend({}, app.params.calendar, params);
    let $containerEl;
    if (calendar.params.containerEl) {
      $containerEl = dom7_default(calendar.params.containerEl);
      if ($containerEl.length === 0)
        return calendar;
    }
    let $inputEl;
    if (calendar.params.inputEl) {
      $inputEl = dom7_default(calendar.params.inputEl);
    }
    const isHorizontal = calendar.params.direction === "horizontal";
    let inverter = 1;
    if (isHorizontal) {
      inverter = app.rtl ? -1 : 1;
    }
    extend(calendar, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      animating: false,
      allowTouchMove: true,
      hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple
    });
    calendar.dayFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        day: "numeric"
      });
      return formatter.format(date).replace(/日/, "");
    };
    calendar.monthFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        month: "long"
      });
      return formatter.format(date);
    };
    calendar.yearFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        year: "numeric"
      });
      return formatter.format(date);
    };
    calendar.timeSelectorFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);
      return formatter.format(date);
    };
    const timeFormatCheckDate = calendar.timeSelectorFormatter(/* @__PURE__ */ new Date()).toLowerCase();
    calendar.is12HoursFormat = timeFormatCheckDate.indexOf("pm") >= 0 || timeFormatCheckDate.indexOf("am") >= 0;
    let {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar.params;
    const {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    } = calendar.getIntlNames();
    if (monthNames === "auto")
      monthNames = monthNamesIntl;
    if (monthNamesShort === "auto")
      monthNamesShort = monthNamesShortIntl;
    if (dayNames === "auto")
      dayNames = dayNamesIntl;
    if (dayNamesShort === "auto")
      dayNamesShort = dayNamesShortIntl;
    extend(calendar, {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    });
    function onInputClick() {
      calendar.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onInputClear() {
      calendar.setValue([]);
      if (calendar.opened) {
        calendar.update();
      }
    }
    function onHtmlClick(e) {
      const $targetEl = dom7_default(e.target);
      if (calendar.destroyed || !calendar.params)
        return;
      if (calendar.isPopover())
        return;
      if (!calendar.opened || calendar.closing)
        return;
      if ($targetEl.closest('[class*="backdrop"]').length)
        return;
      if (calendar.monthPickerPopover || calendar.yearPickerPopover || calendar.timePickerPopover)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal, .calendar-modal").length === 0) {
          calendar.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal, .calendar-modal").length === 0) {
        calendar.close();
      }
    }
    extend(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on("click", onInputClick);
        calendar.$inputEl.on("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            calendar.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        calendar.$inputEl.off("click", onInputClick);
        calendar.$inputEl.off("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            delete calendar.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
      }
    });
    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;
      const {
        $el,
        $wrapperEl
      } = calendar;
      function handleTouchStart(e) {
        if (isMoved || isTouched)
          return;
        isTouched = true;
        touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = (/* @__PURE__ */ new Date()).getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = void 0;
        currentTranslate = calendar.monthsTranslate;
      }
      function handleTouchMove(e) {
        if (!isTouched)
          return;
        const {
          isHorizontal: isH
        } = calendar;
        touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === "undefined") {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isH && isScrolling || !calendar.allowTouchMove) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (calendar.animating) {
          isTouched = false;
          return;
        }
        allowItemClick = false;
        if (!isMoved) {
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }
        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = (calendar.monthsTranslate * calendar.inverter + percentage) * 100;
        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;
        touchEndTime = (/* @__PURE__ */ new Date()).getTime();
        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app.rtl)
              calendar.nextMonth();
            else
              calendar.prevMonth();
          } else if (app.rtl)
            calendar.prevMonth();
          else
            calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app.rtl)
            calendar.prevMonth();
          else
            calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app.rtl)
            calendar.nextMonth();
          else
            calendar.prevMonth();
        } else {
          calendar.resetMonth();
        }
        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }
      function handleDayClick(e) {
        if (!allowItemClick)
          return;
        let $dayEl = dom7_default(e.target).parents(".calendar-day");
        if ($dayEl.length === 0 && dom7_default(e.target).hasClass("calendar-day")) {
          $dayEl = dom7_default(e.target);
        }
        if ($dayEl.length === 0)
          return;
        if ($dayEl.hasClass("calendar-day-disabled"))
          return;
        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass("calendar-day-next"))
            calendar.nextMonth();
          if ($dayEl.hasClass("calendar-day-prev"))
            calendar.prevMonth();
        }
        const dateYear = parseInt($dayEl.attr("data-year"), 10);
        const dateMonth = parseInt($dayEl.attr("data-month"), 10);
        const dateDay = parseInt($dayEl.attr("data-day"), 10);
        calendar.emit("local::dayClick calendarDayClick", calendar, $dayEl[0], dateYear, dateMonth, dateDay);
        if (!$dayEl.hasClass("calendar-day-selected") || calendar.params.multiple || calendar.params.rangePicker) {
          const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);
          if (calendar.hasTimePicker) {
            if (calendar.value && calendar.value[0]) {
              valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
            } else {
              valueToAdd.setHours((/* @__PURE__ */ new Date()).getHours(), (/* @__PURE__ */ new Date()).getMinutes());
            }
          }
          calendar.addValue(valueToAdd);
        }
        if (calendar.params.closeOnSelect) {
          if (calendar.params.rangePicker && calendar.value.length === 2 || !calendar.params.rangePicker) {
            calendar.close();
          }
        }
      }
      function onNextMonthClick() {
        calendar.nextMonth();
      }
      function onPrevMonthClick() {
        calendar.prevMonth();
      }
      function onNextYearClick() {
        calendar.nextYear();
      }
      function onPrevYearClick() {
        calendar.prevYear();
      }
      function onMonthSelectorClick() {
        calendar.openMonthPicker();
      }
      function onYearSelectorClick() {
        calendar.openYearPicker();
      }
      function onTimeSelectorClick() {
        calendar.openTimePicker();
      }
      const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
        passive: true,
        capture: false
      } : false;
      $el.find(".calendar-prev-month-button").on("click", onPrevMonthClick);
      $el.find(".calendar-next-month-button").on("click", onNextMonthClick);
      $el.find(".calendar-prev-year-button").on("click", onPrevYearClick);
      $el.find(".calendar-next-year-button").on("click", onNextYearClick);
      if (calendar.params.monthPicker) {
        $el.find(".current-month-value").on("click", onMonthSelectorClick);
      }
      if (calendar.params.yearPicker) {
        $el.find(".current-year-value").on("click", onYearSelectorClick);
      }
      if (calendar.hasTimePicker) {
        $el.find(".calendar-time-selector a").on("click", onTimeSelectorClick);
      }
      $wrapperEl.on("click", handleDayClick);
      if (calendar.params.touchMove) {
        $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on("touchmove:active", handleTouchMove);
        app.on("touchend:passive", handleTouchEnd);
      }
      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find(".calendar-prev-month-button").off("click", onPrevMonthClick);
        $el.find(".calendar-next-month-button").off("click", onNextMonthClick);
        $el.find(".calendar-prev-year-button").off("click", onPrevYearClick);
        $el.find(".calendar-next-year-button").off("click", onNextYearClick);
        if (calendar.params.monthPicker) {
          $el.find(".current-month-value").off("click", onMonthSelectorClick);
        }
        if (calendar.params.yearPicker) {
          $el.find(".current-year-value").off("click", onYearSelectorClick);
        }
        if (calendar.hasTimePicker) {
          $el.find(".calendar-time-selector a").off("click", onTimeSelectorClick);
        }
        $wrapperEl.off("click", handleDayClick);
        if (calendar.params.touchMove) {
          $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off("touchmove:active", handleTouchMove);
          app.off("touchend:passive", handleTouchEnd);
        }
      };
    };
    calendar.init();
    return calendar;
  }
  get view() {
    const {
      $inputEl,
      app,
      params
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  getIntlNames() {
    const calendar = this;
    const locale = calendar.params.locale;
    const monthNamesIntl = [];
    const monthNamesShortIntl = [];
    const dayNamesIntl = [];
    const dayNamesShortIntl = [];
    const formatterMonthNames = new Intl.DateTimeFormat(locale, {
      month: "long"
    });
    const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, {
      month: "short"
    });
    const formatterDayNames = new Intl.DateTimeFormat(locale, {
      weekday: "long"
    });
    const formatterDayNamesShort = new Intl.DateTimeFormat(locale, {
      weekday: "short"
    });
    let year;
    let yearStarted;
    let yearEnded;
    for (let i = 0; i < 24; i += 1) {
      const date = (/* @__PURE__ */ new Date()).setMonth(i, 1);
      const currentYear = calendar.yearFormatter(date);
      if (year && currentYear !== year) {
        if (yearStarted)
          yearEnded = true;
        yearStarted = true;
        year = currentYear;
      }
      if (!year) {
        year = currentYear;
      }
      if (yearStarted && year === currentYear && !yearEnded) {
        monthNamesIntl.push(formatterMonthNames.format(date));
        monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
      }
    }
    const weekDay = (/* @__PURE__ */ new Date()).getDay();
    for (let i = 0; i < 7; i += 1) {
      const date = (/* @__PURE__ */ new Date()).getTime() + (i - weekDay) * 24 * 60 * 60 * 1e3;
      dayNamesIntl.push(formatterDayNames.format(date));
      dayNamesShortIntl.push(formatterDayNamesShort.format(date));
    }
    return {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    };
  }
  normalizeDate(date) {
    const calendar = this;
    const d = new Date(date);
    if (calendar.hasTimePicker) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
    }
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }
  normalizeValues(values) {
    const calendar = this;
    let newValues = [];
    if (values && Array.isArray(values)) {
      newValues = values.map((val) => calendar.normalizeDate(val));
    }
    return newValues;
  }
  initInput() {
    const calendar = this;
    if (!calendar.$inputEl)
      return;
    if (calendar.params.inputReadOnly)
      calendar.$inputEl.prop("readOnly", true);
  }
  isPopover() {
    const calendar = this;
    const {
      app,
      modal,
      params
    } = calendar;
    const device = getDevice();
    if (params.openIn === "sheet")
      return false;
    if (modal && modal.type !== "popover")
      return false;
    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === "popover")
        return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (device.desktop && app.theme === "aurora") {
        return true;
      }
    }
    return false;
  }
  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar;
    const {
      dateFormat,
      locale
    } = calendar.params;
    function twoDigits(number) {
      return number < 10 ? `0${number}` : number;
    }
    if (typeof dateFormat === "string") {
      const tokens = {
        yyyy: year,
        yy: String(year).substring(2),
        mm: twoDigits(month1),
        m: month1,
        MM: monthNames[month],
        M: monthNamesShort[month],
        dd: twoDigits(day),
        d: day,
        DD: dayNames[weekDay],
        D: dayNamesShort[weekDay]
      };
      if (calendar.params.timePicker) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        let hours12 = hours;
        if (hours > 12)
          hours12 = hours - 12;
        if (hours === 0)
          hours12 = 12;
        const a = hours >= 12 && hours !== 0 ? "pm" : "am";
        Object.assign(tokens, {
          HH: twoDigits(hours),
          H: hours,
          hh: twoDigits(hours12),
          h: hours12,
          ss: twoDigits(seconds),
          s: seconds,
          ":mm": twoDigits(minutes),
          ":m": minutes,
          a,
          A: a.toUpperCase()
        });
      }
      const regexp = new RegExp(Object.keys(tokens).map((t) => `(${t})`).join("|"), "g");
      return dateFormat.replace(regexp, (token) => {
        if (token in tokens)
          return tokens[token];
        return token;
      });
    }
    if (typeof dateFormat === "function") {
      return dateFormat(date);
    }
    const formatter = new Intl.DateTimeFormat(locale, dateFormat);
    return formatter.format(date);
  }
  formatValue() {
    const calendar = this;
    const {
      value
    } = calendar;
    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value);
    }
    return value.map((v) => calendar.formatDate(v)).join(calendar.params.rangePicker ? " - " : ", ");
  }
  addValue(newValue) {
    const calendar = this;
    const {
      multiple,
      rangePicker,
      rangePickerMinDays,
      rangePickerMaxDays
    } = calendar.params;
    if (multiple) {
      if (!calendar.value)
        calendar.value = [];
      let inValuesIndex;
      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }
      if (typeof inValuesIndex === "undefined") {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }
      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value)
        calendar.value = [];
      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }
      if (calendar.value.length === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1e3 && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1e3))
        calendar.value.push(newValue);
      else
        calendar.value = [];
      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }
  setValue(values) {
    const calendar = this;
    const currentValue = calendar.value;
    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
      let equal = true;
      currentValue.forEach((v, index) => {
        if (v !== values[index])
          equal = false;
      });
      if (equal)
        return;
    }
    calendar.value = values;
    calendar.updateValue();
  }
  getValue() {
    const calendar = this;
    return calendar.value;
  }
  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value,
      params
    } = calendar;
    let i;
    if ($el && $el.length > 0) {
      $wrapperEl.find(".calendar-day-selected").removeClass("calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right");
      let valueDate;
      if (params.rangePicker && value.length === 2) {
        const leftDate = new Date(value[0]).getTime();
        const rightDate = new Date(value[1]).getTime();
        for (i = leftDate; i <= rightDate; i += 24 * 60 * 60 * 1e3) {
          valueDate = new Date(i);
          let addClass = "calendar-day-selected";
          if (leftDate !== rightDate) {
            if (i !== leftDate && i !== rightDate) {
              addClass += " calendar-day-selected-range";
            }
            if (i === leftDate) {
              addClass += " calendar-day-selected-left";
            }
            if (i === rightDate) {
              addClass += " calendar-day-selected-right";
            }
          }
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass(addClass);
        }
        valueDate = new Date(leftDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-left");
        valueDate = new Date(rightDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-right");
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass("calendar-day-selected");
        }
      }
    }
    if (!onlyHeader) {
      calendar.emit("local::change calendarChange", calendar, value);
    }
    if ($el && $el.length > 0 && calendar.hasTimePicker) {
      $el.find(".calendar-time-selector a").text(value && value.length ? calendar.timeSelectorFormatter(value[0]) : calendar.params.timePickerPlaceholder);
    }
    if ($inputEl && $inputEl.length || params.header) {
      const inputValue = calendar.formatValue(value);
      if (params.header && $el && $el.length) {
        $el.find(".calendar-selected-date").text(inputValue);
      }
      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger("change");
      }
    }
  }
  updateCurrentMonthYear(dir) {
    const calendar = this;
    const {
      $months,
      $el,
      monthNames
    } = calendar;
    let currentLocaleMonth;
    let currentLocaleYear;
    if (typeof dir === "undefined") {
      calendar.currentMonth = parseInt($months.eq(1).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(1).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(1).attr("data-locale-month");
      currentLocaleYear = $months.eq(1).attr("data-locale-year");
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-month");
      currentLocaleYear = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-year");
    }
    $el.find(".current-month-value").text(monthNames[currentLocaleMonth]);
    $el.find(".current-year-value").text(currentLocaleYear);
  }
  update() {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl
    } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, "prev");
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, "next");
    $wrapperEl.transition(0).html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`).transform("translate3d(0,0,0)");
    calendar.$months = $wrapperEl.find(".calendar-month");
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
  }
  onMonthChangeStart(dir) {
    const calendar = this;
    const {
      $months,
      currentYear,
      currentMonth
    } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const currentIndex = dir === "next" ? $months.length - 1 : 0;
    $months.eq(currentIndex).addClass("calendar-month-current");
    $months.eq(dir === "next" ? currentIndex - 1 : currentIndex + 1).addClass(dir === "next" ? "calendar-month-prev" : "calendar-month-next");
    calendar.emit("local::monthYearChangeStart calendarMonthYearChangeStart", calendar, currentYear, currentMonth);
  }
  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl,
      monthsTranslate
    } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl.find(".calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)").remove();
    if (typeof dir === "undefined") {
      dir = "next";
      rebuildBoth = true;
    }
    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find(".calendar-month-next, .calendar-month-prev").remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "prev");
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "next");
    }
    if (dir === "next" || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }
    if (dir === "prev" || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }
    const $months = $wrapperEl.find(".calendar-month");
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit("local::monthAdd calendarMonthAdd", calendar, dir === "next" ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]);
    calendar.emit("local::monthYearChangeEnd calendarMonthYearChangeEnd", calendar, currentYear, currentMonth);
  }
  setMonthsTranslate(translate) {
    const calendar = this;
    const {
      $months,
      isHorizontal: isH,
      inverter
    } = calendar;
    translate = translate || calendar.monthsTranslate || 0;
    if (typeof calendar.monthsTranslate === "undefined") {
      calendar.monthsTranslate = translate;
    }
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
    $months.eq(1).transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`).addClass("calendar-month-current");
    $months.eq(2).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
  }
  nextMonth(transition) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition === "undefined" || typeof transition === "object") {
      transition = "";
      if (!params.animate)
        transition = 0;
    }
    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-month"), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-year"), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate -= 1;
    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const nextMonthHtml = dom7_default(calendar.renderMonth(nextDateTime, "next")).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(calendar.$months.length - 1)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("next");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("next");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("next");
    }
  }
  prevMonth(transition) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition === "undefined" || typeof transition === "object") {
      transition = "";
      if (!params.animate)
        transition = 0;
    }
    const prevMonth = parseInt(calendar.$months.eq(0).attr("data-month"), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr("data-year"), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (prevDateTime < minDate.getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate += 1;
    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const prevMonthHtml = dom7_default(calendar.renderMonth(prevDateTime, "prev")).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(0)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("prev");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("prev");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("prev");
    }
  }
  resetMonth(transition) {
    if (transition === void 0) {
      transition = "";
    }
    const calendar = this;
    const {
      $wrapperEl,
      inverter,
      isHorizontal: isH,
      monthsTranslate
    } = calendar;
    const translate = monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  }
  // eslint-disable-next-line
  setYearMonth(year, month, transition) {
    const calendar = this;
    const {
      params,
      isHorizontal: isH,
      $wrapperEl,
      inverter
    } = calendar;
    if (typeof year === "undefined")
      year = calendar.currentYear;
    if (typeof month === "undefined")
      month = calendar.currentMonth;
    if (typeof transition === "undefined" || typeof transition === "object") {
      transition = "";
      if (!params.animate)
        transition = 0;
    }
    let targetDate;
    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }
    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (targetDate < minDate.getTime()) {
        return false;
      }
    }
    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? "next" : "prev";
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating && transition !== 0;
    if (targetDate > currentDate) {
      calendar.monthsTranslate -= 1;
      if (!calendar.animating)
        calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months.eq(calendar.$months.length - 1).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-next");
    } else {
      calendar.monthsTranslate += 1;
      if (!calendar.animating)
        calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months.eq(0).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-prev");
    }
    calendar.emit("local::monthAdd calendarMonthAdd", dir === "next" ? calendar.$months.eq(calendar.$months.length - 1)[0] : calendar.$months.eq(0)[0]);
    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }
    if (!params.animate || transition === 0) {
      calendar.onMonthChangeEnd(dir, true);
    }
  }
  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }
  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  }
  // eslint-disable-next-line
  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range)
      return false;
    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime() && dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (range[i].date) {
          if (dayDate === new Date(range[i].date).getTime()) {
            match = true;
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if (dayDate <= new Date(range.to).getTime() && dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (range.date) {
      match = dayDate === new Date(range.date).getTime();
    } else if (typeof range === "function") {
      match = range(new Date(dayDate));
    }
    return match;
  }
  // eslint-disable-next-line
  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }
  renderMonths(date) {
    const calendar = this;
    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }
    return jsx_default("div", {
      class: "calendar-months-wrapper"
    }, calendar.renderMonth(date, "prev"), calendar.renderMonth(date), calendar.renderMonth(date, "next"));
  }
  renderMonth(d, offset) {
    const calendar = this;
    const {
      params,
      value
    } = calendar;
    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset);
    }
    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();
    let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
    if (localeMonth < 0)
      localeMonth = month;
    let localeYear = calendar.yearFormatter(date);
    if (offset === "next") {
      if (month === 11)
        date = new Date(year + 1, 0);
      else
        date = new Date(year, month + 1, 1);
    }
    if (offset === "prev") {
      if (month === 0)
        date = new Date(year - 1, 11);
      else
        date = new Date(year, month - 1, 1);
    }
    if (offset === "next" || offset === "prev") {
      month = date.getMonth();
      year = date.getFullYear();
      localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
      if (localeMonth < 0)
        localeMonth = month;
      localeYear = calendar.yearFormatter(date);
    }
    const currentValues = [];
    const today = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1e3);
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;
    let monthHtml = "";
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvents;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0)
      firstDayOfMonthIndex = 7;
    if (value && value.length) {
      for (let i = 0; i < value.length; i += 1) {
        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
      }
    }
    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = "";
      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass = "";
        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }
        const weekDayIndex = col - 1 + params.firstDay > 6 ? col - 1 - 7 + params.firstDay : col - 1 + params.firstDay;
        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass += " calendar-day-prev";
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;
          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass += " calendar-day-next";
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        }
        if (dayDate === today)
          addClass += " calendar-day-today";
        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) {
            addClass += " calendar-day-selected";
          }
          if (currentValues[0] !== currentValues[1]) {
            if (dayDate > currentValues[0] && dayDate < currentValues[1]) {
              addClass += " calendar-day-selected-range";
            }
            if (dayDate === currentValues[0]) {
              addClass += " calendar-day-selected-left";
            }
            if (dayDate === currentValues[1]) {
              addClass += " calendar-day-selected-right";
            }
          }
        } else if (currentValues.indexOf(dayDate) >= 0)
          addClass += " calendar-day-selected";
        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass += " calendar-day-weekend";
        }
        let eventsHtml = "";
        hasEvents = false;
        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvents = true;
          }
        }
        if (hasEvents) {
          addClass += " calendar-day-has-events";
          eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;
          if (Array.isArray(params.events)) {
            const eventDots = [];
            params.events.forEach((ev) => {
              const color = ev.color || "";
              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                eventDots.push(color);
              }
            });
            eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map((color) => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ""}"></span>
                `.trim()).join("")}
              </span>
            `;
          }
        }
        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        }
        disabled = false;
        if (minDate && dayDate < minDate || maxDate && dayDate > maxDate) {
          disabled = true;
        }
        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }
        if (disabled) {
          addClass += " calendar-day-disabled";
        }
        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        const dayNumberDisplay = calendar.dayFormatter(dayDate);
        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
      }
      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }
    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
    return monthHtml;
  }
  renderWeekHeader() {
    const calendar = this;
    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }
    const {
      params
    } = calendar;
    let weekDaysHtml = "";
    for (let i = 0; i < 7; i += 1) {
      const dayIndex = i + params.firstDay > 6 ? i - 7 + params.firstDay : i + params.firstDay;
      const dayName = calendar.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }
    return jsx_default("div", {
      class: "calendar-week-header"
    }, weekDaysHtml);
  }
  renderMonthSelector() {
    const calendar = this;
    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }
    return jsx_default("div", {
      class: "calendar-month-selector"
    }, jsx_default("a", {
      class: "link icon-only calendar-prev-month-button"
    }, jsx_default("i", {
      class: "icon icon-prev"
    })), calendar.params.monthPicker ? jsx_default("a", {
      class: "current-month-value link"
    }) : jsx_default("span", {
      class: "current-month-value"
    }), jsx_default("a", {
      class: "link icon-only calendar-next-month-button"
    }, jsx_default("i", {
      class: "icon icon-next"
    })));
  }
  renderYearSelector() {
    const calendar = this;
    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }
    return jsx_default("div", {
      class: "calendar-year-selector"
    }, jsx_default("a", {
      class: "link icon-only calendar-prev-year-button"
    }, jsx_default("i", {
      class: "icon icon-prev"
    })), calendar.params.yearPicker ? jsx_default("a", {
      class: "current-year-value link"
    }) : jsx_default("span", {
      class: "current-year-value"
    }), jsx_default("a", {
      class: "link icon-only calendar-next-year-button"
    }, jsx_default("i", {
      class: "icon icon-next"
    })));
  }
  // eslint-disable-next-line
  renderTimeSelector() {
    const calendar = this;
    const value = calendar.value && calendar.value[0];
    let timeString;
    if (value)
      timeString = calendar.timeSelectorFormatter(value);
    return jsx_default("div", {
      class: "calendar-time-selector"
    }, jsx_default("span", null, calendar.params.timePickerLabel), jsx_default("a", {
      class: "link"
    }, timeString || calendar.params.timePickerPlaceholder));
  }
  renderHeader() {
    const calendar = this;
    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }
    return jsx_default("div", {
      class: "calendar-header"
    }, jsx_default("div", {
      class: "calendar-selected-date"
    }, calendar.params.headerPlaceholder));
  }
  renderFooter() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }
    return jsx_default("div", {
      class: "calendar-footer"
    }, jsx_default("a", {
      class: `${app.theme === "md" ? "button" : "link"} calendar-close sheet-close popover-close`
    }, calendar.params.toolbarCloseText));
  }
  renderToolbar() {
    const calendar = this;
    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    }
    return jsx_default("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default("div", {
      class: "toolbar-inner"
    }, calendar.params.monthSelector ? calendar.renderMonthSelector() : "", calendar.params.yearSelector ? calendar.renderYearSelector() : ""));
  }
  // eslint-disable-next-line
  renderInline() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return jsx_default("div", {
      class: `calendar calendar-inline ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderCustomModal() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return jsx_default("div", {
      class: `calendar calendar-modal ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderSheet() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return jsx_default("div", {
      class: `sheet-modal calendar calendar-sheet ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default("div", {
      class: "sheet-modal-inner calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderPopover() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return jsx_default("div", {
      class: "popover calendar-popover"
    }, jsx_default("div", {
      class: "popover-inner"
    }, jsx_default("div", {
      class: `calendar ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter())));
  }
  render() {
    const calendar = this;
    const {
      params
    } = calendar;
    if (params.render)
      return params.render.call(calendar);
    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === "auto")
        modalType = calendar.isPopover() ? "popover" : "sheet";
      if (modalType === "popover")
        return calendar.renderPopover();
      if (modalType === "sheet")
        return calendar.renderSheet();
      return calendar.renderCustomModal();
    }
    return calendar.renderInline();
  }
  openMonthPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>');
    calendar.monthPickerPopover = app.popover.create({
      el: $el.find(".calendar-month-picker-popover"),
      targetEl: $el.find(".calendar-month-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeMonthPicker();
        },
        closed() {
          if (calendar.monthPickerPopover.$el)
            calendar.monthPickerPopover.$el.remove();
          calendar.monthPickerPopover.destroy();
          if (calendar.monthPickerInstance) {
            calendar.monthPickerInstance.close();
            calendar.monthPickerInstance.destroy();
          }
          delete calendar.monthPickerInstance;
          delete calendar.monthPickerPopover;
        }
      }
    });
    calendar.monthPickerPopover.open();
    const localeMonth = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const values = [];
    const displayValues = [];
    calendar.monthNames.forEach((m, index) => {
      values.push(index);
      displayValues.push(m);
    });
    calendar.monthPickerInstance = app.picker.create({
      containerEl: calendar.monthPickerPopover.$el.find(".calendar-month-picker"),
      value: [localeMonth],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values,
        displayValues
      }]
    });
  }
  closeMonthPicker() {
    const calendar = this;
    if (calendar.monthPickerPopover && calendar.monthPickerPopover.opened)
      calendar.monthPickerPopover.close();
    const index = calendar.monthPickerInstance.value[0];
    const localeMonthIndex = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const monthIndex = calendar.currentMonth;
    const diff = localeMonthIndex - monthIndex;
    const diffIndex = index - diff;
    calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
  }
  openYearPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>');
    calendar.yearPickerPopover = app.popover.create({
      el: $el.find(".calendar-year-picker-popover"),
      targetEl: $el.find(".calendar-year-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeYearPicker();
        },
        closed() {
          if (calendar.yearPickerPopover.$el)
            calendar.yearPickerPopover.$el.remove();
          calendar.yearPickerPopover.destroy();
          if (calendar.yearPickerInstance) {
            calendar.yearPickerInstance.close();
            calendar.yearPickerInstance.destroy();
          }
          delete calendar.yearPickerInstance;
          delete calendar.yearPickerPopover;
        }
      }
    });
    calendar.yearPickerPopover.open();
    const currentYear = calendar.currentYear;
    let yearMin = calendar.params.yearPickerMin || (/* @__PURE__ */ new Date()).getFullYear() - 100;
    if (calendar.params.minDate) {
      yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
    }
    let yearMax = calendar.params.yearPickerMax || (/* @__PURE__ */ new Date()).getFullYear() + 100;
    if (calendar.params.maxDate) {
      yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
    }
    const years = [];
    for (let i = yearMin; i <= yearMax; i += 1) {
      years.push(i);
    }
    calendar.yearPickerInstance = app.picker.create({
      containerEl: calendar.yearPickerPopover.$el.find(".calendar-year-picker"),
      value: [currentYear],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: years
      }]
    });
  }
  closeYearPicker() {
    const calendar = this;
    if (calendar.yearPickerPopover && calendar.yearPickerPopover.opened)
      calendar.yearPickerPopover.close();
    calendar.setYearMonth(calendar.yearPickerInstance.value[0], void 0, 0);
  }
  openTimePicker() {
    const calendar = this;
    const {
      $el,
      app,
      is12HoursFormat
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>');
    const hoursArr = [];
    const minutesArr = [];
    const hoursMin = is12HoursFormat ? 1 : 0;
    const hoursMax = is12HoursFormat ? 12 : 23;
    for (let i = hoursMin; i <= hoursMax; i += 1) {
      hoursArr.push(i);
    }
    for (let i = 0; i <= 59; i += 1) {
      minutesArr.push(i);
    }
    let value;
    if (calendar.value && calendar.value.length) {
      value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
    } else {
      value = [(/* @__PURE__ */ new Date()).getHours(), (/* @__PURE__ */ new Date()).getMinutes()];
    }
    if (is12HoursFormat) {
      value.push(value[0] < 12 ? "AM" : "PM");
      if (value[0] > 12)
        value[0] -= 12;
      if (value[0] === 0)
        value[0] = 12;
    }
    calendar.timePickerPopover = app.popover.create({
      el: $el.find(".calendar-time-picker-popover"),
      targetEl: $el.find(".calendar-time-selector .link"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeTimePicker();
        },
        closed() {
          if (calendar.timePickerPopover.$el)
            calendar.timePickerPopover.$el.remove();
          calendar.timePickerPopover.destroy();
          if (calendar.timePickerInstance) {
            calendar.timePickerInstance.close();
            calendar.timePickerInstance.destroy();
          }
          delete calendar.timePickerInstance;
          delete calendar.timePickerPopover;
        }
      }
    });
    calendar.timePickerPopover.open();
    calendar.timePickerInstance = app.picker.create({
      containerEl: calendar.timePickerPopover.$el.find(".calendar-time-picker"),
      value,
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: hoursArr
      }, {
        divider: true,
        content: ":"
      }, {
        values: minutesArr,
        displayValues: minutesArr.map((m) => m < 10 ? `0${m}` : m)
      }, ...is12HoursFormat ? [{
        values: ["AM", "PM"]
      }] : []]
    });
  }
  closeTimePicker() {
    const calendar = this;
    const {
      is12HoursFormat
    } = calendar;
    if (calendar.timePickerInstance) {
      const timePickerValue = calendar.timePickerInstance.value;
      let hours = parseInt(timePickerValue[0], 10);
      const minutes = parseInt(timePickerValue[1], 10);
      const period = calendar.timePickerInstance.value[2];
      if (is12HoursFormat) {
        if (period === "AM" && hours === 12) {
          hours = 0;
        } else if (period === "PM" && hours !== 12) {
          hours += 12;
        }
      }
      let value = calendar.value && calendar.value.length && calendar.value[0];
      if (!value) {
        value = /* @__PURE__ */ new Date();
        value.setHours(hours, minutes, 0, 0);
      } else {
        value = new Date(value);
        value.setHours(hours, minutes);
      }
      calendar.setValue([value]);
      if (calendar.timePickerPopover && calendar.timePickerPopover.opened)
        calendar.timePickerPopover.close();
    }
  }
  onOpen() {
    const calendar = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = calendar;
    calendar.closing = false;
    calendar.opened = true;
    calendar.opening = true;
    calendar.attachCalendarEvents();
    const updateValue = !value && params.value;
    if (!initialized) {
      if (value)
        calendar.setValue(value, 0);
      else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value) {
      calendar.setValue(value, 0);
    }
    calendar.updateCurrentMonthYear();
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    if (updateValue)
      calendar.updateValue();
    else if (params.header && value) {
      calendar.updateValue(true);
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    calendar.initialized = true;
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
    if ($el) {
      $el.trigger("calendar:open");
    }
    if ($inputEl) {
      $inputEl.trigger("calendar:open");
    }
    calendar.emit("local::open calendarOpen", calendar);
  }
  onOpened() {
    const calendar = this;
    calendar.opening = false;
    if (calendar.$el) {
      calendar.$el.trigger("calendar:opened");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:opened");
    }
    calendar.emit("local::opened calendarOpened", calendar);
  }
  onClose() {
    const calendar = this;
    const app = calendar.app;
    calendar.opening = false;
    calendar.closing = true;
    if (calendar.$inputEl) {
      if (app.theme === "md") {
        calendar.$inputEl.trigger("blur");
      } else {
        const validate = calendar.$inputEl.attr("validate");
        const required = calendar.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(calendar.$inputEl);
        }
      }
    }
    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:close");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:close");
    }
    calendar.emit("local::close calendarClose", calendar);
  }
  onClosed() {
    const calendar = this;
    calendar.opened = false;
    calendar.closing = false;
    if (!calendar.inline) {
      nextTick(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }
        delete calendar.modal;
      });
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy)
        calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:closed");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:closed");
    }
    calendar.emit("local::closed calendarClosed", calendar);
  }
  open() {
    const calendar = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      params
    } = calendar;
    if (opened)
      return;
    if (inline) {
      calendar.$el = dom7_default(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
      calendar.$months = calendar.$wrapperEl.find(".calendar-month");
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }
    let modalType = params.openIn;
    if (modalType === "auto") {
      modalType = calendar.isPopover() ? "popover" : "sheet";
    }
    const modalContent = calendar.render();
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: params.scrollToInput ? $inputEl : void 0,
      content: modalContent,
      backdrop: params.backdrop === true || modalType === "popover" && app.params.popover.backdrop !== false && params.backdrop !== false,
      closeByBackdropClick: params.closeByBackdropClick,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === "popover" ? modal.$el.find(".calendar") : modal.$el;
          calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
          calendar.$months = calendar.$wrapperEl.find(".calendar-month");
          calendar.$el[0].f7Calendar = calendar;
          if (modalType === "customModal") {
            dom7_default(calendar.$el).find(".calendar-close").once("click", () => {
              calendar.close();
            });
          }
          calendar.onOpen();
        },
        opened() {
          calendar.onOpened();
        },
        close() {
          calendar.onClose();
        },
        closed() {
          calendar.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && calendar.view) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams
        }
      });
    } else {
      calendar.modal = app[modalType].create(modalParams);
      calendar.modal.open();
    }
  }
  close() {
    const calendar = this;
    const {
      opened,
      inline
    } = calendar;
    if (!opened)
      return;
    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }
    if (calendar.params.routableModals && calendar.view) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }
  init() {
    const calendar = this;
    calendar.initInput();
    if (calendar.inline) {
      calendar.open();
      calendar.emit("local::init calendarInit", calendar);
      return;
    }
    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    }
    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }
    calendar.emit("local::init calendarInit", calendar);
  }
  destroy() {
    const calendar = this;
    if (calendar.destroyed)
      return;
    const {
      $el
    } = calendar;
    calendar.emit("local::beforeDestroy calendarBeforeDestroy", calendar);
    if ($el)
      $el.trigger("calendar:beforedestroy");
    calendar.close();
    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy)
        calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if ($el && $el.length)
      delete calendar.$el[0].f7Calendar;
    deleteProps(calendar);
    calendar.destroyed = true;
  }
};
var calendar_class_default = Calendar;

// node_modules/framework7/components/calendar/calendar.js
var calendar_default = {
  name: "calendar",
  static: {
    Calendar: calendar_class_default
  },
  create() {
    const app = this;
    app.calendar = ConstructorMethods({
      defaultSelector: ".calendar",
      constructor: calendar_class_default,
      app,
      domProp: "f7Calendar"
    });
    app.calendar.close = function close6(el) {
      if (el === void 0) {
        el = ".calendar";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || calendar && !calendar.opened)
        return;
      calendar.close();
    };
  },
  params: {
    calendar: {
      // Calendar settings
      dateFormat: void 0,
      monthNames: "auto",
      monthNamesShort: "auto",
      dayNames: "auto",
      dayNamesShort: "auto",
      locale: void 0,
      firstDay: 1,
      // First day of the week, Monday
      weekendDays: [0, 6],
      // Sunday and Saturday
      multiple: false,
      rangePicker: false,
      rangePickerMinDays: 1,
      // when calendar is used as rangePicker
      rangePickerMaxDays: 0,
      // when calendar is used as rangePicker, 0 means unlimited
      direction: "horizontal",
      // or 'vertical'
      minDate: null,
      maxDate: null,
      disabled: null,
      // dates range of disabled days
      events: null,
      // dates range of days with events
      rangesClasses: null,
      // array with custom classes date ranges
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      monthPicker: true,
      yearSelector: true,
      yearPicker: true,
      yearPickerMin: void 0,
      yearPickerMax: void 0,
      timePicker: false,
      timePickerLabel: "Time",
      timePickerFormat: {
        hour: "numeric",
        minute: "numeric"
      },
      timePickerPlaceholder: "Select time",
      weekHeader: true,
      value: null,
      // Common opener settings
      containerEl: null,
      openIn: "auto",
      // or 'popover' or 'sheet' or 'customModal'
      sheetPush: false,
      sheetSwipeToClose: void 0,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: "Select date",
      toolbar: true,
      toolbarCloseText: "Done",
      footer: false,
      cssClass: null,
      routableModals: false,
      view: null,
      url: "date/",
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null
    }
  }
};

// node_modules/framework7/components/picker/picker-column.js
function pickerColumn(colEl, updateItems) {
  const picker = this;
  const $colEl = dom7_default(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider)
    return;
  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find(".picker-items");
  col.items = col.$itemsEl.find(".picker-item");
  let itemHeight;
  let colHeight;
  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find(".picker-item");
    col.calcSize();
    col.setValue(col.values[0], true);
    col.attachEvents();
  };
  col.calcSize = function calcColSize() {
    colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    const hadPadding = col.el.style.getPropertyValue("--f7-picker-scroll-padding");
    col.el.style.setProperty("--f7-picker-scroll-padding", `${(colHeight - itemHeight) / 2}px`);
    if (!hadPadding) {
      col.$itemsEl[0].scrollTop = 0;
    }
  };
  col.setValue = function setColValue(newValue, valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
    if (typeof newActiveIndex === "undefined" || newActiveIndex === -1) {
      return;
    }
    const newScrollTop = newActiveIndex * itemHeight;
    col.$itemsEl[0].scrollTop = newScrollTop;
    col.updateItems(newActiveIndex, newScrollTop, valueCallbacks);
  };
  col.updateItems = function updateColItems(activeIndex, scrollTop, valueCallbacks) {
    if (typeof scrollTop === "undefined") {
      scrollTop = col.$itemsEl[0].scrollTop;
    }
    if (typeof activeIndex === "undefined") {
      activeIndex = Math.round(scrollTop / itemHeight);
    }
    if (activeIndex < 0)
      activeIndex = 0;
    if (activeIndex >= col.items.length)
      activeIndex = col.items.length - 1;
    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find(".picker-item-selected").removeClass("picker-item-selected");
    const selectedItem = col.items.eq(activeIndex);
    selectedItem.addClass("picker-item-selected").children().transform("");
    if (picker.params.rotateEffect) {
      col.items.each((itemEl) => {
        const $itemEl = dom7_default(itemEl);
        const itemOffset = itemEl.offsetTop - (colHeight - itemHeight) / 2 - scrollTop;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;
        let angle = -24 * percentage;
        if (angle > 180)
          angle = 180;
        if (angle < -180)
          angle = -180;
        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass("picker-item-far");
        } else {
          $itemEl.removeClass("picker-item-far");
        }
        $itemEl.children("span").transform(`translate3d(0, ${-percentage * itemHeight}px, -100px) rotateX(${angle}deg)`);
      });
    }
    if (valueCallbacks || typeof valueCallbacks === "undefined") {
      col.value = selectedItem.attr("data-picker-value");
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }
        picker.updateValue();
      }
    }
  };
  function handleScroll() {
    col.updateItems();
  }
  function handleClick() {
    const value = dom7_default(this).attr("data-picker-value");
    col.setValue(value);
  }
  col.attachEvents = function attachColEvents() {
    col.$itemsEl.on("scroll", handleScroll);
    col.items.on("click", handleClick);
  };
  col.detachEvents = function detachColEvents() {
    col.items.off("click", handleClick);
  };
  col.init = function initCol() {
    col.calcSize();
    if (colIndex === 0)
      col.$el.addClass("picker-column-first");
    if (colIndex === picker.cols.length - 1)
      col.$el.addClass("picker-column-last");
    if (picker.params.freeMode)
      col.$el.addClass("picker-column-free-mode");
    if (updateItems)
      col.updateItems(0);
    col.attachEvents();
  };
  col.destroy = function destroyCol() {
    col.detachEvents();
  };
  col.init();
}

// node_modules/framework7/components/picker/picker-class.js
var Picker = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const picker = this;
    const device = getDevice();
    const window = getWindow();
    picker.params = extend({}, app.params.picker, params);
    let $containerEl;
    if (picker.params.containerEl) {
      $containerEl = dom7_default(picker.params.containerEl);
      if ($containerEl.length === 0)
        return picker;
    }
    let $inputEl;
    if (picker.params.inputEl) {
      $inputEl = dom7_default(picker.params.inputEl);
    }
    let $scrollToEl = picker.params.scrollToInput ? $inputEl : void 0;
    if (picker.params.scrollToEl) {
      const scrollToEl = dom7_default(picker.params.scrollToEl);
      if (scrollToEl.length > 0) {
        $scrollToEl = scrollToEl;
      }
    }
    extend(picker, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: device.ios || window.navigator.userAgent.toLowerCase().indexOf("safari") >= 0 && window.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 && !device.android,
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $scrollToEl,
      initialized: false,
      opened: false,
      url: picker.params.url
    });
    function onResize() {
      picker.resizeCols();
    }
    function onInputClick() {
      picker.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    let htmlTouchStartTarget = null;
    function onHtmlTouchStart(e) {
      htmlTouchStartTarget = e.target;
    }
    function onHtmlClick(e) {
      if (picker.destroyed || !picker.params)
        return;
      const $targetEl = dom7_default(e.target);
      if (picker.isPopover())
        return;
      if (!picker.opened || picker.closing)
        return;
      if ($targetEl.closest('[class*="backdrop"]').length)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if (htmlTouchStartTarget === e.target && $targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal").length === 0) {
          picker.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal").length === 0) {
        picker.close();
      }
    }
    extend(picker, {
      attachResizeEvent() {
        app.on("resize", onResize);
      },
      detachResizeEvent() {
        app.off("resize", onResize);
      },
      attachInputEvents() {
        picker.$inputEl.on("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.on("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            picker.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        picker.$inputEl.off("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.off("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            delete picker.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
        app.on("touchstart", onHtmlTouchStart);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
        app.off("touchstart", onHtmlTouchStart);
      }
    });
    picker.init();
    return picker;
  }
  get view() {
    const {
      app,
      params,
      $inputEl
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  initInput() {
    const picker = this;
    if (!picker.$inputEl)
      return;
    if (picker.params.inputReadOnly)
      picker.$inputEl.prop("readOnly", true);
  }
  resizeCols() {
    const picker = this;
    if (!picker.opened)
      return;
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, false);
      }
    }
  }
  isPopover() {
    const picker = this;
    const {
      app,
      modal,
      params
    } = picker;
    const device = getDevice();
    if (params.openIn === "sheet")
      return false;
    if (modal && modal.type !== "popover")
      return false;
    if (!picker.inline && picker.inputEl) {
      if (params.openIn === "popover")
        return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (device.desktop && app.theme === "aurora") {
        return true;
      }
    }
    return false;
  }
  formatValue() {
    const picker = this;
    const {
      value,
      displayValue
    } = picker;
    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value, displayValue);
    }
    return value.join(" ");
  }
  setValue(values) {
    const picker = this;
    let valueIndex = 0;
    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex]);
        valueIndex += 1;
      }
    }
  }
  getValue() {
    const picker = this;
    return picker.value;
  }
  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;
    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter((c) => !c.divider);
      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];
        if (column.displayValues !== void 0 && column.values !== void 0 && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }
    if (newValue.indexOf(void 0) >= 0) {
      return;
    }
    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit("local::change pickerChange", picker, picker.value, picker.displayValue);
    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger("change");
    }
  }
  initColumn(colEl, updateItems) {
    const picker = this;
    pickerColumn.call(picker, colEl, updateItems);
  }
  // eslint-disable-next-line
  destroyColumn(colEl) {
    const picker = this;
    const $colEl = dom7_default(colEl);
    const index = $colEl.index();
    if (picker.cols[index] && picker.cols[index].destroy) {
      picker.cols[index].destroy();
    }
  }
  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar)
      return picker.params.renderToolbar.call(picker, picker);
    return jsx_default("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default("div", {
      class: "toolbar-inner"
    }, jsx_default("div", {
      class: "left"
    }), jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link sheet-close popover-close"
    }, picker.params.toolbarCloseText))));
  }
  // eslint-disable-next-line
  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ""} ${col.cssClass || ""}`;
    let columnHtml;
    let columnItemsHtml;
    if (col.divider) {
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      columnItemsHtml = col.values.map((value, index) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index] : value}</span>
        </div>
      `).join("");
      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }
    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }
  renderInline() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const inlineHtml = jsx_default("div", {
      class: `picker picker-inline ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default("div", {
      class: "picker-center-highlight"
    })));
    return inlineHtml;
  }
  renderSheet() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const sheetHtml = jsx_default("div", {
      class: `sheet-modal picker picker-sheet ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default("div", {
      class: "sheet-modal-inner picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default("div", {
      class: "picker-center-highlight"
    })));
    return sheetHtml;
  }
  renderPopover() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const popoverHtml = jsx_default("div", {
      class: "popover picker-popover"
    }, jsx_default("div", {
      class: "popover-inner"
    }, jsx_default("div", {
      class: `picker ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default("div", {
      class: "picker-center-highlight"
    })))));
    return popoverHtml;
  }
  render() {
    const picker = this;
    if (picker.params.render)
      return picker.params.render.call(picker);
    if (!picker.inline) {
      if (picker.isPopover())
        return picker.renderPopover();
      return picker.renderSheet();
    }
    return picker.renderInline();
  }
  onOpen() {
    const picker = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = picker;
    picker.opened = true;
    picker.closing = false;
    picker.opening = true;
    picker.attachResizeEvent();
    $el.find(".picker-column").each((colEl) => {
      let updateItems = true;
      if (!initialized && params.value || initialized && value) {
        updateItems = false;
      }
      picker.initColumn(colEl, updateItems);
    });
    if (!initialized) {
      if (value)
        picker.setValue(value);
      else if (params.value) {
        picker.setValue(params.value);
      }
    } else if (value) {
      picker.setValue(value);
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    picker.initialized = true;
    if ($el) {
      $el.trigger("picker:open");
    }
    if ($inputEl) {
      $inputEl.trigger("picker:open");
    }
    picker.emit("local::open pickerOpen", picker);
  }
  onOpened() {
    const picker = this;
    picker.opening = false;
    if (picker.$el) {
      picker.$el.trigger("picker:opened");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:opened");
    }
    picker.emit("local::opened pickerOpened", picker);
  }
  onClose() {
    const picker = this;
    const app = picker.app;
    picker.opening = false;
    picker.closing = true;
    picker.detachResizeEvent();
    picker.cols.forEach((col) => {
      if (col.destroy)
        col.destroy();
    });
    if (picker.$inputEl) {
      if (app.theme === "md") {
        picker.$inputEl.trigger("blur");
      } else {
        const validate = picker.$inputEl.attr("validate");
        const required = picker.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(picker.$inputEl);
        }
      }
    }
    if (picker.$el) {
      picker.$el.trigger("picker:close");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:close");
    }
    picker.emit("local::close pickerClose", picker);
  }
  onClosed() {
    const picker = this;
    picker.opened = false;
    picker.closing = false;
    if (!picker.inline) {
      nextTick(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }
        delete picker.modal;
      });
    }
    if (picker.$el) {
      picker.$el.trigger("picker:closed");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:closed");
    }
    picker.emit("local::closed pickerClosed", picker);
  }
  open() {
    const picker = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $scrollToEl,
      params
    } = picker;
    if (opened)
      return;
    if (picker.cols.length === 0 && params.cols.length) {
      params.cols.forEach((col) => {
        picker.cols.push(col);
      });
    }
    if (inline) {
      picker.$el = dom7_default(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }
    const isPopover = picker.isPopover();
    const modalType = isPopover ? "popover" : "sheet";
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: $scrollToEl,
      content: picker.render(),
      backdrop: typeof params.backdrop !== "undefined" ? params.backdrop : isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find(".picker") : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },
        opened() {
          picker.onOpened();
        },
        close() {
          picker.onClose();
        },
        closed() {
          picker.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && picker.view) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams
        }
      });
    } else {
      picker.modal = app[modalType].create(modalParams);
      picker.modal.open();
    }
  }
  close() {
    const picker = this;
    const {
      opened,
      inline
    } = picker;
    if (!opened)
      return;
    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }
    if (picker.params.routableModals && picker.view) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }
  init() {
    const picker = this;
    picker.initInput();
    if (picker.inline) {
      picker.open();
      picker.emit("local::init pickerInit", picker);
      return;
    }
    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    }
    if (picker.$inputEl) {
      picker.attachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }
    picker.emit("local::init pickerInit", picker);
  }
  destroy() {
    const picker = this;
    if (picker.destroyed)
      return;
    const {
      $el
    } = picker;
    picker.emit("local::beforeDestroy pickerBeforeDestroy", picker);
    if ($el)
      $el.trigger("picker:beforedestroy");
    picker.close();
    if (picker.$inputEl) {
      picker.detachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }
    if ($el && $el.length)
      delete picker.$el[0].f7Picker;
    deleteProps(picker);
    picker.destroyed = true;
  }
};
var picker_class_default = Picker;

// node_modules/framework7/components/picker/picker.js
var picker_default = {
  name: "picker",
  static: {
    Picker: picker_class_default
  },
  create() {
    const app = this;
    app.picker = ConstructorMethods({
      defaultSelector: ".picker",
      constructor: picker_class_default,
      app,
      domProp: "f7Picker"
    });
    app.picker.close = function close6(el) {
      if (el === void 0) {
        el = ".picker";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const picker = $el[0].f7Picker;
      if (!picker || picker && !picker.opened)
        return;
      picker.close();
    };
  },
  params: {
    picker: {
      // Picker settings
      rotateEffect: false,
      freeMode: false,
      cols: [],
      // Common opener settings
      containerEl: null,
      openIn: "auto",
      // or 'popover' or 'sheet'
      sheetPush: false,
      sheetSwipeToClose: void 0,
      backdrop: void 0,
      // uses Popover or Sheet defaults
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      scrollToEl: void 0,
      toolbar: true,
      toolbarCloseText: "Done",
      cssClass: null,
      routableModals: false,
      view: null,
      url: "select/",
      // Render functions
      renderToolbar: null,
      render: null
    }
  }
};

// node_modules/framework7/components/infinite-scroll/infinite-scroll.js
var InfiniteScroll = {
  handle(el, e) {
    const app = this;
    const $el = dom7_default(el);
    const scrollTop = $el[0].scrollTop;
    const scrollHeight = $el[0].scrollHeight;
    const height = $el[0].offsetHeight;
    let distance = $el[0].getAttribute("data-infinite-distance");
    const virtualListContainer = $el.find(".virtual-list");
    let virtualList;
    const onTop = $el.hasClass("infinite-scroll-top");
    if (!distance)
      distance = 50;
    if (typeof distance === "string" && distance.indexOf("%") >= 0) {
      distance = parseInt(distance, 10) / 100 * height;
    }
    if (distance > height)
      distance = height;
    if (onTop) {
      if (scrollTop < distance) {
        $el.trigger("infinite", e);
        app.emit("infinite", $el[0], e);
      }
    } else if (scrollTop + height >= scrollHeight - distance) {
      if (virtualListContainer.length > 0) {
        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
          return;
        }
      }
      $el.trigger("infinite", e);
      app.emit("infinite", $el[0], e);
    }
  },
  create(el) {
    const $el = dom7_default(el);
    const app = this;
    function scrollHandler(e) {
      app.infiniteScroll.handle(this, e);
    }
    $el.each((element) => {
      element.f7InfiniteScrollHandler = scrollHandler;
      element.addEventListener("scroll", element.f7InfiniteScrollHandler);
    });
  },
  destroy(el) {
    const $el = dom7_default(el);
    $el.each((element) => {
      element.removeEventListener("scroll", element.f7InfiniteScrollHandler);
      delete element.f7InfiniteScrollHandler;
    });
  }
};
var infinite_scroll_default = {
  name: "infiniteScroll",
  create() {
    const app = this;
    bindMethods(app, {
      infiniteScroll: InfiniteScroll
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      const $isEls = $tabEl.find(".infinite-scroll-content");
      if ($tabEl.is(".infinite-scroll-content"))
        $isEls.add($tabEl);
      $isEls.each((el) => {
        app.infiniteScroll.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = dom7_default(tabEl);
      const app = this;
      const $isEls = $tabEl.find(".infinite-scroll-content");
      if ($tabEl.is(".infinite-scroll-content"))
        $isEls.add($tabEl);
      $isEls.each((el) => {
        app.infiniteScroll.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".infinite-scroll-content").each((el) => {
        app.infiniteScroll.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".infinite-scroll-content").each((el) => {
        app.infiniteScroll.destroy(el);
      });
    }
  }
};

// node_modules/framework7/components/pull-to-refresh/pull-to-refresh-class.js
var PullToRefresh = class extends class_default {
  constructor(app, el) {
    super({}, [app]);
    const ptr = this;
    const device = getDevice();
    const support = getSupport();
    const $el = dom7_default(el);
    const $preloaderEl = $el.find(".ptr-preloader");
    ptr.$el = $el;
    ptr.el = $el[0];
    ptr.app = app;
    ptr.bottom = ptr.$el.hasClass("ptr-bottom");
    ptr.useModulesParams({});
    const isMaterial = app.theme === "md";
    const isIos = app.theme === "ios";
    const isAurora = app.theme === "aurora";
    ptr.done = function done() {
      const $transitionTarget = isMaterial ? $preloaderEl : $el;
      const onTranstionEnd = (e) => {
        if (dom7_default(e.target).closest($preloaderEl).length)
          return;
        $el.removeClass("ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing");
        $el.trigger("ptr:done");
        ptr.emit("local::done ptrDone", $el[0]);
        $transitionTarget.off("transitionend", onTranstionEnd);
      };
      $transitionTarget.on("transitionend", onTranstionEnd);
      $el.removeClass("ptr-refreshing").addClass("ptr-transitioning ptr-closing");
      return ptr;
    };
    ptr.refresh = function refresh2() {
      if ($el.hasClass("ptr-refreshing"))
        return ptr;
      $el.addClass("ptr-transitioning ptr-refreshing");
      $el.trigger("ptr:refresh", ptr.done);
      ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      return ptr;
    };
    ptr.mousewheel = $el.attr("data-ptr-mousewheel") === "true";
    let touchId;
    let isTouched;
    let isMoved;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let refresh = false;
    let useTranslate = false;
    let forceUseTranslate = false;
    let startTranslate = 0;
    let translate;
    let scrollTop;
    let wasScrolled;
    let triggerDistance;
    let dynamicTriggerDistance;
    let pullStarted;
    let hasNavbar = false;
    let scrollHeight;
    let offsetHeight;
    let maxScrollTop;
    const $pageEl = $el.parents(".page");
    if ($pageEl.find(".navbar").length > 0 || $pageEl.parents(".view").children(".navbars").length > 0)
      hasNavbar = true;
    if ($pageEl.hasClass("no-navbar"))
      hasNavbar = false;
    if (!ptr.bottom) {
      const pageNavbarEl = app.navbar.getElByPage($pageEl[0]);
      if (pageNavbarEl) {
        const $pageNavbarEl = dom7_default(pageNavbarEl);
        const isLargeTransparent = $pageNavbarEl.hasClass("navbar-large-transparent") || $pageNavbarEl.hasClass("navbar-large") && $pageNavbarEl.hasClass("navbar-transparent");
        const isTransparent = $pageNavbarEl.hasClass("navbar-transparent") && !$pageNavbarEl.hasClass("navbar-large");
        if (isLargeTransparent) {
          $el.addClass("ptr-with-navbar-large-transparent");
        } else if (isTransparent) {
          $el.addClass("ptr-with-navbar-transparent");
        }
      }
    }
    if (!hasNavbar && !ptr.bottom)
      $el.addClass("ptr-no-navbar");
    if ($el.attr("data-ptr-distance")) {
      dynamicTriggerDistance = true;
    } else if (isMaterial) {
      triggerDistance = 66;
    } else if (isIos) {
      triggerDistance = 44;
    } else if (isAurora) {
      triggerDistance = 38;
    }
    function setPreloaderProgress(progress) {
      if (progress === void 0) {
        progress = 0;
      }
      const $bars = $preloaderEl.find(".preloader-inner-line");
      const perBarProgress = 1 / $bars.length;
      $bars.forEach((barEl, barIndex) => {
        const barProgress = (progress - barIndex * perBarProgress) / perBarProgress;
        barEl.style.opacity = Math.max(Math.min(barProgress, 1), 0) * 0.27;
      });
    }
    function unsetPreloaderProgress() {
      $preloaderEl.find(".preloader-inner-line").css("opacity", "");
    }
    function handleTouchStart(e) {
      if (isTouched) {
        if (device.os === "android") {
          if ("targetTouches" in e && e.targetTouches.length > 1)
            return;
        } else
          return;
      }
      if ($el.hasClass("ptr-refreshing")) {
        return;
      }
      if (dom7_default(e.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length)
        return;
      isMoved = false;
      pullStarted = false;
      isTouched = true;
      isScrolling = void 0;
      wasScrolled = void 0;
      if (e.type === "touchstart")
        touchId = e.targetTouches[0].identifier;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      let pageX;
      let pageY;
      let touch;
      if (e.type === "touchmove") {
        if (touchId && e.touches) {
          for (let i = 0; i < e.touches.length; i += 1) {
            if (e.touches[i].identifier === touchId) {
              touch = e.touches[i];
            }
          }
        }
        if (!touch)
          touch = e.targetTouches[0];
        pageX = touch.pageX;
        pageY = touch.pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (!pageX || !pageY)
        return;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (!isScrolling) {
        isTouched = false;
        return;
      }
      scrollTop = $el[0].scrollTop;
      if (!isMoved) {
        $el.removeClass("ptr-transitioning");
        if (isIos) {
          setPreloaderProgress(0);
        }
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          isTouched = false;
          return;
        }
        const $ptrWatchScrollable = dom7_default(e.target).closest(".ptr-watch-scroll");
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableEl) => {
            if (ptrScrollableEl === el)
              return;
            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && dom7_default(ptrScrollableEl).css("overflow") === "auto" && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          isTouched = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr("data-ptr-distance");
          if (triggerDistance.indexOf("%") >= 0)
            triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }
        startTranslate = $el.hasClass("ptr-refreshing") ? triggerDistance : 0;
        if (scrollHeight === offsetHeight || device.os !== "ios" || isMaterial) {
          useTranslate = true;
        } else {
          useTranslate = false;
        }
        forceUseTranslate = false;
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      if (typeof wasScrolled === "undefined" && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0))
        wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;
      if (ptrStarted) {
        if (device.os === "ios" && parseInt(device.osVersion.split(".")[0], 10) > 7) {
          if (!ptr.bottom && scrollTop === 0 && !wasScrolled)
            useTranslate = true;
          if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled)
            useTranslate = true;
        }
        if (!useTranslate && ptr.bottom && !isMaterial) {
          $el.css("-webkit-overflow-scrolling", "auto");
          $el.scrollTop(maxScrollTop);
          forceUseTranslate = true;
        }
        if (useTranslate || forceUseTranslate) {
          if (e.cancelable) {
            e.preventDefault();
          }
          translate = (ptr.bottom ? -1 * Math.abs(touchesDiff) ** 0.85 : touchesDiff ** 0.85) + startTranslate;
          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
          } else {
            if (ptr.bottom || isIos) {
              $el.children().transform(`translate3d(0,${translate}px,0)`);
            } else {
              $el.transform(`translate3d(0,${translate}px,0)`);
            }
            if (isIos) {
              $preloaderEl.transform(`translate3d(0,0px,0)`);
            }
          }
        } else if (isIos && !ptr.bottom) {
          $preloaderEl.transform(`translate3d(0,${scrollTop}px,0)`);
        }
        let progress;
        if (isIos && !refresh) {
          progress = useTranslate || forceUseTranslate ? Math.abs(touchesDiff) ** 0.85 / triggerDistance : Math.abs(touchesDiff) / (triggerDistance * 2);
          setPreloaderProgress(progress);
        }
        if ((useTranslate || forceUseTranslate) && Math.abs(touchesDiff) ** 0.85 > triggerDistance || !useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2) {
          refresh = true;
          $el.addClass("ptr-pull-up").removeClass("ptr-pull-down");
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass("ptr-pull-up").addClass("ptr-pull-down");
        }
        if (!pullStarted) {
          $el.trigger("ptr:pullstart");
          ptr.emit("local::pullStart ptrPullStart", $el[0]);
          pullStarted = true;
        }
        $el.trigger("ptr:pullmove", {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit("local::pullMove ptrPullMove", $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass("ptr-pull-up ptr-pull-down");
        refresh = false;
      }
    }
    function handleTouchEnd(e) {
      if (e.type === "touchend" && e.changedTouches && e.changedTouches.length > 0 && touchId) {
        if (e.changedTouches[0].identifier !== touchId) {
          isTouched = false;
          isScrolling = false;
          isMoved = false;
          touchId = null;
          return;
        }
      }
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      if (translate) {
        $el.addClass("ptr-transitioning");
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform("").find(".ptr-arrow").transform("");
      } else {
        $preloaderEl.transform("");
        if (ptr.bottom || isIos) {
          $el.children().transform("");
        } else {
          $el.transform("");
        }
      }
      if (!useTranslate && ptr.bottom && !isMaterial) {
        $el.css("-webkit-overflow-scrolling", "");
      }
      if (refresh) {
        $el.addClass("ptr-refreshing");
        $el.trigger("ptr:refresh", ptr.done);
        ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      } else {
        $el.removeClass("ptr-pull-down");
      }
      isTouched = false;
      isMoved = false;
      if (pullStarted) {
        $el.trigger("ptr:pullend");
        ptr.emit("local::pullEnd ptrPullEnd", $el[0]);
      }
    }
    let mousewheelTimeout;
    let mousewheelMoved;
    let mousewheelAllow = true;
    let mousewheelTranslate = 0;
    function handleMouseWheelRelease() {
      mousewheelAllow = true;
      mousewheelMoved = false;
      mousewheelTranslate = 0;
      if (translate) {
        $el.addClass("ptr-transitioning");
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform("").find(".ptr-arrow").transform("");
      } else {
        $preloaderEl.transform("");
        if (ptr.bottom) {
          $el.children().transform("");
        } else {
          $el.transform("");
        }
      }
      if (refresh) {
        $el.addClass("ptr-refreshing");
        $el.trigger("ptr:refresh", ptr.done);
        ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      } else {
        $el.removeClass("ptr-pull-down");
      }
      if (pullStarted) {
        $el.trigger("ptr:pullend");
        ptr.emit("local::pullEnd ptrPullEnd", $el[0]);
      }
    }
    function handleMouseWheel(e) {
      if (!mousewheelAllow)
        return;
      const {
        deltaX,
        deltaY
      } = e;
      if (Math.abs(deltaX) > Math.abs(deltaY))
        return;
      if ($el.hasClass("ptr-refreshing")) {
        return;
      }
      if (dom7_default(e.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length)
        return;
      clearTimeout(mousewheelTimeout);
      scrollTop = $el[0].scrollTop;
      if (!mousewheelMoved) {
        $el.removeClass("ptr-transitioning");
        if (isIos) {
          setPreloaderProgress(0);
        }
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          mousewheelAllow = false;
          return;
        }
        const $ptrWatchScrollable = dom7_default(e.target).closest(".ptr-watch-scroll");
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableEl) => {
            if (ptrScrollableEl === el)
              return;
            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && dom7_default(ptrScrollableEl).css("overflow") === "auto" && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          mousewheelAllow = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr("data-ptr-distance");
          if (triggerDistance.indexOf("%") >= 0)
            triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }
      }
      isMoved = true;
      mousewheelTranslate -= deltaY;
      touchesDiff = mousewheelTranslate;
      if (typeof wasScrolled === "undefined" && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0))
        wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;
      if (ptrStarted) {
        if (e.cancelable) {
          e.preventDefault();
        }
        translate = touchesDiff;
        if (Math.abs(translate) > triggerDistance) {
          translate = triggerDistance + (Math.abs(translate) - triggerDistance) ** 0.7;
          if (ptr.bottom)
            translate = -translate;
        }
        if (isMaterial) {
          $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
        } else {
          if (ptr.bottom) {
            $el.children().transform(`translate3d(0,${translate}px,0)`);
          } else {
            $el.transform(`translate3d(0,${translate}px,0)`);
            if (isIos) {
              $preloaderEl.transform(`translate3d(0,${-translate}px,0)`);
            }
          }
        }
        let progress;
        if (isIos && !refresh) {
          progress = Math.abs(translate) / triggerDistance;
          setPreloaderProgress(progress);
        }
        if (Math.abs(translate) > triggerDistance) {
          refresh = true;
          $el.addClass("ptr-pull-up").removeClass("ptr-pull-down");
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass("ptr-pull-up").addClass("ptr-pull-down");
        }
        if (!pullStarted) {
          $el.trigger("ptr:pullstart");
          ptr.emit("local::pullStart ptrPullStart", $el[0]);
          pullStarted = true;
        }
        $el.trigger("ptr:pullmove", {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit("local::pullMove ptrPullMove", $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass("ptr-pull-up ptr-pull-down");
        refresh = false;
      }
      mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
    }
    if (!$pageEl.length || !$el.length)
      return ptr;
    $el[0].f7PullToRefresh = ptr;
    ptr.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.on("wheel", handleMouseWheel);
      }
    };
    ptr.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.off("wheel", handleMouseWheel);
      }
    };
    ptr.useModules();
    ptr.init();
    return ptr;
  }
  init() {
    const ptr = this;
    ptr.attachEvents();
  }
  destroy() {
    let ptr = this;
    ptr.emit("local::beforeDestroy ptrBeforeDestroy", ptr);
    ptr.$el.trigger("ptr:beforedestroy");
    delete ptr.el.f7PullToRefresh;
    ptr.detachEvents();
    deleteProps(ptr);
    ptr = null;
  }
};
var pull_to_refresh_class_default = PullToRefresh;

// node_modules/framework7/components/pull-to-refresh/pull-to-refresh.js
var pull_to_refresh_default = {
  name: "pullToRefresh",
  create() {
    const app = this;
    app.ptr = extend(ConstructorMethods({
      defaultSelector: ".ptr-content",
      constructor: pull_to_refresh_class_default,
      app,
      domProp: "f7PullToRefresh"
    }), {
      done(el) {
        const ptr = app.ptr.get(el);
        if (ptr)
          return ptr.done();
        return void 0;
      },
      refresh(el) {
        const ptr = app.ptr.get(el);
        if (ptr)
          return ptr.refresh();
        return void 0;
      }
    });
  },
  static: {
    PullToRefresh: pull_to_refresh_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      const $ptrEls = $tabEl.find(".ptr-content");
      if ($tabEl.is(".ptr-content"))
        $ptrEls.add($tabEl);
      $ptrEls.each((el) => {
        app.ptr.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = dom7_default(tabEl);
      const app = this;
      const $ptrEls = $tabEl.find(".ptr-content");
      if ($tabEl.is(".ptr-content"))
        $ptrEls.add($tabEl);
      $ptrEls.each((el) => {
        app.ptr.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".ptr-content").each((el) => {
        app.ptr.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".ptr-content").each((el) => {
        app.ptr.destroy(el);
      });
    }
  }
};

// node_modules/framework7/components/lazy/lazy.js
var Lazy2 = {
  destroy(pageEl) {
    const $pageEl = dom7_default(pageEl).closest(".page");
    if (!$pageEl.length)
      return;
    if ($pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy();
    }
  },
  create(pageEl) {
    const app = this;
    const window = getWindow();
    const support = getSupport();
    const $pageEl = dom7_default(pageEl).closest(".page").eq(0);
    const $lazyLoadImages = $pageEl.find(".lazy");
    if ($lazyLoadImages.length === 0 && !$pageEl.hasClass("lazy"))
      return;
    const placeholderSrc = app.params.lazy.placeholder;
    if (placeholderSrc !== false) {
      $lazyLoadImages.each((lazyEl) => {
        if (dom7_default(lazyEl).attr("data-src") && !dom7_default(lazyEl).attr("src"))
          dom7_default(lazyEl).attr("src", placeholderSrc);
      });
    }
    const imagesSequence = [];
    let imageIsLoading = false;
    function onImageComplete(lazyEl) {
      if (imagesSequence.indexOf(lazyEl) >= 0) {
        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
      }
      imageIsLoading = false;
      if (app.params.lazy.sequential && imagesSequence.length > 0) {
        imageIsLoading = true;
        app.lazy.loadImage(imagesSequence[0], onImageComplete);
      }
    }
    function observerCallback(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          if (app.params.lazy.sequential && imageIsLoading) {
            if (imagesSequence.indexOf(entry.target) < 0)
              imagesSequence.push(entry.target);
            return;
          }
          imageIsLoading = true;
          app.lazy.loadImage(entry.target, onImageComplete);
          observer.unobserve(entry.target);
        }
      });
    }
    if (app.params.lazy.observer && support.intersectionObserver) {
      let observer = $pageEl[0].f7LazyObserver;
      if (!observer) {
        observer = new window.IntersectionObserver(observerCallback, {
          root: $pageEl[0]
        });
      }
      $lazyLoadImages.each((el) => {
        if (el.f7LazyObserverAdded)
          return;
        el.f7LazyObserverAdded = true;
        observer.observe(el);
      });
      if (!$pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy = () => {
          observer.disconnect();
          delete $pageEl[0].f7LazyDestroy;
          delete $pageEl[0].f7LazyObserver;
        };
      }
      return;
    }
    function lazyHandler() {
      app.lazy.load($pageEl, (lazyEl) => {
        if (app.params.lazy.sequential && imageIsLoading) {
          if (imagesSequence.indexOf(lazyEl) < 0)
            imagesSequence.push(lazyEl);
          return;
        }
        imageIsLoading = true;
        app.lazy.loadImage(lazyEl, onImageComplete);
      });
    }
    function attachEvents() {
      $pageEl[0].f7LazyAttached = true;
      $pageEl.on("lazy", lazyHandler);
      $pageEl.on("scroll", lazyHandler, true);
      $pageEl.find(".tab").on("tab:mounted tab:show", lazyHandler);
      app.on("resize", lazyHandler);
    }
    function detachEvents() {
      $pageEl[0].f7LazyAttached = false;
      delete $pageEl[0].f7LazyAttached;
      $pageEl.off("lazy", lazyHandler);
      $pageEl.off("scroll", lazyHandler, true);
      $pageEl.find(".tab").off("tab:mounted tab:show", lazyHandler);
      app.off("resize", lazyHandler);
    }
    if (!$pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy = detachEvents;
    }
    if (!$pageEl[0].f7LazyAttached) {
      attachEvents();
    }
    lazyHandler();
  },
  isInViewport(lazyEl) {
    const app = this;
    const rect = lazyEl.getBoundingClientRect();
    const threshold = app.params.lazy.threshold || 0;
    return rect.top >= 0 - threshold && rect.left >= 0 - threshold && rect.top <= app.height + threshold && rect.left <= app.width + threshold;
  },
  loadImage(imageEl, callback) {
    const app = this;
    const window = getWindow();
    const $imageEl = dom7_default(imageEl);
    const bg = $imageEl.attr("data-background");
    const src = bg || $imageEl.attr("data-src");
    function onLoad() {
      $imageEl.removeClass("lazy").addClass("lazy-loaded");
      if (bg) {
        $imageEl.css("background-image", `url(${src})`);
      } else if (src) {
        $imageEl.attr("src", src);
      }
      if (callback)
        callback(imageEl);
      $imageEl.trigger("lazy:loaded");
      app.emit("lazyLoaded", $imageEl[0]);
    }
    if (!src) {
      $imageEl.trigger("lazy:load");
      app.emit("lazyLoad", $imageEl[0]);
      onLoad();
      return;
    }
    function onError() {
      $imageEl.removeClass("lazy").addClass("lazy-loaded");
      if (bg) {
        $imageEl.css("background-image", `url(${app.params.lazy.placeholder || ""})`);
      } else {
        $imageEl.attr("src", app.params.lazy.placeholder || "");
      }
      if (callback)
        callback(imageEl);
      $imageEl.trigger("lazy:error");
      app.emit("lazyError", $imageEl[0]);
    }
    const image = new window.Image();
    image.onload = onLoad;
    image.onerror = onError;
    image.src = src;
    $imageEl.removeAttr("data-src").removeAttr("data-background");
    $imageEl.trigger("lazy:load");
    app.emit("lazyLoad", $imageEl[0]);
  },
  load(pageEl, callback) {
    const app = this;
    let $pageEl = dom7_default(pageEl);
    if (!$pageEl.hasClass("page"))
      $pageEl = $pageEl.parents(".page").eq(0);
    if ($pageEl.length === 0) {
      return;
    }
    $pageEl.find(".lazy").each((lazyEl) => {
      const $lazyEl = dom7_default(lazyEl);
      if ($lazyEl.parents(".tab:not(.tab-active)").length > 0) {
        return;
      }
      if (app.lazy.isInViewport(lazyEl)) {
        if (callback)
          callback(lazyEl);
        else
          app.lazy.loadImage(lazyEl);
      }
    });
  }
};
var lazy_default = {
  name: "lazy",
  params: {
    lazy: {
      placeholder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
      threshold: 0,
      sequential: true,
      observer: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      lazy: Lazy2
    });
  },
  on: {
    pageInit(page) {
      const app = this;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.create(page.$el);
      }
    },
    pageAfterIn(page) {
      const app = this;
      const support = getSupport();
      if (app.params.lazy.observer && support.intersectionObserver)
        return;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.create(page.$el);
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.destroy(page.$el);
      }
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      if ($tabEl.find(".lazy").length > 0 || $tabEl.hasClass("lazy")) {
        app.lazy.create($tabEl);
      }
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      const support = getSupport();
      if (app.params.lazy.observer && support.intersectionObserver)
        return;
      const $tabEl = dom7_default(tabEl);
      if ($tabEl.find(".lazy").length > 0 || $tabEl.hasClass("lazy")) {
        app.lazy.destroy($tabEl);
      }
    }
  }
};

// node_modules/framework7/components/data-table/data-table-class.js
var DataTable = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const table = this;
    const defaults = {};
    table.useModulesParams(defaults);
    table.params = extend(defaults, params);
    const $el = dom7_default(table.params.el);
    if ($el.length === 0)
      return void 0;
    table.$el = $el;
    table.el = $el[0];
    if (table.$el[0].f7DataTable) {
      const instance = table.$el[0].f7DataTable;
      table.destroy();
      return instance;
    }
    table.$el[0].f7DataTable = table;
    extend(table, {
      collapsible: $el.hasClass("data-table-collapsible"),
      // Headers
      $headerEl: $el.find(".data-table-header"),
      $headerSelectedEl: $el.find(".data-table-header-selected")
    });
    function handleChange(e) {
      if (e.detail && e.detail.sentByF7DataTable) {
        return;
      }
      const $inputEl = dom7_default(this);
      const checked = $inputEl[0].checked;
      const columnIndex = $inputEl.parents("td,th").index();
      if ($inputEl.parents("thead").length > 0) {
        if (columnIndex === 0) {
          $el.find("tbody tr")[checked ? "addClass" : "removeClass"]("data-table-row-selected");
        }
        $el.find(`tbody tr td:nth-child(${columnIndex + 1}) input`).prop("checked", checked).trigger("change", {
          sentByF7DataTable: true
        });
        $inputEl.prop("indeterminate", false);
      } else {
        if (columnIndex === 0) {
          $inputEl.parents("tr")[checked ? "addClass" : "removeClass"]("data-table-row-selected");
        }
        const checkedRows = $el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length;
        const totalRows = $el.find("tbody tr").length;
        const $headCheckboxEl = $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`);
        if (!checked) {
          $headCheckboxEl.prop("checked", false);
        } else if (checkedRows === totalRows) {
          $headCheckboxEl.prop("checked", true).trigger("change", {
            sentByF7DataTable: true
          });
        }
        $headCheckboxEl.prop("indeterminate", checkedRows > 0 && checkedRows < totalRows);
      }
      table.checkSelectedHeader();
    }
    function handleSortableClick() {
      const $cellEl = dom7_default(this);
      const isActive = $cellEl.hasClass("sortable-cell-active");
      const currentSort = $cellEl.hasClass("sortable-desc") ? "desc" : "asc";
      let newSort;
      if (isActive) {
        newSort = currentSort === "desc" ? "asc" : "desc";
        $cellEl.removeClass("sortable-desc sortable-asc").addClass(`sortable-${newSort}`);
      } else {
        $el.find("thead .sortable-cell-active").removeClass("sortable-cell-active");
        $cellEl.addClass("sortable-cell-active");
        newSort = currentSort;
      }
      $cellEl.trigger("datatable:sort", newSort);
      table.emit("local::sort dataTableSort", table, newSort);
    }
    table.attachEvents = function attachEvents() {
      table.$el.on("change", '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find("thead .sortable-cell").on("click", handleSortableClick);
    };
    table.detachEvents = function detachEvents() {
      table.$el.off("change", '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find("thead .sortable-cell").off("click", handleSortableClick);
    };
    table.useModules();
    table.init();
    return table;
  }
  setCollapsibleLabels() {
    const table = this;
    if (!table.collapsible)
      return;
    table.$el.find("tbody td:not(.checkbox-cell)").each((el) => {
      const $el = dom7_default(el);
      const elIndex = $el.index();
      const collapsibleTitle = $el.attr("data-collapsible-title");
      if (!collapsibleTitle && collapsibleTitle !== "") {
        $el.attr("data-collapsible-title", table.$el.find("thead th").eq(elIndex).text());
      }
    });
  }
  checkSelectedHeader() {
    const table = this;
    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
      const checkedItems = table.$el.find("tbody .checkbox-cell input:checked").length;
      table.$el[checkedItems > 0 ? "addClass" : "removeClass"]("data-table-has-checked");
      table.$headerSelectedEl.find(".data-table-selected-count").text(checkedItems);
    }
  }
  init() {
    const table = this;
    table.attachEvents();
    table.setCollapsibleLabels();
    table.checkSelectedHeader();
  }
  destroy() {
    let table = this;
    table.$el.trigger("datatable:beforedestroy");
    table.emit("local::beforeDestroy dataTableBeforeDestroy", table);
    table.attachEvents();
    if (table.$el[0]) {
      table.$el[0].f7DataTable = null;
      delete table.$el[0].f7DataTable;
    }
    deleteProps(table);
    table = null;
  }
};
var data_table_class_default = DataTable;

// node_modules/framework7/components/data-table/data-table.js
var data_table_default = {
  name: "dataTable",
  static: {
    DataTable: data_table_class_default
  },
  create() {
    const app = this;
    app.dataTable = ConstructorMethods({
      defaultSelector: ".data-table",
      constructor: data_table_class_default,
      app,
      domProp: "f7DataTable"
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".data-table-init").each((tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".data-table-init").each((tableEl) => {
        app.dataTable.create({
          el: tableEl
        });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".data-table-init").each((tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".data-table-init").each((tableEl) => {
        app.dataTable.create({
          el: tableEl
        });
      });
    }
  },
  vnode: {
    "data-table-init": {
      insert(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.create({
          el: tableEl
        });
      },
      destroy(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.destroy(tableEl);
      }
    }
  }
};

// node_modules/framework7/components/fab/fab.js
var Fab = {
  morphOpen(fabEl, targetEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    const $targetEl = dom7_default(targetEl);
    if ($targetEl.length === 0)
      return;
    $targetEl.transition(0).addClass("fab-morph-target-visible");
    const target = {
      width: $targetEl[0].offsetWidth,
      height: $targetEl[0].offsetHeight,
      offset: $targetEl.offset(),
      borderRadius: $targetEl.css("border-radius"),
      zIndex: $targetEl.css("z-index")
    };
    const fab = {
      width: $fabEl[0].offsetWidth,
      height: $fabEl[0].offsetHeight,
      offset: $fabEl.offset(),
      translateX: getTranslate($fabEl[0], "x"),
      translateY: getTranslate($fabEl[0], "y")
    };
    $fabEl[0].f7FabMorphData = {
      $targetEl,
      target,
      fab
    };
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
    if (borderRadius > 0)
      borderRadius += 2;
    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
      $fabEl.transition(0).transform("");
      $targetEl.transition(0);
      target.width = $targetEl[0].offsetWidth;
      target.height = $targetEl[0].offsetHeight;
      target.offset = $targetEl.offset();
      fab.offset = $fabEl.offset();
      const diffXNew = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
      const diffYNew = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
      const scaleXNew = target.width / fab.width;
      const scaleYNew = target.height / fab.height;
      $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
    };
    $targetEl.css("opacity", 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.addClass("fab-opened").css("z-index", target.zIndex - 1).transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $targetEl.transition("");
      nextFrame(() => {
        $targetEl.css("opacity", 1).transform("scale(1,1)");
        $fabEl.transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`).css("border-radius", `${borderRadius}px`).css("box-shadow", "none").css("opacity", "0");
      });
      app.on("resize", $fabEl[0].f7FabMorphResizeHandler);
      if ($targetEl.parents(".page-content").length > 0) {
        $targetEl.parents(".page-content").on("scroll", $fabEl[0].f7FabMorphResizeHandler);
      }
    });
  },
  morphClose(fabEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    const morphData = $fabEl[0].f7FabMorphData;
    if (!morphData)
      return;
    const {
      $targetEl,
      target,
      fab
    } = morphData;
    if ($targetEl.length === 0)
      return;
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    app.off("resize", $fabEl[0].f7FabMorphResizeHandler);
    if ($targetEl.parents(".page-content").length > 0) {
      $targetEl.parents(".page-content").off("scroll", $fabEl[0].f7FabMorphResizeHandler);
    }
    $targetEl.css("opacity", 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.transition("").css("box-shadow", "").css("border-radius", "").css("opacity", "1").transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $fabEl.css("z-index", "").removeClass("fab-opened").transform("");
      nextFrame(() => {
        $fabEl.transitionEnd(() => {
          $targetEl.removeClass("fab-morph-target-visible").css("opacity", "").transform("").transition("");
        });
      });
    });
  },
  open(fabEl, targetEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl).eq(0);
    const $buttonsEl = $fabEl.find(".fab-buttons");
    if (!$fabEl.length)
      return;
    if ($fabEl.hasClass("fab-opened"))
      return;
    if (!$buttonsEl.length && !$fabEl.hasClass("fab-morph"))
      return;
    if (app.fab.openedEl) {
      if (app.fab.openedEl === $fabEl[0])
        return;
      app.fab.close(app.fab.openedEl);
    }
    app.fab.openedEl = $fabEl[0];
    if ($fabEl.hasClass("fab-morph")) {
      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr("data-morph-to"));
    } else {
      $fabEl.addClass("fab-opened");
    }
    $fabEl.siblings(".fab-backdrop").addClass("backdrop-in");
    $fabEl.trigger("fab:open");
  },
  close(fabEl) {
    if (fabEl === void 0) {
      fabEl = ".fab-opened";
    }
    const app = this;
    const $fabEl = dom7_default(fabEl).eq(0);
    const $buttonsEl = $fabEl.find(".fab-buttons");
    if (!$fabEl.length)
      return;
    if (!$fabEl.hasClass("fab-opened"))
      return;
    if (!$buttonsEl.length && !$fabEl.hasClass("fab-morph"))
      return;
    app.fab.openedEl = null;
    if ($fabEl.hasClass("fab-morph")) {
      app.fab.morphClose($fabEl);
    } else {
      $fabEl.removeClass("fab-opened");
    }
    $fabEl.siblings(".fab-backdrop").removeClass("backdrop-in");
    $fabEl.trigger("fab:close");
  },
  toggle(fabEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    if (!$fabEl.hasClass("fab-opened"))
      app.fab.open(fabEl);
    else
      app.fab.close(fabEl);
  }
};
var fab_default = {
  name: "fab",
  create() {
    const app = this;
    bindMethods(app, {
      fab: {
        openedEl: null,
        ...Fab
      }
    });
  },
  clicks: {
    ".fab > a": function open4($clickedEl) {
      const app = this;
      app.fab.toggle($clickedEl.parents(".fab"));
    },
    ".fab-open": function open5($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.fab.open(data.fab);
    },
    ".fab-close": function close4($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.fab.close(data.fab);
    },
    ".fab-backdrop": function close5() {
      const app = this;
      app.fab.close();
    }
  }
};

// node_modules/framework7/components/searchbar/searchbar-class.js
var Searchbar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const sb = this;
    const defaults = {
      el: void 0,
      inputEl: void 0,
      inputEvents: "change input compositionend",
      disableButton: true,
      disableButtonEl: void 0,
      backdropEl: void 0,
      searchContainer: void 0,
      // container to search, HTMLElement or CSS selector
      searchItem: "li",
      // single item selector, CSS selector
      searchIn: void 0,
      // where to search in item, CSS selector
      searchGroup: ".list-group",
      searchGroupTitle: ".item-divider, .list-group-title",
      ignore: ".searchbar-ignore",
      foundEl: ".searchbar-found",
      notFoundEl: ".searchbar-not-found",
      hideOnEnableEl: ".searchbar-hide-on-enable",
      hideOnSearchEl: ".searchbar-hide-on-search",
      backdrop: void 0,
      removeDiacritics: true,
      customSearch: false,
      hideDividers: true,
      hideGroups: true,
      disableOnBackdropClick: true,
      expandable: false,
      inline: false
    };
    sb.useModulesParams(defaults);
    sb.params = extend(defaults, params);
    const $el = dom7_default(sb.params.el);
    if ($el.length === 0)
      return sb;
    if ($el[0].f7Searchbar)
      return $el[0].f7Searchbar;
    $el[0].f7Searchbar = sb;
    let $pageEl;
    const $navbarEl = $el.parents(".navbar");
    if ($el.parents(".page").length > 0) {
      $pageEl = $el.parents(".page");
    } else if ($navbarEl.length > 0) {
      $pageEl = dom7_default(app.navbar.getPageByEl($navbarEl[0]));
      if (!$pageEl.length) {
        const $currentPageEl = $el.parents(".view").find(".page-current");
        if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
          $pageEl = $currentPageEl;
        }
      }
    }
    let $foundEl;
    if (params.foundEl) {
      $foundEl = dom7_default(params.foundEl);
    } else if (typeof sb.params.foundEl === "string" && $pageEl) {
      $foundEl = $pageEl.find(sb.params.foundEl);
    }
    let $notFoundEl;
    if (params.notFoundEl) {
      $notFoundEl = dom7_default(params.notFoundEl);
    } else if (typeof sb.params.notFoundEl === "string" && $pageEl) {
      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
    }
    let $hideOnEnableEl;
    if (params.hideOnEnableEl) {
      $hideOnEnableEl = dom7_default(params.hideOnEnableEl);
    } else if (typeof sb.params.hideOnEnableEl === "string" && $pageEl) {
      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
    }
    let $hideOnSearchEl;
    if (params.hideOnSearchEl) {
      $hideOnSearchEl = dom7_default(params.hideOnSearchEl);
    } else if (typeof sb.params.hideOnSearchEl === "string" && $pageEl) {
      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
    }
    const expandable = sb.params.expandable || $el.hasClass("searchbar-expandable");
    const inline = sb.params.inline || $el.hasClass("searchbar-inline");
    if (typeof sb.params.backdrop === "undefined") {
      if (!inline)
        sb.params.backdrop = app.theme !== "aurora";
      else
        sb.params.backdrop = false;
    }
    let $backdropEl;
    if (sb.params.backdrop) {
      if (sb.params.backdropEl) {
        $backdropEl = dom7_default(sb.params.backdropEl);
      } else if ($pageEl && $pageEl.length > 0) {
        $backdropEl = $pageEl.find(".searchbar-backdrop");
      } else {
        $backdropEl = $el.siblings(".searchbar-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="searchbar-backdrop"></div>');
        if ($pageEl && $pageEl.length) {
          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
            $backdropEl.insertBefore($el);
          } else {
            $backdropEl.insertBefore($pageEl.find(".page-content").eq(0));
          }
        } else {
          $backdropEl.insertBefore($el);
        }
      }
    }
    let $searchContainer;
    if (sb.params.searchContainer) {
      $searchContainer = dom7_default(sb.params.searchContainer);
    }
    let $inputEl;
    if (sb.params.inputEl) {
      $inputEl = dom7_default(sb.params.inputEl);
    } else {
      $inputEl = $el.find('input[type="search"]').eq(0);
    }
    let $disableButtonEl;
    if (sb.params.disableButton) {
      if (sb.params.disableButtonEl) {
        $disableButtonEl = dom7_default(sb.params.disableButtonEl);
      } else {
        $disableButtonEl = $el.find(".searchbar-disable-button");
      }
    }
    extend(sb, {
      app,
      view: app.views.get($el.parents(".view")),
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      $searchContainer,
      searchContainer: $searchContainer && $searchContainer[0],
      $inputEl,
      inputEl: $inputEl[0],
      $disableButtonEl,
      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
      disableButtonHasMargin: false,
      $pageEl,
      pageEl: $pageEl && $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl && $navbarEl[0],
      $foundEl,
      foundEl: $foundEl && $foundEl[0],
      $notFoundEl,
      notFoundEl: $notFoundEl && $notFoundEl[0],
      $hideOnEnableEl,
      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
      $hideOnSearchEl,
      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
      previousQuery: "",
      query: "",
      isVirtualList: $searchContainer && $searchContainer.hasClass("virtual-list"),
      virtualList: void 0,
      enabled: false,
      expandable,
      inline
    });
    function preventSubmit(e) {
      e.preventDefault();
    }
    function onInputFocus(e) {
      sb.enable(e);
      sb.$el.addClass("searchbar-focused");
    }
    function onInputBlur() {
      sb.$el.removeClass("searchbar-focused");
      if (app.theme === "aurora" && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
        sb.disable();
      }
    }
    function onInputChange() {
      const value = sb.$inputEl.val().trim();
      if (sb.$searchContainer && sb.$searchContainer.length > 0 && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem) || sb.params.customSearch) {
        sb.search(value, true);
      }
    }
    function onInputClear(e, previousValue) {
      sb.$el.trigger("searchbar:clear", previousValue);
      sb.emit("local::clear searchbarClear", sb, previousValue);
    }
    function disableOnClick(e) {
      sb.disable(e);
    }
    function onPageBeforeOut() {
      if (!sb || sb && !sb.$el)
        return;
      if (sb.enabled) {
        sb.$el.removeClass("searchbar-enabled");
        if (sb.expandable) {
          sb.$el.parents(".navbar").removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition");
        }
      }
    }
    function onPageBeforeIn() {
      if (!sb || sb && !sb.$el)
        return;
      if (sb.enabled) {
        sb.$el.addClass("searchbar-enabled");
        if (sb.expandable) {
          sb.$el.parents(".navbar").addClass("with-searchbar-expandable-enabled-no-transition");
        }
      }
    }
    sb.attachEvents = function attachEvents() {
      $el.on("submit", preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.on("click", disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.on("click", disableOnClick);
      }
      if (sb.expandable && app.theme === "ios" && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.on("page:beforeout", onPageBeforeOut);
        sb.$pageEl.on("page:beforein", onPageBeforeIn);
      }
      sb.$inputEl.on("focus", onInputFocus);
      sb.$inputEl.on("blur", onInputBlur);
      sb.$inputEl.on(sb.params.inputEvents, onInputChange);
      sb.$inputEl.on("input:clear", onInputClear);
    };
    sb.detachEvents = function detachEvents() {
      $el.off("submit", preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.off("click", disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.off("click", disableOnClick);
      }
      if (sb.expandable && app.theme === "ios" && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.off("page:beforeout", onPageBeforeOut);
        sb.$pageEl.off("page:beforein", onPageBeforeIn);
      }
      sb.$inputEl.off("focus", onInputFocus);
      sb.$inputEl.off("blur", onInputBlur);
      sb.$inputEl.off(sb.params.inputEvents, onInputChange);
      sb.$inputEl.off("input:clear", onInputClear);
    };
    sb.useModules();
    sb.init();
    return sb;
  }
  clear(e) {
    const sb = this;
    if (!sb.query && e && dom7_default(e.target).hasClass("searchbar-clear")) {
      sb.disable();
      return sb;
    }
    const previousQuery = sb.value;
    sb.$inputEl.val("").trigger("change").focus();
    sb.$el.trigger("searchbar:clear", previousQuery);
    sb.emit("local::clear searchbarClear", sb, previousQuery);
    return sb;
  }
  setDisableButtonMargin() {
    const sb = this;
    if (sb.expandable)
      return;
    const app = sb.app;
    sb.$disableButtonEl.transition(0).show();
    sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, `${-sb.disableButtonEl.offsetWidth}px`);
    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
    sb.$disableButtonEl.transition("");
    sb.disableButtonHasMargin = true;
  }
  enable(setFocus) {
    const sb = this;
    if (sb.enabled)
      return sb;
    const app = sb.app;
    const document = getDocument();
    const device = getDevice();
    sb.enabled = true;
    function enable3() {
      if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch) && !sb.$el.hasClass("searchbar-enabled") && !sb.query) {
        sb.backdropShow();
      }
      sb.$el.addClass("searchbar-enabled");
      if (!sb.$disableButtonEl || sb.$disableButtonEl && sb.$disableButtonEl.length === 0) {
        sb.$el.addClass("searchbar-enabled-no-disable-button");
      }
      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== "md") {
        if (!sb.disableButtonHasMargin) {
          sb.setDisableButtonMargin();
        }
        sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, "0px");
      }
      if (sb.expandable) {
        const $navbarEl = sb.$el.parents(".navbar");
        if ($navbarEl.hasClass("navbar-large") && sb.$pageEl) {
          const $pageContentEl = sb.$pageEl.find(".page-content");
          const $titleLargeEl = $navbarEl.find(".title-large");
          $pageContentEl.addClass("with-searchbar-expandable-enabled");
          if ($navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-large-collapsed") && $titleLargeEl.length && $pageContentEl.length) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop -= $titleLargeEl[0].offsetHeight;
            setTimeout(() => {
              $pageContentEl.transition("");
            }, 200);
          }
        }
        if (app.theme === "md" && $navbarEl.length) {
          $navbarEl.addClass("with-searchbar-expandable-enabled");
        } else {
          $navbarEl.addClass("with-searchbar-expandable-enabled");
          if ($navbarEl.hasClass("navbar-large")) {
            $navbarEl.addClass("navbar-large-collapsed");
          }
        }
      }
      if (sb.$hideOnEnableEl)
        sb.$hideOnEnableEl.addClass("hidden-by-searchbar");
      sb.$el.trigger("searchbar:enable");
      sb.emit("local::enable searchbarEnable", sb);
    }
    let needsFocus = false;
    if (setFocus === true) {
      if (document.activeElement !== sb.inputEl) {
        needsFocus = true;
      }
    }
    const isIos = device.ios && app.theme === "ios";
    if (isIos) {
      if (sb.expandable) {
        if (needsFocus)
          sb.$inputEl.focus();
        enable3();
      } else {
        if (needsFocus)
          sb.$inputEl.focus();
        if (setFocus && (setFocus.type === "focus" || setFocus === true)) {
          nextTick(() => {
            enable3();
          }, 400);
        } else {
          enable3();
        }
      }
    } else {
      if (needsFocus)
        sb.$inputEl.focus();
      if (app.theme === "md" && sb.expandable) {
        sb.$el.parents(".page, .view, .navbar-inner, .navbar").scrollLeft(app.rtl ? 100 : 0);
      }
      enable3();
    }
    return sb;
  }
  disable() {
    const sb = this;
    if (!sb.enabled)
      return sb;
    const app = sb.app;
    sb.$inputEl.val("").trigger("change");
    sb.$el.removeClass("searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button");
    if (sb.expandable) {
      const $navbarEl = sb.$el.parents(".navbar");
      const $pageContentEl = sb.$pageEl && sb.$pageEl.find(".page-content");
      if ($navbarEl.hasClass("navbar-large") && $pageContentEl.length) {
        const $titleLargeEl = $navbarEl.find(".title-large");
        sb.$el.transitionEnd(() => {
          $pageContentEl.removeClass("with-searchbar-expandable-closing");
        });
        if ($navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-large-collapsed") && $titleLargeEl.length) {
          const scrollTop = $pageContentEl[0].scrollTop;
          const titleLargeHeight = $titleLargeEl[0].offsetHeight;
          if (scrollTop > titleLargeHeight) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop = scrollTop + titleLargeHeight;
            setTimeout(() => {
              $pageContentEl.transition("");
            }, 200);
          }
        }
        $pageContentEl.removeClass("with-searchbar-expandable-enabled").addClass("with-searchbar-expandable-closing");
      }
      if (app.theme === "md" && $navbarEl.length) {
        $navbarEl.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing");
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass("with-searchbar-expandable-closing");
        });
      } else {
        $navbarEl.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing");
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass("with-searchbar-expandable-closing");
        });
        if (sb.$pageEl) {
          sb.$pageEl.find(".page-content").trigger("scroll");
        }
      }
    }
    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== "md") {
      sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, `${-sb.disableButtonEl.offsetWidth}px`);
    }
    if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch)) {
      sb.backdropHide();
    }
    sb.enabled = false;
    sb.$inputEl.blur();
    if (sb.$hideOnEnableEl)
      sb.$hideOnEnableEl.removeClass("hidden-by-searchbar");
    sb.$el.trigger("searchbar:disable");
    sb.emit("local::disable searchbarDisable", sb);
    return sb;
  }
  toggle() {
    const sb = this;
    if (sb.enabled)
      sb.disable();
    else
      sb.enable(true);
    return sb;
  }
  backdropShow() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.addClass("searchbar-backdrop-in");
    }
    return sb;
  }
  backdropHide() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.removeClass("searchbar-backdrop-in");
    }
    return sb;
  }
  search(query, internal) {
    const sb = this;
    sb.previousQuery = sb.query || "";
    if (query === sb.previousQuery)
      return sb;
    if (!internal) {
      if (!sb.enabled) {
        sb.enable();
      }
      sb.$inputEl.val(query);
      sb.$inputEl.trigger("input");
    }
    sb.query = query;
    sb.value = query;
    const {
      $searchContainer,
      $el,
      $foundEl,
      $notFoundEl,
      $hideOnSearchEl,
      isVirtualList
    } = sb;
    if (query.length > 0 && $hideOnSearchEl) {
      $hideOnSearchEl.addClass("hidden-by-searchbar");
    } else if ($hideOnSearchEl) {
      $hideOnSearchEl.removeClass("hidden-by-searchbar");
    }
    if ($searchContainer && $searchContainer.length && $el.hasClass("searchbar-enabled") || sb.params.customSearch && $el.hasClass("searchbar-enabled")) {
      if (query.length === 0) {
        sb.backdropShow();
      } else {
        sb.backdropHide();
      }
    }
    if (sb.params.customSearch) {
      $el.trigger("searchbar:search", {
        query,
        previousQuery: sb.previousQuery
      });
      sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery);
      return sb;
    }
    let foundItems = [];
    let vlQuery;
    if (isVirtualList) {
      sb.virtualList = $searchContainer[0].f7VirtualList;
      if (query.trim() === "") {
        sb.virtualList.resetFilter();
        if ($notFoundEl)
          $notFoundEl.hide();
        if ($foundEl)
          $foundEl.show();
        $el.trigger("searchbar:search", {
          query,
          previousQuery: sb.previousQuery
        });
        sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery);
        return sb;
      }
      vlQuery = sb.params.removeDiacritics ? remove_diacritics_default(query) : query;
      if (sb.virtualList.params.searchAll) {
        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
      } else if (sb.virtualList.params.searchByItem) {
        for (let i = 0; i < sb.virtualList.items.length; i += 1) {
          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.items[i], i)) {
            foundItems.push(i);
          }
        }
      }
    } else {
      let values;
      if (sb.params.removeDiacritics)
        values = remove_diacritics_default(query.trim().toLowerCase()).split(" ");
      else {
        values = query.trim().toLowerCase().split(" ");
      }
      $searchContainer.find(sb.params.searchItem).removeClass("hidden-by-searchbar").each((itemEl) => {
        const $itemEl = dom7_default(itemEl);
        let compareWithText = [];
        let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
        if (sb.params.searchIn === sb.params.searchItem) {
          $searchIn = $itemEl;
        }
        $searchIn.each((searchInEl) => {
          let itemText = dom7_default(searchInEl).text().trim().toLowerCase();
          if (sb.params.removeDiacritics)
            itemText = remove_diacritics_default(itemText);
          compareWithText.push(itemText);
        });
        compareWithText = compareWithText.join(" ");
        let wordsMatch = 0;
        for (let i = 0; i < values.length; i += 1) {
          if (compareWithText.indexOf(values[i]) >= 0)
            wordsMatch += 1;
        }
        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
          $itemEl.addClass("hidden-by-searchbar");
        } else {
          foundItems.push($itemEl[0]);
        }
      });
      if (sb.params.hideDividers) {
        $searchContainer.find(sb.params.searchGroupTitle).each((titleEl) => {
          const $titleEl = dom7_default(titleEl);
          const $nextElements = $titleEl.nextAll(sb.params.searchItem);
          let hide = true;
          for (let i = 0; i < $nextElements.length; i += 1) {
            const $nextEl = $nextElements.eq(i);
            if ($nextEl.is(sb.params.searchGroupTitle))
              break;
            if (!$nextEl.hasClass("hidden-by-searchbar")) {
              hide = false;
            }
          }
          const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
          if (hide && !ignore)
            $titleEl.addClass("hidden-by-searchbar");
          else
            $titleEl.removeClass("hidden-by-searchbar");
        });
      }
      if (sb.params.hideGroups) {
        $searchContainer.find(sb.params.searchGroup).each((groupEl) => {
          const $groupEl = dom7_default(groupEl);
          const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
          const notHidden = $groupEl.find(sb.params.searchItem).filter((el) => {
            return !dom7_default(el).hasClass("hidden-by-searchbar");
          });
          if (notHidden.length === 0 && !ignore) {
            $groupEl.addClass("hidden-by-searchbar");
          } else {
            $groupEl.removeClass("hidden-by-searchbar");
          }
        });
      }
    }
    if (foundItems.length === 0) {
      if ($notFoundEl)
        $notFoundEl.show();
      if ($foundEl)
        $foundEl.hide();
    } else {
      if ($notFoundEl)
        $notFoundEl.hide();
      if ($foundEl)
        $foundEl.show();
    }
    if (isVirtualList && sb.virtualList) {
      sb.virtualList.filterItems(foundItems);
    }
    $el.trigger("searchbar:search", {
      query,
      previousQuery: sb.previousQuery,
      foundItems
    });
    sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery, foundItems);
    return sb;
  }
  init() {
    const sb = this;
    if (sb.expandable && sb.$el)
      sb.$el.addClass("searchbar-expandable");
    if (sb.inline && sb.$el)
      sb.$el.addClass("searchbar-inline");
    sb.attachEvents();
  }
  destroy() {
    const sb = this;
    sb.emit("local::beforeDestroy searchbarBeforeDestroy", sb);
    sb.$el.trigger("searchbar:beforedestroy");
    sb.detachEvents();
    if (sb.$el[0]) {
      sb.$el[0].f7Searchbar = null;
      delete sb.$el[0].f7Searchbar;
    }
    deleteProps(sb);
  }
};
var searchbar_class_default = Searchbar;

// node_modules/framework7/components/searchbar/searchbar.js
var searchbar_default = {
  name: "searchbar",
  static: {
    Searchbar: searchbar_class_default
  },
  create() {
    const app = this;
    app.searchbar = ConstructorMethods({
      defaultSelector: ".searchbar",
      constructor: searchbar_class_default,
      app,
      domProp: "f7Searchbar",
      addMethods: "clear enable disable toggle search".split(" ")
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".searchbar-init").each((searchbarEl) => {
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".searchbar-init").each((searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".searchbar-init").each((searchbarEl) => {
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".searchbar-init").each((searchbarEl) => {
          const $searchbarEl = dom7_default(searchbarEl);
          app.searchbar.create(extend($searchbarEl.dataset(), {
            el: searchbarEl
          }));
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".searchbar-init").each((searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".searchbar-init").each((searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      }
    }
  },
  clicks: {
    ".searchbar-clear": function clear($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.clear();
    },
    ".searchbar-enable": function enable2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.enable(true);
    },
    ".searchbar-disable": function disable2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.disable();
    },
    ".searchbar-toggle": function toggle2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.toggle();
    }
  },
  vnode: {
    "searchbar-init": {
      insert(vnode) {
        const app = this;
        const searchbarEl = vnode.elm;
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      },
      destroy(vnode) {
        const searchbarEl = vnode.elm;
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      }
    }
  }
};

// node_modules/framework7/components/messages/messages-class.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Messages = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const m = this;
    const defaults = {
      autoLayout: true,
      messages: [],
      newMessagesFirst: false,
      scrollMessages: true,
      scrollMessagesOnEdge: true,
      firstMessageRule: void 0,
      lastMessageRule: void 0,
      tailMessageRule: void 0,
      sameNameMessageRule: void 0,
      sameHeaderMessageRule: void 0,
      sameFooterMessageRule: void 0,
      sameAvatarMessageRule: void 0,
      customClassMessageRule: void 0,
      renderMessage: void 0
    };
    m.useModulesParams(defaults);
    m.params = extend(defaults, params);
    const $el = dom7_default(params.el).eq(0);
    if ($el.length === 0)
      return m;
    if ($el[0].f7Messages)
      return $el[0].f7Messages;
    $el[0].f7Messages = m;
    const $pageContentEl = $el.closest(".page-content").eq(0);
    extend(m, {
      messages: m.params.messages,
      $el,
      el: $el[0],
      $pageContentEl,
      pageContentEl: $pageContentEl[0]
    });
    m.useModules();
    m.init();
    return m;
  }
  // eslint-disable-next-line
  getMessageData(messageEl) {
    const $messageEl = dom7_default(messageEl);
    const data = {
      name: $messageEl.find(".message-name").html(),
      header: $messageEl.find(".message-header").html(),
      textHeader: $messageEl.find(".message-text-header").html(),
      textFooter: $messageEl.find(".message-text-footer").html(),
      footer: $messageEl.find(".message-footer").html(),
      isTitle: $messageEl.hasClass("messages-title"),
      type: $messageEl.hasClass("message-sent") ? "sent" : "received",
      text: $messageEl.find(".message-text").html(),
      image: $messageEl.find(".message-image").html(),
      imageSrc: $messageEl.find(".message-image img").attr("src"),
      typing: $messageEl.hasClass("message-typing")
    };
    if (data.isTitle) {
      data.text = $messageEl.html();
    }
    if (data.text && data.textHeader) {
      data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, "");
    }
    if (data.text && data.textFooter) {
      data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, "");
    }
    let avatar = $messageEl.find(".message-avatar").css("background-image");
    if (avatar === "none" || avatar === "")
      avatar = void 0;
    if (avatar && typeof avatar === "string") {
      avatar = avatar.replace("url(", "").replace(")", "").replace(/"/g, "").replace(/'/g, "");
    } else {
      avatar = void 0;
    }
    data.avatar = avatar;
    return data;
  }
  getMessagesData() {
    const m = this;
    const data = [];
    m.$el.find(".message, .messages-title").each((messageEl) => {
      data.push(m.getMessageData(messageEl));
    });
    return data;
  }
  renderMessage(messageToRender) {
    const m = this;
    const message = extend({
      type: "sent",
      attrs: {}
    }, messageToRender);
    if (m.params.renderMessage) {
      return m.params.renderMessage.call(m, message);
    }
    if (message.isTitle) {
      return `<div class="messages-title">${message.text}</div>`;
    }
    return jsx_default("div", _extends({
      class: `message message-${message.type} ${message.isTyping ? "message-typing" : ""} ${message.cssClass || ""}`
    }, message.attrs), message.avatar && jsx_default("div", {
      class: "message-avatar",
      style: `background-image:url(${message.avatar})`
    }), jsx_default("div", {
      class: "message-content"
    }, message.name && jsx_default("div", {
      class: "message-name"
    }, message.name), message.header && jsx_default("div", {
      class: "message-header"
    }, message.header), jsx_default("div", {
      class: "message-bubble"
    }, message.textHeader && jsx_default("div", {
      class: "message-text-header"
    }, message.textHeader), message.image && jsx_default("div", {
      class: "message-image"
    }, message.image), message.imageSrc && !message.image && jsx_default("div", {
      class: "message-image"
    }, jsx_default("img", {
      src: message.imageSrc
    })), (message.text || message.isTyping) && jsx_default("div", {
      class: "message-text"
    }, message.text || "", message.isTyping && jsx_default("div", {
      class: "message-typing-indicator"
    }, jsx_default("div", null), jsx_default("div", null), jsx_default("div", null))), message.textFooter && jsx_default("div", {
      class: "message-text-footer"
    }, message.textFooter)), message.footer && jsx_default("div", {
      class: "message-footer"
    }, message.footer)));
  }
  renderMessages(messagesToRender, method) {
    if (messagesToRender === void 0) {
      messagesToRender = this.messages;
    }
    if (method === void 0) {
      method = this.params.newMessagesFirst ? "prepend" : "append";
    }
    const m = this;
    const html = messagesToRender.map((message) => m.renderMessage(message)).join("");
    m.$el[method](html);
  }
  isFirstMessage() {
    const m = this;
    if (m.params.firstMessageRule)
      return m.params.firstMessageRule(...arguments);
    return false;
  }
  isLastMessage() {
    const m = this;
    if (m.params.lastMessageRule)
      return m.params.lastMessageRule(...arguments);
    return false;
  }
  isTailMessage() {
    const m = this;
    if (m.params.tailMessageRule)
      return m.params.tailMessageRule(...arguments);
    return false;
  }
  isSameNameMessage() {
    const m = this;
    if (m.params.sameNameMessageRule)
      return m.params.sameNameMessageRule(...arguments);
    return false;
  }
  isSameHeaderMessage() {
    const m = this;
    if (m.params.sameHeaderMessageRule)
      return m.params.sameHeaderMessageRule(...arguments);
    return false;
  }
  isSameFooterMessage() {
    const m = this;
    if (m.params.sameFooterMessageRule)
      return m.params.sameFooterMessageRule(...arguments);
    return false;
  }
  isSameAvatarMessage() {
    const m = this;
    if (m.params.sameAvatarMessageRule)
      return m.params.sameAvatarMessageRule(...arguments);
    return false;
  }
  isCustomClassMessage() {
    const m = this;
    if (m.params.customClassMessageRule)
      return m.params.customClassMessageRule(...arguments);
    return void 0;
  }
  layout() {
    const m = this;
    m.$el.find(".message, .messages-title").each((messageEl, index) => {
      const $messageEl = dom7_default(messageEl);
      if (!m.messages) {
        m.messages = m.getMessagesData();
      }
      const classes = [];
      const message = m.messages[index];
      const previousMessage = m.messages[index - 1];
      const nextMessage = m.messages[index + 1];
      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
        classes.push("message-first");
      }
      if (m.isLastMessage(message, previousMessage, nextMessage)) {
        classes.push("message-last");
      }
      if (m.isTailMessage(message, previousMessage, nextMessage)) {
        classes.push("message-tail");
      }
      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-name");
      }
      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-header");
      }
      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-footer");
      }
      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-avatar");
      }
      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
      if (customMessageClasses && customMessageClasses.length) {
        if (typeof customMessageClasses === "string") {
          customMessageClasses = customMessageClasses.split(" ");
        }
        customMessageClasses.forEach((customClass) => {
          classes.push(customClass);
        });
      }
      $messageEl.removeClass("message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar");
      classes.forEach((className) => {
        $messageEl.addClass(className);
      });
    });
  }
  clear() {
    const m = this;
    m.messages = [];
    m.$el.html("");
  }
  removeMessage(messageToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }
    const m = this;
    let index;
    let $el;
    if (typeof messageToRemove === "number") {
      index = messageToRemove;
      $el = m.$el.find(".message, .messages-title").eq(index);
    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
      index = m.messages.indexOf(messageToRemove);
      $el = m.$el.children().eq(index);
    } else {
      $el = dom7_default(messageToRemove);
      index = $el.index();
    }
    if ($el.length === 0) {
      return m;
    }
    $el.remove();
    m.messages.splice(index, 1);
    if (m.params.autoLayout && layout)
      m.layout();
    return m;
  }
  removeMessages(messagesToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }
    const m = this;
    if (Array.isArray(messagesToRemove)) {
      const messagesToRemoveEls = [];
      messagesToRemove.forEach((messageToRemoveIndex) => {
        messagesToRemoveEls.push(m.$el.find(".message, .messages-title").eq(messageToRemoveIndex));
      });
      messagesToRemoveEls.forEach((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    } else {
      dom7_default(messagesToRemove).each((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    }
    if (m.params.autoLayout && layout)
      m.layout();
    return m;
  }
  addMessage() {
    const m = this;
    let messageToAdd;
    let animate;
    let method;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[1] === "boolean") {
      [messageToAdd, animate, method] = args;
    } else {
      [messageToAdd, method, animate] = args;
    }
    if (typeof animate === "undefined") {
      animate = true;
    }
    if (typeof method === "undefined") {
      method = m.params.newMessagesFirst ? "prepend" : "append";
    }
    return m.addMessages([messageToAdd], animate, method);
  }
  setScrollData() {
    const m = this;
    const scrollHeightBefore = m.pageContentEl.scrollHeight;
    const heightBefore = m.pageContentEl.offsetHeight;
    const scrollBefore = m.pageContentEl.scrollTop;
    m.scrollData = {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
    return {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
  }
  addMessages() {
    const m = this;
    let messagesToAdd;
    let animate;
    let method;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[1] === "boolean") {
      [messagesToAdd, animate, method] = args;
    } else {
      [messagesToAdd, method, animate] = args;
    }
    if (typeof animate === "undefined") {
      animate = true;
    }
    if (typeof method === "undefined") {
      method = m.params.newMessagesFirst ? "prepend" : "append";
    }
    const {
      scrollHeightBefore,
      scrollBefore
    } = m.setScrollData();
    let messagesHTML = "";
    const typingMessage = m.messages.filter((el) => el.isTyping)[0];
    messagesToAdd.forEach((messageToAdd) => {
      if (typingMessage) {
        if (method === "append") {
          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
        } else {
          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
        }
      } else {
        m.messages[method === "append" ? "push" : "unshift"](messageToAdd);
      }
      messagesHTML += m.renderMessage(messageToAdd);
    });
    const $messagesEls = dom7_default(messagesHTML);
    if (animate) {
      if (method === "append" && !m.params.newMessagesFirst) {
        $messagesEls.addClass("message-appear-from-bottom");
      }
      if (method === "prepend" && m.params.newMessagesFirst) {
        $messagesEls.addClass("message-appear-from-top");
      }
    }
    if (typingMessage) {
      if (method === "append") {
        $messagesEls.insertBefore(m.$el.find(".message-typing"));
      } else {
        $messagesEls.insertAfter(m.$el.find(".message-typing"));
      }
    } else {
      m.$el[method]($messagesEls);
    }
    if (m.params.autoLayout)
      m.layout();
    if (method === "prepend" && !typingMessage) {
      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
    }
    if (m.params.scrollMessages && (method === "append" && !m.params.newMessagesFirst || method === "prepend" && m.params.newMessagesFirst && !typingMessage)) {
      m.scrollWithEdgeCheck(animate);
    }
    return m;
  }
  showTyping(message) {
    if (message === void 0) {
      message = {};
    }
    const m = this;
    const typingMessage = m.messages.filter((el) => el.isTyping)[0];
    if (typingMessage) {
      m.removeMessage(m.messages.indexOf(typingMessage));
    }
    m.addMessage(extend({
      type: "received",
      isTyping: true
    }, message));
    return m;
  }
  hideTyping() {
    const m = this;
    let typingMessageIndex;
    let typingFound;
    m.messages.forEach((message, index) => {
      if (message.isTyping)
        typingMessageIndex = index;
    });
    if (typeof typingMessageIndex !== "undefined") {
      if (m.$el.find(".message").eq(typingMessageIndex).hasClass("message-typing")) {
        typingFound = true;
        m.removeMessage(typingMessageIndex);
      }
    }
    if (!typingFound) {
      const $typingMessageEl = m.$el.find(".message-typing");
      if ($typingMessageEl.length) {
        m.removeMessage($typingMessageEl);
      }
    }
    return m;
  }
  scrollWithEdgeCheck(animate) {
    const m = this;
    const {
      scrollBefore,
      scrollHeightBefore,
      heightBefore
    } = m.scrollData;
    if (m.params.scrollMessagesOnEdge) {
      let onEdge = false;
      if (m.params.newMessagesFirst && scrollBefore === 0) {
        onEdge = true;
      }
      if (!m.params.newMessagesFirst && scrollBefore - (scrollHeightBefore - heightBefore) >= -10) {
        onEdge = true;
      }
      if (onEdge)
        m.scroll(animate ? void 0 : 0);
    } else {
      m.scroll(animate ? void 0 : 0);
    }
  }
  scroll(duration, scrollTop) {
    if (duration === void 0) {
      duration = 300;
    }
    const m = this;
    const currentScroll = m.pageContentEl.scrollTop;
    let newScrollTop;
    if (typeof scrollTop !== "undefined")
      newScrollTop = scrollTop;
    else {
      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
      if (newScrollTop === currentScroll)
        return m;
    }
    m.$pageContentEl.scrollTop(newScrollTop, duration);
    return m;
  }
  init() {
    const m = this;
    if (!m.messages || m.messages.length === 0) {
      m.messages = m.getMessagesData();
    }
    if (m.params.messages && m.params.messages.length) {
      m.renderMessages();
    }
    if (m.params.autoLayout)
      m.layout();
    if (m.params.scrollMessages)
      m.scroll(0);
  }
  destroy() {
    const m = this;
    m.emit("local::beforeDestroy messagesBeforeDestroy", m);
    m.$el.trigger("messages:beforedestroy");
    if (m.$el[0]) {
      m.$el[0].f7Messages = null;
      delete m.$el[0].f7Messages;
    }
    deleteProps(m);
  }
};
var messages_class_default = Messages;

// node_modules/framework7/components/messages/messages.js
var messages_default = {
  name: "messages",
  static: {
    Messages: messages_class_default
  },
  create() {
    const app = this;
    app.messages = ConstructorMethods({
      defaultSelector: ".messages",
      constructor: messages_class_default,
      app,
      domProp: "f7Messages",
      addMethods: "renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages".split(" ")
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messages-init").each((messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messages-init").each((messagesEl) => {
        app.messages.create({
          el: messagesEl
        });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".messages-init").each((messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".messages-init").each((messagesEl) => {
        app.messages.create({
          el: messagesEl
        });
      });
    }
  },
  vnode: {
    "messages-init": {
      insert(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.create({
          el: messagesEl
        });
      },
      destroy(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.destroy(messagesEl);
      }
    }
  }
};

// node_modules/framework7/components/messagebar/messagebar-class.js
var Messagebar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const messagebar = this;
    const defaults = {
      top: false,
      topOffset: 0,
      bottomOffset: 0,
      attachments: [],
      renderAttachments: void 0,
      renderAttachment: void 0,
      maxHeight: null,
      resizePage: true
    };
    messagebar.useModulesParams(defaults);
    messagebar.params = extend(defaults, params);
    const $el = dom7_default(messagebar.params.el);
    if ($el.length === 0)
      return messagebar;
    if ($el[0].f7Messagebar)
      return $el[0].f7Messagebar;
    $el[0].f7Messagebar = messagebar;
    const $pageEl = $el.parents(".page").eq(0);
    const $pageContentEl = $pageEl.find(".page-content").eq(0);
    const $areaEl = $el.find(".messagebar-area");
    let $textareaEl;
    if (messagebar.params.textareaEl) {
      $textareaEl = dom7_default(messagebar.params.textareaEl);
    } else {
      $textareaEl = $el.find("textarea");
    }
    const $attachmentsEl = $el.find(".messagebar-attachments");
    const $sheetEl = $el.find(".messagebar-sheet");
    if (messagebar.params.top) {
      $el.addClass("messagebar-top");
    }
    extend(messagebar, {
      $el,
      el: $el[0],
      $areaEl,
      areaEl: $areaEl[0],
      $textareaEl,
      textareaEl: $textareaEl[0],
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
      attachmentsVisible: $attachmentsEl.hasClass("messagebar-attachments-visible"),
      $sheetEl,
      sheetEl: $sheetEl[0],
      sheetVisible: $sheetEl.hasClass("messagebar-sheet-visible"),
      $pageEl,
      pageEl: $pageEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl,
      top: $el.hasClass("messagebar-top") || messagebar.params.top,
      attachments: []
    });
    function onAppResize() {
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
    }
    function onSubmit(e) {
      e.preventDefault();
    }
    function onAttachmentClick(e) {
      const index = dom7_default(this).index();
      if (dom7_default(e.target).closest(".messagebar-attachment-delete").length) {
        dom7_default(this).trigger("messagebar:attachmentdelete", index);
        messagebar.emit("local::attachmentDelete messagebarAttachmentDelete", messagebar, this, index);
      } else {
        dom7_default(this).trigger("messagebar:attachmentclick", index);
        messagebar.emit("local::attachmentClick messagebarAttachmentClick", messagebar, this, index);
      }
    }
    function onTextareaChange() {
      messagebar.checkEmptyState();
      messagebar.$el.trigger("messagebar:change");
      messagebar.emit("local::change messagebarChange", messagebar);
    }
    function onTextareaFocus() {
      messagebar.sheetHide();
      messagebar.$el.addClass("messagebar-focused");
      messagebar.$el.trigger("messagebar:focus");
      messagebar.emit("local::focus messagebarFocus", messagebar);
    }
    function onTextareaBlur() {
      messagebar.$el.removeClass("messagebar-focused");
      messagebar.$el.trigger("messagebar:blur");
      messagebar.emit("local::blur messagebarBlur", messagebar);
    }
    messagebar.attachEvents = function attachEvents() {
      $el.on("textarea:resize", onAppResize);
      $el.on("submit", onSubmit);
      $el.on("click", ".messagebar-attachment", onAttachmentClick);
      $textareaEl.on("change input", onTextareaChange);
      $textareaEl.on("focus", onTextareaFocus);
      $textareaEl.on("blur", onTextareaBlur);
      app.on("resize", onAppResize);
    };
    messagebar.detachEvents = function detachEvents() {
      $el.off("textarea:resize", onAppResize);
      $el.off("submit", onSubmit);
      $el.off("click", ".messagebar-attachment", onAttachmentClick);
      $textareaEl.off("change input", onTextareaChange);
      $textareaEl.off("focus", onTextareaFocus);
      $textareaEl.off("blur", onTextareaBlur);
      app.off("resize", onAppResize);
    };
    messagebar.useModules();
    messagebar.init();
    return messagebar;
  }
  focus() {
    const messagebar = this;
    messagebar.$textareaEl.focus();
    return messagebar;
  }
  blur() {
    const messagebar = this;
    messagebar.$textareaEl.blur();
    return messagebar;
  }
  clear() {
    const messagebar = this;
    messagebar.$textareaEl.val("").trigger("change");
    return messagebar;
  }
  getValue() {
    const messagebar = this;
    return messagebar.$textareaEl.val().trim();
  }
  setValue(value) {
    const messagebar = this;
    messagebar.$textareaEl.val(value).trigger("change");
    return messagebar;
  }
  setPlaceholder(placeholder) {
    const messagebar = this;
    messagebar.$textareaEl.attr("placeholder", placeholder);
    return messagebar;
  }
  resizePage() {
    const messagebar = this;
    const {
      params,
      $el,
      top,
      $pageEl,
      $pageContentEl,
      $areaEl,
      $textareaEl,
      $sheetEl,
      $attachmentsEl
    } = messagebar;
    const elHeight = $el[0].offsetHeight;
    let maxHeight = params.maxHeight;
    if (top) {
    } else {
      const currentPaddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
      const requiredPaddingBottom = elHeight + params.bottomOffset;
      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
        const currentPaddingTop = parseInt($pageContentEl.css("padding-top"), 10);
        const pageScrollHeight = $pageContentEl[0].scrollHeight;
        const pageOffsetHeight = $pageContentEl[0].offsetHeight;
        const pageScrollTop = $pageContentEl[0].scrollTop;
        const scrollOnBottom = pageScrollTop === pageScrollHeight - pageOffsetHeight;
        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css("margin-top"), 10) - parseInt($areaEl.css("margin-bottom"), 10);
        }
        $textareaEl.css("max-height", `${maxHeight}px`);
        $pageContentEl.css("padding-bottom", `${requiredPaddingBottom}px`);
        if (scrollOnBottom) {
          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
        }
        $el.trigger("messagebar:resizepage");
        messagebar.emit("local::resizePage messagebarResizePage", messagebar);
      }
    }
  }
  checkEmptyState() {
    const messagebar = this;
    const {
      $el,
      $textareaEl
    } = messagebar;
    const value = $textareaEl.val().trim();
    if (value && value.length) {
      $el.addClass("messagebar-with-value");
    } else {
      $el.removeClass("messagebar-with-value");
    }
  }
  attachmentsCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    const $attachmentsEl = dom7_default(`<div class="messagebar-attachments">${innerHTML}</div>`);
    $attachmentsEl.insertBefore(messagebar.$textareaEl);
    extend(messagebar, {
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0]
    });
    return messagebar;
  }
  attachmentsShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    messagebar.$attachmentsEl = messagebar.$el.find(".messagebar-attachments");
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(innerHTML);
    }
    messagebar.$el.addClass("messagebar-attachments-visible");
    messagebar.attachmentsVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsHide() {
    const messagebar = this;
    messagebar.$el.removeClass("messagebar-attachments-visible");
    messagebar.attachmentsVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsToggle() {
    const messagebar = this;
    if (messagebar.attachmentsVisible) {
      messagebar.attachmentsHide();
    } else {
      messagebar.attachmentsShow();
    }
    return messagebar;
  }
  renderAttachment(attachment) {
    const messagebar = this;
    if (messagebar.params.renderAttachment) {
      return messagebar.params.renderAttachment.call(messagebar, attachment);
    }
    return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
  }
  renderAttachments() {
    const messagebar = this;
    let html;
    if (messagebar.params.renderAttachments) {
      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
    } else {
      html = `${messagebar.attachments.map((attachment) => messagebar.renderAttachment(attachment)).join("")}`;
    }
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(html);
    } else {
      messagebar.$attachmentsEl.html(html);
    }
  }
  sheetCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    const $sheetEl = dom7_default(`<div class="messagebar-sheet">${innerHTML}</div>`);
    messagebar.$el.append($sheetEl);
    extend(messagebar, {
      $sheetEl,
      sheetEl: $sheetEl[0]
    });
    return messagebar;
  }
  sheetShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    messagebar.$sheetEl = messagebar.$el.find(".messagebar-sheet");
    if (messagebar.$sheetEl.length === 0) {
      messagebar.sheetCreate(innerHTML);
    }
    messagebar.$el.addClass("messagebar-sheet-visible");
    messagebar.sheetVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetHide() {
    const messagebar = this;
    messagebar.$el.removeClass("messagebar-sheet-visible");
    messagebar.sheetVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetToggle() {
    const messagebar = this;
    if (messagebar.sheetVisible) {
      messagebar.sheetHide();
    } else {
      messagebar.sheetShow();
    }
    return messagebar;
  }
  init() {
    const messagebar = this;
    messagebar.attachEvents();
    messagebar.checkEmptyState();
    return messagebar;
  }
  destroy() {
    const messagebar = this;
    messagebar.emit("local::beforeDestroy messagebarBeforeDestroy", messagebar);
    messagebar.$el.trigger("messagebar:beforedestroy");
    messagebar.detachEvents();
    if (messagebar.$el[0]) {
      messagebar.$el[0].f7Messagebar = null;
      delete messagebar.$el[0].f7Messagebar;
    }
    deleteProps(messagebar);
  }
};
var messagebar_class_default = Messagebar;

// node_modules/framework7/components/messagebar/messagebar.js
var messagebar_default = {
  name: "messagebar",
  static: {
    Messagebar: messagebar_class_default
  },
  create() {
    const app = this;
    app.messagebar = ConstructorMethods({
      defaultSelector: ".messagebar",
      constructor: messagebar_class_default,
      app,
      domProp: "f7Messagebar",
      addMethods: "clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle".split(" ")
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      });
    }
  },
  vnode: {
    "messagebar-init": {
      insert(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      },
      destroy(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.destroy(messagebarEl);
      }
    }
  }
};

// node_modules/swiper/swiper-bundle.esm.js
var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
core_default.use(modules);

// node_modules/framework7/components/swiper/swiper.js
function initSwiper(swiperEl) {
  const app = this;
  const $swiperEl = dom7_default(swiperEl);
  if ($swiperEl.length === 0)
    return;
  if ($swiperEl[0].swiper)
    return;
  let initialSlide;
  let params = {};
  let isTabs;
  let isRoutableTabs;
  if ($swiperEl.hasClass("tabs-swipeable-wrap")) {
    $swiperEl.addClass("swiper").children(".tabs").addClass("swiper-wrapper").children(".tab").addClass("swiper-slide");
    initialSlide = $swiperEl.children(".tabs").children(".tab-active").index();
    isTabs = true;
    isRoutableTabs = $swiperEl.find(".tabs-routable").length > 0;
  }
  if ($swiperEl.attr("data-swiper")) {
    params = JSON.parse($swiperEl.attr("data-swiper"));
  } else if ($swiperEl[0].f7SwiperParams) {
    params = $swiperEl[0].f7SwiperParams;
  } else {
    params = $swiperEl.dataset();
    Object.keys(params).forEach((key) => {
      const value = params[key];
      if (typeof value === "string" && value.indexOf("{") === 0 && value.indexOf("}") > 0) {
        try {
          params[key] = JSON.parse(value);
        } catch (e) {
        }
      }
    });
  }
  if (typeof params.initialSlide === "undefined" && typeof initialSlide !== "undefined") {
    params.initialSlide = initialSlide;
  }
  const swiper = app.swiper.create($swiperEl[0], params);
  function updateSwiper() {
    swiper.update();
  }
  const $tabEl = $swiperEl.parents(".tab").filter((tabEl) => {
    return dom7_default(tabEl).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0;
  }).eq(0);
  $swiperEl.parents(".popup, .login-screen, .sheet-modal, .popover").on("modal:open", updateSwiper);
  $swiperEl.parents(".panel").on("panel:open", updateSwiper);
  if ($tabEl && $tabEl.length) {
    $tabEl.on("tab:show", updateSwiper);
  }
  swiper.on("beforeDestroy", () => {
    $swiperEl.parents(".popup, .login-screen, .sheet-modal, .popover").off("modal:open", updateSwiper);
    $swiperEl.parents(".panel").off("panel:open", updateSwiper);
    if ($tabEl && $tabEl.length) {
      $tabEl.off("tab:show", updateSwiper);
    }
  });
  if (isTabs) {
    swiper.on("slideChange", () => {
      if (isRoutableTabs) {
        let view = app.views.get($swiperEl.parents(".view"));
        if (!view)
          view = app.views.main;
        const router = view.router;
        const tabRouteUrl = router.findTabRouteUrl(swiper.slides.eq(swiper.activeIndex)[0]);
        if (tabRouteUrl) {
          setTimeout(() => {
            router.navigate(tabRouteUrl);
          }, 0);
        }
      } else {
        app.tab.show({
          tabEl: swiper.slides.eq(swiper.activeIndex)
        });
      }
    });
  }
}
var swiper_default = {
  name: "swiper",
  static: {
    Swiper: core_default
  },
  create() {
    const app = this;
    app.swiper = ConstructorMethods({
      defaultSelector: ".swiper",
      constructor: core_default,
      domProp: "swiper"
    });
  },
  on: {
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
    pageMounted(page) {
      const app = this;
      page.$el.find(".tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageReinit(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update)
          swiper.update();
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update)
          swiper.update();
      });
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    }
  },
  vnode: {
    "swiper-init": {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }
    },
    "tabs-swipeable-wrap": {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }
    }
  }
};

// node_modules/framework7/components/photo-browser/photo-browser-class.js
var PhotoBrowser = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const pb = this;
    pb.app = app;
    const defaults = extend({
      on: {}
    }, app.params.photoBrowser);
    pb.useModulesParams(defaults);
    pb.params = extend(defaults, params);
    extend(pb, {
      exposed: false,
      opened: false,
      activeIndex: pb.params.swiper.initialSlide,
      url: pb.params.url,
      swipeToClose: {
        allow: true,
        isTouched: false,
        diff: void 0,
        start: void 0,
        current: void 0,
        started: false,
        activeSlide: void 0,
        timeStart: void 0
      }
    });
    pb.useModules();
    pb.init();
  }
  get view() {
    const {
      params,
      app
    } = this;
    return params.view || app.views.main;
  }
  onSlideChange(swiper) {
    const pb = this;
    pb.activeIndex = swiper.activeIndex;
    let current = swiper.activeIndex + 1;
    let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
    if (swiper.params.loop) {
      total -= 2;
      current -= swiper.loopedSlides;
      if (current < 1)
        current = total + current;
      if (current > total)
        current -= total;
    }
    const $activeSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides.eq(swiper.activeIndex);
    const $previousSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`) : swiper.slides.eq(swiper.previousIndex);
    let $currentEl = pb.$el.find(".photo-browser-current");
    let $totalEl = pb.$el.find(".photo-browser-total");
    let navbarEl;
    if (pb.params.type === "page" && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === "ios") {
      navbarEl = pb.app.navbar.getElByPage(pb.$el);
      if (navbarEl) {
        $currentEl = dom7_default(navbarEl).find(".photo-browser-current");
        $totalEl = dom7_default(navbarEl).find(".photo-browser-total");
      }
    }
    if ($currentEl.length && $totalEl.length) {
      $currentEl.text(current);
      $totalEl.text(total);
      if (!navbarEl)
        navbarEl = $currentEl.parents(".navbar")[0];
      if (navbarEl) {
        pb.app.navbar.size(navbarEl);
      }
    }
    if (pb.captions.length > 0) {
      const captionIndex = swiper.params.loop ? $activeSlideEl.attr("data-swiper-slide-index") : pb.activeIndex;
      pb.$captionsContainerEl.find(".photo-browser-caption-active").removeClass("photo-browser-caption-active");
      pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass("photo-browser-caption-active");
    }
    const previousSlideVideo = $previousSlideEl.find("video");
    if (previousSlideVideo.length > 0) {
      if ("pause" in previousSlideVideo[0])
        previousSlideVideo[0].pause();
    }
  }
  onTouchStart() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.allow)
      return;
    swipeToClose.isTouched = true;
  }
  onTouchMove(e) {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.isTouched)
      return;
    if (!swipeToClose.started) {
      swipeToClose.started = true;
      swipeToClose.start = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (pb.params.virtualSlides) {
        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children(".swiper-slide-active");
      } else {
        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
      }
      swipeToClose.timeStart = now();
    }
    e.preventDefault();
    swipeToClose.current = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
    pb.$el.transition(0).transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
  }
  onTouchEnd() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    swipeToClose.isTouched = false;
    if (!swipeToClose.started) {
      swipeToClose.started = false;
      return;
    }
    swipeToClose.started = false;
    swipeToClose.allow = false;
    const diff = Math.abs(swipeToClose.diff);
    const timeDiff = (/* @__PURE__ */ new Date()).getTime() - swipeToClose.timeStart;
    if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
      nextTick(() => {
        if (pb.$el) {
          if (swipeToClose.diff < 0)
            pb.$el.addClass("swipe-close-to-bottom");
          else
            pb.$el.addClass("swipe-close-to-top");
        }
        pb.emit("local::swipeToClose", pb);
        pb.$el.transform("").transition("");
        pb.close();
        swipeToClose.allow = true;
      });
      return;
    }
    if (diff !== 0) {
      pb.$el.addClass("photo-browser-transitioning").transitionEnd(() => {
        swipeToClose.allow = true;
        pb.$el.removeClass("photo-browser-transitioning");
      });
    } else {
      swipeToClose.allow = true;
    }
    nextTick(() => {
      pb.$el.transform("").transition("");
    });
  }
  // Render Functions
  renderNavbar() {
    const pb = this;
    if (pb.params.renderNavbar)
      return pb.params.renderNavbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === "dark")
      iconsColor = "white";
    const pageBackLinkText = (pb.app.theme === "ios" || pb.app.theme === "aurora") && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : "";
    const renderNavbarCount = typeof pb.params.navbarShowCount === "undefined" ? pb.params.photos.length > 1 : pb.params.navbarShowCount;
    const isPopup = pb.params.type !== "page";
    return jsx_default("div", {
      class: `navbar navbar-photo-browser ${pb.params.theme === "dark" ? "navbar-photo-browser-dark" : ""}`
    }, jsx_default("div", {
      class: "navbar-bg"
    }), jsx_default("div", {
      class: "navbar-inner navbar-inner-centered-title sliding"
    }, !isPopup && jsx_default("div", {
      class: "left"
    }, jsx_default("a", {
      class: `link ${!pageBackLinkText ? "icon-only" : ""} back`
    }, jsx_default("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ""}`
    }), pageBackLinkText && jsx_default("span", null, pageBackLinkText))), renderNavbarCount && jsx_default("div", {
      class: "title"
    }, jsx_default("span", {
      class: "photo-browser-current"
    }), jsx_default("span", {
      class: "photo-browser-of"
    }, pb.params.navbarOfText), jsx_default("span", {
      class: "photo-browser-total"
    })), isPopup && jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link popup-close",
      "data-popup": ".photo-browser-popup"
    }, jsx_default("span", null, pb.params.popupCloseLinkText)))));
  }
  renderToolbar() {
    const pb = this;
    if (pb.params.renderToolbar)
      return pb.params.renderToolbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === "dark")
      iconsColor = "white";
    return jsx_default("div", {
      class: "toolbar toolbar-bottom tabbar"
    }, jsx_default("div", {
      class: "toolbar-inner"
    }, jsx_default("a", {
      class: "link photo-browser-prev"
    }, jsx_default("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ""}`
    })), jsx_default("a", {
      class: "link photo-browser-next"
    }, jsx_default("i", {
      class: `icon icon-forward ${iconsColor ? `color-${iconsColor}` : ""}`
    }))));
  }
  renderCaption(caption, index) {
    const pb = this;
    if (pb.params.renderCaption)
      return pb.params.renderCaption.call(pb, caption, index);
    return jsx_default("div", {
      class: "photo-browser-caption",
      "data-caption-index": index
    }, caption);
  }
  renderObject(photo, index) {
    const pb = this;
    if (pb.params.renderObject)
      return pb.params.renderObject.call(pb, photo, index);
    return jsx_default("div", {
      class: "photo-browser-slide photo-browser-object-slide swiper-slide",
      "data-swiper-slide-index": index
    }, photo.html ? photo.html : photo);
  }
  renderLazyPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderLazyPhoto)
      return pb.params.renderLazyPhoto.call(pb, photo, index);
    return jsx_default("div", {
      class: "photo-browser-slide photo-browser-slide-lazy swiper-slide",
      "data-swiper-slide-index": index
    }, jsx_default("div", {
      class: "swiper-lazy-preloader"
    }), jsx_default("span", {
      class: "swiper-zoom-container"
    }, jsx_default("img", {
      "data-src": photo.url ? photo.url : photo,
      class: "swiper-lazy"
    })));
  }
  renderPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderPhoto)
      return pb.params.renderPhoto.call(pb, photo, index);
    return jsx_default("div", {
      class: "photo-browser-slide swiper-slide",
      "data-swiper-slide-index": index
    }, jsx_default("span", {
      class: "swiper-zoom-container"
    }, jsx_default("img", {
      src: photo.url ? photo.url : photo
    })));
  }
  render() {
    const pb = this;
    if (pb.params.render)
      return pb.params.render.call(pb, pb.params);
    return jsx_default("div", {
      class: `photo-browser photo-browser-${pb.params.theme}`
    }, jsx_default("div", {
      class: "view"
    }, jsx_default("div", {
      class: `page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? "no-navbar" : ""}`,
      "data-name": "photo-browser-page"
    }, pb.params.navbar && pb.renderNavbar(), pb.params.toolbar && pb.renderToolbar(), jsx_default("div", {
      class: `photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}`
    }, pb.params.photos.map((photo, index) => {
      if (photo.caption)
        return pb.renderCaption(photo.caption, index);
      return "";
    })), jsx_default("div", {
      class: "photo-browser-swiper-container swiper"
    }, jsx_default("div", {
      class: "photo-browser-swiper-wrapper swiper-wrapper"
    }, !pb.params.virtualSlides && pb.params.photos.map((photo, index) => {
      if (photo.html || (typeof photo === "string" || photo instanceof String) && photo.indexOf("<") >= 0 && photo.indexOf(">") >= 0) {
        return pb.renderObject(photo, index);
      }
      if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
        return pb.renderLazyPhoto(photo, index);
      }
      return pb.renderPhoto(photo, index);
    }))))));
  }
  renderStandalone() {
    const pb = this;
    if (pb.params.renderStandalone)
      return pb.params.renderStandalone.call(pb);
    const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
    return standaloneHtml;
  }
  renderPage() {
    const pb = this;
    if (pb.params.renderPage)
      return pb.params.renderPage.call(pb);
    const pageHtml = pb.render();
    return pageHtml;
  }
  renderPopup() {
    const pb = this;
    if (pb.params.renderPopup)
      return pb.params.renderPopup.call(pb);
    const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;
    return popupHtml;
  }
  // Callbacks
  onOpen(type, el) {
    const pb = this;
    const app = pb.app;
    const $el = dom7_default(el);
    $el[0].f7PhotoBrowser = pb;
    pb.$el = $el;
    pb.el = $el[0];
    pb.openedIn = type;
    pb.opened = true;
    pb.$swiperContainerEl = pb.$el.find(".photo-browser-swiper-container");
    pb.$swiperWrapperEl = pb.$el.find(".photo-browser-swiper-wrapper");
    pb.slides = pb.$el.find(".photo-browser-slide");
    pb.$captionsContainerEl = pb.$el.find(".photo-browser-captions");
    pb.captions = pb.$el.find(".photo-browser-caption");
    let clickTimeout;
    const swiperParams = extend({}, pb.params.swiper, {
      initialSlide: pb.activeIndex,
      cssMode: typeof pb.params.swiper.cssMode === "undefined" && (app.device.ios || app.device.android) ? true : pb.params.swiper.cssMode,
      on: {
        click(e) {
          clearTimeout(clickTimeout);
          if (pb.params.exposition) {
            clickTimeout = setTimeout(() => {
              pb.expositionToggle();
            }, 350);
          }
          pb.emit("local::tap", e);
          pb.emit("local::click", e);
        },
        doubleClick(e) {
          clearTimeout(clickTimeout);
          pb.emit("local::doubleTap", e);
          pb.emit("local::doubleClick", e);
        },
        slideChange() {
          const swiper = this;
          pb.onSlideChange(swiper);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          pb.emit("local::slideChange", ...args);
        },
        transitionStart() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          pb.emit("local::transitionStart", ...args);
        },
        transitionEnd() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          pb.emit("local::transitionEnd", ...args);
        },
        slideChangeTransitionStart() {
          const swiper = this;
          pb.onSlideChange(swiper);
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          pb.emit("local::slideChangeTransitionStart", ...args);
        },
        slideChangeTransitionEnd() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          pb.emit("local::slideChangeTransitionEnd", ...args);
        },
        lazyImageLoad() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          pb.emit("local::lazyImageLoad", ...args);
        },
        lazyImageReady() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          const slideEl = args[0];
          dom7_default(slideEl).removeClass("photo-browser-slide-lazy");
          pb.emit("local::lazyImageReady", ...args);
        }
      }
    });
    if (pb.params.swipeToClose && pb.params.type !== "page") {
      extend(swiperParams.on, {
        touchStart(swiper, e) {
          pb.onTouchStart(e);
          pb.emit("local::touchStart", e);
        },
        touchMoveOpposite(swiper, e) {
          pb.onTouchMove(e);
          pb.emit("local::touchMoveOpposite", e);
        },
        touchEnd(swiper, e) {
          pb.onTouchEnd(e);
          pb.emit("local::touchEnd", e);
        }
      });
    }
    if (pb.params.virtualSlides) {
      extend(swiperParams, {
        virtual: {
          slides: pb.params.photos,
          renderSlide(photo, index) {
            if (photo.html || (typeof photo === "string" || photo instanceof String) && photo.indexOf("<") >= 0 && photo.indexOf(">") >= 0) {
              return pb.renderObject(photo, index);
            }
            if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
              return pb.renderLazyPhoto(photo, index);
            }
            return pb.renderPhoto(photo, index);
          }
        }
      });
    }
    const window = getWindow();
    pb.swiper = app.swiper ? app.swiper.create(pb.$swiperContainerEl, swiperParams) : new window.Swiper(pb.$swiperContainerEl, swiperParams);
    if (pb.activeIndex === 0) {
      pb.onSlideChange(pb.swiper);
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:open");
    }
    pb.emit("local::open photoBrowserOpen", pb);
  }
  onOpened() {
    const pb = this;
    if (pb.$el && pb.params.type === "standalone") {
      pb.$el.css("animation", "none");
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:opened");
    }
    pb.emit("local::opened photoBrowserOpened", pb);
  }
  onClose() {
    const pb = this;
    if (pb.destroyed)
      return;
    if (pb.swiper && pb.swiper.destroy) {
      pb.swiper.destroy(true, false);
      pb.swiper = null;
      delete pb.swiper;
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:close");
    }
    pb.emit("local::close photoBrowserClose", pb);
  }
  onClosed() {
    const pb = this;
    if (pb.destroyed)
      return;
    pb.opened = false;
    pb.$el = null;
    pb.el = null;
    delete pb.$el;
    delete pb.el;
    if (pb.$el) {
      pb.$el.trigger("photobrowser:closed");
    }
    pb.emit("local::closed photoBrowserClosed", pb);
  }
  // Open
  openPage() {
    const pb = this;
    if (pb.opened)
      return pb;
    const pageHtml = pb.renderPage();
    pb.view.router.navigate({
      url: pb.url,
      route: {
        content: pageHtml,
        path: pb.url,
        on: {
          pageBeforeIn(e, page) {
            pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
            pb.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            pb.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
            pb.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            pb.onClosed("page", page.el);
          }
        }
      }
    });
    return pb;
  }
  openStandalone() {
    const pb = this;
    if (pb.opened)
      return pb;
    const standaloneHtml = pb.renderStandalone();
    const popupParams = {
      backdrop: false,
      content: standaloneHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          pb.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          pb.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          pb.onClosed("popup", popup.el);
        }
      }
    };
    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }
  openPopup() {
    const pb = this;
    if (pb.opened)
      return pb;
    const popupHtml = pb.renderPopup();
    const popupParams = {
      content: popupHtml,
      push: pb.params.popupPush,
      closeByBackdropClick: pb.params.closeByBackdropClick,
      on: {
        popupOpen(popup) {
          pb.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          pb.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          pb.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          pb.onClosed("popup", popup.el);
        }
      }
    };
    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }
  // Exposition
  expositionEnable() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.addClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.addClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.addClass("photo-browser-captions-exposed");
    pb.exposed = true;
    return pb;
  }
  expositionDisable() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.removeClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.removeClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.removeClass("photo-browser-captions-exposed");
    pb.exposed = false;
    return pb;
  }
  expositionToggle() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.toggleClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.toggleClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.toggleClass("photo-browser-captions-exposed");
    pb.exposed = !pb.exposed;
    return pb;
  }
  open(index) {
    const pb = this;
    const type = pb.params.type;
    if (pb.opened) {
      if (pb.swiper && typeof index !== "undefined") {
        pb.swiper.slideTo(parseInt(index, 10));
      }
      return pb;
    }
    if (typeof index !== "undefined") {
      pb.activeIndex = index;
    }
    if (type === "standalone") {
      pb.openStandalone();
    }
    if (type === "page") {
      pb.openPage();
    }
    if (type === "popup") {
      pb.openPopup();
    }
    return pb;
  }
  close() {
    const pb = this;
    if (!pb.opened)
      return pb;
    if (pb.params.routableModals && pb.view || pb.openedIn === "page") {
      pb.view.router.back();
    } else {
      pb.modal.once("modalClosed", () => {
        nextTick(() => {
          if (pb.destroyed)
            return;
          pb.modal.destroy();
          delete pb.modal;
        });
      });
      pb.modal.close();
    }
    return pb;
  }
  // eslint-disable-next-line
  init() {
  }
  destroy() {
    let pb = this;
    pb.emit("local::beforeDestroy photoBrowserBeforeDestroy", pb);
    if (pb.$el) {
      pb.$el.trigger("photobrowser:beforedestroy");
      pb.$el[0].f7PhotoBrowser = null;
      delete pb.$el[0].f7PhotoBrowser;
    }
    deleteProps(pb);
    pb.destroyed = true;
    pb = null;
  }
};
var photo_browser_class_default = PhotoBrowser;

// node_modules/framework7/components/photo-browser/photo-browser.js
var photo_browser_default = {
  name: "photoBrowser",
  params: {
    photoBrowser: {
      photos: [],
      exposition: true,
      expositionHideCaptions: false,
      type: "standalone",
      navbar: true,
      toolbar: true,
      theme: "light",
      captionsTheme: void 0,
      iconsColor: void 0,
      popupPush: false,
      swipeToClose: true,
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      navbarOfText: "of",
      navbarShowCount: void 0,
      view: void 0,
      url: "photos/",
      routableModals: false,
      virtualSlides: true,
      closeByBackdropClick: true,
      renderNavbar: void 0,
      renderToolbar: void 0,
      renderCaption: void 0,
      renderObject: void 0,
      renderLazyPhoto: void 0,
      renderPhoto: void 0,
      renderPage: void 0,
      renderPopup: void 0,
      renderStandalone: void 0,
      swiper: {
        cssMode: false,
        initialSlide: 0,
        spaceBetween: 20,
        speed: 300,
        loop: false,
        preloadImages: true,
        keyboard: {
          enabled: true
        },
        navigation: {
          nextEl: ".photo-browser-next",
          prevEl: ".photo-browser-prev"
        },
        zoom: {
          enabled: true,
          maxRatio: 3,
          minRatio: 1
        },
        lazy: {
          enabled: true
        }
      }
    }
  },
  create() {
    const app = this;
    app.photoBrowser = ConstructorMethods({
      defaultSelector: ".photo-browser-popup, .photo-browser-page",
      constructor: photo_browser_class_default,
      app,
      domProp: "f7PhotoBrowser"
    });
  },
  static: {
    PhotoBrowser: photo_browser_class_default
  }
};

// node_modules/framework7/components/notification/notification-class.js
var Notification = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.notification, params);
    super(app, extendedParams);
    const notification = this;
    notification.app = app;
    notification.params = extendedParams;
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      closeTimeout,
      cssClass,
      closeOnClick
    } = notification.params;
    let $el;
    if (!notification.params.el) {
      const notificationHtml = notification.render({
        icon,
        title,
        titleRightText,
        subtitle,
        text,
        closeButton,
        cssClass
      });
      $el = dom7_default(notificationHtml);
    } else {
      $el = dom7_default(notification.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return notification.destroy();
    }
    extend(notification, {
      $el,
      el: $el[0],
      type: "notification"
    });
    $el[0].f7Modal = notification;
    if (closeButton) {
      $el.find(".notification-close-button").on("click", () => {
        notification.close();
      });
    }
    $el.on("click", (e) => {
      if (closeButton && dom7_default(e.target).closest(".notification-close-button").length) {
        return;
      }
      notification.emit("local::click notificationClick", notification);
      if (closeOnClick)
        notification.close();
    });
    notification.on("beforeDestroy", () => {
      $el.off("click");
    });
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchesDiff;
    let touchStartTime;
    let notificationHeight;
    const touchesStart = {};
    function handleTouchStart(e) {
      if (isTouched)
        return;
      isTouched = true;
      isMoved = false;
      isScrolling = void 0;
      touchStartTime = now();
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      if (!isMoved) {
        notification.$el.removeClass("notification-transitioning");
        notification.$el.transition(0);
        notificationHeight = notification.$el[0].offsetHeight / 2;
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      let newTranslate = touchesDiff;
      if (touchesDiff > 0) {
        newTranslate = touchesDiff ** 0.8;
      }
      notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      if (touchesDiff === 0) {
        return;
      }
      const timeDiff = now() - touchStartTime;
      notification.$el.transition("");
      notification.$el.addClass("notification-transitioning");
      notification.$el.transform("");
      if (touchesDiff < -10 && timeDiff < 300 || -touchesDiff >= notificationHeight / 1) {
        notification.close();
      }
    }
    function attachTouchEvents() {
      notification.$el.on(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
    }
    function detachTouchEvents() {
      notification.$el.off(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
    }
    let timeoutId;
    function closeOnTimeout() {
      timeoutId = nextTick(() => {
        if (isTouched && isMoved) {
          closeOnTimeout();
          return;
        }
        notification.close();
      }, closeTimeout);
    }
    notification.on("open", () => {
      if (notification.params.swipeToClose) {
        attachTouchEvents();
      }
      dom7_default(".notification.modal-in").each((openedEl) => {
        const notificationInstance = app.notification.get(openedEl);
        if (openedEl !== notification.el && notificationInstance) {
          notificationInstance.close();
        }
      });
      if (closeTimeout) {
        closeOnTimeout();
      }
    });
    notification.on("close beforeDestroy", () => {
      if (notification.params.swipeToClose) {
        detachTouchEvents();
      }
      clearTimeout(timeoutId);
    });
    return notification;
  }
  render() {
    const notification = this;
    if (notification.params.render)
      return notification.params.render.call(notification, notification);
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      cssClass
    } = notification.params;
    return jsx_default("div", {
      class: `notification ${cssClass || ""}`
    }, jsx_default("div", {
      class: "notification-header"
    }, icon && jsx_default("div", {
      class: "notification-icon"
    }, icon), title && jsx_default("div", {
      class: "notification-title"
    }, title), titleRightText && jsx_default("div", {
      class: "notification-title-right-text"
    }, titleRightText), closeButton && jsx_default("span", {
      class: "notification-close-button"
    })), jsx_default("div", {
      class: "notification-content"
    }, subtitle && jsx_default("div", {
      class: "notification-subtitle"
    }, subtitle), text && jsx_default("div", {
      class: "notification-text"
    }, text)));
  }
};
var notification_class_default = Notification;

// node_modules/framework7/components/notification/notification.js
var notification_default = {
  name: "notification",
  static: {
    Notification: notification_class_default
  },
  create() {
    const app = this;
    app.notification = extend({}, ModalMethods({
      app,
      constructor: notification_class_default,
      defaultSelector: ".notification.modal-in"
    }));
  },
  params: {
    notification: {
      icon: null,
      title: null,
      titleRightText: null,
      subtitle: null,
      text: null,
      closeButton: false,
      closeTimeout: null,
      closeOnClick: false,
      swipeToClose: true,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
};

// node_modules/framework7/components/autocomplete/autocomplete-class.js
var Autocomplete = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const ac = this;
    ac.app = app;
    const device = getDevice();
    const defaults = extend({
      on: {}
    }, app.params.autocomplete);
    if (typeof defaults.searchbarDisableButton === "undefined") {
      defaults.searchbarDisableButton = app.theme !== "aurora";
    }
    ac.useModulesParams(defaults);
    ac.params = extend(defaults, params);
    let $openerEl;
    if (ac.params.openerEl) {
      $openerEl = dom7_default(ac.params.openerEl);
      if ($openerEl.length)
        $openerEl[0].f7Autocomplete = ac;
    }
    let $inputEl;
    if (ac.params.inputEl) {
      $inputEl = dom7_default(ac.params.inputEl);
      if ($inputEl.length)
        $inputEl[0].f7Autocomplete = ac;
    }
    const uniqueId = id();
    let url = params.url;
    if (!url && $openerEl && $openerEl.length) {
      if ($openerEl.attr("href"))
        url = $openerEl.attr("href");
      else if ($openerEl.find("a").length > 0) {
        url = $openerEl.find("a").attr("href");
      }
    }
    if (!url || url === "#" || url === "")
      url = ac.params.url;
    const inputType = ac.params.multiple ? "checkbox" : "radio";
    extend(ac, {
      $openerEl,
      openerEl: $openerEl && $openerEl[0],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      id: uniqueId,
      url,
      value: ac.params.value || [],
      inputType,
      inputName: `${inputType}-${uniqueId}`,
      $modalEl: void 0,
      $dropdownEl: void 0
    });
    let previousQuery = "";
    function onInputChange() {
      let query = ac.$inputEl.val().trim();
      if (!ac.params.source)
        return;
      ac.params.source.call(ac, query, (items) => {
        let itemsHTML = "";
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        let regExp;
        if (ac.params.highlightMatches) {
          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          regExp = new RegExp(`(${query})`, "i");
        }
        let firstValue;
        let firstItem;
        for (let i = 0; i < limit; i += 1) {
          const itemValue = typeof items[i] === "object" ? items[i][ac.params.valueProperty] : items[i];
          const itemText = typeof items[i] === "object" ? items[i][ac.params.textProperty] : items[i];
          if (i === 0) {
            firstValue = itemValue;
            firstItem = ac.items[i];
          }
          itemsHTML += ac.renderItem({
            value: itemValue,
            text: ac.params.highlightMatches ? itemText.replace(regExp, "<b>$1</b>") : itemText
          }, i);
        }
        if (itemsHTML === "" && query === "" && ac.params.dropdownPlaceholderText) {
          itemsHTML += ac.renderItem({
            placeholder: true,
            text: ac.params.dropdownPlaceholderText
          });
        }
        ac.$dropdownEl.find("ul").html(itemsHTML);
        if (ac.params.typeahead) {
          if (!firstValue || !firstItem) {
            return;
          }
          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
            return;
          }
          if (previousQuery.toLowerCase() === query.toLowerCase()) {
            ac.value = [];
            return;
          }
          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
            previousQuery = query;
            ac.value = [];
            return;
          }
          $inputEl.val(firstValue);
          $inputEl[0].setSelectionRange(query.length, firstValue.length);
          const previousValue = typeof ac.value[0] === "object" ? ac.value[0][ac.params.valueProperty] : ac.value[0];
          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
            ac.value = [firstItem];
            ac.emit("local::change autocompleteChange", [firstItem]);
          }
        }
        previousQuery = query;
      });
    }
    function onPageInputChange() {
      const inputEl = this;
      const value = inputEl.value;
      const isValues = dom7_default(inputEl).parents(".autocomplete-values").length > 0;
      let item;
      let itemValue;
      let aValue;
      if (isValues) {
        if (ac.inputType === "checkbox" && !inputEl.checked) {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === "string" ? ac.value[i] : ac.value[i][ac.params.valueProperty];
            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }
          ac.updateValues();
          ac.emit("local::change autocompleteChange", ac.value);
        }
        return;
      }
      for (let i = 0; i < ac.items.length; i += 1) {
        itemValue = typeof ac.items[i] === "object" ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        if (itemValue === value || itemValue * 1 === value * 1)
          item = ac.items[i];
      }
      if (ac.inputType === "radio") {
        ac.value = [item];
      } else if (inputEl.checked) {
        ac.value.push(item);
      } else {
        for (let i = 0; i < ac.value.length; i += 1) {
          aValue = typeof ac.value[i] === "object" ? ac.value[i][ac.params.valueProperty] : ac.value[i];
          if (aValue === value || aValue * 1 === value * 1) {
            ac.value.splice(i, 1);
          }
        }
      }
      ac.updateValues();
      if (ac.inputType === "radio" && inputEl.checked || ac.inputType === "checkbox") {
        ac.emit("local::change autocompleteChange", ac.value);
      }
    }
    function onHtmlClick(e) {
      const $targetEl = dom7_default(e.target);
      if ($targetEl.is(ac.$inputEl[0]) || ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)
        return;
      ac.close();
    }
    function onOpenerClick() {
      ac.open();
    }
    function onInputFocus() {
      ac.open();
    }
    function onInputBlur() {
      if (ac.$dropdownEl.find("label.active-state").length > 0)
        return;
      setTimeout(() => {
        ac.close();
      }, 0);
    }
    function onResize() {
      ac.positionDropdown();
    }
    function onKeyDown(e) {
      if (!ac.opened)
        return;
      if (e.keyCode === 27) {
        e.preventDefault();
        ac.$inputEl.blur();
        return;
      }
      if (e.keyCode === 13) {
        const $selectedItemLabel = ac.$dropdownEl.find(".autocomplete-dropdown-selected label");
        if ($selectedItemLabel.length) {
          e.preventDefault();
          $selectedItemLabel.trigger("click");
          ac.$inputEl.blur();
          return;
        }
        if (ac.params.typeahead) {
          e.preventDefault();
          ac.$inputEl.blur();
        }
        return;
      }
      if (e.keyCode !== 40 && e.keyCode !== 38)
        return;
      e.preventDefault();
      const $selectedItem = ac.$dropdownEl.find(".autocomplete-dropdown-selected");
      let $newItem;
      if ($selectedItem.length) {
        $newItem = $selectedItem[e.keyCode === 40 ? "next" : "prev"]("li");
        if (!$newItem.length) {
          $newItem = ac.$dropdownEl.find("li").eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find("li").length - 1);
        }
      } else {
        $newItem = ac.$dropdownEl.find("li").eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find("li").length - 1);
      }
      if ($newItem.hasClass("autocomplete-dropdown-placeholder"))
        return;
      $selectedItem.removeClass("autocomplete-dropdown-selected");
      $newItem.addClass("autocomplete-dropdown-selected");
    }
    function onDropdownClick() {
      const $clickedEl = dom7_default(this);
      let clickedItem;
      for (let i = 0; i < ac.items.length; i += 1) {
        const itemValue = typeof ac.items[i] === "object" ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        const value = $clickedEl.attr("data-value");
        if (itemValue === value || itemValue * 1 === value * 1) {
          clickedItem = ac.items[i];
        }
      }
      if (ac.params.updateInputValueOnSelect) {
        ac.$inputEl.val(typeof clickedItem === "object" ? clickedItem[ac.params.valueProperty] : clickedItem);
        ac.$inputEl.trigger("input change");
      }
      ac.value = [clickedItem];
      ac.emit("local::change autocompleteChange", [clickedItem]);
      ac.close();
    }
    ac.attachEvents = function attachEvents() {
      if (ac.params.openIn !== "dropdown" && ac.$openerEl) {
        ac.$openerEl.on("click", onOpenerClick);
      }
      if (ac.params.openIn === "dropdown" && ac.$inputEl) {
        ac.$inputEl.on("focus", onInputFocus);
        ac.$inputEl.on(ac.params.inputEvents, onInputChange);
        if (device.android) {
          dom7_default("html").on("click", onHtmlClick);
        } else {
          ac.$inputEl.on("blur", onInputBlur);
        }
        ac.$inputEl.on("keydown", onKeyDown);
      }
    };
    ac.detachEvents = function attachEvents() {
      if (ac.params.openIn !== "dropdown" && ac.$openerEl) {
        ac.$openerEl.off("click", onOpenerClick);
      }
      if (ac.params.openIn === "dropdown" && ac.$inputEl) {
        ac.$inputEl.off("focus", onInputFocus);
        ac.$inputEl.off(ac.params.inputEvents, onInputChange);
        if (device.android) {
          dom7_default("html").off("click", onHtmlClick);
        } else {
          ac.$inputEl.off("blur", onInputBlur);
        }
        ac.$inputEl.off("keydown", onKeyDown);
      }
    };
    ac.attachDropdownEvents = function attachDropdownEvents() {
      ac.$dropdownEl.on("click", "label", onDropdownClick);
      app.on("resize", onResize);
    };
    ac.detachDropdownEvents = function detachDropdownEvents() {
      ac.$dropdownEl.off("click", "label", onDropdownClick);
      app.off("resize", onResize);
    };
    ac.attachPageEvents = function attachPageEvents() {
      ac.$el.on("change", 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
      if (ac.params.closeOnSelect && !ac.params.multiple) {
        ac.$el.once("click", ".list label", () => {
          nextTick(() => {
            ac.close();
          });
        });
      }
    };
    ac.detachPageEvents = function detachPageEvents() {
      ac.$el.off("change", 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
    };
    ac.useModules();
    ac.init();
    return ac;
  }
  get view() {
    const ac = this;
    const {
      $openerEl,
      $inputEl,
      app
    } = ac;
    let view;
    if (ac.params.view) {
      view = ac.params.view;
    } else if ($openerEl || $inputEl) {
      const $el = $openerEl || $inputEl;
      view = $el.closest(".view").length && $el.closest(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  positionDropdown() {
    const ac = this;
    const {
      $inputEl,
      app,
      $dropdownEl
    } = ac;
    const $pageContentEl = $inputEl.parents(".page-content");
    if ($pageContentEl.length === 0)
      return;
    const inputOffset = $inputEl.offset();
    const inputOffsetWidth = $inputEl[0].offsetWidth;
    const inputOffsetHeight = $inputEl[0].offsetHeight;
    const $listEl = $inputEl.parents(".list");
    let $listParent;
    $listEl.parents().each((parentEl) => {
      if ($listParent)
        return;
      const $parentEl = dom7_default(parentEl);
      if ($parentEl.parent($pageContentEl).length)
        $listParent = $parentEl;
    });
    const listOffset = $listEl.offset();
    const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
    const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
    const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
    const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);
    const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;
    const paddingProp = app.rtl ? "padding-right" : "padding-left";
    let paddingValue;
    if ($listEl.length && !ac.params.expandInput) {
      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === "md" ? 16 : 15);
    }
    $dropdownEl.css({
      left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
      top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
      width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`
    });
    $dropdownEl.children(".autocomplete-dropdown-inner").css({
      maxHeight: `${maxHeight}px`,
      [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : ""
    });
  }
  focus() {
    const ac = this;
    ac.$el.find("input[type=search]").focus();
  }
  source(query) {
    const ac = this;
    if (!ac.params.source)
      return;
    const {
      $el
    } = ac;
    ac.params.source.call(ac, query, (items) => {
      let itemsHTML = "";
      const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
      ac.items = items;
      for (let i = 0; i < limit; i += 1) {
        let selected = false;
        const itemValue = typeof items[i] === "object" ? items[i][ac.params.valueProperty] : items[i];
        for (let j = 0; j < ac.value.length; j += 1) {
          const aValue = typeof ac.value[j] === "object" ? ac.value[j][ac.params.valueProperty] : ac.value[j];
          if (aValue === itemValue || aValue * 1 === itemValue * 1)
            selected = true;
        }
        itemsHTML += ac.renderItem({
          value: itemValue,
          text: typeof items[i] === "object" ? items[i][ac.params.textProperty] : items[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: ac.inputName,
          selected
        }, i);
      }
      $el.find(".autocomplete-found ul").html(itemsHTML);
      if (items.length === 0) {
        if (query.length !== 0) {
          $el.find(".autocomplete-not-found").show();
          $el.find(".autocomplete-found, .autocomplete-values").hide();
        } else {
          $el.find(".autocomplete-values").show();
          $el.find(".autocomplete-found, .autocomplete-not-found").hide();
        }
      } else {
        $el.find(".autocomplete-found").show();
        $el.find(".autocomplete-not-found, .autocomplete-values").hide();
      }
    });
  }
  updateValues() {
    const ac = this;
    let valuesHTML = "";
    for (let i = 0; i < ac.value.length; i += 1) {
      valuesHTML += ac.renderItem({
        value: typeof ac.value[i] === "object" ? ac.value[i][ac.params.valueProperty] : ac.value[i],
        text: typeof ac.value[i] === "object" ? ac.value[i][ac.params.textProperty] : ac.value[i],
        inputType: ac.inputType,
        id: ac.id,
        inputName: `${ac.inputName}-checked}`,
        selected: true
      }, i);
    }
    ac.$el.find(".autocomplete-values ul").html(valuesHTML);
  }
  preloaderHide() {
    const ac = this;
    if (ac.params.openIn === "dropdown" && ac.$dropdownEl) {
      ac.$dropdownEl.find(".autocomplete-preloader").removeClass("autocomplete-preloader-visible");
    } else {
      dom7_default(".autocomplete-preloader").removeClass("autocomplete-preloader-visible");
    }
  }
  preloaderShow() {
    const ac = this;
    if (ac.params.openIn === "dropdown" && ac.$dropdownEl) {
      ac.$dropdownEl.find(".autocomplete-preloader").addClass("autocomplete-preloader-visible");
    } else {
      dom7_default(".autocomplete-preloader").addClass("autocomplete-preloader-visible");
    }
  }
  renderPreloader() {
    const ac = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    return jsx_default("div", {
      class: `autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ""}`
    }, preloaders[`${ac.app.theme}PreloaderContent`] || "");
  }
  renderSearchbar() {
    const ac = this;
    if (ac.params.renderSearchbar)
      return ac.params.renderSearchbar.call(ac);
    return jsx_default("form", {
      class: "searchbar"
    }, jsx_default("div", {
      class: "searchbar-inner"
    }, jsx_default("div", {
      class: "searchbar-input-wrap"
    }, jsx_default("input", {
      type: "search",
      spellcheck: ac.params.searchbarSpellcheck || "false",
      placeholder: ac.params.searchbarPlaceholder
    }), jsx_default("i", {
      class: "searchbar-icon"
    }), jsx_default("span", {
      class: "input-clear-button"
    })), ac.params.searchbarDisableButton && jsx_default("span", {
      class: "searchbar-disable-button"
    }, ac.params.searchbarDisableText)));
  }
  renderItem(item, index) {
    const ac = this;
    if (ac.params.renderItem)
      return ac.params.renderItem.call(ac, item, index);
    const itemValue = item.value && typeof item.value === "string" ? item.value.replace(/"/g, "&quot;") : item.value;
    if (ac.params.openIn !== "dropdown") {
      return jsx_default("li", null, jsx_default("label", {
        class: `item-${item.inputType} item-content`
      }, jsx_default("input", {
        type: item.inputType,
        name: item.inputName,
        value: itemValue,
        _checked: item.selected
      }), jsx_default("i", {
        class: `icon icon-${item.inputType}`
      }), jsx_default("div", {
        class: "item-inner"
      }, jsx_default("div", {
        class: "item-title"
      }, item.text))));
    }
    if (!item.placeholder) {
      return jsx_default("li", null, jsx_default("label", {
        class: "item-radio item-content",
        "data-value": itemValue
      }, jsx_default("div", {
        class: "item-inner"
      }, jsx_default("div", {
        class: "item-title"
      }, item.text))));
    }
    return jsx_default("li", {
      class: "autocomplete-dropdown-placeholder"
    }, jsx_default("label", {
      class: "item-content"
    }, jsx_default("div", {
      class: "item-inner"
    }, jsx_default("div", {
      class: "item-title"
    }, item.text))));
  }
  renderNavbar() {
    const ac = this;
    if (ac.params.renderNavbar)
      return ac.params.renderNavbar.call(ac);
    let pageTitle = ac.params.pageTitle;
    if (typeof pageTitle === "undefined" && ac.$openerEl && ac.$openerEl.length) {
      pageTitle = ac.$openerEl.find(".item-title").text().trim();
    }
    const inPopup = ac.params.openIn === "popup";
    const navbarLeft = inPopup ? ac.params.preloader && jsx_default("div", {
      class: "left"
    }, ac.renderPreloader()) : jsx_default("div", {
      class: "left sliding"
    }, jsx_default("a", {
      class: "link back"
    }, jsx_default("i", {
      class: "icon icon-back"
    }), jsx_default("span", {
      class: "if-not-md"
    }, ac.params.pageBackLinkText)));
    const navbarRight = inPopup ? jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link popup-close",
      "data-popup": ".autocomplete-popup"
    }, ac.params.popupCloseLinkText)) : ac.params.preloader && jsx_default("div", {
      class: "right"
    }, ac.renderPreloader());
    return jsx_default("div", {
      class: `navbar ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ""}`
    }, jsx_default("div", {
      class: "navbar-bg"
    }), jsx_default("div", {
      class: `navbar-inner ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ""}`
    }, navbarLeft, pageTitle && jsx_default("div", {
      class: "title sliding"
    }, pageTitle), navbarRight, jsx_default("div", {
      class: "subnavbar sliding"
    }, ac.renderSearchbar())));
  }
  renderDropdown() {
    const ac = this;
    if (ac.params.renderDropdown)
      return ac.params.renderDropdown.call(ac, ac.items);
    return jsx_default("div", {
      class: "autocomplete-dropdown"
    }, jsx_default("div", {
      class: "autocomplete-dropdown-inner"
    }, jsx_default("div", {
      class: `list ${!ac.params.expandInput ? "no-safe-areas" : ""}`
    }, jsx_default("ul", null))), ac.params.preloader && ac.renderPreloader());
  }
  renderPage(inPopup) {
    const ac = this;
    if (ac.params.renderPage)
      return ac.params.renderPage.call(ac, ac.items);
    return jsx_default("div", {
      class: "page page-with-subnavbar autocomplete-page",
      "data-name": "autocomplete-page"
    }, ac.renderNavbar(inPopup), jsx_default("div", {
      class: "searchbar-backdrop"
    }), jsx_default("div", {
      class: "page-content"
    }, jsx_default("div", {
      class: `list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-${ac.params.formColorTheme}` : ""}`
    }, jsx_default("ul", null)), jsx_default("div", {
      class: "list autocomplete-not-found"
    }, jsx_default("ul", null, jsx_default("li", {
      class: "item-content"
    }, jsx_default("div", {
      class: "item-inner"
    }, jsx_default("div", {
      class: "item-title"
    }, ac.params.notFoundText))))), jsx_default("div", {
      class: "list autocomplete-values"
    }, jsx_default("ul", null))));
  }
  renderPopup() {
    const ac = this;
    if (ac.params.renderPopup)
      return ac.params.renderPopup.call(ac, ac.items);
    return jsx_default("div", {
      class: "popup autocomplete-popup"
    }, jsx_default("div", {
      class: "view"
    }, ac.renderPage(true), ";"));
  }
  onOpen(type, el) {
    const ac = this;
    const app = ac.app;
    const $el = dom7_default(el);
    ac.$el = $el;
    ac.el = $el[0];
    ac.openedIn = type;
    ac.opened = true;
    if (ac.params.openIn === "dropdown") {
      ac.attachDropdownEvents();
      ac.$dropdownEl.addClass("autocomplete-dropdown-in");
      ac.$inputEl.trigger("input");
    } else {
      let $searchbarEl = $el.find(".searchbar");
      if (ac.params.openIn === "page" && app.theme === "ios" && $searchbarEl.length === 0) {
        $searchbarEl = dom7_default(app.navbar.getElByPage($el)).find(".searchbar");
      }
      ac.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $el.find(".searchbar-backdrop"),
        customSearch: true,
        on: {
          search(sb, query) {
            if (query.length === 0 && ac.searchbar.enabled) {
              ac.searchbar.backdropShow();
            } else {
              ac.searchbar.backdropHide();
            }
            ac.source(query);
          }
        }
      });
      ac.attachPageEvents();
      ac.updateValues();
      if (ac.params.requestSourceOnOpen)
        ac.source("");
    }
    ac.emit("local::open autocompleteOpen", ac);
  }
  autoFocus() {
    const ac = this;
    if (ac.searchbar && ac.searchbar.$inputEl) {
      ac.searchbar.$inputEl.focus();
    }
    return ac;
  }
  onOpened() {
    const ac = this;
    if (ac.params.openIn !== "dropdown" && ac.params.autoFocus) {
      ac.autoFocus();
    }
    ac.emit("local::opened autocompleteOpened", ac);
  }
  onClose() {
    const ac = this;
    if (ac.destroyed)
      return;
    if (ac.searchbar && ac.searchbar.destroy) {
      ac.searchbar.destroy();
      ac.searchbar = null;
      delete ac.searchbar;
    }
    if (ac.params.openIn === "dropdown") {
      ac.detachDropdownEvents();
      ac.$dropdownEl.removeClass("autocomplete-dropdown-in").remove();
      ac.$inputEl.parents(".item-content-dropdown-expanded").removeClass("item-content-dropdown-expanded");
    } else {
      ac.detachPageEvents();
    }
    ac.emit("local::close autocompleteClose", ac);
  }
  onClosed() {
    const ac = this;
    if (ac.destroyed)
      return;
    ac.opened = false;
    ac.$el = null;
    ac.el = null;
    delete ac.$el;
    delete ac.el;
    ac.emit("local::closed autocompleteClosed", ac);
  }
  openPage() {
    const ac = this;
    if (ac.opened)
      return ac;
    const pageHtml = ac.renderPage();
    ac.view.router.navigate({
      url: ac.url,
      route: {
        content: pageHtml,
        path: ac.url,
        on: {
          pageBeforeIn(e, page) {
            ac.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            ac.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            ac.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            ac.onClosed("page", page.el);
          }
        },
        options: {
          animate: ac.params.animate
        }
      }
    });
    return ac;
  }
  openPopup() {
    const ac = this;
    if (ac.opened)
      return ac;
    const popupHtml = ac.renderPopup();
    const popupParams = {
      content: popupHtml,
      animate: ac.params.animate,
      push: ac.params.popupPush,
      swipeToClose: ac.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ac.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          ac.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          ac.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          ac.onClosed("popup", popup.el);
        }
      }
    };
    if (ac.params.routableModals && ac.view) {
      ac.view.router.navigate({
        url: ac.url,
        route: {
          path: ac.url,
          popup: popupParams
        }
      });
    } else {
      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
    }
    return ac;
  }
  openDropdown() {
    const ac = this;
    if (!ac.$dropdownEl) {
      ac.$dropdownEl = dom7_default(ac.renderDropdown());
    }
    const $listEl = ac.$inputEl.parents(".list");
    if ($listEl.length && ac.$inputEl.parents(".item-content").length > 0 && ac.params.expandInput) {
      ac.$inputEl.parents(".item-content").addClass("item-content-dropdown-expanded");
    }
    const $pageContentEl = ac.$inputEl.parents(".page-content");
    if (ac.params.dropdownContainerEl) {
      dom7_default(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
    } else if ($pageContentEl.length === 0) {
      ac.$dropdownEl.insertAfter(ac.$inputEl);
    } else {
      ac.positionDropdown();
      $pageContentEl.append(ac.$dropdownEl);
    }
    ac.onOpen("dropdown", ac.$dropdownEl);
    ac.onOpened("dropdown", ac.$dropdownEl);
  }
  open() {
    const ac = this;
    if (ac.opened)
      return ac;
    const openIn = ac.params.openIn;
    ac[`open${openIn.split("").map((el, index) => {
      if (index === 0)
        return el.toUpperCase();
      return el;
    }).join("")}`]();
    return ac;
  }
  close() {
    const ac = this;
    if (!ac.opened)
      return ac;
    if (ac.params.openIn === "dropdown") {
      ac.onClose();
      ac.onClosed();
    } else if (ac.params.routableModals && ac.view || ac.openedIn === "page") {
      ac.view.router.back({
        animate: ac.params.animate
      });
    } else {
      ac.modal.once("modalClosed", () => {
        nextTick(() => {
          if (ac.destroyed)
            return;
          ac.modal.destroy();
          delete ac.modal;
        });
      });
      ac.modal.close();
    }
    return ac;
  }
  init() {
    const ac = this;
    ac.attachEvents();
  }
  destroy() {
    const ac = this;
    ac.emit("local::beforeDestroy autocompleteBeforeDestroy", ac);
    ac.detachEvents();
    if (ac.$inputEl && ac.$inputEl[0]) {
      delete ac.$inputEl[0].f7Autocomplete;
    }
    if (ac.$openerEl && ac.$openerEl[0]) {
      delete ac.$openerEl[0].f7Autocomplete;
    }
    deleteProps(ac);
    ac.destroyed = true;
  }
};
var autocomplete_class_default = Autocomplete;

// node_modules/framework7/components/autocomplete/autocomplete.js
var autocomplete_default = {
  name: "autocomplete",
  params: {
    autocomplete: {
      openerEl: void 0,
      inputEl: void 0,
      view: void 0,
      // DropDown
      dropdownContainerEl: void 0,
      dropdownPlaceholderText: void 0,
      typeahead: false,
      highlightMatches: true,
      expandInput: false,
      updateInputValueOnSelect: true,
      inputEvents: "input",
      value: void 0,
      multiple: false,
      source: void 0,
      limit: void 0,
      valueProperty: "id",
      textProperty: "text",
      openIn: "page",
      // or 'popup' or 'dropdown'
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      pageTitle: void 0,
      searchbarPlaceholder: "Search...",
      searchbarDisableText: "Cancel",
      searchbarDisableButton: void 0,
      searchbarSpellcheck: false,
      popupPush: false,
      popupSwipeToClose: void 0,
      animate: true,
      autoFocus: false,
      closeOnSelect: false,
      notFoundText: "Nothing found",
      requestSourceOnOpen: false,
      // Preloader
      preloaderColor: void 0,
      preloader: false,
      // Colors
      formColorTheme: void 0,
      navbarColorTheme: void 0,
      // Routing
      routableModals: false,
      url: "select/",
      // Custom render functions
      renderDropdown: void 0,
      renderPage: void 0,
      renderPopup: void 0,
      renderItem: void 0,
      renderSearchbar: void 0,
      renderNavbar: void 0
    }
  },
  static: {
    Autocomplete: autocomplete_class_default
  },
  create() {
    const app = this;
    app.autocomplete = extend(ConstructorMethods({
      defaultSelector: void 0,
      constructor: autocomplete_class_default,
      app,
      domProp: "f7Autocomplete"
    }), {
      open(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.open)
          return ac.open();
        return void 0;
      },
      close(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.close)
          return ac.close();
        return void 0;
      }
    });
  }
};

// node_modules/framework7/components/tooltip/tooltip-class.js
var Tooltip = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const tooltip = this;
    const support = getSupport();
    const defaults = extend({}, app.params.tooltip);
    const document = getDocument();
    tooltip.useModulesParams(defaults);
    tooltip.params = extend(defaults, params);
    if (typeof params.offset === "undefined" && support.touch && tooltip.params.trigger === "hover") {
      tooltip.params.offset = 10;
    }
    const {
      targetEl,
      containerEl
    } = tooltip.params;
    if (!targetEl && !tooltip.params.delegated)
      return tooltip;
    const $targetEl = dom7_default(targetEl);
    if ($targetEl.length === 0 && !tooltip.params.delegated)
      return tooltip;
    if ($targetEl[0] && $targetEl[0].f7Tooltip && !tooltip.params.delegated)
      return $targetEl[0].f7Tooltip;
    let $containerEl = dom7_default(containerEl || app.$el).eq(0);
    if ($containerEl.length === 0) {
      $containerEl = app.$el;
    }
    const $el = dom7_default(tooltip.render()).eq(0);
    extend(tooltip, {
      app,
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      $el,
      el: $el && $el[0],
      text: tooltip.params.text || "",
      visible: false,
      opened: false
    });
    if ($targetEl[0])
      $targetEl[0].f7Tooltip = tooltip;
    const touchesStart = {};
    let isTouched;
    function handleClick() {
      if (tooltip.opened)
        tooltip.hide();
      else
        tooltip.show(this);
    }
    function handleClickOut(e) {
      if (tooltip.opened && (dom7_default(e.target).closest($targetEl).length || dom7_default(e.target).closest(tooltip.$el).length))
        return;
      tooltip.hide();
    }
    function handleTouchStart(e) {
      if (isTouched)
        return;
      isTouched = true;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      tooltip.show(this);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      const distance = ((x - touchesStart.x) ** 2 + (y - touchesStart.y) ** 2) ** 0.5;
      if (distance > 50) {
        isTouched = false;
        tooltip.hide();
      }
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      isTouched = false;
      tooltip.hide();
    }
    function handleMouseEnter() {
      tooltip.show(this);
    }
    function handleMouseLeave() {
      tooltip.hide();
    }
    function handleTransitionEnd() {
      if (!$el.hasClass("tooltip-in")) {
        $el.removeClass("tooltip-out").remove();
      }
    }
    tooltip.attachEvents = function attachEvents() {
      $el.on("transitionend", handleTransitionEnd);
      if (tooltip.params.trigger === "click") {
        if (tooltip.params.delegated) {
          dom7_default(document).on("click", tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.on("click", handleClick);
        }
        dom7_default("html").on("click", handleClickOut);
        return;
      }
      if (tooltip.params.trigger === "manual")
        return;
      if (support.touch) {
        const passive = support.passiveListener ? {
          passive: true
        } : false;
        if (tooltip.params.delegated) {
          dom7_default(document).on(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.on(app.touchEvents.start, handleTouchStart, passive);
        }
        app.on("touchmove", handleTouchMove);
        app.on("touchend:passive", handleTouchEnd);
      } else {
        if (tooltip.params.delegated) {
          dom7_default(document).on(support.pointerEvents ? "pointerenter" : "mouseenter", tooltip.params.targetEl, handleMouseEnter, true);
          dom7_default(document).on(support.pointerEvents ? "pointerleave" : "mouseleave", tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.on(support.pointerEvents ? "pointerenter" : "mouseenter", handleMouseEnter);
          tooltip.$targetEl.on(support.pointerEvents ? "pointerleave" : "mouseleave", handleMouseLeave);
        }
      }
    };
    tooltip.detachEvents = function detachEvents() {
      $el.off("transitionend", handleTransitionEnd);
      if (tooltip.params.trigger === "click") {
        if (tooltip.params.delegated) {
          dom7_default(document).on("click", tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.off("click", handleClick);
        }
        dom7_default("html").off("click", handleClickOut);
        return;
      }
      if (tooltip.params.trigger === "manual")
        return;
      if (support.touch) {
        const passive = support.passiveListener ? {
          passive: true
        } : false;
        if (tooltip.params.delegated) {
          dom7_default(document).off(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.off(app.touchEvents.start, handleTouchStart, passive);
        }
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      } else {
        if (tooltip.params.delegated) {
          dom7_default(document).off(support.pointerEvents ? "pointerenter" : "mouseenter", tooltip.params.targetEl, handleMouseEnter, true);
          dom7_default(document).off(support.pointerEvents ? "pointerleave" : "mouseleave", tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.off(support.pointerEvents ? "pointerenter" : "mouseenter", handleMouseEnter);
          tooltip.$targetEl.off(support.pointerEvents ? "pointerleave" : "mouseleave", handleMouseLeave);
        }
      }
    };
    tooltip.useModules();
    tooltip.init();
    return tooltip;
  }
  setTargetEl(targetEl) {
    const tooltip = this;
    tooltip.detachEvents();
    tooltip.$targetEl = dom7_default(targetEl);
    tooltip.targetEl = tooltip.$targetEl[0];
    tooltip.attachEvents();
    return tooltip;
  }
  position(targetEl) {
    const tooltip = this;
    const {
      $el,
      app,
      $containerEl
    } = tooltip;
    const hasContainerEl = !!tooltip.params.containerEl;
    const tooltipOffset = tooltip.params.offset || 0;
    $el.css({
      left: "",
      top: ""
    });
    const $targetEl = dom7_default(targetEl || tooltip.targetEl);
    const [width, height] = [$el.width(), $el.height()];
    $el.css({
      left: "",
      top: ""
    });
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    const boundaries = hasContainerEl && $containerEl.length ? $containerEl[0].getBoundingClientRect() : app;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      if (typeof targetWidth === "undefined" && typeof targetHeight === "undefined") {
        const clientRect = $targetEl[0].getBoundingClientRect();
        targetWidth = clientRect.width;
        targetHeight = clientRect.height;
      }
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - boundaries.left;
      targetOffsetTop = targetOffset.top - boundaries.top;
      const targetParentPage = $targetEl.parents(".page");
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    }
    let [left, top] = [0, 0, 0];
    let position = "top";
    if (height + tooltipOffset < targetOffsetTop) {
      top = targetOffsetTop - height - tooltipOffset;
    } else if (height < boundaries.height - targetOffsetTop - targetHeight) {
      position = "bottom";
      top = targetOffsetTop + targetHeight + tooltipOffset;
    } else {
      position = "middle";
      top = targetHeight / 2 + targetOffsetTop - height / 2;
      if (top <= 0) {
        top = 8;
      } else if (top + height >= boundaries.height) {
        top = boundaries.height - height - 8;
      }
    }
    if (position === "top" || position === "bottom") {
      left = targetWidth / 2 + targetOffsetLeft - width / 2;
      if (left < 8)
        left = 8;
      if (left + width > boundaries.width)
        left = boundaries.width - width - 8;
      if (left < 0)
        left = 0;
    } else if (position === "middle") {
      left = targetOffsetLeft - width;
      if (left < 8 || left + width > boundaries.width) {
        if (left < 8)
          left = targetOffsetLeft + targetWidth;
        if (left + width > boundaries.width)
          left = boundaries.width - width - 8;
      }
    }
    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }
  show(aroundEl) {
    const tooltip = this;
    const {
      $el,
      $targetEl,
      $containerEl
    } = tooltip;
    if ($containerEl[0] && $el[0] && !$containerEl[0].contains($el[0])) {
      $containerEl.append($el);
    }
    tooltip.position(aroundEl);
    const $aroundEl = dom7_default(aroundEl);
    tooltip.visible = true;
    tooltip.opened = true;
    $targetEl.trigger("tooltip:show");
    $el.trigger("tooltip:show");
    if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
      $aroundEl.trigger("tooltip:show");
    }
    tooltip.emit("local::show tooltipShow", tooltip);
    $el.removeClass("tooltip-out").addClass("tooltip-in");
    return tooltip;
  }
  hide() {
    const tooltip = this;
    const {
      $el,
      $targetEl
    } = tooltip;
    tooltip.visible = false;
    tooltip.opened = false;
    $targetEl.trigger("tooltip:hide");
    $el.trigger("tooltip:hide");
    tooltip.emit("local::hide tooltipHide", tooltip);
    $el.addClass("tooltip-out").removeClass("tooltip-in");
    return tooltip;
  }
  render() {
    const tooltip = this;
    if (tooltip.params.render)
      return tooltip.params.render.call(tooltip, tooltip);
    const {
      cssClass,
      text
    } = tooltip.params;
    return `
      <div class="tooltip ${cssClass || ""}">
        <div class="tooltip-content">${text || ""}</div>
      </div>
    `.trim();
  }
  setText(newText) {
    const tooltip = this;
    if (typeof newText === "undefined") {
      return tooltip;
    }
    tooltip.params.text = newText;
    tooltip.text = newText;
    if (tooltip.$el) {
      tooltip.$el.children(".tooltip-content").html(newText);
    }
    if (tooltip.opened) {
      tooltip.position();
    }
    return tooltip;
  }
  init() {
    const tooltip = this;
    tooltip.attachEvents();
  }
  destroy() {
    const tooltip = this;
    if (!tooltip.$targetEl || tooltip.destroyed)
      return;
    tooltip.$targetEl.trigger("tooltip:beforedestroy");
    tooltip.emit("local::beforeDestroy tooltipBeforeDestroy", tooltip);
    tooltip.$el.remove();
    if (tooltip.$targetEl[0])
      delete tooltip.$targetEl[0].f7Tooltip;
    tooltip.detachEvents();
    deleteProps(tooltip);
    tooltip.destroyed = true;
  }
};
var tooltip_class_default = Tooltip;

// node_modules/framework7/components/tooltip/tooltip.js
var tooltip_default = {
  name: "tooltip",
  static: {
    Tooltip: tooltip_class_default
  },
  create() {
    const app = this;
    app.tooltip = ConstructorMethods({
      defaultSelector: ".tooltip",
      constructor: tooltip_class_default,
      app,
      domProp: "f7Tooltip"
    });
    app.tooltip.show = function show(el) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.show($el[0]);
      return tooltip;
    };
    app.tooltip.hide = function hide(el) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.hide();
      return tooltip;
    };
    app.tooltip.setText = function text(el, newText) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.setText(newText);
      return tooltip;
    };
  },
  params: {
    tooltip: {
      targetEl: null,
      delegated: false,
      text: null,
      cssClass: null,
      render: null,
      offset: 0,
      trigger: "hover",
      containerEl: void 0
    }
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".tooltip-init").each((el) => {
        const text = dom7_default(el).attr("data-tooltip");
        if (!text)
          return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".tooltip-init").each((el) => {
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".tooltip-init").each((el) => {
        const text = dom7_default(el).attr("data-tooltip");
        if (!text)
          return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".tooltip-init").each((el) => {
          const text = dom7_default(el).attr("data-tooltip");
          if (!text)
            return;
          app.tooltip.create({
            targetEl: el,
            text
          });
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".tooltip-init").each((el) => {
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".tooltip-init").each((el) => {
          if (el.f7Tooltip)
            el.f7Tooltip.destroy();
        });
      }
    }
  },
  vnode: {
    "tooltip-init": {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        const text = dom7_default(el).attr("data-tooltip");
        if (!text)
          return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      },
      update(vnode) {
        const el = vnode.elm;
        if (!el.f7Tooltip)
          return;
        if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs["data-tooltip"]) {
          el.f7Tooltip.setText(vnode.data.attrs["data-tooltip"]);
        }
      },
      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      }
    }
  }
};

// node_modules/framework7/components/skeleton/skeleton.js
var skeleton_default = {
  name: "skeleton"
};

// node_modules/framework7/components/menu/menu.js
var Menu = {
  open(el) {
    if (el === void 0) {
      el = ".menu-item-dropdown";
    }
    const app = this;
    if (!el)
      return;
    const $el = dom7_default(el).closest(".menu-item-dropdown");
    if (!$el.length)
      return;
    const $menuEl = $el.closest(".menu").eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl.css("z-index");
      const originalZIndex = $menuEl[0].style.zIndex;
      $menuEl.css("z-index", parseInt(zIndex || 0, 10) + 1);
      $menuEl[0].f7MenuZIndex = originalZIndex;
    }
    $el.eq(0).addClass("menu-item-dropdown-opened").trigger("menu:opened");
    app.emit("menuOpened", $el.eq(0)[0]);
  },
  close(el) {
    if (el === void 0) {
      el = ".menu-item-dropdown-opened";
    }
    const app = this;
    if (!el)
      return;
    const $el = dom7_default(el).closest(".menu-item-dropdown-opened");
    if (!$el.length)
      return;
    const $menuEl = $el.closest(".menu").eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl[0].f7MenuZIndex;
      $menuEl.css("z-index", zIndex);
      delete $menuEl[0].f7MenuZIndex;
    }
    $el.eq(0).removeClass("menu-item-dropdown-opened").trigger("menu:closed");
    app.emit("menuClosed", $el.eq(0)[0]);
  }
};
var menu_default = {
  name: "menu",
  create() {
    const app = this;
    bindMethods(app, {
      menu: Menu
    });
  },
  on: {
    click(e) {
      const app = this;
      const openedMenus = dom7_default(".menu-item-dropdown-opened");
      if (!openedMenus.length)
        return;
      openedMenus.each((el) => {
        if (!dom7_default(e.target).closest(".menu-item-dropdown-opened").length) {
          app.menu.close(el);
        }
      });
    }
  },
  clicks: {
    ".menu-item-dropdown": function onClick($clickedEl, dataset, e) {
      const app = this;
      if ($clickedEl.hasClass("menu-item-dropdown-opened")) {
        if (dom7_default(e.target).closest(".menu-dropdown").length)
          return;
        app.menu.close($clickedEl);
      } else {
        app.menu.open($clickedEl);
      }
    },
    ".menu-close": function onClick2() {
      const app = this;
      app.menu.close();
    }
  }
};

// node_modules/framework7/components/color-picker/modules/alpha-slider.js
var alpha_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      alphaLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-alpha-slider"
    }, jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, alphaLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-alpha"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.01",
      min: "0",
      max: "1",
      class: "color-picker-value-alpha"
    }) : jsx_default("span", {
      class: "color-picker-value-alpha"
    }))));
  },
  init(self) {
    self.alphaRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-alpha"),
      min: 0,
      max: 1,
      step: 0.01,
      value: 1,
      on: {
        change(range, value) {
          const alpha = Math.floor(value * 100) / 100;
          self.setValue({
            alpha
          });
        }
      }
    });
    function handleInputChange(e) {
      const alpha = self.value.alpha;
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = alpha;
        return;
      }
      value = Math.max(0, Math.min(1, value));
      self.setValue({
        alpha: value
      });
    }
    self.$el.on("change", ".color-picker-module-alpha-slider input", handleInputChange);
    self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
      self.$el.off("change", ".color-picker-module-alpha-slider input", handleInputChange);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      alpha
    } = value;
    self.alphaRangeSlider.value = alpha;
    self.alphaRangeSlider.layout();
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-alpha").val(alpha);
    } else {
      self.$el.find("span.color-picker-value-alpha").text(alpha);
    }
  },
  destroy(self) {
    if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
      self.alphaRangeSlider.destroy();
    }
    delete self.alphaRangeSlider;
    if (self.destroyAlphaSliderEvents)
      self.destroyAlphaSliderEvents();
    delete self.destroyAlphaSliderEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/current-color.js
var current_color_default = {
  render() {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-current-color"
    }, jsx_default("div", {
      class: "color-picker-current-color"
    }));
  },
  update(self) {
    self.$el.find(".color-picker-module-current-color .color-picker-current-color").css("background-color", self.value.hex);
  }
};

// node_modules/framework7/components/color-picker/modules/hex.js
var hex_default = {
  render(self) {
    const {
      hexLabel,
      hexLabelText,
      hexValueEditable
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-hex"
    }, jsx_default("div", {
      class: "color-picker-hex-wrap"
    }, hexLabel && jsx_default("div", {
      class: "color-picker-hex-label"
    }, hexLabelText), jsx_default("div", {
      class: "color-picker-hex-value"
    }, hexValueEditable ? jsx_default("input", {
      type: "text",
      class: "color-picker-value-hex"
    }) : jsx_default("span", {
      class: "color-picker-value-hex"
    }))));
  },
  init(self) {
    function handleInputChange(e) {
      const hex = self.value.hex;
      let value = e.target.value.replace(/#/g, "");
      if (Number.isNaN(value) || !value || value.length !== 3 && value.length !== 6) {
        e.target.value = hex;
        return;
      }
      const min = 0;
      const current = parseInt(value, 16);
      const max = parseInt("ffffff", 16);
      if (current > max) {
        value = "fff";
      }
      if (current < min) {
        value = "000";
      }
      self.setValue({
        hex: value
      });
    }
    self.$el.on("change", ".color-picker-module-hex input", handleInputChange);
    self.destroyHexEvents = function destroyHexEvents() {
      self.$el.off("change", ".color-picker-module-hex input", handleInputChange);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hexValueEditable
    } = self.params;
    const {
      hex
    } = value;
    if (hexValueEditable) {
      self.$el.find("input.color-picker-value-hex").val(hex);
    } else {
      self.$el.find("span.color-picker-value-hex").text(hex);
    }
  },
  destroy(self) {
    if (self.destroyHexEvents)
      self.destroyHexEvents();
    delete self.destroyHexEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hsb-sliders.js
var hsb_sliders_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText,
      saturationLabelText,
      brightnessLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-hsb-sliders"
    }, jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue",
      "data-color-index": "0"
    }) : jsx_default("span", {
      class: "color-picker-value-hue"
    }))), jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, saturationLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-saturation"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-saturation",
      "data-color-index": "1"
    }) : jsx_default("span", {
      class: "color-picker-value-saturation"
    }))), jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness",
      "data-color-index": "2"
    }) : jsx_default("span", {
      class: "color-picker-value-brightness"
    }))));
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-hue"),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }
      }
    });
    self.saturationRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-saturation"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const s = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], s, self.value.hsb[2]]
          });
        }
      }
    });
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-brightness"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }
      }
    });
    function handleInputChange(e) {
      const hsb = [...self.value.hsb];
      const index = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = hsb[index];
        return;
      }
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
      }
      hsb[index] = value;
      self.setValue({
        hsb
      });
    }
    self.$el.on("change", ".color-picker-module-hsb-sliders input", handleInputChange);
    self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
      self.$el.off("change", ".color-picker-module-hsb-sliders input", handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb,
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.saturationRangeSlider.value = hsb[1];
    self.brightnessRangeSlider.value = hsb[2];
    self.hueRangeSlider.layout();
    self.saturationRangeSlider.layout();
    self.brightnessRangeSlider.layout();
    const hslCurrent = colorHsbToHsl(hsb[0], hsb[1], 1);
    const hslLeft = colorHsbToHsl(hsb[0], 0, 1);
    const hslRight = colorHsbToHsl(hsb[0], 1, 1);
    const brightness = hsb[2];
    self.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hue}, 100%, 50%)`);
    self.saturationRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${brightness * 255}, ${brightness * 255}, ${brightness * 255})`);
    self.saturationRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${app.rtl ? "to left" : "to right"}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-hue").val(`${hue}`);
      self.$el.find("input.color-picker-value-saturation").val(`${hsb[1] * 1e3 / 10}`);
      self.$el.find("input.color-picker-value-brightness").val(`${hsb[2] * 1e3 / 10}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-hue").text(`${hue}`);
      self.$el.find("span.color-picker-value-saturation").text(`${hsb[1] * 1e3 / 10}`);
      self.$el.find("span.color-picker-value-brightness").text(`${hsb[2] * 1e3 / 10}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
      self.saturationRangeSlider.destroy();
    }
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }
    delete self.hueRangeSlider;
    delete self.saturationRangeSlider;
    delete self.brightnessRangeSlider;
    if (self.destroyHsbSlidersEvents)
      self.destroyHsbSlidersEvents();
    delete self.destroyHsbSlidersEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hue-slider.js
var hue_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-hue-slider"
    }, jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue"
    }) : jsx_default("span", {
      class: "color-picker-value-hue"
    }))));
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-hue"),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }
      }
    });
  },
  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.hueRangeSlider.layout();
    self.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hue}, 100%, 50%)`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-hue").val(`${hue}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-hue").text(`${hue}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    delete self.hueRangeSlider;
  }
};

// node_modules/framework7/components/color-picker/modules/brightness-slider.js
var brightness_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      brightnessLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-brightness-slider"
    }, jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness"
    }) : jsx_default("span", {
      class: "color-picker-value-brightness"
    }))));
  },
  init(self) {
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-brightness"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }
      }
    });
  },
  update(self) {
    const {
      value,
      app
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb
    } = value;
    self.brightnessRangeSlider.value = hsb[2];
    self.brightnessRangeSlider.layout();
    const hslCurrent = colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
    const hslLeft = colorHsbToHsl(hsb[0], hsb[1], 0);
    const hslRight = colorHsbToHsl(hsb[0], hsb[1], 1);
    self.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${app.rtl ? "to left" : "to right"}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-brightness").val(`${hsb[2] * 1e3 / 10}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-brightness").text(`${hsb[2] * 1e3 / 10}`);
    }
  },
  destroy(self) {
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }
    delete self.brightnessRangeSlider;
  }
};

// node_modules/framework7/components/color-picker/modules/palette.js
var palette_default = {
  render(self) {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-palette"
    }, jsx_default("div", {
      class: "color-picker-palette"
    }, self.params.palette.map((p) => {
      if (Array.isArray(p)) {
        let row = '<div class="color-picker-palette-row">';
        row += p.map((c) => `
                <div class="color-picker-palette-value" data-palette-color="${c}" style="background-color: ${c}"></div>
              `).join("");
        row += "</div>";
        return row;
      }
      return jsx_default("div", {
        class: "color-picker-palette-value",
        "data-palette-color": p,
        style: `background-color: ${p}`
      });
    })));
  },
  init(self) {
    function handlePaletteClick(e) {
      const hex = dom7_default(e.target).attr("data-palette-color");
      self.setValue({
        hex
      });
    }
    self.$el.on("click", ".color-picker-module-palette .color-picker-palette-value", handlePaletteClick);
    self.destroyPaletteEvents = function destroyPaletteEvents() {
      self.$el.off("click", ".color-picker-module-hex input", handlePaletteClick);
    };
  },
  destroy(self) {
    if (self.destroyPaletteEvents) {
      self.destroyPaletteEvents();
    }
    delete self.destroyPaletteEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/initial-current-colors.js
var initial_current_colors_default = {
  render() {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-initial-current-colors"
    }, jsx_default("div", {
      class: "color-picker-initial-current-colors"
    }, jsx_default("div", {
      class: "color-picker-initial-color"
    }), jsx_default("div", {
      class: "color-picker-current-color"
    })));
  },
  init(self) {
    function handleInitialColorClick() {
      if (self.initialValue) {
        const {
          hex,
          alpha
        } = self.initialValue;
        self.setValue({
          hex,
          alpha
        });
      }
    }
    self.$el.on("click", ".color-picker-initial-color", handleInitialColorClick);
    self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
      self.$el.off("click", ".color-picker-initial-color", handleInitialColorClick);
    };
  },
  update(self) {
    self.$el.find(".color-picker-module-initial-current-colors .color-picker-initial-color").css("background-color", self.initialValue.hex);
    self.$el.find(".color-picker-module-initial-current-colors .color-picker-current-color").css("background-color", self.value.hex);
  },
  destroy(self) {
    if (self.destroyInitialCurrentEvents) {
      self.destroyInitialCurrentEvents();
    }
    delete self.destroyInitialCurrentEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/rgb-bars.js
var rgb_bars_default = {
  render(self) {
    const {
      barLabel,
      barValue,
      barValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-rgb-bars"
    }, jsx_default("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default("div", {
      class: "color-picker-bar-label"
    }, redLabelText), jsx_default("div", {
      class: "range-slider color-picker-bar color-picker-bar-red"
    }), barValue && jsx_default("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-red",
      "data-color-index": "0"
    }) : jsx_default("span", {
      class: "color-picker-value-bar-red"
    }))), jsx_default("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default("div", {
      class: "color-picker-bar-label"
    }, greenLabelText), jsx_default("div", {
      class: "range-slider color-picker-bar color-picker-bar-green"
    }), barValue && jsx_default("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-green",
      "data-color-index": "1"
    }) : jsx_default("span", {
      class: "color-picker-value-bar-green"
    }))), jsx_default("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default("div", {
      class: "color-picker-bar-label"
    }, blueLabelText), jsx_default("div", {
      class: "range-slider color-picker-bar color-picker-bar-blue"
    }), barValue && jsx_default("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-blue",
      "data-color-index": "2"
    }) : jsx_default("span", {
      class: "color-picker-value-bar-blue"
    }))));
  },
  init(self) {
    self.redBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-red"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }
      }
    });
    self.greenBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-green"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }
      }
    });
    self.blueBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-blue"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }
      }
    });
    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({
        rgb
      });
    }
    self.$el.on("change", ".color-picker-module-rgb-bars input", handleInputChange);
    self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
      self.$el.off("change", ".color-picker-module-rgb-bars input", handleInputChange);
    };
  },
  update(self) {
    const {
      value,
      redBar,
      greenBar,
      blueBar
    } = self;
    const {
      barValue,
      barValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redBar.value = rgb[0];
    greenBar.value = rgb[1];
    blueBar.value = rgb[2];
    redBar.layout();
    greenBar.layout();
    blueBar.layout();
    redBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);
    if (barValue && barValueEditable) {
      self.$el.find("input.color-picker-value-bar-red").val(rgb[0]);
      self.$el.find("input.color-picker-value-bar-green").val(rgb[1]);
      self.$el.find("input.color-picker-value-bar-blue").val(rgb[2]);
    } else if (barValue) {
      self.$el.find("span.color-picker-value-bar-red").text(rgb[0]);
      self.$el.find("span.color-picker-value-bar-green").text(rgb[1]);
      self.$el.find("span.color-picker-value-bar-blue").text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redBar && self.redBar.destroy) {
      self.redBar.destroy();
    }
    if (self.greenBar && self.greenBar.destroy) {
      self.greenBar.destroy();
    }
    if (self.blueBar && self.blueBar.destroy) {
      self.blueBar.destroy();
    }
    delete self.redBar;
    delete self.greenBar;
    delete self.blueBar;
    if (self.destroyRgbBarsEvents)
      self.destroyRgbBarsEvents();
    delete self.destroyRgbBarsEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/rgb-sliders.js
var rgb_sliders_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-rgb-sliders"
    }, jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, redLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-red"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-red",
      "data-color-index": "0"
    }) : jsx_default("span", {
      class: "color-picker-value-red"
    }))), jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, greenLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-green"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-green",
      "data-color-index": "1"
    }) : jsx_default("span", {
      class: "color-picker-value-green"
    }))), jsx_default("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default("div", {
      class: "color-picker-slider-label"
    }, blueLabelText), jsx_default("div", {
      class: "range-slider color-picker-slider color-picker-slider-blue"
    }), sliderValue && jsx_default("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-blue",
      "data-color-index": "2"
    }) : jsx_default("span", {
      class: "color-picker-value-blue"
    }))));
  },
  init(self) {
    self.redRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-red"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }
      }
    });
    self.greenRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-green"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }
      }
    });
    self.blueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-blue"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }
      }
    });
    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({
        rgb
      });
    }
    self.$el.on("change", ".color-picker-module-rgb-sliders input", handleInputChange);
    self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
      self.$el.off("change", ".color-picker-module-rgb-sliders input", handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value,
      redRangeSlider,
      greenRangeSlider,
      blueRangeSlider
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redRangeSlider.value = rgb[0];
    greenRangeSlider.value = rgb[1];
    blueRangeSlider.value = rgb[2];
    redRangeSlider.layout();
    greenRangeSlider.layout();
    blueRangeSlider.layout();
    redRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    greenRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    blueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    const direction = app.rtl ? "to left" : "to right";
    redRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-red").val(rgb[0]);
      self.$el.find("input.color-picker-value-green").val(rgb[1]);
      self.$el.find("input.color-picker-value-blue").val(rgb[2]);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-red").text(rgb[0]);
      self.$el.find("span.color-picker-value-green").text(rgb[1]);
      self.$el.find("span.color-picker-value-blue").text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redRangeSlider && self.redRangeSlider.destroy) {
      self.redRangeSlider.destroy();
    }
    if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
      self.greenRangeSlider.destroy();
    }
    if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
      self.blueRangeSlider.destroy();
    }
    delete self.redRangeSlider;
    delete self.greenRangeSlider;
    delete self.blueRangeSlider;
    if (self.destroyRgbSlidersEvents)
      self.destroyRgbSlidersEvents();
    delete self.destroyRgbSlidersEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/sb-spectrum.js
var sb_spectrum_default = {
  render() {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-sb-spectrum"
    }, jsx_default("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, jsx_default("div", {
      class: "color-picker-sb-spectrum-handle"
    })));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      specterHandleIsTouched = $targetEl.closest(".color-picker-sb-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-sb-spectrum").length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed");
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules["sb-spectrum"].update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-sb-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-sb-spectrum")[0].offsetHeight;
    self.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents)
      self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hs-spectrum.js
var hs_spectrum_default = {
  render() {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-hs-spectrum"
    }, jsx_default("div", {
      class: "color-picker-hs-spectrum"
    }, jsx_default("div", {
      class: "color-picker-hs-spectrum-handle"
    })));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setHSFromSpecterCoords(x, y) {
      let h = (x - specterRect.left) / specterRect.width * 360;
      let s = (y - specterRect.top) / specterRect.height;
      h = Math.max(0, Math.min(360, h));
      s = 1 - Math.max(0, Math.min(1, s));
      self.setValue({
        hsb: [h, s, self.value.hsb[2]]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      specterHandleIsTouched = $targetEl.closest(".color-picker-hs-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-hs-spectrum").length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-hs-spectrum")[0].getBoundingClientRect();
        setHSFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-hs-spectrum-handle").addClass("color-picker-hs-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-hs-spectrum")[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-hs-spectrum-handle").removeClass("color-picker-hs-spectrum-handle-pressed");
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules["hs-spectrum"].update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-hs-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-hs-spectrum")[0].offsetHeight;
    const hslBright = colorHsbToHsl(hsb[0], hsb[1], 1);
    self.$el.find(".color-picker-hs-spectrum-handle").css("background-color", `hsl(${hslBright[0]}, ${hslBright[1] * 100}%, ${hslBright[2] * 100}%)`).transform(`translate(${specterWidth * (hsb[0] / 360)}px, ${specterHeight * (1 - hsb[1])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents)
      self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/wheel.js
function svgWheelCircles() {
  const total = 256;
  let circles = "";
  for (let i = total; i > 0; i -= 1) {
    const angle = i * Math.PI / (total / 2);
    const hue = 360 / total * i;
    circles += `<circle cx="${150 - Math.sin(angle) * 125}" cy="${150 - Math.cos(angle) * 125}" r="25" fill="hsl(${hue}, 100%, 50%)"></circle>`;
  }
  return circles;
}
var wheel_default = {
  render() {
    return jsx_default("div", {
      class: "color-picker-module color-picker-module-wheel"
    }, jsx_default("div", {
      class: "color-picker-wheel"
    }, jsx_default("svg", {
      viewBox: "0 0 300 300",
      width: "300",
      height: "300"
    }, svgWheelCircles()), jsx_default("div", {
      class: "color-picker-wheel-handle"
    }), jsx_default("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, jsx_default("div", {
      class: "color-picker-sb-spectrum-handle"
    }))));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let wheelRect;
    let wheelIsTouched;
    let wheelHandleIsTouched;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setHueFromWheelCoords(x, y) {
      const wheelCenterX = wheelRect.left + wheelRect.width / 2;
      const wheelCenterY = wheelRect.top + wheelRect.height / 2;
      const angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
      let angleDeg = angleRad * 180 / Math.PI + 90;
      if (angleDeg < 0)
        angleDeg += 360;
      angleDeg = 360 - angleDeg;
      self.setValue({
        hue: angleDeg
      });
    }
    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      wheelHandleIsTouched = $targetEl.closest(".color-picker-wheel-handle").length > 0;
      wheelIsTouched = $targetEl.closest("circle").length > 0;
      specterHandleIsTouched = $targetEl.closest(".color-picker-sb-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-sb-spectrum").length > 0;
      }
      if (wheelIsTouched) {
        wheelRect = $el.find(".color-picker-wheel")[0].getBoundingClientRect();
        setHueFromWheelCoords(touchStartX, touchStartY);
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (wheelHandleIsTouched) {
          wheelRect = $el.find(".color-picker-wheel")[0].getBoundingClientRect();
        }
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        }
      }
      if (wheelIsTouched || wheelHandleIsTouched) {
        setHueFromWheelCoords(touchCurrentX, touchCurrentY);
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed");
      }
      wheelIsTouched = false;
      wheelHandleIsTouched = false;
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules.wheel.update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroyWheelEvents = function destroyWheelEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-sb-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-sb-spectrum")[0].offsetHeight;
    const wheelSize = self.$el.find(".color-picker-wheel")[0].offsetWidth;
    const wheelHalfSize = wheelSize / 2;
    const angleRad = value.hue * Math.PI / 180;
    const handleSize = wheelSize / 6;
    const handleHalfSize = handleSize / 2;
    const tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    const tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    self.$el.find(".color-picker-wheel-handle").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`).transform(`translate(${tX}px, ${tY}px)`);
    self.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroyWheelEvents)
      self.destroyWheelEvents();
    delete self.destroyWheelEvents;
  }
};

// node_modules/framework7/components/color-picker/color-picker-class.js
var ColorPicker = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const self = this;
    self.params = extend({}, app.params.colorPicker, params);
    let $containerEl;
    if (self.params.containerEl) {
      $containerEl = dom7_default(self.params.containerEl);
      if ($containerEl.length === 0)
        return self;
    }
    let $inputEl;
    if (self.params.inputEl) {
      $inputEl = dom7_default(self.params.inputEl);
    }
    let $targetEl;
    if (self.params.targetEl) {
      $targetEl = dom7_default(self.params.targetEl);
    }
    extend(self, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      initialized: false,
      opened: false,
      url: self.params.url,
      modules: {
        "alpha-slider": alpha_slider_default,
        "current-color": current_color_default,
        hex: hex_default,
        // eslint-disable-line
        "hsb-sliders": hsb_sliders_default,
        "hue-slider": hue_slider_default,
        "brightness-slider": brightness_slider_default,
        palette: palette_default,
        // eslint-disable-line
        "initial-current-colors": initial_current_colors_default,
        "rgb-bars": rgb_bars_default,
        "rgb-sliders": rgb_sliders_default,
        "sb-spectrum": sb_spectrum_default,
        "hs-spectrum": hs_spectrum_default,
        wheel: wheel_default
        // eslint-disable-line
      }
    });
    function onInputClick() {
      self.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onTargetClick() {
      self.open();
    }
    function onHtmlClick(e) {
      if (self.destroyed || !self.params)
        return;
      if (self.params.openIn === "page")
        return;
      const $clickTargetEl = dom7_default(e.target);
      if (!self.opened || self.closing)
        return;
      if ($clickTargetEl.closest('[class*="backdrop"]').length)
        return;
      if ($clickTargetEl.closest(".color-picker-popup, .color-picker-popover").length)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest(".sheet-modal").length === 0) {
          self.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal").length === 0) {
        self.close();
      }
    }
    extend(self, {
      attachInputEvents() {
        self.$inputEl.on("click", onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.on("focus mousedown", onInputFocus);
          if (self.$inputEl[0]) {
            self.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        self.$inputEl.off("click", onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.off("focus mousedown", onInputFocus);
          if (self.$inputEl[0]) {
            delete self.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachTargetEvents() {
        self.$targetEl.on("click", onTargetClick);
      },
      detachTargetEvents() {
        self.$targetEl.off("click", onTargetClick);
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
      }
    });
    self.init();
    return self;
  }
  get view() {
    const {
      $inputEl,
      $targetEl,
      app,
      params
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else {
      if ($inputEl) {
        view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
      }
      if (!view && $targetEl) {
        view = $targetEl.parents(".view").length && $targetEl.parents(".view")[0].f7View;
      }
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  attachEvents() {
    const self = this;
    self.centerModules = self.centerModules.bind(self);
    if (self.params.centerModules) {
      self.app.on("resize", self.centerModules);
    }
  }
  detachEvents() {
    const self = this;
    if (self.params.centerModules) {
      self.app.off("resize", self.centerModules);
    }
  }
  centerModules() {
    const self = this;
    if (!self.opened || !self.$el || self.inline)
      return;
    const $pageContentEl = self.$el.find(".page-content");
    if (!$pageContentEl.length)
      return;
    const {
      scrollHeight,
      offsetHeight
    } = $pageContentEl[0];
    if (scrollHeight <= offsetHeight) {
      $pageContentEl.addClass("justify-content-center");
    } else {
      $pageContentEl.removeClass("justify-content-center");
    }
  }
  initInput() {
    const self = this;
    if (!self.$inputEl)
      return;
    if (self.params.inputReadOnly)
      self.$inputEl.prop("readOnly", true);
  }
  getModalType() {
    const self = this;
    const {
      app,
      modal,
      params
    } = self;
    const {
      openIn,
      openInPhone
    } = params;
    const device = getDevice();
    if (modal && modal.type)
      return modal.type;
    if (openIn !== "auto")
      return openIn;
    if (self.inline)
      return null;
    if (device.ios) {
      return device.ipad ? "popover" : openInPhone;
    }
    if (app.width >= 768 || device.desktop && app.theme === "aurora") {
      return "popover";
    }
    return openInPhone;
  }
  formatValue() {
    const self = this;
    const {
      value
    } = self;
    if (self.params.formatValue) {
      return self.params.formatValue.call(self, value);
    }
    return value.hex;
  }
  // eslint-disable-next-line
  normalizeHsValues(arr) {
    return [Math.floor(arr[0] * 10) / 10, Math.floor(arr[1] * 1e3) / 1e3, Math.floor(arr[2] * 1e3) / 1e3];
  }
  setValue(value, updateModules) {
    if (value === void 0) {
      value = {};
    }
    if (updateModules === void 0) {
      updateModules = true;
    }
    const self = this;
    if (typeof value === "undefined")
      return;
    let {
      hex,
      rgb,
      hsl,
      hsb,
      alpha = 1,
      hue,
      rgba,
      hsla
    } = self.value || {};
    const needChangeEvent = self.value || !self.value && !self.params.value;
    let valueChanged;
    Object.keys(value).forEach((k) => {
      if (!self.value || typeof self.value[k] === "undefined") {
        valueChanged = true;
        return;
      }
      const v = value[k];
      if (Array.isArray(v)) {
        v.forEach((subV, subIndex) => {
          if (subV !== self.value[k][subIndex]) {
            valueChanged = true;
          }
        });
      } else if (v !== self.value[k]) {
        valueChanged = true;
      }
    });
    if (!valueChanged)
      return;
    if (value.rgb || value.rgba) {
      const [r, g, b, a = alpha] = value.rgb || value.rgba;
      rgb = [r, g, b];
      hex = colorRgbToHex(...rgb);
      hsl = colorRgbToHsl(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hsl || value.hsla) {
      const [h, s, l, a = alpha] = value.hsl || value.hsla;
      hsl = [h, s, l];
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hsb) {
      const [h, s, b, a = alpha] = value.hsb;
      hsb = [h, s, b];
      hsl = colorHsbToHsl(...hsb);
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hex) {
      rgb = colorHexToRgb(value.hex);
      hex = colorRgbToHex(...rgb);
      hsl = colorRgbToHsl(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }
    if (typeof value.alpha !== "undefined") {
      alpha = value.alpha;
      if (typeof rgb !== "undefined") {
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
      }
      if (typeof hsl !== "undefined") {
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }
    }
    if (typeof value.hue !== "undefined") {
      const [h, s, l] = hsl;
      hsl = [value.hue, s, l];
      hsb = colorHslToHsb(...hsl);
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }
    self.value = {
      hex,
      alpha,
      hue,
      rgb,
      hsl,
      hsb,
      rgba,
      hsla
    };
    if (!self.initialValue)
      self.initialValue = extend({}, self.value);
    self.updateValue(needChangeEvent);
    if (self.opened && updateModules) {
      self.updateModules();
    }
  }
  getValue() {
    const self = this;
    return self.value;
  }
  updateValue(fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }
    const self = this;
    const {
      $inputEl,
      value,
      $targetEl
    } = self;
    if ($targetEl && self.params.targetElSetBackgroundColor) {
      const {
        rgba
      } = value;
      $targetEl.css("background-color", `rgba(${rgba.join(", ")})`);
    }
    if (fireEvents) {
      self.emit("local::change colorPickerChange", self, value);
    }
    if ($inputEl && $inputEl.length) {
      const inputValue = self.formatValue(value);
      if ($inputEl && $inputEl.length) {
        $inputEl.val(inputValue);
        if (fireEvents) {
          $inputEl.trigger("change");
        }
      }
    }
  }
  updateModules() {
    const self = this;
    const {
      modules: modules2
    } = self;
    self.params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].update) {
        modules2[m].update(self);
      } else if (m && m.update) {
        m.update(self);
      }
    });
  }
  update() {
    const self = this;
    self.updateModules();
  }
  renderPicker() {
    const self = this;
    const {
      params,
      modules: modules2
    } = self;
    let html = "";
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].render) {
        html += modules2[m].render(self);
      } else if (m && m.render) {
        html += m.render(self);
      }
    });
    return html;
  }
  renderNavbar() {
    const self = this;
    if (self.params.renderNavbar) {
      return self.params.renderNavbar.call(self, self);
    }
    const {
      openIn,
      navbarTitleText,
      navbarBackLinkText,
      navbarCloseText
    } = self.params;
    return jsx_default("div", {
      class: "navbar"
    }, jsx_default("div", {
      class: "navbar-bg"
    }), jsx_default("div", {
      class: "navbar-inner sliding"
    }, openIn === "page" && jsx_default("div", {
      class: "left"
    }, jsx_default("a", {
      class: "link back"
    }, jsx_default("i", {
      class: "icon icon-back"
    }), jsx_default("span", {
      class: "if-not-md"
    }, navbarBackLinkText))), jsx_default("div", {
      class: "title"
    }, navbarTitleText), openIn !== "page" && jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link popup-close",
      "data-popup": ".color-picker-popup"
    }, navbarCloseText))));
  }
  renderToolbar() {
    const self = this;
    if (self.params.renderToolbar) {
      return self.params.renderToolbar.call(self, self);
    }
    return jsx_default("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default("div", {
      class: "toolbar-inner"
    }, jsx_default("div", {
      class: "left"
    }), jsx_default("div", {
      class: "right"
    }, jsx_default("a", {
      class: "link sheet-close popover-close",
      "data-sheet": ".color-picker-sheet-modal",
      "data-popover": ".color-picker-popover"
    }, self.params.toolbarCloseText))));
  }
  renderInline() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return jsx_default("div", {
      class: `color-picker color-picker-inline ${groupedModules ? "color-picker-grouped-modules" : ""} ${cssClass || ""}`
    }, self.renderPicker());
  }
  renderSheet() {
    const self = this;
    const {
      cssClass,
      toolbarSheet,
      groupedModules
    } = self.params;
    return jsx_default("div", {
      class: `sheet-modal color-picker color-picker-sheet-modal ${groupedModules ? "color-picker-grouped-modules" : ""} ${cssClass || ""}`
    }, toolbarSheet && self.renderToolbar(), jsx_default("div", {
      class: "sheet-modal-inner"
    }, jsx_default("div", {
      class: "page-content"
    }, self.renderPicker())));
  }
  renderPopover() {
    const self = this;
    const {
      cssClass,
      toolbarPopover,
      groupedModules
    } = self.params;
    return jsx_default("div", {
      class: `popover color-picker-popover ${cssClass || ""}`
    }, jsx_default("div", {
      class: "popover-inner"
    }, jsx_default("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, toolbarPopover && self.renderToolbar(), jsx_default("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }
  renderPopup() {
    const self = this;
    const {
      cssClass,
      navbarPopup,
      groupedModules
    } = self.params;
    return jsx_default("div", {
      class: `popup color-picker-popup ${cssClass || ""}`
    }, jsx_default("div", {
      class: "page"
    }, navbarPopup && self.renderNavbar(), jsx_default("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, jsx_default("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }
  renderPage() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return jsx_default("div", {
      class: `page color-picker-page ${cssClass || ""}`,
      "data-name": "color-picker-page"
    }, self.renderNavbar(), jsx_default("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, jsx_default("div", {
      class: "page-content"
    }, self.renderPicker())));
  }
  // eslint-disable-next-line
  render() {
    const self = this;
    const {
      params
    } = self;
    if (params.render)
      return params.render.call(self);
    if (self.inline)
      return self.renderInline();
    if (params.openIn === "page") {
      return self.renderPage();
    }
    const modalType = self.getModalType();
    if (modalType === "popover")
      return self.renderPopover();
    if (modalType === "sheet")
      return self.renderSheet();
    if (modalType === "popup")
      return self.renderPopup();
  }
  onOpen() {
    const self = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params,
      modules: modules2
    } = self;
    self.closing = false;
    self.opened = true;
    self.opening = true;
    self.attachEvents();
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].init) {
        modules2[m].init(self);
      } else if (m && m.init) {
        m.init(self);
      }
    });
    const updateValue = !value && params.value;
    if (!initialized) {
      if (value)
        self.setValue(value);
      else if (params.value) {
        self.setValue(params.value, false);
      } else if (!params.value) {
        self.setValue({
          hex: "#ff0000"
        }, false);
      }
    } else if (value) {
      self.initialValue = extend({}, value);
      self.setValue(value, false);
    }
    if (updateValue)
      self.updateValue();
    self.updateModules();
    if (params.centerModules) {
      self.centerModules();
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    self.initialized = true;
    if ($el) {
      $el.trigger("colorpicker:open");
    }
    if ($inputEl) {
      $inputEl.trigger("colorpicker:open");
    }
    self.emit("local::open colorPickerOpen", self);
  }
  onOpened() {
    const self = this;
    self.opening = false;
    if (self.$el) {
      self.$el.trigger("colorpicker:opened");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:opened");
    }
    self.emit("local::opened colorPickerOpened", self);
  }
  onClose() {
    const self = this;
    const {
      app,
      params,
      modules: modules2
    } = self;
    self.opening = false;
    self.closing = true;
    self.detachEvents();
    if (self.$inputEl) {
      if (app.theme === "md") {
        self.$inputEl.trigger("blur");
      } else {
        const validate = self.$inputEl.attr("validate");
        const required = self.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(self.$inputEl);
        }
      }
    }
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].destroy) {
        modules2[m].destroy(self);
      } else if (m && m.destroy) {
        m.destroy(self);
      }
    });
    if (self.$el) {
      self.$el.trigger("colorpicker:close");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:close");
    }
    self.emit("local::close colorPickerClose", self);
  }
  onClosed() {
    const self = this;
    self.opened = false;
    self.closing = false;
    if (!self.inline) {
      nextTick(() => {
        if (self.modal && self.modal.el && self.modal.destroy) {
          if (!self.params.routableModals) {
            self.modal.destroy();
          }
        }
        delete self.modal;
      });
    }
    if (self.$el) {
      self.$el.trigger("colorpicker:closed");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:closed");
    }
    self.emit("local::closed colorPickerClosed", self);
  }
  open() {
    const self = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $targetEl,
      params
    } = self;
    if (opened)
      return;
    if (inline) {
      self.$el = dom7_default(self.render());
      self.$el[0].f7ColorPicker = self;
      self.$containerEl.append(self.$el);
      self.onOpen();
      self.onOpened();
      return;
    }
    const colorPickerContent = self.render();
    if (params.openIn === "page") {
      self.view.router.navigate({
        url: self.url,
        route: {
          content: colorPickerContent,
          path: self.url,
          on: {
            pageBeforeIn(e, page) {
              self.$el = page.$el.find(".color-picker");
              self.$el[0].f7ColorPicker = self;
              self.onOpen();
            },
            pageAfterIn() {
              self.onOpened();
            },
            pageBeforeOut() {
              self.onClose();
            },
            pageAfterOut() {
              self.onClosed();
              if (self.$el && self.$el[0]) {
                self.$el[0].f7ColorPicker = null;
                delete self.$el[0].f7ColorPicker;
              }
            }
          }
        }
      });
    } else {
      const modalType = self.getModalType();
      let backdrop = params.backdrop;
      if (backdrop === null || typeof backdrop === "undefined") {
        if (modalType === "popover" && app.params.popover.backdrop !== false)
          backdrop = true;
        if (modalType === "popup")
          backdrop = true;
      }
      const modalParams = {
        targetEl: $targetEl || $inputEl,
        scrollToEl: params.scrollToInput ? $targetEl || $inputEl : void 0,
        content: colorPickerContent,
        backdrop,
        closeByBackdropClick: params.closeByBackdropClick,
        on: {
          open() {
            const modal = this;
            self.modal = modal;
            self.$el = modalType === "popover" || modalType === "popup" ? modal.$el.find(".color-picker") : modal.$el;
            self.$el[0].f7ColorPicker = self;
            self.onOpen();
          },
          opened() {
            self.onOpened();
          },
          close() {
            self.onClose();
          },
          closed() {
            self.onClosed();
            if (self.$el && self.$el[0]) {
              self.$el[0].f7ColorPicker = null;
              delete self.$el[0].f7ColorPicker;
            }
          }
        }
      };
      if (modalType === "popup") {
        modalParams.push = params.popupPush;
        modalParams.swipeToClose = params.popupSwipeToClose;
      }
      if (modalType === "sheet") {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }
      if (params.routableModals && self.view) {
        self.view.router.navigate({
          url: self.url,
          route: {
            path: self.url,
            [modalType]: modalParams
          }
        });
      } else {
        self.modal = app[modalType].create(modalParams);
        self.modal.open();
      }
    }
  }
  close() {
    const self = this;
    const {
      opened,
      inline
    } = self;
    if (!opened)
      return;
    if (inline) {
      self.onClose();
      self.onClosed();
      return;
    }
    if (self.params.routableModals && self.view || self.params.openIn === "page") {
      self.view.router.back();
    } else {
      self.modal.close();
    }
  }
  init() {
    const self = this;
    self.initInput();
    if (self.inline) {
      self.open();
      self.emit("local::init colorPickerInit", self);
      return;
    }
    if (!self.initialized && self.params.value) {
      self.setValue(self.params.value);
    }
    if (self.$inputEl) {
      self.attachInputEvents();
    }
    if (self.$targetEl) {
      self.attachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.attachHtmlEvents();
    }
    self.emit("local::init colorPickerInit", self);
  }
  destroy() {
    const self = this;
    if (self.destroyed)
      return;
    const {
      $el
    } = self;
    self.emit("local::beforeDestroy colorPickerBeforeDestroy", self);
    if ($el)
      $el.trigger("colorpicker:beforedestroy");
    self.close();
    self.detachEvents();
    if (self.$inputEl) {
      self.detachInputEvents();
    }
    if (self.$targetEl) {
      self.detachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.detachHtmlEvents();
    }
    if ($el && $el.length)
      delete self.$el[0].f7ColorPicker;
    deleteProps(self);
    self.destroyed = true;
  }
};
var color_picker_class_default = ColorPicker;

// node_modules/framework7/components/color-picker/color-picker.js
var color_picker_default = {
  name: "colorPicker",
  static: {
    ColorPicker: color_picker_class_default
  },
  create() {
    const app = this;
    app.colorPicker = ConstructorMethods({
      defaultSelector: ".color-picker",
      constructor: color_picker_class_default,
      app,
      domProp: "f7ColorPicker"
    });
    app.colorPicker.close = function close6(el) {
      if (el === void 0) {
        el = ".color-picker";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const colorPicker = $el[0].f7ColorPicker;
      if (!colorPicker || colorPicker && !colorPicker.opened)
        return;
      colorPicker.close();
    };
  },
  params: {
    colorPicker: {
      // Color picker settings
      value: null,
      modules: ["wheel"],
      palette: [["#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373", "#EF5350", "#F44336", "#E53935", "#D32F2F", "#C62828", "#B71C1C"], ["#F3E5F5", "#E1BEE7", "#CE93D8", "#BA68C8", "#AB47BC", "#9C27B0", "#8E24AA", "#7B1FA2", "#6A1B9A", "#4A148C"], ["#E8EAF6", "#C5CAE9", "#9FA8DA", "#7986CB", "#5C6BC0", "#3F51B5", "#3949AB", "#303F9F", "#283593", "#1A237E"], ["#E1F5FE", "#B3E5FC", "#81D4FA", "#4FC3F7", "#29B6F6", "#03A9F4", "#039BE5", "#0288D1", "#0277BD", "#01579B"], ["#E0F2F1", "#B2DFDB", "#80CBC4", "#4DB6AC", "#26A69A", "#009688", "#00897B", "#00796B", "#00695C", "#004D40"], ["#F1F8E9", "#DCEDC8", "#C5E1A5", "#AED581", "#9CCC65", "#8BC34A", "#7CB342", "#689F38", "#558B2F", "#33691E"], ["#FFFDE7", "#FFF9C4", "#FFF59D", "#FFF176", "#FFEE58", "#FFEB3B", "#FDD835", "#FBC02D", "#F9A825", "#F57F17"], ["#FFF3E0", "#FFE0B2", "#FFCC80", "#FFB74D", "#FFA726", "#FF9800", "#FB8C00", "#F57C00", "#EF6C00", "#E65100"]],
      groupedModules: false,
      centerModules: true,
      sliderLabel: false,
      sliderValue: false,
      sliderValueEdiable: false,
      barLabel: false,
      barValue: false,
      barValueEdiable: false,
      hexLabel: false,
      hexValueEditable: false,
      redLabelText: "R",
      greenLabelText: "G",
      blueLabelText: "B",
      hueLabelText: "H",
      saturationLabelText: "S",
      brightnessLabelText: "B",
      hexLabelText: "HEX",
      alphaLabelText: "A",
      // Common opener settings
      containerEl: null,
      openIn: "popover",
      // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
      openInPhone: "popup",
      // or 'popover' or 'sheet' or 'popup' or 'page'
      popupPush: false,
      popupSwipeToClose: void 0,
      sheetPush: false,
      sheetSwipeToClose: void 0,
      formatValue: null,
      targetEl: null,
      targetElSetBackgroundColor: false,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      toolbarSheet: true,
      toolbarPopover: false,
      toolbarCloseText: "Done",
      navbarPopup: true,
      navbarCloseText: "Done",
      navbarTitleText: "Color",
      navbarBackLinkText: "Back",
      cssClass: null,
      routableModals: false,
      view: null,
      url: "color/",
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderToolbar: null,
      renderNavbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      renderPopup: null,
      render: null
    }
  }
};

// node_modules/framework7/components/treeview/treeview.js
var Treeview = {
  open(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    $itemEl.addClass("treeview-item-opened");
    $itemEl.trigger("treeview:open");
    app.emit("treeviewOpen", $itemEl[0]);
    function done(cancel) {
      if (cancel) {
        $itemEl.removeClass("treeview-item-opened");
        $itemEl.trigger("treeview:close");
        app.emit("treeviewClose", $itemEl[0]);
      } else {
        $itemEl[0].f7TreeviewChildrenLoaded = true;
      }
      $itemEl.find(".treeview-toggle").removeClass("treeview-toggle-hidden");
      $itemEl.find(".treeview-preloader").remove();
    }
    if ($itemEl.hasClass("treeview-load-children") && !$itemEl[0].f7TreeviewChildrenLoaded) {
      const preloaders = {
        iosPreloaderContent,
        mdPreloaderContent,
        auroraPreloaderContent
      };
      $itemEl.trigger("treeview:loadchildren", done);
      app.emit("treeviewLoadChildren", $itemEl[0], done);
      $itemEl.find(".treeview-toggle").addClass("treeview-toggle-hidden");
      $itemEl.find(".treeview-item-root").prepend(`<div class="preloader treeview-preloader">${preloaders[`${app.theme}PreloaderContent`]}</div>`);
    }
  },
  close(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    $itemEl.removeClass("treeview-item-opened");
    $itemEl.trigger("treeview:close");
    app.emit("treeviewClose", $itemEl[0]);
  },
  toggle(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    const wasOpened = $itemEl.hasClass("treeview-item-opened");
    app.treeview[wasOpened ? "close" : "open"]($itemEl);
  }
};
var treeview_default = {
  name: "treeview",
  create() {
    const app = this;
    bindMethods(app, {
      treeview: Treeview
    });
  },
  clicks: {
    ".treeview-toggle": function toggle3($clickedEl, clickedData, e) {
      const app = this;
      if ($clickedEl.parents(".treeview-item-toggle").length)
        return;
      const $treeviewItemEl = $clickedEl.parents(".treeview-item").eq(0);
      if (!$treeviewItemEl.length)
        return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    },
    ".treeview-item-toggle": function toggle4($clickedEl, clickedData, e) {
      const app = this;
      const $treeviewItemEl = $clickedEl.closest(".treeview-item").eq(0);
      if (!$treeviewItemEl.length)
        return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    }
  }
};

// node_modules/framework7/components/text-editor/text-editor-class.js
var textEditorButtonsMap = {
  // f7-icon, material-icon, command
  bold: ["bold", "format_bold", "bold"],
  italic: ["italic", "format_italic", "italic"],
  underline: ["underline", "format_underlined", "underline"],
  strikeThrough: ["strikethrough", "strikethrough_s", "strikeThrough"],
  orderedList: ["list_number", "format_list_numbered", "insertOrderedList"],
  unorderedList: ["list_bullet", "format_list_bulleted", "insertUnorderedList"],
  link: ["link", "link", "createLink"],
  image: ["photo", "image", "insertImage"],
  paragraph: ["paragraph", '<i class="icon">¶</i>', "formatBlock.P"],
  h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', "formatBlock.H1"],
  h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', "formatBlock.H2"],
  h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', "formatBlock.H3"],
  alignLeft: ["text_alignleft", "format_align_left", "justifyLeft"],
  alignCenter: ["text_aligncenter", "format_align_center", "justifyCenter"],
  alignRight: ["text_alignright", "format_align_right", "justifyRight"],
  alignJustify: ["text_justify", "format_align_justify", "justifyFull"],
  subscript: ["textformat_subscript", '<i class="icon">A<sub>1</sub></i>', "subscript"],
  superscript: ["textformat_superscript", '<i class="icon">A<sup>1</sup></i>', "superscript"],
  indent: ["increase_indent", "format_indent_increase", "indent"],
  outdent: ["decrease_indent", "format_indent_decrease", "outdent"]
};
var TextEditor = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const self = this;
    const document = getDocument();
    const device = getDevice();
    const defaults = extend({}, app.params.textEditor);
    self.useModulesParams(defaults);
    self.params = extend(defaults, params);
    const el = self.params.el;
    if (!el)
      return self;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return self;
    if ($el[0].f7TextEditor)
      return $el[0].f7TextEditor;
    let $contentEl = $el.children(".text-editor-content");
    if (!$contentEl.length) {
      $el.append('<div class="text-editor-content" contenteditable></div>');
      $contentEl = $el.children(".text-editor-content");
    }
    extend(self, {
      app,
      $el,
      el: $el[0],
      $contentEl,
      contentEl: $contentEl[0]
    });
    if ("value" in params) {
      self.value = self.params.value;
    }
    if (self.params.mode === "keyboard-toolbar") {
      if (!(device.cordova || device.capacitor) && !device.android) {
        self.params.mode = "popover";
      }
    }
    if (typeof self.params.buttons === "string") {
      try {
        self.params.buttons = JSON.parse(self.params.buttons);
      } catch (err) {
        throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
      }
    }
    $el[0].f7TextEditor = self;
    self.onButtonClick = self.onButtonClick.bind(self);
    self.onFocus = self.onFocus.bind(self);
    self.onBlur = self.onBlur.bind(self);
    self.onInput = self.onInput.bind(self);
    self.onPaste = self.onPaste.bind(self);
    self.onSelectionChange = self.onSelectionChange.bind(self);
    self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self);
    self.attachEvents = function attachEvents() {
      if (self.params.mode === "toolbar") {
        self.$el.find(".text-editor-toolbar").on("click", "button", self.onButtonClick);
      }
      if (self.params.mode === "keyboard-toolbar") {
        self.$keyboardToolbarEl.on("click", "button", self.onButtonClick);
        self.$el.parents(".page").on("page:beforeout", self.closeKeyboardToolbar);
      }
      if (self.params.mode === "popover" && self.popover) {
        self.popover.$el.on("click", "button", self.onButtonClick);
      }
      self.$contentEl.on("paste", self.onPaste);
      self.$contentEl.on("focus", self.onFocus);
      self.$contentEl.on("blur", self.onBlur);
      self.$contentEl.on("input", self.onInput, true);
      dom7_default(document).on("selectionchange", self.onSelectionChange);
    };
    self.detachEvents = function detachEvents() {
      if (self.params.mode === "toolbar") {
        self.$el.find(".text-editor-toolbar").off("click", "button", self.onButtonClick);
      }
      if (self.params.mode === "keyboard-toolbar") {
        self.$keyboardToolbarEl.off("click", "button", self.onButtonClick);
        self.$el.parents(".page").off("page:beforeout", self.closeKeyboardToolbar);
      }
      if (self.params.mode === "popover" && self.popover) {
        self.popover.$el.off("click", "button", self.onButtonClick);
      }
      self.$contentEl.off("paste", self.onPaste);
      self.$contentEl.off("focus", self.onFocus);
      self.$contentEl.off("blur", self.onBlur);
      self.$contentEl.off("input", self.onInput, true);
      dom7_default(document).off("selectionchange", self.onSelectionChange);
    };
    self.useModules();
    self.init();
    return self;
  }
  setValue(newValue) {
    const self = this;
    const currentValue = self.value;
    if (currentValue === newValue)
      return self;
    self.value = newValue;
    self.$contentEl.html(newValue);
    self.$el.trigger("texteditor:change", self.value);
    self.emit("local::change textEditorChange", self, self.value);
    return self;
  }
  getValue() {
    const self = this;
    return self.value;
  }
  clearValue() {
    const self = this;
    self.setValue("");
    if (self.params.placeholder && !self.$contentEl.html()) {
      self.insertPlaceholder();
    }
    return self;
  }
  createLink() {
    const self = this;
    const window = getWindow();
    const document = getDocument();
    const currentSelection = window.getSelection();
    const selectedNodes = [];
    let $selectedLinks;
    if (currentSelection && currentSelection.anchorNode && dom7_default(currentSelection.anchorNode).parents(self.$el).length) {
      let anchorNode = currentSelection.anchorNode;
      while (anchorNode) {
        selectedNodes.push(anchorNode);
        if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
          anchorNode = null;
        }
        if (anchorNode) {
          anchorNode = anchorNode.nextSibling;
        }
      }
      const selectedNodesLinks = [];
      const $selectedNodes = dom7_default(selectedNodes);
      for (let i = 0; i < $selectedNodes.length; i += 1) {
        const childNodes = $selectedNodes[i].children;
        if (childNodes) {
          for (let j = 0; j < childNodes.length; j += 1) {
            if (dom7_default(childNodes[j]).is("a")) {
              selectedNodesLinks.push(childNodes[j]);
            }
          }
        }
      }
      $selectedLinks = $selectedNodes.closest("a").add(dom7_default(selectedNodesLinks));
    }
    if ($selectedLinks && $selectedLinks.length) {
      $selectedLinks.each((linkNode) => {
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(linkNode);
        selection.removeAllRanges();
        selection.addRange(range);
        document.execCommand("unlink", false);
        selection.removeAllRanges();
      });
      return self;
    }
    const currentRange = self.getSelectionRange();
    if (!currentRange)
      return self;
    const dialog = self.app.dialog.prompt(self.params.linkUrlText, "", (link) => {
      if (link && link.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand("createLink", false, link.trim());
        self.$el.trigger("texteditor:insertlink", {
          url: link.trim()
        });
        self.emit("local:insertLink textEditorInsertLink", self, link.trim());
      }
    });
    dialog.$el.find("input").focus();
    return self;
  }
  insertImage() {
    const self = this;
    const document = getDocument();
    const currentRange = self.getSelectionRange();
    if (!currentRange)
      return self;
    const dialog = self.app.dialog.prompt(self.params.imageUrlText, "", (imageUrl) => {
      if (imageUrl && imageUrl.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand("insertImage", false, imageUrl.trim());
        self.$el.trigger("texteditor:insertimage", {
          url: imageUrl.trim()
        });
        self.emit("local:insertImage textEditorInsertImage", self, imageUrl.trim());
      }
    });
    dialog.$el.find("input").focus();
    return self;
  }
  removePlaceholder() {
    const self = this;
    self.$contentEl.find(".text-editor-placeholder").remove();
  }
  insertPlaceholder() {
    const self = this;
    self.$contentEl.append(`<div class="text-editor-placeholder">${self.params.placeholder}</div>`);
  }
  onSelectionChange() {
    const self = this;
    const window = getWindow();
    const document = getDocument();
    if (self.params.mode === "toolbar")
      return;
    const selection = window.getSelection();
    const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (self.params.mode === "keyboard-toolbar") {
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      } else {
        self.openKeyboardToolbar();
      }
      return;
    }
    if (self.params.mode === "popover") {
      const selectionIsInPopover = dom7_default(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;
      if (!selectionIsInContent && !selectionIsInPopover) {
        self.closePopover();
        return;
      }
      if (!selection.isCollapsed && selection.rangeCount) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        const rootEl = self.app.$el[0] || document.body;
        self.openPopover(rect.x + (window.scrollX || 0) - rootEl.offsetLeft, rect.y + (window.scrollY || 0) - rootEl.offsetTop, rect.width, rect.height);
      } else if (selection.isCollapsed) {
        self.closePopover();
      }
    }
  }
  onPaste(e) {
    const self = this;
    const document = getDocument();
    if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
      const text = e.clipboardData.getData("text/plain");
      e.preventDefault();
      document.execCommand("insertText", false, text);
    }
  }
  onInput() {
    const self = this;
    const value = self.$contentEl.html();
    self.value = value;
    self.$el.trigger("texteditor:input");
    self.emit("local:input textEditorInput", self, self.value);
    self.$el.trigger("texteditor:change", self.value);
    self.emit("local::change textEditorChange", self, self.value);
  }
  onFocus() {
    const self = this;
    self.removePlaceholder();
    self.$contentEl.focus();
    self.$el.trigger("texteditor:focus");
    self.emit("local::focus textEditorFocus", self);
  }
  onBlur() {
    const self = this;
    const window = getWindow();
    const document = getDocument();
    if (self.params.placeholder && self.$contentEl.html() === "") {
      self.insertPlaceholder();
    }
    if (self.params.mode === "popover") {
      const selection = window.getSelection();
      const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      const inPopover = document.activeElement && self.popover && dom7_default(document.activeElement).closest(self.popover.$el).length;
      if (!inPopover && !selectionIsInContent) {
        self.closePopover();
      }
    }
    if (self.params.mode === "keyboard-toolbar") {
      const selection = window.getSelection();
      const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      }
    }
    self.$el.trigger("texteditor:blur");
    self.emit("local::blur textEditorBlur", self);
  }
  onButtonClick(e) {
    const self = this;
    const window = getWindow();
    const document = getDocument();
    const selection = window.getSelection();
    const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (!selectionIsInContent)
      return;
    const $buttonEl = dom7_default(e.target).closest("button");
    if ($buttonEl.parents("form").length) {
      e.preventDefault();
    }
    const button = $buttonEl.attr("data-button");
    const buttonData = self.params.customButtons && self.params.customButtons[button];
    if (!button || !(textEditorButtonsMap[button] || buttonData))
      return;
    $buttonEl.trigger("texteditor:buttonclick", button);
    self.emit("local::buttonClick textEditorButtonClick", self, button);
    if (buttonData) {
      if (buttonData.onClick)
        buttonData.onClick(self, $buttonEl[0]);
      return;
    }
    const command = textEditorButtonsMap[button][2];
    if (command === "createLink") {
      self.createLink();
      return;
    }
    if (command === "insertImage") {
      self.insertImage();
      return;
    }
    if (command.indexOf("formatBlock") === 0) {
      const tagName = command.split(".")[1];
      const $anchorNode = dom7_default(selection.anchorNode);
      if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
        document.execCommand("formatBlock", false, "div");
      } else {
        document.execCommand("formatBlock", false, tagName);
      }
      return;
    }
    document.execCommand(command, false);
  }
  // eslint-disable-next-line
  getSelectionRange() {
    const window = getWindow();
    const document = getDocument();
    if (window.getSelection) {
      const sel = window.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        return sel.getRangeAt(0);
      }
    } else if (document.selection && document.selection.createRange) {
      return document.selection.createRange();
    }
    return null;
  }
  // eslint-disable-next-line
  setSelectionRange(range) {
    const window = getWindow();
    const document = getDocument();
    if (range) {
      if (window.getSelection) {
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (document.selection && range.select) {
        range.select();
      }
    }
  }
  renderButtons() {
    const self = this;
    let html = "";
    function renderButton(button) {
      const iconClass = self.app.theme === "md" ? "material-icons" : "f7-icons";
      if (self.params.customButtons && self.params.customButtons[button]) {
        const buttonData = self.params.customButtons[button];
        return `<button type="button" class="text-editor-button" data-button="${button}">${buttonData.content || ""}</button>`;
      }
      if (!textEditorButtonsMap[button])
        return "";
      const iconContent = textEditorButtonsMap[button][self.app.theme === "md" ? 1 : 0];
      return `<button type="button" class="text-editor-button" data-button="${button}">${iconContent.indexOf("<") >= 0 ? iconContent : `<i class="${iconClass}">${iconContent}</i>`}</button>`.trim();
    }
    self.params.buttons.forEach((button, buttonIndex) => {
      if (Array.isArray(button)) {
        button.forEach((b) => {
          html += renderButton(b);
        });
        if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
          html += '<div class="text-editor-button-divider"></div>';
        }
      } else {
        html += renderButton(button);
      }
    });
    return html;
  }
  createToolbar() {
    const self = this;
    self.$el.prepend(`<div class="text-editor-toolbar">${self.renderButtons()}</div>`);
  }
  createKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl = dom7_default(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar"><div class="toolbar-inner">${self.renderButtons()}</div></div>`);
  }
  createPopover() {
    const self = this;
    self.popover = self.app.popover.create({
      content: `
        <div class="popover dark text-editor-popover">
          <div class="popover-inner">${self.renderButtons()}</div>
        </div>
      `,
      closeByOutsideClick: false,
      backdrop: false
    });
  }
  openKeyboardToolbar() {
    const self = this;
    if (self.$keyboardToolbarEl.parent(self.app.$el).length)
      return;
    self.$el.trigger("texteditor:keyboardopen");
    self.emit("local::keyboardOpen textEditorKeyboardOpen", self);
    self.app.$el.append(self.$keyboardToolbarEl);
  }
  closeKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl.remove();
    self.$el.trigger("texteditor:keyboardclose");
    self.emit("local::keyboardClose textEditorKeyboardClose", self);
  }
  openPopover(targetX, targetY, targetWidth, targetHeight) {
    const self = this;
    if (!self.popover)
      return;
    Object.assign(self.popover.params, {
      targetX,
      targetY,
      targetWidth,
      targetHeight
    });
    clearTimeout(self.popoverTimeout);
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover)
        return;
      if (self.popover.opened) {
        self.popover.resize();
      } else {
        self.$el.trigger("texteditor:popoveropen");
        self.emit("local::popoverOpen textEditorPopoverOpen", self);
        self.popover.open();
      }
    }, 400);
  }
  closePopover() {
    const self = this;
    clearTimeout(self.popoverTimeout);
    if (!self.popover || !self.popover.opened)
      return;
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover)
        return;
      self.$el.trigger("texteditor:popoverclose");
      self.emit("local::popoverClose textEditorPopoverClose", self);
      self.popover.close();
    }, 400);
  }
  init() {
    const self = this;
    if (self.value) {
      self.$contentEl.html(self.value);
    } else {
      self.value = self.$contentEl.html();
    }
    if (self.params.placeholder && self.value === "") {
      self.insertPlaceholder();
    }
    if (self.params.mode === "toolbar") {
      self.createToolbar();
    } else if (self.params.mode === "popover") {
      self.createPopover();
    } else if (self.params.mode === "keyboard-toolbar") {
      self.createKeyboardToolbar();
    }
    self.attachEvents();
    self.$el.trigger("texteditor:init");
    self.emit("local::init textEditorInit", self);
    return self;
  }
  destroy() {
    let self = this;
    self.$el.trigger("texteditor:beforedestroy");
    self.emit("local::beforeDestroy textEditorBeforeDestroy", self);
    self.detachEvents();
    if (self.params.mode === "keyboard-toolbar" && self.$keyboardToolbarEl) {
      self.$keyboardToolbarEl.remove();
    }
    if (self.popover) {
      self.popover.close(false);
      self.popover.destroy();
    }
    delete self.$el[0].f7TextEditor;
    deleteProps(self);
    self = null;
  }
};
var text_editor_class_default = TextEditor;

// node_modules/framework7/components/text-editor/text-editor.js
var text_editor_default = {
  name: "textEditor",
  params: {
    textEditor: {
      el: null,
      mode: "toolbar",
      // or 'popover'
      value: void 0,
      // will use html content
      customButtons: null,
      buttons: [["bold", "italic", "underline", "strikeThrough"], ["orderedList", "unorderedList"], ["link", "image"], ["paragraph", "h1", "h2", "h3"], ["alignLeft", "alignCenter", "alignRight", "alignJustify"], ["subscript", "superscript"], ["indent", "outdent"]],
      dividers: true,
      imageUrlText: "Insert image URL",
      linkUrlText: "Insert link URL",
      placeholder: null,
      clearFormattingOnPaste: true
    }
  },
  create() {
    const app = this;
    app.textEditor = extend(ConstructorMethods({
      defaultSelector: ".text-editor",
      constructor: text_editor_class_default,
      app,
      domProp: "f7TextEditor"
    }));
  },
  static: {
    TextEditor: text_editor_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".text-editor-init").each((editorEl) => {
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".text-editor-init").each((editorEl) => {
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".text-editor-init").each((editorEl) => {
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".text-editor-init").each((editorEl) => {
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      });
    }
  },
  vnode: {
    "text-editor-init": {
      insert(vnode) {
        const app = this;
        const editorEl = vnode.elm;
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      },
      destroy(vnode) {
        const editorEl = vnode.elm;
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      }
    }
  }
};

// node_modules/framework7/components/breadcrumbs/breadcrumbs.js
var Breadcrumbs = {};
var breadcrumbs_default = {
  name: "breadrumbs",
  create() {
    const app = this;
    bindMethods(app, {
      breadrumbs: Breadcrumbs
    });
  }
};

// node_modules/framework7/components/elevation/elevation.js
var elevation_default = {
  name: "elevation"
};

// node_modules/framework7/components/typography/typography.js
var typography_default = {
  name: "typography"
};

// node_modules/framework7/framework7-lite-bundle.esm.js
app_class_default.use([device_default, support_default, utils_default, resize_default, request_default2, touch_default, clicks_default, router_default, history_default, service_worker_default, store_default, statusbar_default, view_default, navbar_default, toolbar_default, subnavbar_default, touch_ripple_default, modal_default, appbar_default, dialog_default, popup_default, login_screen_default, popover_default, actions_default, sheet_default, toast_default, preloader_default, progressbar_default, sortable_default, swipeout_default, accordion_default, contacts_list_default, virtual_list_default, list_index_default, timeline_default, tabs_default, panel_default, card_default, chip_default, form_default, input_default, checkbox_default, radio_default, toggle_default, range_default, stepper_default, smart_select_default, grid_default, calendar_default, picker_default, infinite_scroll_default, pull_to_refresh_default, lazy_default, data_table_default, fab_default, searchbar_default, messages_default, messagebar_default, swiper_default, photo_browser_default, notification_default, autocomplete_default, tooltip_default, skeleton_default, menu_default, color_picker_default, treeview_default, text_editor_default, breadcrumbs_default, elevation_default, typography_default]);
var framework7_lite_bundle_esm_default = app_class_default;
export {
  dom7_default as Dom7,
  create_store_default as createStore,
  framework7_lite_bundle_esm_default as default,
  getDevice,
  getSupport,
  request_default as request,
  utils_exports as utils
};
//# sourceMappingURL=framework7_lite_bundle.js.map
